
await(async()=>{let{dirname:e}=await import("path"),{fileURLToPath:i}=await import("url");if(typeof globalThis.__filename>"u"&&(globalThis.__filename=i(import.meta.url)),typeof globalThis.__dirname>"u"&&(globalThis.__dirname=e(globalThis.__filename)),typeof globalThis.require>"u"){let{default:a}=await import("module");globalThis.require=a.createRequire(import.meta.url)}})();

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/es5-ext/function/noop.js
var require_noop = __commonJS({
  "node_modules/es5-ext/function/noop.js"(exports, module) {
    "use strict";
    module.exports = function() {
    };
  }
});

// node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  "node_modules/es5-ext/object/is-value.js"(exports, module) {
    "use strict";
    var _undefined = require_noop()();
    module.exports = function(val2) {
      return val2 !== _undefined && val2 !== null;
    };
  }
});

// node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/es5-ext/object/normalize-options.js"(exports, module) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options))
          return;
        process2(Object(options), result);
      });
      return result;
    };
  }
});

// node_modules/es5-ext/math/sign/is-implemented.js
var require_is_implemented = __commonJS({
  "node_modules/es5-ext/math/sign/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var sign = Math.sign;
      if (typeof sign !== "function")
        return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  }
});

// node_modules/es5-ext/math/sign/shim.js
var require_shim = __commonJS({
  "node_modules/es5-ext/math/sign/shim.js"(exports, module) {
    "use strict";
    module.exports = function(value2) {
      value2 = Number(value2);
      if (isNaN(value2) || value2 === 0)
        return value2;
      return value2 > 0 ? 1 : -1;
    };
  }
});

// node_modules/es5-ext/math/sign/index.js
var require_sign = __commonJS({
  "node_modules/es5-ext/math/sign/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented()() ? Math.sign : require_shim();
  }
});

// node_modules/es5-ext/number/to-integer.js
var require_to_integer = __commonJS({
  "node_modules/es5-ext/number/to-integer.js"(exports, module) {
    "use strict";
    var sign = require_sign();
    var abs = Math.abs;
    var floor = Math.floor;
    module.exports = function(value2) {
      if (isNaN(value2))
        return 0;
      value2 = Number(value2);
      if (value2 === 0 || !isFinite(value2))
        return value2;
      return sign(value2) * floor(abs(value2));
    };
  }
});

// node_modules/es5-ext/number/to-pos-integer.js
var require_to_pos_integer = __commonJS({
  "node_modules/es5-ext/number/to-pos-integer.js"(exports, module) {
    "use strict";
    var toInteger = require_to_integer();
    var max = Math.max;
    module.exports = function(value2) {
      return max(0, toInteger(value2));
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-length.js
var require_resolve_length = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-length.js"(exports, module) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    module.exports = function(optsLength, fnLength, isAsync) {
      var length;
      if (isNaN(optsLength)) {
        length = fnLength;
        if (!(length >= 0))
          return 1;
        if (isAsync && length)
          return length - 1;
        return length;
      }
      if (optsLength === false)
        return false;
      return toPosInt(optsLength);
    };
  }
});

// node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  "node_modules/es5-ext/object/valid-callable.js"(exports, module) {
    "use strict";
    module.exports = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
  }
});

// node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  "node_modules/es5-ext/object/valid-value.js"(exports, module) {
    "use strict";
    var isValue = require_is_value();
    module.exports = function(value2) {
      if (!isValue(value2))
        throw new TypeError("Cannot use null or undefined");
      return value2;
    };
  }
});

// node_modules/es5-ext/object/_iterate.js
var require_iterate = __commonJS({
  "node_modules/es5-ext/object/_iterate.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    var value2 = require_valid_value();
    var bind3 = Function.prototype.bind;
    var call = Function.prototype.call;
    var keys4 = Object.keys;
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module.exports = function(method, defVal) {
      return function(obj, cb) {
        var list2, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value2(obj));
        callable(cb);
        list2 = keys4(obj);
        if (compareFn) {
          list2.sort(typeof compareFn === "function" ? bind3.call(compareFn, obj) : void 0);
        }
        if (typeof method !== "function")
          method = list2[method];
        return call.call(method, list2, function(key, index2) {
          if (!objPropertyIsEnumerable.call(obj, key))
            return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index2);
        });
      };
    };
  }
});

// node_modules/es5-ext/object/for-each.js
var require_for_each = __commonJS({
  "node_modules/es5-ext/object/for-each.js"(exports, module) {
    "use strict";
    module.exports = require_iterate()("forEach");
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/lib/registered-extensions.js
var require_registered_extensions = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/lib/registered-extensions.js"() {
    "use strict";
  }
});

// node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented2 = __commonJS({
  "node_modules/es5-ext/object/assign/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function")
        return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented3 = __commonJS({
  "node_modules/es5-ext/object/keys/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// node_modules/es5-ext/object/keys/shim.js
var require_shim2 = __commonJS({
  "node_modules/es5-ext/object/keys/shim.js"(exports, module) {
    "use strict";
    var isValue = require_is_value();
    var keys4 = Object.keys;
    module.exports = function(object) {
      return keys4(isValue(object) ? Object(object) : object);
    };
  }
});

// node_modules/es5-ext/object/keys/index.js
var require_keys = __commonJS({
  "node_modules/es5-ext/object/keys/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented3()() ? Object.keys : require_shim2();
  }
});

// node_modules/es5-ext/object/assign/shim.js
var require_shim3 = __commonJS({
  "node_modules/es5-ext/object/assign/shim.js"(exports, module) {
    "use strict";
    var keys4 = require_keys();
    var value2 = require_valid_value();
    var max = Math.max;
    module.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value2(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error)
            error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys4(src).forEach(assign);
      }
      if (error !== void 0)
        throw error;
      return dest;
    };
  }
});

// node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  "node_modules/es5-ext/object/assign/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented2()() ? Object.assign : require_shim3();
  }
});

// node_modules/es5-ext/object/is-object.js
var require_is_object = __commonJS({
  "node_modules/es5-ext/object/is-object.js"(exports, module) {
    "use strict";
    var isValue = require_is_value();
    var map4 = { function: true, object: true };
    module.exports = function(value2) {
      return isValue(value2) && map4[typeof value2] || false;
    };
  }
});

// node_modules/es5-ext/error/custom.js
var require_custom = __commonJS({
  "node_modules/es5-ext/error/custom.js"(exports, module) {
    "use strict";
    var assign = require_assign();
    var isObject = require_is_object();
    var isValue = require_is_value();
    var captureStackTrace = Error.captureStackTrace;
    module.exports = function(message) {
      var err = new Error(message), code = arguments[1], ext = arguments[2];
      if (!isValue(ext)) {
        if (isObject(code)) {
          ext = code;
          code = null;
        }
      }
      if (isValue(ext))
        assign(err, ext);
      if (isValue(code))
        err.code = code;
      if (captureStackTrace)
        captureStackTrace(err, module.exports);
      return err;
    };
  }
});

// node_modules/es5-ext/object/mixin.js
var require_mixin = __commonJS({
  "node_modules/es5-ext/object/mixin.js"(exports, module) {
    "use strict";
    var value2 = require_valid_value();
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    module.exports = function(target, source) {
      var error, sourceObject = Object(value2(source));
      target = Object(value2(target));
      getOwnPropertyNames(sourceObject).forEach(function(name) {
        try {
          defineProperty(target, name, getOwnPropertyDescriptor(source, name));
        } catch (e) {
          error = e;
        }
      });
      if (typeof getOwnPropertySymbols === "function") {
        getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
          try {
            defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
          } catch (e) {
            error = e;
          }
        });
      }
      if (error !== void 0)
        throw error;
      return target;
    };
  }
});

// node_modules/es5-ext/function/_define-length.js
var require_define_length = __commonJS({
  "node_modules/es5-ext/function/_define-length.js"(exports, module) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var test = function(arg1, arg2) {
      return arg2;
    };
    var desc;
    var defineProperty;
    var generate2;
    var mixin;
    try {
      Object.defineProperty(test, "length", {
        configurable: true,
        writable: false,
        enumerable: false,
        value: 1
      });
    } catch (ignore) {
    }
    if (test.length === 1) {
      desc = { configurable: true, writable: false, enumerable: false };
      defineProperty = Object.defineProperty;
      module.exports = function(fn, length) {
        length = toPosInt(length);
        if (fn.length === length)
          return fn;
        desc.value = length;
        return defineProperty(fn, "length", desc);
      };
    } else {
      mixin = require_mixin();
      generate2 = function() {
        var cache = [];
        return function(length) {
          var args, i = 0;
          if (cache[length])
            return cache[length];
          args = [];
          while (length--)
            args.push("a" + (++i).toString(36));
          return new Function(
            "fn",
            "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
          );
        };
      }();
      module.exports = function(src, length) {
        var target;
        length = toPosInt(length);
        if (src.length === length)
          return src;
        target = generate2(length)(src);
        try {
          mixin(target, src);
        } catch (ignore) {
        }
        return target;
      };
    }
  }
});

// node_modules/type/value/is.js
var require_is = __commonJS({
  "node_modules/type/value/is.js"(exports, module) {
    "use strict";
    var _undefined = void 0;
    module.exports = function(value2) {
      return value2 !== _undefined && value2 !== null;
    };
  }
});

// node_modules/type/object/is.js
var require_is2 = __commonJS({
  "node_modules/type/object/is.js"(exports, module) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = {
      "object": true,
      "function": true,
      "undefined": true
      /* document.all */
    };
    module.exports = function(value2) {
      if (!isValue(value2))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value2);
    };
  }
});

// node_modules/type/prototype/is.js
var require_is3 = __commonJS({
  "node_modules/type/prototype/is.js"(exports, module) {
    "use strict";
    var isObject = require_is2();
    module.exports = function(value2) {
      if (!isObject(value2))
        return false;
      try {
        if (!value2.constructor)
          return false;
        return value2.constructor.prototype === value2;
      } catch (error) {
        return false;
      }
    };
  }
});

// node_modules/type/function/is.js
var require_is4 = __commonJS({
  "node_modules/type/function/is.js"(exports, module) {
    "use strict";
    var isPrototype = require_is3();
    module.exports = function(value2) {
      if (typeof value2 !== "function")
        return false;
      if (!hasOwnProperty.call(value2, "length"))
        return false;
      try {
        if (typeof value2.length !== "number")
          return false;
        if (typeof value2.call !== "function")
          return false;
        if (typeof value2.apply !== "function")
          return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value2);
    };
  }
});

// node_modules/type/plain-function/is.js
var require_is5 = __commonJS({
  "node_modules/type/plain-function/is.js"(exports, module) {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module.exports = function(value2) {
      if (!isFunction(value2))
        return false;
      if (classRe.test(functionToString.call(value2)))
        return false;
      return true;
    };
  }
});

// node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented4 = __commonJS({
  "node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module) {
    "use strict";
    var str = "razdwatrzy";
    module.exports = function() {
      if (typeof str.contains !== "function")
        return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  }
});

// node_modules/es5-ext/string/#/contains/shim.js
var require_shim4 = __commonJS({
  "node_modules/es5-ext/string/#/contains/shim.js"(exports, module) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  "node_modules/es5-ext/string/#/contains/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented4()() ? String.prototype.contains : require_shim4();
  }
});

// node_modules/d/index.js
var require_d = __commonJS({
  "node_modules/d/index.js"(exports, module) {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains5 = require_contains();
    var d = module.exports = function(dscr, value2) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value2;
        value2 = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c = contains5.call(dscr, "c");
        e = contains5.call(dscr, "e");
        w = contains5.call(dscr, "w");
      } else {
        c = w = true;
        e = false;
      }
      desc = { value: value2, configurable: c, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get2, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get2;
        get2 = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get2)) {
        get2 = void 0;
      } else if (!isPlainFunction(get2)) {
        options = get2;
        get2 = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c = contains5.call(dscr, "c");
        e = contains5.call(dscr, "e");
      } else {
        c = true;
        e = false;
      }
      desc = { get: get2, set, configurable: c, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  "node_modules/event-emitter/index.js"(exports, module) {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on;
    var once;
    var off;
    var emit;
    var methods2;
    var descriptors;
    var base;
    on = function(type3, listener) {
      var data3;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data3 = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data3 = this.__ee__;
      }
      if (!data3[type3])
        data3[type3] = listener;
      else if (typeof data3[type3] === "object")
        data3[type3].push(listener);
      else
        data3[type3] = [data3[type3], listener];
      return this;
    };
    once = function(type3, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type3, once2 = function() {
        off.call(self2, type3, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type3, listener) {
      var data3, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__"))
        return this;
      data3 = this.__ee__;
      if (!data3[type3])
        return this;
      listeners = data3[type3];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data3[type3] = listeners[i ? 0 : 1];
            else
              listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data3[type3];
        }
      }
      return this;
    };
    emit = function(type3) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__"))
        return;
      listeners = this.__ee__[type3];
      if (!listeners)
        return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
          args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods2 = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module.exports = exports = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods2;
  }
});

// node_modules/es5-ext/array/from/is-implemented.js
var require_is_implemented5 = __commonJS({
  "node_modules/es5-ext/array/from/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var from = Array.from, arr, result;
      if (typeof from !== "function")
        return false;
      arr = ["raz", "dwa"];
      result = from(arr);
      return Boolean(result && result !== arr && result[1] === "dwa");
    };
  }
});

// node_modules/ext/global-this/is-implemented.js
var require_is_implemented6 = __commonJS({
  "node_modules/ext/global-this/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      if (typeof globalThis !== "object")
        return false;
      if (!globalThis)
        return false;
      return globalThis.Array === Array;
    };
  }
});

// node_modules/ext/global-this/implementation.js
var require_implementation = __commonJS({
  "node_modules/ext/global-this/implementation.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof self === "object" && self)
        return self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this)
        return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/ext/global-this/index.js
var require_global_this = __commonJS({
  "node_modules/ext/global-this/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented6()() ? globalThis : require_implementation();
  }
});

// node_modules/es6-symbol/is-implemented.js
var require_is_implemented7 = __commonJS({
  "node_modules/es6-symbol/is-implemented.js"(exports, module) {
    "use strict";
    var global = require_global_this();
    var validTypes = { object: true, symbol: true };
    module.exports = function() {
      var Symbol2 = global.Symbol;
      var symbol;
      if (typeof Symbol2 !== "function")
        return false;
      symbol = Symbol2("test symbol");
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (!validTypes[typeof Symbol2.iterator])
        return false;
      if (!validTypes[typeof Symbol2.toPrimitive])
        return false;
      if (!validTypes[typeof Symbol2.toStringTag])
        return false;
      return true;
    };
  }
});

// node_modules/es6-symbol/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/es6-symbol/is-symbol.js"(exports, module) {
    "use strict";
    module.exports = function(value2) {
      if (!value2)
        return false;
      if (typeof value2 === "symbol")
        return true;
      if (!value2.constructor)
        return false;
      if (value2.constructor.name !== "Symbol")
        return false;
      return value2[value2.constructor.toStringTag] === "Symbol";
    };
  }
});

// node_modules/es6-symbol/validate-symbol.js
var require_validate_symbol = __commonJS({
  "node_modules/es6-symbol/validate-symbol.js"(exports, module) {
    "use strict";
    var isSymbol = require_is_symbol();
    module.exports = function(value2) {
      if (!isSymbol(value2))
        throw new TypeError(value2 + " is not a symbol");
      return value2;
    };
  }
});

// node_modules/es6-symbol/lib/private/generate-name.js
var require_generate_name = __commonJS({
  "node_modules/es6-symbol/lib/private/generate-name.js"(exports, module) {
    "use strict";
    var d = require_d();
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var objPrototype = Object.prototype;
    var created = create(null);
    module.exports = function(desc) {
      var postfix = 0, name, ie11BugWorkaround;
      while (created[desc + (postfix || "")])
        ++postfix;
      desc += postfix || "";
      created[desc] = true;
      name = "@@" + desc;
      defineProperty(
        objPrototype,
        name,
        d.gs(null, function(value2) {
          if (ie11BugWorkaround)
            return;
          ie11BugWorkaround = true;
          defineProperty(this, name, d(value2));
          ie11BugWorkaround = false;
        })
      );
      return name;
    };
  }
});

// node_modules/es6-symbol/lib/private/setup/standard-symbols.js
var require_standard_symbols = __commonJS({
  "node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports, module) {
    "use strict";
    var d = require_d();
    var NativeSymbol = require_global_this().Symbol;
    module.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d(
          "",
          NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
        ),
        isConcatSpreadable: d(
          "",
          NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
        ),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d(
          "",
          NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
        ),
        toStringTag: d(
          "",
          NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
        ),
        unscopables: d(
          "",
          NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
        )
      });
    };
  }
});

// node_modules/es6-symbol/lib/private/setup/symbol-registry.js
var require_symbol_registry = __commonJS({
  "node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports, module) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var registry = /* @__PURE__ */ Object.create(null);
    module.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
          if (registry[key])
            return registry[key];
          return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
          var key;
          validateSymbol(symbol);
          for (key in registry) {
            if (registry[key] === symbol)
              return key;
          }
          return void 0;
        })
      });
    };
  }
});

// node_modules/es6-symbol/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/es6-symbol/polyfill.js"(exports, module) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var NativeSymbol = require_global_this().Symbol;
    var generateName = require_generate_name();
    var setupStandardSymbols = require_standard_symbols();
    var setupSymbolRegistry = require_symbol_registry();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var defineProperty = Object.defineProperty;
    var SymbolPolyfill;
    var HiddenSymbol;
    var isNativeSafe;
    if (typeof NativeSymbol === "function") {
      try {
        String(NativeSymbol());
        isNativeSafe = true;
      } catch (ignore) {
      }
    } else {
      NativeSymbol = null;
    }
    HiddenSymbol = function Symbol2(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError("Symbol is not a constructor");
      return SymbolPolyfill(description);
    };
    module.exports = SymbolPolyfill = function Symbol2(description) {
      var symbol;
      if (this instanceof Symbol2)
        throw new TypeError("Symbol is not a constructor");
      if (isNativeSafe)
        return NativeSymbol(description);
      symbol = create(HiddenSymbol.prototype);
      description = description === void 0 ? "" : String(description);
      return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
      });
    };
    setupStandardSymbols(SymbolPolyfill);
    setupSymbolRegistry(SymbolPolyfill);
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d("", function() {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
      }),
      valueOf: d(function() {
        return validateSymbol(this);
      })
    });
    defineProperty(
      SymbolPolyfill.prototype,
      SymbolPolyfill.toPrimitive,
      d("", function() {
        var symbol = validateSymbol(this);
        if (typeof symbol === "symbol")
          return symbol;
        return symbol.toString();
      })
    );
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toStringTag,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
    );
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toPrimitive,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
    );
  }
});

// node_modules/es6-symbol/index.js
var require_es6_symbol = __commonJS({
  "node_modules/es6-symbol/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented7()() ? require_global_this().Symbol : require_polyfill();
  }
});

// node_modules/es5-ext/function/is-arguments.js
var require_is_arguments = __commonJS({
  "node_modules/es5-ext/function/is-arguments.js"(exports, module) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call(function() {
      return arguments;
    }());
    module.exports = function(value2) {
      return objToString.call(value2) === id;
    };
  }
});

// node_modules/es5-ext/function/is-function.js
var require_is_function = __commonJS({
  "node_modules/es5-ext/function/is-function.js"(exports, module) {
    "use strict";
    var objToString = Object.prototype.toString;
    var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    module.exports = function(value2) {
      return typeof value2 === "function" && isFunctionStringTag(objToString.call(value2));
    };
  }
});

// node_modules/es5-ext/string/is-string.js
var require_is_string = __commonJS({
  "node_modules/es5-ext/string/is-string.js"(exports, module) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call("");
    module.exports = function(value2) {
      return typeof value2 === "string" || value2 && typeof value2 === "object" && (value2 instanceof String || objToString.call(value2) === id) || false;
    };
  }
});

// node_modules/es5-ext/array/from/shim.js
var require_shim5 = __commonJS({
  "node_modules/es5-ext/array/from/shim.js"(exports, module) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArguments = require_is_arguments();
    var isFunction = require_is_function();
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var validValue = require_valid_value();
    var isValue = require_is_value();
    var isString = require_is_string();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var desc = { configurable: true, enumerable: true, writable: true, value: null };
    var defineProperty = Object.defineProperty;
    module.exports = function(arrayLike) {
      var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value2;
      arrayLike = Object(validValue(arrayLike));
      if (isValue(mapFn))
        callable(mapFn);
      if (!this || this === Array || !isFunction(this)) {
        if (!mapFn) {
          if (isArguments(arrayLike)) {
            length = arrayLike.length;
            if (length !== 1)
              return Array.apply(null, arrayLike);
            arr = new Array(1);
            arr[0] = arrayLike[0];
            return arr;
          }
          if (isArray(arrayLike)) {
            arr = new Array(length = arrayLike.length);
            for (i = 0; i < length; ++i)
              arr[i] = arrayLike[i];
            return arr;
          }
        }
        arr = [];
      } else {
        Context = this;
      }
      if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
          iterator = callable(getIterator).call(arrayLike);
          if (Context)
            arr = new Context();
          result = iterator.next();
          i = 0;
          while (!result.done) {
            value2 = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
            if (Context) {
              desc.value = value2;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value2;
            }
            result = iterator.next();
            ++i;
          }
          length = i;
        } else if (isString(arrayLike)) {
          length = arrayLike.length;
          if (Context)
            arr = new Context();
          for (i = 0, j = 0; i < length; ++i) {
            value2 = arrayLike[i];
            if (i + 1 < length) {
              code = value2.charCodeAt(0);
              if (code >= 55296 && code <= 56319)
                value2 += arrayLike[++i];
            }
            value2 = mapFn ? call.call(mapFn, thisArg, value2, j) : value2;
            if (Context) {
              desc.value = value2;
              defineProperty(arr, j, desc);
            } else {
              arr[j] = value2;
            }
            ++j;
          }
          length = j;
        }
      }
      if (length === void 0) {
        length = toPosInt(arrayLike.length);
        if (Context)
          arr = new Context(length);
        for (i = 0; i < length; ++i) {
          value2 = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
          if (Context) {
            desc.value = value2;
            defineProperty(arr, i, desc);
          } else {
            arr[i] = value2;
          }
        }
      }
      if (Context) {
        desc.value = null;
        arr.length = length;
      }
      return arr;
    };
  }
});

// node_modules/es5-ext/array/from/index.js
var require_from = __commonJS({
  "node_modules/es5-ext/array/from/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented5()() ? Array.from : require_shim5();
  }
});

// node_modules/es5-ext/array/to-array.js
var require_to_array = __commonJS({
  "node_modules/es5-ext/array/to-array.js"(exports, module) {
    "use strict";
    var from = require_from();
    var isArray = Array.isArray;
    module.exports = function(arrayLike) {
      return isArray(arrayLike) ? arrayLike : from(arrayLike);
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-resolve.js
var require_resolve_resolve = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-resolve.js"(exports, module) {
    "use strict";
    var toArray2 = require_to_array();
    var isValue = require_is_value();
    var callable = require_valid_callable();
    var slice2 = Array.prototype.slice;
    var resolveArgs;
    resolveArgs = function(args) {
      return this.map(function(resolve, i) {
        return resolve ? resolve(args[i]) : args[i];
      }).concat(slice2.call(args, this.length));
    };
    module.exports = function(resolvers) {
      resolvers = toArray2(resolvers);
      resolvers.forEach(function(resolve) {
        if (isValue(resolve))
          callable(resolve);
      });
      return resolveArgs.bind(resolvers);
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-normalize.js
var require_resolve_normalize = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/lib/resolve-normalize.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    module.exports = function(userNormalizer) {
      var normalizer;
      if (typeof userNormalizer === "function")
        return { set: userNormalizer, get: userNormalizer };
      normalizer = { get: callable(userNormalizer.get) };
      if (userNormalizer.set !== void 0) {
        normalizer.set = callable(userNormalizer.set);
        if (userNormalizer.delete)
          normalizer.delete = callable(userNormalizer.delete);
        if (userNormalizer.clear)
          normalizer.clear = callable(userNormalizer.clear);
        return normalizer;
      }
      normalizer.set = normalizer.get;
      return normalizer;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/lib/configure-map.js
var require_configure_map = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/lib/configure-map.js"(exports, module) {
    "use strict";
    var customError = require_custom();
    var defineLength = require_define_length();
    var d = require_d();
    var ee = require_event_emitter().methods;
    var resolveResolve = require_resolve_resolve();
    var resolveNormalize = require_resolve_normalize();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var on = ee.on;
    var emit = ee.emit;
    module.exports = function(original, length, options) {
      var cache = create(null), conf, memLength, get2, set, del, clear, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized2, resolve;
      if (length !== false)
        memLength = length;
      else if (isNaN(original.length))
        memLength = 1;
      else
        memLength = original.length;
      if (options.normalizer) {
        normalizer = resolveNormalize(options.normalizer);
        get2 = normalizer.get;
        set = normalizer.set;
        del = normalizer.delete;
        clear = normalizer.clear;
      }
      if (options.resolvers != null)
        resolve = resolveResolve(options.resolvers);
      if (get2) {
        memoized2 = defineLength(function(arg) {
          var id, result, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get2(args);
          if (id !== null) {
            if (hasOwnProperty.call(cache, id)) {
              if (getListeners)
                conf.emit("get", id, args, this);
              return cache[id];
            }
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (id === null) {
            id = get2(args);
            if (id !== null)
              throw customError("Circular invocation", "CIRCULAR_INVOCATION");
            id = set(args);
          } else if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id, null, result);
          return result;
        }, memLength);
      } else if (length === 0) {
        memoized2 = function() {
          var result;
          if (hasOwnProperty.call(cache, "data")) {
            if (getListeners)
              conf.emit("get", "data", arguments, this);
            return cache.data;
          }
          if (arguments.length)
            result = apply.call(original, this, arguments);
          else
            result = call.call(original, this);
          if (hasOwnProperty.call(cache, "data")) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache.data = result;
          if (setListeners)
            conf.emit("set", "data", null, result);
          return result;
        };
      } else {
        memoized2 = function(arg) {
          var result, args = arguments, id;
          if (resolve)
            args = resolve(arguments);
          id = String(args[0]);
          if (hasOwnProperty.call(cache, id)) {
            if (getListeners)
              conf.emit("get", id, args, this);
            return cache[id];
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id, null, result);
          return result;
        };
      }
      conf = {
        original,
        memoized: memoized2,
        profileName: options.profileName,
        get: function(args) {
          if (resolve)
            args = resolve(args);
          if (get2)
            return get2(args);
          return String(args[0]);
        },
        has: function(id) {
          return hasOwnProperty.call(cache, id);
        },
        delete: function(id) {
          var result;
          if (!hasOwnProperty.call(cache, id))
            return;
          if (del)
            del(id);
          result = cache[id];
          delete cache[id];
          if (deleteListeners)
            conf.emit("delete", id, result);
        },
        clear: function() {
          var oldCache = cache;
          if (clear)
            clear();
          cache = create(null);
          conf.emit("clear", oldCache);
        },
        on: function(type3, listener) {
          if (type3 === "get")
            getListeners = true;
          else if (type3 === "set")
            setListeners = true;
          else if (type3 === "delete")
            deleteListeners = true;
          return on.call(this, type3, listener);
        },
        emit,
        updateEnv: function() {
          original = conf.original;
        }
      };
      if (get2) {
        extDel = defineLength(function(arg) {
          var id, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get2(args);
          if (id === null)
            return;
          conf.delete(id);
        }, memLength);
      } else if (length === 0) {
        extDel = function() {
          return conf.delete("data");
        };
      } else {
        extDel = function(arg) {
          if (resolve)
            arg = resolve(arguments)[0];
          return conf.delete(arg);
        };
      }
      extGet = defineLength(function() {
        var id, args = arguments;
        if (length === 0)
          return cache.data;
        if (resolve)
          args = resolve(args);
        if (get2)
          id = get2(args);
        else
          id = String(args[0]);
        return cache[id];
      });
      extHas = defineLength(function() {
        var id, args = arguments;
        if (length === 0)
          return conf.has("data");
        if (resolve)
          args = resolve(args);
        if (get2)
          id = get2(args);
        else
          id = String(args[0]);
        if (id === null)
          return false;
        return conf.has(id);
      });
      defineProperties(memoized2, {
        __memoized__: d(true),
        delete: d(extDel),
        clear: d(conf.clear),
        _get: d(extGet),
        _has: d(extHas)
      });
      return conf;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/plain.js
var require_plain = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/plain.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var configure = require_configure_map();
    var resolveLength = require_resolve_length();
    module.exports = function self2(fn) {
      var options, length, conf;
      callable(fn);
      options = Object(arguments[1]);
      if (options.async && options.promise) {
        throw new Error("Options 'async' and 'promise' cannot be used together");
      }
      if (hasOwnProperty.call(fn, "__memoized__") && !options.force)
        return fn;
      length = resolveLength(options.length, fn.length, options.async && extensions.async);
      conf = configure(fn, length, options);
      forEach(extensions, function(extFn, name) {
        if (options[name])
          extFn(options[name], conf, options);
      });
      if (self2.__profiler__)
        self2.__profiler__(conf);
      conf.updateEnv();
      return conf.memoized;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/normalizers/primitive.js
var require_primitive = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/normalizers/primitive.js"(exports, module) {
    "use strict";
    module.exports = function(args) {
      var id, i, length = args.length;
      if (!length)
        return "";
      id = String(args[i = 0]);
      while (--length)
        id += "" + args[++i];
      return id;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-primitive-fixed.js
var require_get_primitive_fixed = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-primitive-fixed.js"(exports, module) {
    "use strict";
    module.exports = function(length) {
      if (!length) {
        return function() {
          return "";
        };
      }
      return function(args) {
        var id = String(args[0]), i = 0, currentLength = length;
        while (--currentLength) {
          id += "" + args[++i];
        }
        return id;
      };
    };
  }
});

// node_modules/es5-ext/number/is-nan/is-implemented.js
var require_is_implemented8 = __commonJS({
  "node_modules/es5-ext/number/is-nan/is-implemented.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var numberIsNaN = Number.isNaN;
      if (typeof numberIsNaN !== "function")
        return false;
      return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    };
  }
});

// node_modules/es5-ext/number/is-nan/shim.js
var require_shim6 = __commonJS({
  "node_modules/es5-ext/number/is-nan/shim.js"(exports, module) {
    "use strict";
    module.exports = function(value2) {
      return value2 !== value2;
    };
  }
});

// node_modules/es5-ext/number/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/es5-ext/number/is-nan/index.js"(exports, module) {
    "use strict";
    module.exports = require_is_implemented8()() ? Number.isNaN : require_shim6();
  }
});

// node_modules/es5-ext/array/#/e-index-of.js
var require_e_index_of = __commonJS({
  "node_modules/es5-ext/array/#/e-index-of.js"(exports, module) {
    "use strict";
    var numberIsNaN = require_is_nan();
    var toPosInt = require_to_pos_integer();
    var value2 = require_valid_value();
    var indexOf = Array.prototype.indexOf;
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    var abs = Math.abs;
    var floor = Math.floor;
    module.exports = function(searchElement) {
      var i, length, fromIndex, val2;
      if (!numberIsNaN(searchElement))
        return indexOf.apply(this, arguments);
      length = toPosInt(value2(this).length);
      fromIndex = arguments[1];
      if (isNaN(fromIndex))
        fromIndex = 0;
      else if (fromIndex >= 0)
        fromIndex = floor(fromIndex);
      else
        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
      for (i = fromIndex; i < length; ++i) {
        if (objHasOwnProperty.call(this, i)) {
          val2 = this[i];
          if (numberIsNaN(val2))
            return i;
        }
      }
      return -1;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/normalizers/get.js
var require_get = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/normalizers/get.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module.exports = function() {
      var lastId = 0, map4 = [], cache = create(null);
      return {
        get: function(args) {
          var index2 = 0, set = map4, i, length = args.length;
          if (length === 0)
            return set[length] || null;
          if (set = set[length]) {
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1)
                return null;
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1)
              return null;
            return set[1][i] || null;
          }
          return null;
        },
        set: function(args) {
          var index2 = 0, set = map4, i, length = args.length;
          if (length === 0) {
            set[length] = ++lastId;
          } else {
            if (!set[length]) {
              set[length] = [[], []];
            }
            set = set[length];
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1) {
                i = set[0].push(args[index2]) - 1;
                set[1].push([[], []]);
              }
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              i = set[0].push(args[index2]) - 1;
            }
            set[1][i] = ++lastId;
          }
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index2 = 0, set = map4, i, args = cache[id], length = args.length, path3 = [];
          if (length === 0) {
            delete set[length];
          } else if (set = set[length]) {
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1) {
                return;
              }
              path3.push(set, i);
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              return;
            }
            id = set[1][i];
            set[0].splice(i, 1);
            set[1].splice(i, 1);
            while (!set[0].length && path3.length) {
              i = path3.pop();
              set = path3.pop();
              set[0].splice(i, 1);
              set[1].splice(i, 1);
            }
          }
          delete cache[id];
        },
        clear: function() {
          map4 = [];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-1.js
var require_get_1 = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-1.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    module.exports = function() {
      var lastId = 0, argsMap = [], cache = [];
      return {
        get: function(args) {
          var index2 = indexOf.call(argsMap, args[0]);
          return index2 === -1 ? null : cache[index2];
        },
        set: function(args) {
          argsMap.push(args[0]);
          cache.push(++lastId);
          return lastId;
        },
        delete: function(id) {
          var index2 = indexOf.call(cache, id);
          if (index2 !== -1) {
            argsMap.splice(index2, 1);
            cache.splice(index2, 1);
          }
        },
        clear: function() {
          argsMap = [];
          cache = [];
        }
      };
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-fixed.js
var require_get_fixed = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/normalizers/get-fixed.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module.exports = function(length) {
      var lastId = 0, map4 = [[], []], cache = create(null);
      return {
        get: function(args) {
          var index2 = 0, set = map4, i;
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1)
              return null;
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1)
            return null;
          return set[1][i] || null;
        },
        set: function(args) {
          var index2 = 0, set = map4, i;
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              i = set[0].push(args[index2]) - 1;
              set[1].push([[], []]);
            }
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1) {
            i = set[0].push(args[index2]) - 1;
          }
          set[1][i] = ++lastId;
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index2 = 0, set = map4, i, path3 = [], args = cache[id];
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              return;
            }
            path3.push(set, i);
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1) {
            return;
          }
          id = set[1][i];
          set[0].splice(i, 1);
          set[1].splice(i, 1);
          while (!set[0].length && path3.length) {
            i = path3.pop();
            set = path3.pop();
            set[0].splice(i, 1);
            set[1].splice(i, 1);
          }
          delete cache[id];
        },
        clear: function() {
          map4 = [[], []];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/es5-ext/object/map.js
var require_map = __commonJS({
  "node_modules/es5-ext/object/map.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    module.exports = function(obj, cb) {
      var result = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function(value2, key, targetObj, index2) {
        result[key] = call.call(cb, thisArg, value2, key, targetObj, index2);
      });
      return result;
    };
  }
});

// node_modules/next-tick/index.js
var require_next_tick = __commonJS({
  "node_modules/next-tick/index.js"(exports, module) {
    "use strict";
    var ensureCallable = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
    var byObserver = function(Observer) {
      var node = document.createTextNode(""), queue, currentQueue, i = 0;
      new Observer(function() {
        var callback;
        if (!queue) {
          if (!currentQueue)
            return;
          queue = currentQueue;
        } else if (currentQueue) {
          queue = currentQueue.concat(queue);
        }
        currentQueue = queue;
        queue = null;
        if (typeof currentQueue === "function") {
          callback = currentQueue;
          currentQueue = null;
          callback();
          return;
        }
        node.data = i = ++i % 2;
        while (currentQueue) {
          callback = currentQueue.shift();
          if (!currentQueue.length)
            currentQueue = null;
          callback();
        }
      }).observe(node, { characterData: true });
      return function(fn) {
        ensureCallable(fn);
        if (queue) {
          if (typeof queue === "function")
            queue = [queue, fn];
          else
            queue.push(fn);
          return;
        }
        queue = fn;
        node.data = i = ++i % 2;
      };
    };
    module.exports = function() {
      if (typeof process === "object" && process && typeof process.nextTick === "function") {
        return process.nextTick;
      }
      if (typeof queueMicrotask === "function") {
        return function(cb) {
          queueMicrotask(ensureCallable(cb));
        };
      }
      if (typeof document === "object" && document) {
        if (typeof MutationObserver === "function")
          return byObserver(MutationObserver);
        if (typeof WebKitMutationObserver === "function")
          return byObserver(WebKitMutationObserver);
      }
      if (typeof setImmediate === "function") {
        return function(cb) {
          setImmediate(ensureCallable(cb));
        };
      }
      if (typeof setTimeout === "function" || typeof setTimeout === "object") {
        return function(cb) {
          setTimeout(ensureCallable(cb), 0);
        };
      }
      return null;
    }();
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/async.js
var require_async = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/async.js"() {
    "use strict";
    var aFrom = require_from();
    var objectMap = require_map();
    var mixin = require_mixin();
    var defineLength = require_define_length();
    var nextTick = require_next_tick();
    var slice2 = Array.prototype.slice;
    var apply = Function.prototype.apply;
    var create = Object.create;
    require_registered_extensions().async = function(tbi, conf) {
      var waiting = create(null), cache = create(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
      conf.memoized = defineLength(function(arg) {
        var args = arguments, last2 = args[args.length - 1];
        if (typeof last2 === "function") {
          currentCallback = last2;
          args = slice2.call(args, 0, -1);
        }
        return base.apply(currentContext = this, currentArgs = args);
      }, base);
      try {
        mixin(conf.memoized, base);
      } catch (ignore) {
      }
      conf.on("get", function(id) {
        var cb, context, args;
        if (!currentCallback)
          return;
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback];
          else
            waiting[id].push(currentCallback);
          currentCallback = null;
          return;
        }
        cb = currentCallback;
        context = currentContext;
        args = currentArgs;
        currentCallback = currentContext = currentArgs = null;
        nextTick(function() {
          var data3;
          if (hasOwnProperty.call(cache, id)) {
            data3 = cache[id];
            conf.emit("getasync", id, args, context);
            apply.call(cb, data3.context, data3.args);
          } else {
            currentCallback = cb;
            currentContext = context;
            currentArgs = args;
            base.apply(context, args);
          }
        });
      });
      conf.original = function() {
        var args, cb, origCb, result;
        if (!currentCallback)
          return apply.call(original, this, arguments);
        args = aFrom(arguments);
        cb = function self2(err) {
          var cb2, args2, id = self2.id;
          if (id == null) {
            nextTick(apply.bind(self2, this, arguments));
            return void 0;
          }
          delete self2.id;
          cb2 = waiting[id];
          delete waiting[id];
          if (!cb2) {
            return void 0;
          }
          args2 = aFrom(arguments);
          if (conf.has(id)) {
            if (err) {
              conf.delete(id);
            } else {
              cache[id] = { context: this, args: args2 };
              conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
            }
          }
          if (typeof cb2 === "function") {
            result = apply.call(cb2, this, args2);
          } else {
            cb2.forEach(function(cb3) {
              result = apply.call(cb3, this, args2);
            }, this);
          }
          return result;
        };
        origCb = currentCallback;
        currentCallback = currentContext = currentArgs = null;
        args.push(cb);
        result = apply.call(original, this, args);
        cb.cb = origCb;
        currentCallback = cb;
        return result;
      };
      conf.on("set", function(id) {
        if (!currentCallback) {
          conf.delete(id);
          return;
        }
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback.cb];
          else
            waiting[id].push(currentCallback.cb);
        } else {
          waiting[id] = currentCallback.cb;
        }
        delete currentCallback.cb;
        currentCallback.id = id;
        currentCallback = null;
      });
      conf.on("delete", function(id) {
        var result;
        if (hasOwnProperty.call(waiting, id))
          return;
        if (!cache[id])
          return;
        result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, slice2.call(result.args, 1));
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        conf.emit(
          "clearasync",
          objectMap(oldCache, function(data3) {
            return slice2.call(data3.args, 1);
          })
        );
      });
    };
  }
});

// node_modules/es5-ext/object/primitive-set.js
var require_primitive_set = __commonJS({
  "node_modules/es5-ext/object/primitive-set.js"(exports, module) {
    "use strict";
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    module.exports = function(arg) {
      var set = create(null);
      forEach.call(arguments, function(name) {
        set[name] = true;
      });
      return set;
    };
  }
});

// node_modules/es5-ext/object/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/es5-ext/object/is-callable.js"(exports, module) {
    "use strict";
    module.exports = function(obj) {
      return typeof obj === "function";
    };
  }
});

// node_modules/es5-ext/object/validate-stringifiable.js
var require_validate_stringifiable = __commonJS({
  "node_modules/es5-ext/object/validate-stringifiable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(stringifiable) {
      try {
        if (stringifiable && isCallable(stringifiable.toString))
          return stringifiable.toString();
        return String(stringifiable);
      } catch (e) {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    };
  }
});

// node_modules/es5-ext/object/validate-stringifiable-value.js
var require_validate_stringifiable_value = __commonJS({
  "node_modules/es5-ext/object/validate-stringifiable-value.js"(exports, module) {
    "use strict";
    var ensureValue = require_valid_value();
    var stringifiable = require_validate_stringifiable();
    module.exports = function(value2) {
      return stringifiable(ensureValue(value2));
    };
  }
});

// node_modules/es5-ext/safe-to-string.js
var require_safe_to_string = __commonJS({
  "node_modules/es5-ext/safe-to-string.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(value2) {
      try {
        if (value2 && isCallable(value2.toString))
          return value2.toString();
        return String(value2);
      } catch (e) {
        return "<Non-coercible to string value>";
      }
    };
  }
});

// node_modules/es5-ext/to-short-string-representation.js
var require_to_short_string_representation = __commonJS({
  "node_modules/es5-ext/to-short-string-representation.js"(exports, module) {
    "use strict";
    var safeToString = require_safe_to_string();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module.exports = function(value2) {
      var string = safeToString(value2);
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        return JSON.stringify(char).slice(1, -1);
      });
      return string;
    };
  }
});

// node_modules/is-promise/index.js
var require_is_promise = __commonJS({
  "node_modules/is-promise/index.js"(exports, module) {
    module.exports = isPromise;
    module.exports.default = isPromise;
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/promise.js
var require_promise = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/promise.js"() {
    "use strict";
    var objectMap = require_map();
    var primitiveSet = require_primitive_set();
    var ensureString = require_validate_stringifiable_value();
    var toShortString = require_to_short_string_representation();
    var isPromise = require_is_promise();
    var nextTick = require_next_tick();
    var create = Object.create;
    var supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");
    require_registered_extensions().promise = function(mode, conf) {
      var waiting = create(null), cache = create(null), promises = create(null);
      if (mode === true) {
        mode = null;
      } else {
        mode = ensureString(mode);
        if (!supportedModes[mode]) {
          throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
        }
      }
      conf.on("set", function(id, ignore, promise) {
        var isFailed = false;
        if (!isPromise(promise)) {
          cache[id] = promise;
          conf.emit("setasync", id, 1);
          return;
        }
        waiting[id] = 1;
        promises[id] = promise;
        var onSuccess = function(result) {
          var count = waiting[id];
          if (isFailed) {
            throw new Error(
              "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
            );
          }
          if (!count)
            return;
          delete waiting[id];
          cache[id] = result;
          conf.emit("setasync", id, count);
        };
        var onFailure = function() {
          isFailed = true;
          if (!waiting[id])
            return;
          delete waiting[id];
          delete promises[id];
          conf.delete(id);
        };
        var resolvedMode = mode;
        if (!resolvedMode)
          resolvedMode = "then";
        if (resolvedMode === "then") {
          var nextTickFailure = function() {
            nextTick(onFailure);
          };
          promise = promise.then(function(result) {
            nextTick(onSuccess.bind(this, result));
          }, nextTickFailure);
          if (typeof promise.finally === "function") {
            promise.finally(nextTickFailure);
          }
        } else if (resolvedMode === "done") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
            );
          }
          promise.done(onSuccess, onFailure);
        } else if (resolvedMode === "done:finally") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
            );
          }
          if (typeof promise.finally !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
            );
          }
          promise.done(onSuccess);
          promise.finally(onFailure);
        }
      });
      conf.on("get", function(id, args, context) {
        var promise;
        if (waiting[id]) {
          ++waiting[id];
          return;
        }
        promise = promises[id];
        var emit = function() {
          conf.emit("getasync", id, args, context);
        };
        if (isPromise(promise)) {
          if (typeof promise.done === "function")
            promise.done(emit);
          else {
            promise.then(function() {
              nextTick(emit);
            });
          }
        } else {
          emit();
        }
      });
      conf.on("delete", function(id) {
        delete promises[id];
        if (waiting[id]) {
          delete waiting[id];
          return;
        }
        if (!hasOwnProperty.call(cache, id))
          return;
        var result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, [result]);
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        waiting = create(null);
        promises = create(null);
        conf.emit("clearasync", objectMap(oldCache, function(data3) {
          return [data3];
        }));
      });
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/dispose.js
var require_dispose = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/dispose.js"() {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var apply = Function.prototype.apply;
    extensions.dispose = function(dispose, conf, options) {
      var del;
      callable(dispose);
      if (options.async && extensions.async || options.promise && extensions.promise) {
        conf.on("deleteasync", del = function(id, resultArray) {
          apply.call(dispose, null, resultArray);
        });
        conf.on("clearasync", function(cache) {
          forEach(cache, function(result, id) {
            del(id, result);
          });
        });
        return;
      }
      conf.on("delete", del = function(id, result) {
        dispose(result);
      });
      conf.on("clear", function(cache) {
        forEach(cache, function(result, id) {
          del(id, result);
        });
      });
    };
  }
});

// node_modules/timers-ext/max-timeout.js
var require_max_timeout = __commonJS({
  "node_modules/timers-ext/max-timeout.js"(exports, module) {
    "use strict";
    module.exports = 2147483647;
  }
});

// node_modules/timers-ext/valid-timeout.js
var require_valid_timeout = __commonJS({
  "node_modules/timers-ext/valid-timeout.js"(exports, module) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var maxTimeout = require_max_timeout();
    module.exports = function(value2) {
      value2 = toPosInt(value2);
      if (value2 > maxTimeout)
        throw new TypeError(value2 + " exceeds maximum possible timeout");
      return value2;
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/max-age.js
var require_max_age = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/max-age.js"() {
    "use strict";
    var aFrom = require_from();
    var forEach = require_for_each();
    var nextTick = require_next_tick();
    var isPromise = require_is_promise();
    var timeout = require_valid_timeout();
    var extensions = require_registered_extensions();
    var noop = Function.prototype;
    var max = Math.max;
    var min = Math.min;
    var create = Object.create;
    extensions.maxAge = function(maxAge, conf, options) {
      var timeouts, postfix, preFetchAge, preFetchTimeouts;
      maxAge = timeout(maxAge);
      if (!maxAge)
        return;
      timeouts = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id) {
        timeouts[id] = setTimeout(function() {
          conf.delete(id);
        }, maxAge);
        if (typeof timeouts[id].unref === "function")
          timeouts[id].unref();
        if (!preFetchTimeouts)
          return;
        if (preFetchTimeouts[id]) {
          if (preFetchTimeouts[id] !== "nextTick")
            clearTimeout(preFetchTimeouts[id]);
        }
        preFetchTimeouts[id] = setTimeout(function() {
          delete preFetchTimeouts[id];
        }, preFetchAge);
        if (typeof preFetchTimeouts[id].unref === "function")
          preFetchTimeouts[id].unref();
      });
      conf.on("delete" + postfix, function(id) {
        clearTimeout(timeouts[id]);
        delete timeouts[id];
        if (!preFetchTimeouts)
          return;
        if (preFetchTimeouts[id] !== "nextTick")
          clearTimeout(preFetchTimeouts[id]);
        delete preFetchTimeouts[id];
      });
      if (options.preFetch) {
        if (options.preFetch === true || isNaN(options.preFetch)) {
          preFetchAge = 0.333;
        } else {
          preFetchAge = max(min(Number(options.preFetch), 1), 0);
        }
        if (preFetchAge) {
          preFetchTimeouts = {};
          preFetchAge = (1 - preFetchAge) * maxAge;
          conf.on("get" + postfix, function(id, args, context) {
            if (!preFetchTimeouts[id]) {
              preFetchTimeouts[id] = "nextTick";
              nextTick(function() {
                var result;
                if (preFetchTimeouts[id] !== "nextTick")
                  return;
                delete preFetchTimeouts[id];
                conf.delete(id);
                if (options.async) {
                  args = aFrom(args);
                  args.push(noop);
                }
                result = conf.memoized.apply(context, args);
                if (options.promise) {
                  if (isPromise(result)) {
                    if (typeof result.done === "function")
                      result.done(noop, noop);
                    else
                      result.then(noop, noop);
                  }
                }
              });
            }
          });
        }
      }
      conf.on("clear" + postfix, function() {
        forEach(timeouts, function(id) {
          clearTimeout(id);
        });
        timeouts = {};
        if (preFetchTimeouts) {
          forEach(preFetchTimeouts, function(id) {
            if (id !== "nextTick")
              clearTimeout(id);
          });
          preFetchTimeouts = {};
        }
      });
    };
  }
});

// node_modules/lru-queue/index.js
var require_lru_queue = __commonJS({
  "node_modules/lru-queue/index.js"(exports, module) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module.exports = function(limit) {
      var size = 0, base = 1, queue = create(null), map4 = create(null), index2 = 0, del;
      limit = toPosInt(limit);
      return {
        hit: function(id) {
          var oldIndex = map4[id], nuIndex = ++index2;
          queue[nuIndex] = id;
          map4[id] = nuIndex;
          if (!oldIndex) {
            ++size;
            if (size <= limit)
              return;
            id = queue[base];
            del(id);
            return id;
          }
          delete queue[oldIndex];
          if (base !== oldIndex)
            return;
          while (!hasOwnProperty2.call(queue, ++base))
            continue;
        },
        delete: del = function(id) {
          var oldIndex = map4[id];
          if (!oldIndex)
            return;
          delete queue[oldIndex];
          delete map4[id];
          --size;
          if (base !== oldIndex)
            return;
          if (!size) {
            index2 = 0;
            base = 1;
            return;
          }
          while (!hasOwnProperty2.call(queue, ++base))
            continue;
        },
        clear: function() {
          size = 0;
          base = 1;
          queue = create(null);
          map4 = create(null);
          index2 = 0;
        }
      };
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/max.js
var require_max = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/max.js"() {
    "use strict";
    var toPosInteger = require_to_pos_integer();
    var lruQueue = require_lru_queue();
    var extensions = require_registered_extensions();
    extensions.max = function(max, conf, options) {
      var postfix, queue, hit;
      max = toPosInteger(max);
      if (!max)
        return;
      queue = lruQueue(max);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, hit = function(id) {
        id = queue.hit(id);
        if (id === void 0)
          return;
        conf.delete(id);
      });
      conf.on("get" + postfix, hit);
      conf.on("delete" + postfix, queue.delete);
      conf.on("clear" + postfix, queue.clear);
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/ext/ref-counter.js
var require_ref_counter = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/ext/ref-counter.js"() {
    "use strict";
    var d = require_d();
    var extensions = require_registered_extensions();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    extensions.refCounter = function(ignore, conf, options) {
      var cache, postfix;
      cache = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id, length) {
        cache[id] = length || 1;
      });
      conf.on("get" + postfix, function(id) {
        ++cache[id];
      });
      conf.on("delete" + postfix, function(id) {
        delete cache[id];
      });
      conf.on("clear" + postfix, function() {
        cache = {};
      });
      defineProperties(conf.memoized, {
        deleteRef: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return null;
          if (!cache[id])
            return null;
          if (!--cache[id]) {
            conf.delete(id);
            return true;
          }
          return false;
        }),
        getRefCount: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return 0;
          if (!cache[id])
            return 0;
          return cache[id];
        })
      });
    };
  }
});

// node_modules/google-play-scraper/node_modules/memoizee/index.js
var require_memoizee = __commonJS({
  "node_modules/google-play-scraper/node_modules/memoizee/index.js"(exports, module) {
    "use strict";
    var normalizeOpts = require_normalize_options();
    var resolveLength = require_resolve_length();
    var plain = require_plain();
    module.exports = function(fn) {
      var options = normalizeOpts(arguments[1]), length;
      if (!options.normalizer) {
        length = options.length = resolveLength(options.length, fn.length, options.async);
        if (length !== 0) {
          if (options.primitive) {
            if (length === false) {
              options.normalizer = require_primitive();
            } else if (length > 1) {
              options.normalizer = require_get_primitive_fixed()(length);
            }
          } else if (length === false)
            options.normalizer = require_get()();
          else if (length === 1)
            options.normalizer = require_get_1()();
          else
            options.normalizer = require_get_fixed()(length);
        }
      }
      if (options.async)
        require_async();
      if (options.promise)
        require_promise();
      if (options.dispose)
        require_dispose();
      if (options.maxAge)
        require_max_age();
      if (options.max)
        require_max();
      if (options.refCounter)
        require_ref_counter();
      return plain(fn, options);
    };
  }
});

// node_modules/@sindresorhus/is/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sindresorhus/is/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typedArrayTypeNames = [
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function isTypedArrayName(name) {
      return typedArrayTypeNames.includes(name);
    }
    var objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Blob",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "FormData",
      "URLSearchParams",
      "HTMLElement",
      ...typedArrayTypeNames
    ];
    function isObjectTypeName(name) {
      return objectTypeNames.includes(name);
    }
    var primitiveTypeNames = [
      "null",
      "undefined",
      "string",
      "number",
      "bigint",
      "boolean",
      "symbol"
    ];
    function isPrimitiveTypeName(name) {
      return primitiveTypeNames.includes(name);
    }
    function isOfType(type3) {
      return (value2) => typeof value2 === type3;
    }
    var { toString: toString3 } = Object.prototype;
    var getObjectType = (value2) => {
      const objectTypeName = toString3.call(value2).slice(8, -1);
      if (/HTML\w+Element/.test(objectTypeName) && is6.domElement(value2)) {
        return "HTMLElement";
      }
      if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    };
    var isObjectOfType = (type3) => (value2) => getObjectType(value2) === type3;
    function is6(value2) {
      if (value2 === null) {
        return "null";
      }
      switch (typeof value2) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "function":
          return "Function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        default:
      }
      if (is6.observable(value2)) {
        return "Observable";
      }
      if (is6.array(value2)) {
        return "Array";
      }
      if (is6.buffer(value2)) {
        return "Buffer";
      }
      const tagType = getObjectType(value2);
      if (tagType) {
        return tagType;
      }
      if (value2 instanceof String || value2 instanceof Boolean || value2 instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    is6.undefined = isOfType("undefined");
    is6.string = isOfType("string");
    var isNumberType = isOfType("number");
    is6.number = (value2) => isNumberType(value2) && !is6.nan(value2);
    is6.bigint = isOfType("bigint");
    is6.function_ = isOfType("function");
    is6.null_ = (value2) => value2 === null;
    is6.class_ = (value2) => is6.function_(value2) && value2.toString().startsWith("class ");
    is6.boolean = (value2) => value2 === true || value2 === false;
    is6.symbol = isOfType("symbol");
    is6.numericString = (value2) => is6.string(value2) && !is6.emptyStringOrWhitespace(value2) && !Number.isNaN(Number(value2));
    is6.array = (value2, assertion) => {
      if (!Array.isArray(value2)) {
        return false;
      }
      if (!is6.function_(assertion)) {
        return true;
      }
      return value2.every(assertion);
    };
    is6.buffer = (value2) => {
      var _a2, _b, _c, _d;
      return (_d = (_c = (_b = (_a2 = value2) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value2)) !== null && _d !== void 0 ? _d : false;
    };
    is6.blob = (value2) => isObjectOfType("Blob")(value2);
    is6.nullOrUndefined = (value2) => is6.null_(value2) || is6.undefined(value2);
    is6.object = (value2) => !is6.null_(value2) && (typeof value2 === "object" || is6.function_(value2));
    is6.iterable = (value2) => {
      var _a2;
      return is6.function_((_a2 = value2) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]);
    };
    is6.asyncIterable = (value2) => {
      var _a2;
      return is6.function_((_a2 = value2) === null || _a2 === void 0 ? void 0 : _a2[Symbol.asyncIterator]);
    };
    is6.generator = (value2) => {
      var _a2, _b;
      return is6.iterable(value2) && is6.function_((_a2 = value2) === null || _a2 === void 0 ? void 0 : _a2.next) && is6.function_((_b = value2) === null || _b === void 0 ? void 0 : _b.throw);
    };
    is6.asyncGenerator = (value2) => is6.asyncIterable(value2) && is6.function_(value2.next) && is6.function_(value2.throw);
    is6.nativePromise = (value2) => isObjectOfType("Promise")(value2);
    var hasPromiseAPI = (value2) => {
      var _a2, _b;
      return is6.function_((_a2 = value2) === null || _a2 === void 0 ? void 0 : _a2.then) && is6.function_((_b = value2) === null || _b === void 0 ? void 0 : _b.catch);
    };
    is6.promise = (value2) => is6.nativePromise(value2) || hasPromiseAPI(value2);
    is6.generatorFunction = isObjectOfType("GeneratorFunction");
    is6.asyncGeneratorFunction = (value2) => getObjectType(value2) === "AsyncGeneratorFunction";
    is6.asyncFunction = (value2) => getObjectType(value2) === "AsyncFunction";
    is6.boundFunction = (value2) => is6.function_(value2) && !value2.hasOwnProperty("prototype");
    is6.regExp = isObjectOfType("RegExp");
    is6.date = isObjectOfType("Date");
    is6.error = isObjectOfType("Error");
    is6.map = (value2) => isObjectOfType("Map")(value2);
    is6.set = (value2) => isObjectOfType("Set")(value2);
    is6.weakMap = (value2) => isObjectOfType("WeakMap")(value2);
    is6.weakSet = (value2) => isObjectOfType("WeakSet")(value2);
    is6.int8Array = isObjectOfType("Int8Array");
    is6.uint8Array = isObjectOfType("Uint8Array");
    is6.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
    is6.int16Array = isObjectOfType("Int16Array");
    is6.uint16Array = isObjectOfType("Uint16Array");
    is6.int32Array = isObjectOfType("Int32Array");
    is6.uint32Array = isObjectOfType("Uint32Array");
    is6.float32Array = isObjectOfType("Float32Array");
    is6.float64Array = isObjectOfType("Float64Array");
    is6.bigInt64Array = isObjectOfType("BigInt64Array");
    is6.bigUint64Array = isObjectOfType("BigUint64Array");
    is6.arrayBuffer = isObjectOfType("ArrayBuffer");
    is6.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
    is6.dataView = isObjectOfType("DataView");
    is6.enumCase = (value2, targetEnum) => Object.values(targetEnum).includes(value2);
    is6.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
    is6.urlInstance = (value2) => isObjectOfType("URL")(value2);
    is6.urlString = (value2) => {
      if (!is6.string(value2)) {
        return false;
      }
      try {
        new URL(value2);
        return true;
      } catch (_a2) {
        return false;
      }
    };
    is6.truthy = (value2) => Boolean(value2);
    is6.falsy = (value2) => !value2;
    is6.nan = (value2) => Number.isNaN(value2);
    is6.primitive = (value2) => is6.null_(value2) || isPrimitiveTypeName(typeof value2);
    is6.integer = (value2) => Number.isInteger(value2);
    is6.safeInteger = (value2) => Number.isSafeInteger(value2);
    is6.plainObject = (value2) => {
      if (toString3.call(value2) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value2);
      return prototype === null || prototype === Object.getPrototypeOf({});
    };
    is6.typedArray = (value2) => isTypedArrayName(getObjectType(value2));
    var isValidLength = (value2) => is6.safeInteger(value2) && value2 >= 0;
    is6.arrayLike = (value2) => !is6.nullOrUndefined(value2) && !is6.function_(value2) && isValidLength(value2.length);
    is6.inRange = (value2, range) => {
      if (is6.number(range)) {
        return value2 >= Math.min(0, range) && value2 <= Math.max(range, 0);
      }
      if (is6.array(range) && range.length === 2) {
        return value2 >= Math.min(...range) && value2 <= Math.max(...range);
      }
      throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
    };
    var NODE_TYPE_ELEMENT = 1;
    var DOM_PROPERTIES_TO_CHECK = [
      "innerHTML",
      "ownerDocument",
      "style",
      "attributes",
      "nodeValue"
    ];
    is6.domElement = (value2) => {
      return is6.object(value2) && value2.nodeType === NODE_TYPE_ELEMENT && is6.string(value2.nodeName) && !is6.plainObject(value2) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value2);
    };
    is6.observable = (value2) => {
      var _a2, _b, _c, _d;
      if (!value2) {
        return false;
      }
      if (value2 === ((_b = (_a2 = value2)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a2))) {
        return true;
      }
      if (value2 === ((_d = (_c = value2)["@@observable"]) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
      }
      return false;
    };
    is6.nodeStream = (value2) => is6.object(value2) && is6.function_(value2.pipe) && !is6.observable(value2);
    is6.infinite = (value2) => value2 === Infinity || value2 === -Infinity;
    var isAbsoluteMod2 = (remainder) => (value2) => is6.integer(value2) && Math.abs(value2 % 2) === remainder;
    is6.evenInteger = isAbsoluteMod2(0);
    is6.oddInteger = isAbsoluteMod2(1);
    is6.emptyArray = (value2) => is6.array(value2) && value2.length === 0;
    is6.nonEmptyArray = (value2) => is6.array(value2) && value2.length > 0;
    is6.emptyString = (value2) => is6.string(value2) && value2.length === 0;
    var isWhiteSpaceString = (value2) => is6.string(value2) && !/\S/.test(value2);
    is6.emptyStringOrWhitespace = (value2) => is6.emptyString(value2) || isWhiteSpaceString(value2);
    is6.nonEmptyString = (value2) => is6.string(value2) && value2.length > 0;
    is6.nonEmptyStringAndNotWhitespace = (value2) => is6.string(value2) && !is6.emptyStringOrWhitespace(value2);
    is6.emptyObject = (value2) => is6.object(value2) && !is6.map(value2) && !is6.set(value2) && Object.keys(value2).length === 0;
    is6.nonEmptyObject = (value2) => is6.object(value2) && !is6.map(value2) && !is6.set(value2) && Object.keys(value2).length > 0;
    is6.emptySet = (value2) => is6.set(value2) && value2.size === 0;
    is6.nonEmptySet = (value2) => is6.set(value2) && value2.size > 0;
    is6.emptyMap = (value2) => is6.map(value2) && value2.size === 0;
    is6.nonEmptyMap = (value2) => is6.map(value2) && value2.size > 0;
    is6.propertyKey = (value2) => is6.any([is6.string, is6.number, is6.symbol], value2);
    is6.formData = (value2) => isObjectOfType("FormData")(value2);
    is6.urlSearchParams = (value2) => isObjectOfType("URLSearchParams")(value2);
    var predicateOnArray = (method, predicate, values3) => {
      if (!is6.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
      }
      if (values3.length === 0) {
        throw new TypeError("Invalid number of values");
      }
      return method.call(values3, predicate);
    };
    is6.any = (predicate, ...values3) => {
      const predicates = is6.array(predicate) ? predicate : [predicate];
      return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values3));
    };
    is6.all = (predicate, ...values3) => predicateOnArray(Array.prototype.every, predicate, values3);
    var assertType = (condition, description, value2, options = {}) => {
      if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues ? `received values of types ${[
          ...new Set(value2.map((singleValue) => `\`${is6(singleValue)}\``))
        ].join(", ")}` : `received value of type \`${is6(value2)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
      }
    };
    exports.assert = {
      // Unknowns.
      undefined: (value2) => assertType(is6.undefined(value2), "undefined", value2),
      string: (value2) => assertType(is6.string(value2), "string", value2),
      number: (value2) => assertType(is6.number(value2), "number", value2),
      bigint: (value2) => assertType(is6.bigint(value2), "bigint", value2),
      // eslint-disable-next-line @typescript-eslint/ban-types
      function_: (value2) => assertType(is6.function_(value2), "Function", value2),
      null_: (value2) => assertType(is6.null_(value2), "null", value2),
      class_: (value2) => assertType(is6.class_(value2), "Class", value2),
      boolean: (value2) => assertType(is6.boolean(value2), "boolean", value2),
      symbol: (value2) => assertType(is6.symbol(value2), "symbol", value2),
      numericString: (value2) => assertType(is6.numericString(value2), "string with a number", value2),
      array: (value2, assertion) => {
        const assert = assertType;
        assert(is6.array(value2), "Array", value2);
        if (assertion) {
          value2.forEach(assertion);
        }
      },
      buffer: (value2) => assertType(is6.buffer(value2), "Buffer", value2),
      blob: (value2) => assertType(is6.blob(value2), "Blob", value2),
      nullOrUndefined: (value2) => assertType(is6.nullOrUndefined(value2), "null or undefined", value2),
      object: (value2) => assertType(is6.object(value2), "Object", value2),
      iterable: (value2) => assertType(is6.iterable(value2), "Iterable", value2),
      asyncIterable: (value2) => assertType(is6.asyncIterable(value2), "AsyncIterable", value2),
      generator: (value2) => assertType(is6.generator(value2), "Generator", value2),
      asyncGenerator: (value2) => assertType(is6.asyncGenerator(value2), "AsyncGenerator", value2),
      nativePromise: (value2) => assertType(is6.nativePromise(value2), "native Promise", value2),
      promise: (value2) => assertType(is6.promise(value2), "Promise", value2),
      generatorFunction: (value2) => assertType(is6.generatorFunction(value2), "GeneratorFunction", value2),
      asyncGeneratorFunction: (value2) => assertType(is6.asyncGeneratorFunction(value2), "AsyncGeneratorFunction", value2),
      // eslint-disable-next-line @typescript-eslint/ban-types
      asyncFunction: (value2) => assertType(is6.asyncFunction(value2), "AsyncFunction", value2),
      // eslint-disable-next-line @typescript-eslint/ban-types
      boundFunction: (value2) => assertType(is6.boundFunction(value2), "Function", value2),
      regExp: (value2) => assertType(is6.regExp(value2), "RegExp", value2),
      date: (value2) => assertType(is6.date(value2), "Date", value2),
      error: (value2) => assertType(is6.error(value2), "Error", value2),
      map: (value2) => assertType(is6.map(value2), "Map", value2),
      set: (value2) => assertType(is6.set(value2), "Set", value2),
      weakMap: (value2) => assertType(is6.weakMap(value2), "WeakMap", value2),
      weakSet: (value2) => assertType(is6.weakSet(value2), "WeakSet", value2),
      int8Array: (value2) => assertType(is6.int8Array(value2), "Int8Array", value2),
      uint8Array: (value2) => assertType(is6.uint8Array(value2), "Uint8Array", value2),
      uint8ClampedArray: (value2) => assertType(is6.uint8ClampedArray(value2), "Uint8ClampedArray", value2),
      int16Array: (value2) => assertType(is6.int16Array(value2), "Int16Array", value2),
      uint16Array: (value2) => assertType(is6.uint16Array(value2), "Uint16Array", value2),
      int32Array: (value2) => assertType(is6.int32Array(value2), "Int32Array", value2),
      uint32Array: (value2) => assertType(is6.uint32Array(value2), "Uint32Array", value2),
      float32Array: (value2) => assertType(is6.float32Array(value2), "Float32Array", value2),
      float64Array: (value2) => assertType(is6.float64Array(value2), "Float64Array", value2),
      bigInt64Array: (value2) => assertType(is6.bigInt64Array(value2), "BigInt64Array", value2),
      bigUint64Array: (value2) => assertType(is6.bigUint64Array(value2), "BigUint64Array", value2),
      arrayBuffer: (value2) => assertType(is6.arrayBuffer(value2), "ArrayBuffer", value2),
      sharedArrayBuffer: (value2) => assertType(is6.sharedArrayBuffer(value2), "SharedArrayBuffer", value2),
      dataView: (value2) => assertType(is6.dataView(value2), "DataView", value2),
      enumCase: (value2, targetEnum) => assertType(is6.enumCase(value2, targetEnum), "EnumCase", value2),
      urlInstance: (value2) => assertType(is6.urlInstance(value2), "URL", value2),
      urlString: (value2) => assertType(is6.urlString(value2), "string with a URL", value2),
      truthy: (value2) => assertType(is6.truthy(value2), "truthy", value2),
      falsy: (value2) => assertType(is6.falsy(value2), "falsy", value2),
      nan: (value2) => assertType(is6.nan(value2), "NaN", value2),
      primitive: (value2) => assertType(is6.primitive(value2), "primitive", value2),
      integer: (value2) => assertType(is6.integer(value2), "integer", value2),
      safeInteger: (value2) => assertType(is6.safeInteger(value2), "integer", value2),
      plainObject: (value2) => assertType(is6.plainObject(value2), "plain object", value2),
      typedArray: (value2) => assertType(is6.typedArray(value2), "TypedArray", value2),
      arrayLike: (value2) => assertType(is6.arrayLike(value2), "array-like", value2),
      domElement: (value2) => assertType(is6.domElement(value2), "HTMLElement", value2),
      observable: (value2) => assertType(is6.observable(value2), "Observable", value2),
      nodeStream: (value2) => assertType(is6.nodeStream(value2), "Node.js Stream", value2),
      infinite: (value2) => assertType(is6.infinite(value2), "infinite number", value2),
      emptyArray: (value2) => assertType(is6.emptyArray(value2), "empty array", value2),
      nonEmptyArray: (value2) => assertType(is6.nonEmptyArray(value2), "non-empty array", value2),
      emptyString: (value2) => assertType(is6.emptyString(value2), "empty string", value2),
      emptyStringOrWhitespace: (value2) => assertType(is6.emptyStringOrWhitespace(value2), "empty string or whitespace", value2),
      nonEmptyString: (value2) => assertType(is6.nonEmptyString(value2), "non-empty string", value2),
      nonEmptyStringAndNotWhitespace: (value2) => assertType(is6.nonEmptyStringAndNotWhitespace(value2), "non-empty string and not whitespace", value2),
      emptyObject: (value2) => assertType(is6.emptyObject(value2), "empty object", value2),
      nonEmptyObject: (value2) => assertType(is6.nonEmptyObject(value2), "non-empty object", value2),
      emptySet: (value2) => assertType(is6.emptySet(value2), "empty set", value2),
      nonEmptySet: (value2) => assertType(is6.nonEmptySet(value2), "non-empty set", value2),
      emptyMap: (value2) => assertType(is6.emptyMap(value2), "empty map", value2),
      nonEmptyMap: (value2) => assertType(is6.nonEmptyMap(value2), "non-empty map", value2),
      propertyKey: (value2) => assertType(is6.propertyKey(value2), "PropertyKey", value2),
      formData: (value2) => assertType(is6.formData(value2), "FormData", value2),
      urlSearchParams: (value2) => assertType(is6.urlSearchParams(value2), "URLSearchParams", value2),
      // Numbers.
      evenInteger: (value2) => assertType(is6.evenInteger(value2), "even integer", value2),
      oddInteger: (value2) => assertType(is6.oddInteger(value2), "odd integer", value2),
      // Two arguments.
      directInstanceOf: (instance, class_) => assertType(is6.directInstanceOf(instance, class_), "T", instance),
      inRange: (value2, range) => assertType(is6.inRange(value2, range), "in range", value2),
      // Variadic functions.
      any: (predicate, ...values3) => {
        return assertType(is6.any(predicate, ...values3), "predicate returns truthy for any value", values3, { multipleValues: true });
      },
      all: (predicate, ...values3) => assertType(is6.all(predicate, ...values3), "predicate returns truthy for all values", values3, { multipleValues: true })
    };
    Object.defineProperties(is6, {
      class: {
        value: is6.class_
      },
      function: {
        value: is6.function_
      },
      null: {
        value: is6.null_
      }
    });
    Object.defineProperties(exports.assert, {
      class: {
        value: exports.assert.class_
      },
      function: {
        value: exports.assert.function_
      },
      null: {
        value: exports.assert.null_
      }
    });
    exports.default = is6;
    module.exports = is6;
    module.exports.default = is6;
    module.exports.assert = exports.assert;
  }
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "node_modules/p-cancelable/index.js"(exports, module) {
    "use strict";
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class _PCancelable {
      static fn(userFn) {
        return (...arguments_) => {
          return new _PCancelable((resolve, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve, reject) => {
          this._reject = reject;
          const onResolve = (value2) => {
            if (!this._isCanceled || !onCancel.shouldReject) {
              this._isPending = false;
              resolve(value2);
            }
          };
          const onReject = (error) => {
            this._isPending = false;
            reject(error);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
            return;
          }
        }
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module.exports = PCancelable;
    module.exports.CancelError = CancelError;
  }
});

// node_modules/defer-to-connect/dist/source/index.js
var require_source = __commonJS({
  "node_modules/defer-to-connect/dist/source/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    var deferToConnect = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports.default = deferToConnect;
    module.exports = deferToConnect;
    module.exports.default = deferToConnect;
  }
});

// node_modules/@szmarczak/http-timer/dist/source/index.js
var require_source2 = __commonJS({
  "node_modules/@szmarczak/http-timer/dist/source/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defer_to_connect_1 = require_source();
    var util_1 = __require("util");
    var nodejsMajorVersion = Number(process.versions.node.split(".")[0]);
    var timer = (request2) => {
      if (request2.timings) {
        return request2.timings;
      }
      const timings = {
        start: Date.now(),
        socket: void 0,
        lookup: void 0,
        connect: void 0,
        secureConnect: void 0,
        upload: void 0,
        response: void 0,
        end: void 0,
        error: void 0,
        abort: void 0,
        phases: {
          wait: void 0,
          dns: void 0,
          tcp: void 0,
          tls: void 0,
          request: void 0,
          firstByte: void 0,
          download: void 0,
          total: void 0
        }
      };
      request2.timings = timings;
      const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
          if (event === "error") {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
            origin.emit = emit;
          }
          return emit(event, ...args);
        };
      };
      handleError(request2);
      const onAbort = () => {
        timings.abort = Date.now();
        if (!timings.response || nodejsMajorVersion >= 13) {
          timings.phases.total = Date.now() - timings.start;
        }
      };
      request2.prependOnceListener("abort", onAbort);
      const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (util_1.types.isProxy(socket)) {
          return;
        }
        const lookupListener = () => {
          timings.lookup = Date.now();
          timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener("lookup", lookupListener);
        defer_to_connect_1.default(socket, {
          connect: () => {
            timings.connect = Date.now();
            if (timings.lookup === void 0) {
              socket.removeListener("lookup", lookupListener);
              timings.lookup = timings.connect;
              timings.phases.dns = timings.lookup - timings.socket;
            }
            timings.phases.tcp = timings.connect - timings.lookup;
          },
          secureConnect: () => {
            timings.secureConnect = Date.now();
            timings.phases.tls = timings.secureConnect - timings.connect;
          }
        });
      };
      if (request2.socket) {
        onSocket(request2.socket);
      } else {
        request2.prependOnceListener("socket", onSocket);
      }
      const onUpload = () => {
        var _a2;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - ((_a2 = timings.secureConnect) !== null && _a2 !== void 0 ? _a2 : timings.connect);
      };
      const writableFinished = () => {
        if (typeof request2.writableFinished === "boolean") {
          return request2.writableFinished;
        }
        return request2.finished && request2.outputSize === 0 && (!request2.socket || request2.socket.writableLength === 0);
      };
      if (writableFinished()) {
        onUpload();
      } else {
        request2.prependOnceListener("finish", onUpload);
      }
      request2.prependOnceListener("response", (response2) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response2.timings = timings;
        handleError(response2);
        response2.prependOnceListener("end", () => {
          timings.end = Date.now();
          timings.phases.download = timings.end - timings.response;
          timings.phases.total = timings.end - timings.start;
        });
        response2.prependOnceListener("aborted", onAbort);
      });
      return timings;
    };
    exports.default = timer;
    module.exports = timer;
    module.exports.default = timer;
  }
});

// node_modules/cacheable-lookup/source/index.js
var require_source3 = __commonJS({
  "node_modules/cacheable-lookup/source/index.js"(exports, module) {
    "use strict";
    var {
      V4MAPPED,
      ADDRCONFIG,
      ALL,
      promises: {
        Resolver: AsyncResolver
      },
      lookup: dnsLookup
    } = __require("dns");
    var { promisify } = __require("util");
    var os = __require("os");
    var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
    var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
    var kExpires = Symbol("expires");
    var supportsALL = typeof ALL === "number";
    var verifyAgent = (agent) => {
      if (!(agent && typeof agent.createConnection === "function")) {
        throw new Error("Expected an Agent instance as the first argument");
      }
    };
    var map4to6 = (entries) => {
      for (const entry of entries) {
        if (entry.family === 6) {
          continue;
        }
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
      }
    };
    var getIfaceInfo = () => {
      let has4 = false;
      let has6 = false;
      for (const device of Object.values(os.networkInterfaces())) {
        for (const iface of device) {
          if (iface.internal) {
            continue;
          }
          if (iface.family === "IPv6") {
            has6 = true;
          } else {
            has4 = true;
          }
          if (has4 && has6) {
            return { has4, has6 };
          }
        }
      }
      return { has4, has6 };
    };
    var isIterable = (map4) => {
      return Symbol.iterator in map4;
    };
    var ttl = { ttl: true };
    var all = { all: true };
    var CacheableLookup = class {
      constructor({
        cache = /* @__PURE__ */ new Map(),
        maxTtl = Infinity,
        fallbackDuration = 3600,
        errorTtl = 0.15,
        resolver = new AsyncResolver(),
        lookup = dnsLookup
      } = {}) {
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache;
        this._resolver = resolver;
        this._dnsLookup = promisify(lookup);
        if (this._resolver instanceof AsyncResolver) {
          this._resolve4 = this._resolver.resolve4.bind(this._resolver);
          this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
          this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
          this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = /* @__PURE__ */ new Set();
        if (fallbackDuration < 1) {
          this._fallback = false;
        } else {
          this._fallback = true;
          const interval = setInterval(() => {
            this._hostnamesToFallback.clear();
          }, fallbackDuration * 1e3);
          if (interval.unref) {
            interval.unref();
          }
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
      }
      set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
      }
      get servers() {
        return this._resolver.getServers();
      }
      lookup(hostname, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "number") {
          options = {
            family: options
          };
        }
        if (!callback) {
          throw new Error("Callback must be a function.");
        }
        this.lookupAsync(hostname, options).then((result) => {
          if (options.all) {
            callback(null, result);
          } else {
            callback(null, result.address, result.family, result.expires, result.ttl);
          }
        }, callback);
      }
      async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") {
          options = {
            family: options
          };
        }
        let cached = await this.query(hostname);
        if (options.family === 6) {
          const filtered = cached.filter((entry) => entry.family === 6);
          if (options.hints & V4MAPPED) {
            if (supportsALL && options.hints & ALL || filtered.length === 0) {
              map4to6(cached);
            } else {
              cached = filtered;
            }
          } else {
            cached = filtered;
          }
        } else if (options.family === 4) {
          cached = cached.filter((entry) => entry.family === 4);
        }
        if (options.hints & ADDRCONFIG) {
          const { _iface } = this;
          cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
          const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
          error.code = "ENOTFOUND";
          error.hostname = hostname;
          throw error;
        }
        if (options.all) {
          return cached;
        }
        return cached[0];
      }
      async query(hostname) {
        let cached = await this._cache.get(hostname);
        if (!cached) {
          const pending = this._pending[hostname];
          if (pending) {
            cached = await pending;
          } else {
            const newPromise = this.queryAndCache(hostname);
            this._pending[hostname] = newPromise;
            try {
              cached = await newPromise;
            } finally {
              delete this._pending[hostname];
            }
          }
        }
        cached = cached.map((entry) => {
          return { ...entry };
        });
        return cached;
      }
      async _resolve(hostname) {
        const wrap2 = async (promise) => {
          try {
            return await promise;
          } catch (error) {
            if (error.code === "ENODATA" || error.code === "ENOTFOUND") {
              return [];
            }
            throw error;
          }
        };
        const [A, AAAA] = await Promise.all([
          this._resolve4(hostname, ttl),
          this._resolve6(hostname, ttl)
        ].map((promise) => wrap2(promise)));
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now = Date.now();
        for (const entry of A) {
          entry.family = 4;
          entry.expires = now + entry.ttl * 1e3;
          aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA) {
          entry.family = 6;
          entry.expires = now + entry.ttl * 1e3;
          aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
          if (AAAA.length > 0) {
            cacheTtl = Math.min(aTtl, aaaaTtl);
          } else {
            cacheTtl = aTtl;
          }
        } else {
          cacheTtl = aaaaTtl;
        }
        return {
          entries: [
            ...A,
            ...AAAA
          ],
          cacheTtl
        };
      }
      async _lookup(hostname) {
        try {
          const entries = await this._dnsLookup(hostname, {
            all: true
          });
          return {
            entries,
            cacheTtl: 0
          };
        } catch (_) {
          return {
            entries: [],
            cacheTtl: 0
          };
        }
      }
      async _set(hostname, data3, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
          cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
          data3[kExpires] = Date.now() + cacheTtl;
          try {
            await this._cache.set(hostname, data3, cacheTtl);
          } catch (error) {
            this.lookupAsync = async () => {
              const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
              cacheError.cause = error;
              throw cacheError;
            };
          }
          if (isIterable(this._cache)) {
            this._tick(cacheTtl);
          }
        }
      }
      async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) {
          return this._dnsLookup(hostname, all);
        }
        let query = await this._resolve(hostname);
        if (query.entries.length === 0 && this._fallback) {
          query = await this._lookup(hostname);
          if (query.entries.length !== 0) {
            this._hostnamesToFallback.add(hostname);
          }
        }
        const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
        await this._set(hostname, query.entries, cacheTtl);
        return query.entries;
      }
      _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
          clearTimeout(this._removalTimeout);
          this._nextRemovalTime = ms;
          this._removalTimeout = setTimeout(() => {
            this._nextRemovalTime = false;
            let nextExpiry = Infinity;
            const now = Date.now();
            for (const [hostname, entries] of this._cache) {
              const expires = entries[kExpires];
              if (now >= expires) {
                this._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
            if (nextExpiry !== Infinity) {
              this._tick(nextExpiry - now);
            }
          }, ms);
          if (this._removalTimeout.unref) {
            this._removalTimeout.unref();
          }
        }
      }
      install(agent) {
        verifyAgent(agent);
        if (kCacheableLookupCreateConnection in agent) {
          throw new Error("CacheableLookup has been already installed");
        }
        agent[kCacheableLookupCreateConnection] = agent.createConnection;
        agent[kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback) => {
          if (!("lookup" in options)) {
            options.lookup = this.lookup;
          }
          return agent[kCacheableLookupCreateConnection](options, callback);
        };
      }
      uninstall(agent) {
        verifyAgent(agent);
        if (agent[kCacheableLookupCreateConnection]) {
          if (agent[kCacheableLookupInstance] !== this) {
            throw new Error("The agent is not owned by this CacheableLookup instance");
          }
          agent.createConnection = agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupInstance];
        }
      }
      updateInterfaceInfo() {
        const { _iface } = this;
        this._iface = getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
          this._cache.clear();
        }
      }
      clear(hostname) {
        if (hostname) {
          this._cache.delete(hostname);
          return;
        }
        this._cache.clear();
      }
    };
    module.exports = CacheableLookup;
    module.exports.default = CacheableLookup;
  }
});

// node_modules/normalize-url/index.js
var require_normalize_url = __commonJS({
  "node_modules/normalize-url/index.js"(exports, module) {
    "use strict";
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters2) => {
      return filters2.some((filter4) => filter4 instanceof RegExp ? filter4.test(name) : filter4 === name);
    };
    var normalizeDataURL = (urlString, { stripHash }) => {
      const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      let { type: type3, data: data3, hash } = match.groups;
      const mediaType = type3.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        isBase64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes2 = mediaType.map((attribute) => {
        let [key, value2 = ""] = attribute.split("=").map((string) => string.trim());
        if (key === "charset") {
          value2 = value2.toLowerCase();
          if (value2 === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value2 ? `=${value2}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes2
      ];
      if (isBase64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${isBase64 ? data3.trim() : data3}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = {
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripTextFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeSingleSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true,
        ...options
      };
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      if (/^view-source:/i.test(urlString)) {
        throw new Error("`view-source:` is not supported as it is a non-standard protocol");
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URL(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      } else if (options.stripTextFragment) {
        urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, "/");
      }
      if (urlObj.pathname) {
        try {
          urlObj.pathname = decodeURI(urlObj.pathname);
        } catch (_) {
        }
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.removeQueryParameters === true) {
        urlObj.search = "";
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      const oldUrlString = urlString;
      urlString = urlObj.toString();
      if (!options.removeSingleSlash && urlObj.pathname === "/" && !oldUrlString.endsWith("/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "" && options.removeSingleSlash) {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module.exports = normalizeUrl;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs = __require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe2 = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    };
    module.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports, module) {
    "use strict";
    var { PassThrough: PassThroughStream } = __require("stream");
    module.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports, module) {
    "use strict";
    var { constants: BufferConstants } = __require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module.exports = getStream;
    module.exports.default = getStream;
    module.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
    module.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
    module.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "node_modules/http-cache-semantics/index.js"(exports, module) {
    "use strict";
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      // included, because we add Age update Date
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response2) {
      if (!response2) {
        return true;
      }
      return errorStatusCodes.has(response2.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/,/);
      for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === void 0 ? true : v.trim().replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      /**
       * Value of the Date response header or current time if Date was invalid
       * @return timestamp
       */
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       *
       * @return Number
       */
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * @return Number
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @return {Object} {policy: CachePolicy, modified: Boolean}
       */
      revalidatedPolicy(request2, response2) {
        this._assertRequestHasHeaders(request2);
        if (this._useStaleIfError() && isErrorResponse(response2)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response2 || !response2.headers) {
          throw Error("Response headers missing");
        }
        let matches2 = false;
        if (response2.status !== void 0 && response2.status != 304) {
          matches2 = false;
        } else if (response2.headers.etag && !/^\s*W\//.test(response2.headers.etag)) {
          matches2 = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response2.headers.etag;
        } else if (this._resHeaders.etag && response2.headers.etag) {
          matches2 = this._resHeaders.etag.replace(/^\s*W\//, "") === response2.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches2 = this._resHeaders["last-modified"] === response2.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response2.headers.etag && !response2.headers["last-modified"]) {
            matches2 = true;
          }
        }
        if (!matches2) {
          return {
            policy: new this.constructor(request2, response2),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response2.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response2.headers && !excludedFromRevalidationUpdate[k] ? response2.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response2, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request2, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "node_modules/lowercase-keys/index.js"(exports, module) {
    "use strict";
    module.exports = (object) => {
      const result = {};
      for (const [key, value2] of Object.entries(object)) {
        result[key.toLowerCase()] = value2;
      }
      return result;
    };
  }
});

// node_modules/responselike/src/index.js
var require_src = __commonJS({
  "node_modules/responselike/src/index.js"(exports, module) {
    "use strict";
    var Readable = __require("stream").Readable;
    var lowercaseKeys = require_lowercase_keys();
    var Response = class extends Readable {
      constructor(statusCode, headers, body, url6) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url6 !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys(headers);
        this.body = body;
        this.url = url6;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module.exports = Response;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports, module) {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop2 of fromProps) {
        if (prop2 in toStream) {
          continue;
        }
        toStream[prop2] = typeof fromStream[prop2] === "function" ? fromStream[prop2].bind(fromStream) : fromStream[prop2];
      }
    };
  }
});

// node_modules/clone-response/src/index.js
var require_src2 = __commonJS({
  "node_modules/clone-response/src/index.js"(exports, module) {
    "use strict";
    var PassThrough = __require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response2) => {
      if (!(response2 && response2.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone2 = new PassThrough();
      mimicResponse(response2, clone2);
      return response2.pipe(clone2);
    };
    module.exports = cloneResponse;
  }
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "node_modules/json-buffer/index.js"(exports) {
    exports.stringify = function stringify2(o) {
      if ("undefined" == typeof o)
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && "object" === typeof o) {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first2 = true;
        for (var k in o) {
          var ignore = "function" == typeof o[k] || !array && "undefined" === typeof o[k];
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first2)
              s += ",";
            first2 = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify2(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify2(k) + ":" + stringify2(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if ("string" === typeof o) {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if ("undefined" === typeof o) {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports.parse = function(s) {
      return JSON.parse(s, function(key, value2) {
        if ("string" === typeof value2) {
          if (/^:base64:/.test(value2))
            return Buffer.from(value2.substring(8), "base64");
          else
            return /^:/.test(value2) ? value2.substring(1) : value2;
        }
        return value2;
      });
    };
  }
});

// node_modules/keyv/src/index.js
var require_src3 = __commonJS({
  "node_modules/keyv/src/index.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var JSONB = require_json_buffer();
    var loadStore = (options) => {
      const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        const adapter2 = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (__require(adapters[adapter2]))(options);
      }
      return /* @__PURE__ */ new Map();
    };
    var iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ];
    var Keyv = class extends EventEmitter {
      constructor(uri, { emitErrors = true, ...options } = {}) {
        super();
        this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri === "string" ? { uri } : uri,
          ...options
        };
        if (!this.opts.store) {
          const adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compression) {
          const compression = this.opts.compression;
          this.opts.serialize = compression.serialize.bind(compression);
          this.opts.deserialize = compression.deserialize.bind(compression);
        }
        if (typeof this.opts.store.on === "function" && emitErrors) {
          this.opts.store.on("error", (error) => this.emit("error", error));
        }
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = (iterator) => async function* () {
          for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
            const data3 = await this.opts.deserialize(raw);
            if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
              continue;
            }
            if (typeof data3.expires === "number" && Date.now() > data3.expires) {
              this.delete(key);
              continue;
            }
            yield [this._getKeyUnprefix(key), data3.value];
          }
        };
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
          this.iterator = generateIterator(this.opts.store);
        } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
          this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
        }
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys4) {
        return keys4.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        const { store: store2 } = this.opts;
        const isArray = Array.isArray(key);
        const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray && store2.getMany === void 0) {
          const promises = [];
          for (const key2 of keyPrefixed) {
            promises.push(
              Promise.resolve().then(() => store2.get(key2)).then((data3) => typeof data3 === "string" ? this.opts.deserialize(data3) : this.opts.compression ? this.opts.deserialize(data3) : data3).then((data3) => {
                if (data3 === void 0 || data3 === null) {
                  return void 0;
                }
                if (typeof data3.expires === "number" && Date.now() > data3.expires) {
                  return this.delete(key2).then(() => void 0);
                }
                return options && options.raw ? data3 : data3.value;
              })
            );
          }
          return Promise.allSettled(promises).then((values3) => {
            const data3 = [];
            for (const value2 of values3) {
              data3.push(value2.value);
            }
            return data3;
          });
        }
        return Promise.resolve().then(() => isArray ? store2.getMany(keyPrefixed) : store2.get(keyPrefixed)).then((data3) => typeof data3 === "string" ? this.opts.deserialize(data3) : this.opts.compression ? this.opts.deserialize(data3) : data3).then((data3) => {
          if (data3 === void 0 || data3 === null) {
            return void 0;
          }
          if (isArray) {
            const result = [];
            for (let row of data3) {
              if (typeof row === "string") {
                row = this.opts.deserialize(row);
              }
              if (row === void 0 || row === null) {
                result.push(void 0);
                continue;
              }
              if (typeof row.expires === "number" && Date.now() > row.expires) {
                this.delete(key).then(() => void 0);
                result.push(void 0);
              } else {
                result.push(options && options.raw ? row : row.value);
              }
            }
            return result;
          }
          if (typeof data3.expires === "number" && Date.now() > data3.expires) {
            return this.delete(key).then(() => void 0);
          }
          return options && options.raw ? data3 : data3.value;
        });
      }
      set(key, value2, ttl) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const { store: store2 } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          if (typeof value2 === "symbol") {
            this.emit("error", "symbol cannot be serialized");
          }
          value2 = { value: value2, expires };
          return this.opts.serialize(value2);
        }).then((value3) => store2.set(keyPrefixed, value3, ttl)).then(() => true);
      }
      delete(key) {
        const { store: store2 } = this.opts;
        if (Array.isArray(key)) {
          const keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store2.deleteMany === void 0) {
            const promises = [];
            for (const key2 of keyPrefixed2) {
              promises.push(store2.delete(key2));
            }
            return Promise.allSettled(promises).then((values3) => values3.every((x) => x.value === true));
          }
          return Promise.resolve().then(() => store2.deleteMany(keyPrefixed2));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store2.delete(keyPrefixed));
      }
      clear() {
        const { store: store2 } = this.opts;
        return Promise.resolve().then(() => store2.clear());
      }
      has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store: store2 } = this.opts;
        return Promise.resolve().then(async () => {
          if (typeof store2.has === "function") {
            return store2.has(keyPrefixed);
          }
          const value2 = await store2.get(keyPrefixed);
          return value2 !== void 0;
        });
      }
      disconnect() {
        const { store: store2 } = this.opts;
        if (typeof store2.disconnect === "function") {
          return store2.disconnect();
        }
      }
    };
    module.exports = Keyv;
  }
});

// node_modules/cacheable-request/src/index.js
var require_src4 = __commonJS({
  "node_modules/cacheable-request/src/index.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var urlLib = __require("url");
    var normalizeUrl = require_normalize_url();
    var getStream = require_get_stream();
    var CachePolicy = require_http_cache_semantics();
    var Response = require_src();
    var lowercaseKeys = require_lowercase_keys();
    var cloneResponse = require_src2();
    var Keyv = require_src3();
    var CacheableRequest = class _CacheableRequest {
      constructor(request2, cacheAdapter) {
        if (typeof request2 !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request2);
      }
      createCacheableRequest(request2) {
        return (opts, cb) => {
          let url6;
          if (typeof opts === "string") {
            url6 = normalizeUrlObject(urlLib.parse(opts));
            opts = {};
          } else if (opts instanceof urlLib.URL) {
            url6 = normalizeUrlObject(urlLib.parse(opts.toString()));
            opts = {};
          } else {
            const [pathname, ...searchParts] = (opts.path || "").split("?");
            const search2 = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
            url6 = normalizeUrlObject({ ...opts, pathname, search: search2 });
          }
          opts = {
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false,
            ...opts,
            ...urlObjectToRequestOptions(url6)
          };
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter();
          const normalizedUrlString = normalizeUrl(
            urlLib.format(url6),
            {
              stripWWW: false,
              removeTrailingSlash: false,
              stripAuthentication: false
            }
          );
          const key = `${opts.method}:${normalizedUrlString}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise((resolve) => {
              requestErrorCallback = () => {
                if (!requestErrored) {
                  requestErrored = true;
                  resolve();
                }
              };
            });
            const handler = (response2) => {
              if (revalidate && !opts2.forceRefresh) {
                response2.status = response2.statusCode;
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response2);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response2 = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                  response2.cachePolicy = revalidatedPolicy.policy;
                  response2.fromCache = true;
                }
              }
              if (!response2.fromCache) {
                response2.cachePolicy = new CachePolicy(opts2, response2, opts2);
                response2.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response2.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response2);
                (async () => {
                  try {
                    const bodyPromise = getStream.buffer(response2);
                    await Promise.race([
                      requestErrorPromise,
                      new Promise((resolve) => response2.once("end", resolve))
                    ]);
                    if (requestErrored) {
                      return;
                    }
                    const body = await bodyPromise;
                    const value2 = {
                      cachePolicy: response2.cachePolicy.toObject(),
                      url: response2.url,
                      statusCode: response2.fromCache ? revalidate.statusCode : response2.statusCode,
                      body
                    };
                    let ttl = opts2.strictTtl ? response2.cachePolicy.timeToLive() : void 0;
                    if (opts2.maxTtl) {
                      ttl = ttl ? Math.min(ttl, opts2.maxTtl) : opts2.maxTtl;
                    }
                    await this.cache.set(key, value2, ttl);
                  } catch (error) {
                    ee.emit("error", new _CacheableRequest.CacheError(error));
                  }
                })();
              } else if (opts2.cache && revalidate) {
                (async () => {
                  try {
                    await this.cache.delete(key);
                  } catch (error) {
                    ee.emit("error", new _CacheableRequest.CacheError(error));
                  }
                })();
              }
              ee.emit("response", clonedResponse || response2);
              if (typeof cb === "function") {
                cb(clonedResponse || response2);
              }
            };
            try {
              const req = request2(opts2, handler);
              req.once("error", requestErrorCallback);
              req.once("abort", requestErrorCallback);
              ee.emit("request", req);
            } catch (error) {
              ee.emit("error", new _CacheableRequest.RequestError(error));
            }
          };
          (async () => {
            const get2 = async (opts2) => {
              await Promise.resolve();
              const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
              if (typeof cacheEntry === "undefined") {
                return makeRequest(opts2);
              }
              const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
              if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
                const headers = policy.responseHeaders();
                const response2 = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                response2.cachePolicy = policy;
                response2.fromCache = true;
                ee.emit("response", response2);
                if (typeof cb === "function") {
                  cb(response2);
                }
              } else {
                revalidate = cacheEntry;
                opts2.headers = policy.revalidationHeaders(opts2);
                makeRequest(opts2);
              }
            };
            const errorHandler = (error) => ee.emit("error", new _CacheableRequest.CacheError(error));
            this.cache.once("error", errorHandler);
            ee.on("response", () => this.cache.removeListener("error", errorHandler));
            try {
              await get2(opts);
            } catch (error) {
              if (opts.automaticFailover && !madeRequest) {
                makeRequest(opts);
              }
              ee.emit("error", new _CacheableRequest.CacheError(error));
            }
          })();
          return ee;
        };
      }
    };
    function urlObjectToRequestOptions(url6) {
      const options = { ...url6 };
      options.path = `${url6.pathname || "/"}${url6.search || ""}`;
      delete options.pathname;
      delete options.search;
      return options;
    }
    function normalizeUrlObject(url6) {
      return {
        protocol: url6.protocol,
        auth: url6.auth,
        hostname: url6.hostname || url6.host || "localhost",
        port: url6.port,
        pathname: url6.pathname,
        search: url6.search
      };
    }
    CacheableRequest.RequestError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "RequestError";
        Object.assign(this, error);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "CacheError";
        Object.assign(this, error);
      }
    };
    module.exports = CacheableRequest;
  }
});

// node_modules/decompress-response/node_modules/mimic-response/index.js
var require_mimic_response2 = __commonJS({
  "node_modules/decompress-response/node_modules/mimic-response/index.js"(exports, module) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value2 = fromStream[property];
            const isFunction = typeof value2 === "function";
            return isFunction ? value2.bind(fromStream) : value2;
          },
          set(value2) {
            fromStream[property] = value2;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports, module) {
    "use strict";
    var { Transform, PassThrough } = __require("stream");
    var zlib = __require("zlib");
    var mimicResponse = require_mimic_response2();
    module.exports = (response2) => {
      const contentEncoding = (response2.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response2;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response2.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response2;
      }
      let isEmpty = true;
      const checker = new Transform({
        transform(data3, _encoding, callback) {
          isEmpty = false;
          callback(null, data3);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response2.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response2.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response2, finalStream);
      response2.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value2) {
        this.cache.set(key, value2);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value3] of this.oldCache.entries()) {
              this.onEviction(key2, value3);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value2 = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value2);
          return value2;
        }
      }
      set(key, value2) {
        if (this.cache.has(key)) {
          this.cache.set(key, value2);
        } else {
          this._set(key, value2);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value2] of this) {
          yield value2;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/http2-wrapper/source/agent.js
var require_agent = __commonJS({
  "node_modules/http2-wrapper/source/agent.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var tls = __require("tls");
    var http2 = __require("http2");
    var QuickLRU = require_quick_lru();
    var kCurrentStreamsCount = Symbol("currentStreamsCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var nameKeys = [
      // `http2.connect()` options
      "maxDeflateDynamicTableSize",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      // `tls.connect()` options
      "localAddress",
      "path",
      "rejectUnauthorized",
      "minDHSize",
      // `tls.createSecureContext()` options
      "ca",
      "cert",
      "clientCertEngine",
      "ciphers",
      "key",
      "pfx",
      "servername",
      "minVersion",
      "maxVersion",
      "secureProtocol",
      "crl",
      "honorCipherOrder",
      "ecdhCurve",
      "dhparam",
      "secureOptions",
      "sessionIdContext"
    ];
    var getSortedIndex = (array, value2, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value2)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => {
      return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    };
    var closeCoveredSessions = (where, session) => {
      for (const coveredSession of where) {
        if (
          // The set is a proper subset when its length is less than the other set.
          coveredSession[kOriginSet].length < session[kOriginSet].length && // And the other set includes all elements of the subset.
          coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && // Makes sure that the session can handle all requests from the covered session.
          coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
        ) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (const session of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var getSessions = ({ agent, isFree }) => {
      const result = {};
      for (const normalizedOptions in agent.sessions) {
        const sessions = agent.sessions[normalizedOptions];
        const filtered = sessions.filter((session) => {
          const result2 = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
          return isFree ? result2 : !result2;
        });
        if (filtered.length !== 0) {
          result[normalizedOptions] = filtered;
        }
      }
      return result;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamsCount] === 0) {
        session.close();
      }
    };
    var Agent = class _Agent extends EventEmitter {
      constructor({ timeout = 6e4, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxFreeSessions = maxFreeSessions;
        this._freeSessionsCount = 0;
        this._sessionsCount = 0;
        this.settings = {
          enablePush: false
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      static normalizeOrigin(url6, servername) {
        if (typeof url6 === "string") {
          url6 = new URL(url6);
        }
        if (servername && url6.hostname !== servername) {
          url6.hostname = servername;
        }
        return url6.origin;
      }
      normalizeOptions(options) {
        let normalized = "";
        if (options) {
          for (const key of nameKeys) {
            if (options[key]) {
              normalized += `:${options[key]}`;
            }
          }
        }
        return normalized;
      }
      _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
        if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
          return;
        }
        const item = this.queue[normalizedOptions][normalizedOrigin];
        if (this._sessionsCount < this.maxSessions && !item.completed) {
          item.completed = true;
          item();
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners)) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = _Agent.normalizeOrigin(origin, options && options.servername);
          if (normalizedOrigin === void 0) {
            for (const { reject: reject2 } of listeners) {
              reject2(new TypeError("The `origin` argument needs to be a string or an URL object"));
            }
            return;
          }
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (const session of sessions) {
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (session[kOriginSet].includes(normalizedOrigin)) {
                const sessionCurrentStreamsCount = session[kCurrentStreamsCount];
                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || // Unfortunately the `close` event isn't called immediately,
                // so `session.destroyed` is `true`, but `session.closed` is `false`.
                session.destroyed) {
                  continue;
                }
                if (!optimalSession) {
                  maxConcurrentStreams = sessionMaxConcurrentStreams;
                }
                if (sessionCurrentStreamsCount > currentStreamsCount) {
                  optimalSession = session;
                  currentStreamsCount = sessionCurrentStreamsCount;
                }
              }
            }
            if (optimalSession) {
              if (listeners.length !== 1) {
                for (const { reject: reject2 } of listeners) {
                  const error = new Error(
                    `Expected the length of listeners to be 1, got ${listeners.length}.
Please report this to https://github.com/szmarczak/http2-wrapper/`
                  );
                  reject2(error);
                }
                return;
              }
              listeners[0].resolve(optimalSession);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {};
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (Object.keys(this.queue[normalizedOptions]).length === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = () => {
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            try {
              const session = http2.connect(origin, {
                createConnection: this.createConnection,
                settings: this.settings,
                session: this.tlsSessionCache.get(name),
                ...options
              });
              session[kCurrentStreamsCount] = 0;
              session[kGracefullyClosing] = false;
              const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
              let wasFree = true;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error) => {
                for (const { reject: reject2 } of listeners) {
                  reject2(error);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                if (receivedSettings) {
                  if (wasFree) {
                    this._freeSessionsCount--;
                  }
                  this._sessionsCount--;
                  const where = this.sessions[normalizedOptions];
                  where.splice(where.indexOf(session), 1);
                  if (where.length === 0) {
                    delete this.sessions[normalizedOptions];
                  }
                } else {
                  const error = new Error("Session closed without receiving a SETTINGS frame");
                  error.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (const { reject: reject2 } of listeners) {
                    reject2(error);
                  }
                  removeFromQueue();
                }
                this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              });
              const processListeners = () => {
                if (!(normalizedOptions in this.queue) || !isFree()) {
                  return;
                }
                for (const origin2 of session[kOriginSet]) {
                  if (origin2 in this.queue[normalizedOptions]) {
                    const { listeners: listeners2 } = this.queue[normalizedOptions][origin2];
                    while (listeners2.length !== 0 && isFree()) {
                      listeners2.shift().resolve(session);
                    }
                    const where = this.queue[normalizedOptions];
                    if (where[origin2].listeners.length === 0) {
                      delete where[origin2];
                      if (Object.keys(where).length === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = session.originSet;
                if (!isFree()) {
                  return;
                }
                processListeners();
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                session.ref();
                session.unref();
                this._sessionsCount++;
                if (entry.destroyed) {
                  const error = new Error("Agent has been destroyed");
                  for (const listener of listeners) {
                    listener.reject(error);
                  }
                  session.destroy();
                  return;
                }
                session[kOriginSet] = session.originSet;
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                this._freeSessionsCount += 1;
                receivedSettings = true;
                this.emit("session", session);
                processListeners();
                removeFromQueue();
                if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
                  session.close();
                }
                if (listeners.length !== 0) {
                  this.getSession(normalizedOrigin, options, listeners);
                  listeners.length = 0;
                }
                session.on("remoteSettings", () => {
                  processListeners();
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream = session[kRequest](headers, streamOptions);
                session.ref();
                ++session[kCurrentStreamsCount];
                if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
                  this._freeSessionsCount--;
                }
                stream.once("close", () => {
                  wasFree = isFree();
                  --session[kCurrentStreamsCount];
                  if (!session.destroyed && !session.closed) {
                    closeSessionIfCovered(this.sessions[normalizedOptions], session);
                    if (isFree() && !session.closed) {
                      if (!wasFree) {
                        this._freeSessionsCount++;
                        wasFree = true;
                      }
                      const isEmpty = session[kCurrentStreamsCount] === 0;
                      if (isEmpty) {
                        session.unref();
                      }
                      if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {
                        session.close();
                      } else {
                        closeCoveredSessions(this.sessions[normalizedOptions], session);
                        processListeners();
                      }
                    }
                  }
                });
                return stream;
              };
            } catch (error) {
              for (const listener of listeners) {
                listener.reject(error);
              }
              removeFromQueue();
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                resolve(session.request(headers, streamOptions));
              } catch (error) {
                reject(error);
              }
            }
          }]);
        });
      }
      createConnection(origin, options) {
        return _Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname || origin.host;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        return tls.connect(port, host, options);
      }
      closeFreeSessions() {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            if (session[kCurrentStreamsCount] === 0) {
              session.close();
            }
          }
        }
      }
      destroy(reason) {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            session.destroy(reason);
          }
        }
        for (const entriesOfAuthority of Object.values(this.queue)) {
          for (const entry of Object.values(entriesOfAuthority)) {
            entry.destroyed = true;
          }
        }
        this.queue = {};
      }
      get freeSessions() {
        return getSessions({ agent: this, isFree: true });
      }
      get busySessions() {
        return getSessions({ agent: this, isFree: false });
      }
    };
    Agent.kCurrentStreamsCount = kCurrentStreamsCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS({
  "node_modules/http2-wrapper/source/incoming-message.js"(exports, module) {
    "use strict";
    var { Readable } = __require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          highWaterMark,
          autoDestroy: false
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this.connection = socket;
        this._dumped = false;
      }
      _destroy(error) {
        this.req._request.destroy(error);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module.exports = IncomingMessage;
  }
});

// node_modules/http2-wrapper/source/utils/url-to-options.js
var require_url_to_options = __commonJS({
  "node_modules/http2-wrapper/source/utils/url-to-options.js"(exports, module) {
    "use strict";
    module.exports = (url6) => {
      const options = {
        protocol: url6.protocol,
        hostname: typeof url6.hostname === "string" && url6.hostname.startsWith("[") ? url6.hostname.slice(1, -1) : url6.hostname,
        host: url6.host,
        hash: url6.hash,
        search: url6.search,
        pathname: url6.pathname,
        href: url6.href,
        path: `${url6.pathname || ""}${url6.search || ""}`
      };
      if (typeof url6.port === "string" && url6.port.length !== 0) {
        options.port = Number(url6.port);
      }
      if (url6.username || url6.password) {
        options.auth = `${url6.username || ""}:${url6.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-events.js"(exports, module) {
    "use strict";
    module.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS({
  "node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports, module) {
    "use strict";
    module.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors = __commonJS({
  "node_modules/http2-wrapper/source/utils/errors.js"(exports, module) {
    "use strict";
    var makeError = (Base, key, getMessage) => {
      module.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage === "string" ? getMessage : getMessage(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type3 = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type3} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
      return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
    });
    makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
      return `Cannot ${args[0]} headers after they are sent to the client`;
    });
    makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
      return `${args[0]} must be a valid HTTP token [${args[1]}]`;
    });
    makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
      return `Invalid value "${args[0]} for header "${args[1]}"`;
    });
    makeError(TypeError, "ERR_INVALID_CHAR", (args) => {
      return `Invalid character in ${args[0]} [${args[1]}]`;
    });
  }
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS({
  "node_modules/http2-wrapper/source/client-request.js"(exports, module) {
    "use strict";
    var http2 = __require("http2");
    var { Writable } = __require("stream");
    var { Agent, globalAgent } = require_agent();
    var IncomingMessage = require_incoming_message();
    var urlToOptions = require_url_to_options();
    var proxyEvents = require_proxy_events();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT,
      ERR_INVALID_HTTP_TOKEN,
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_METHOD_CONNECT
    } = http2.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false
        });
        const hasInput = typeof input === "string" || input instanceof URL;
        if (hasInput) {
          input = urlToOptions(input instanceof URL ? input : new URL(input));
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = hasInput ? input : { ...input };
        } else {
          options = { ...input, ...options };
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
        } else if (options.agent === false) {
          this.agent = new Agent({ maxFreeSessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          if (typeof options.createConnection === "function") {
            this.agent = new Agent({ maxFreeSessions: 0 });
            this.agent.createConnection = options.createConnection;
          } else {
            this.agent = globalAgent;
          }
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["Agent-like Object", "undefined", "false"], options.agent);
        }
        if (options.protocol && options.protocol !== "https:") {
          throw new ERR_INVALID_PROTOCOL(options.protocol, "https:");
        }
        const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;
        const host = options.hostname || options.host || "localhost";
        delete options.hostname;
        delete options.host;
        delete options.port;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        this.path = options.path;
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        if (options.headers) {
          for (const [header, value2] of Object.entries(options.headers)) {
            this.setHeader(header, value2);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        if (port === 443) {
          this[kOrigin] = `https://${host}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = host;
          }
        } else {
          this[kOrigin] = `https://${host}:${port}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = `${host}:${port}`;
          }
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value2) {
        if (value2) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value2.toUpperCase();
        }
      }
      get path() {
        return this[kHeaders][HTTP2_HEADER_PATH];
      }
      set path(value2) {
        if (value2) {
          this[kHeaders][HTTP2_HEADER_PATH] = value2;
        }
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        if (this.destroyed) {
          return;
        }
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody) {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      _destroy(error, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        }
        callback(error);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream) => {
          this._request = stream;
          if (this.destroyed) {
            stream.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents(stream, this, ["timeout", "continue", "close", "error"]);
          }
          const waitForEnd = (fn) => {
            return (...args) => {
              if (!this.writable && !this.destroyed) {
                fn(...args);
              } else {
                this.once("finish", () => {
                  fn(...args);
                });
              }
            };
          };
          stream.once("response", waitForEnd((headers, flags, rawHeaders) => {
            const response2 = new IncomingMessage(this.socket, stream.readableHighWaterMark);
            this.res = response2;
            response2.req = this;
            response2.statusCode = headers[HTTP2_HEADER_STATUS];
            response2.headers = headers;
            response2.rawHeaders = rawHeaders;
            response2.once("end", () => {
              if (this.aborted) {
                response2.aborted = true;
                response2.emit("aborted");
              } else {
                response2.complete = true;
                response2.socket = null;
                response2.connection = null;
              }
            });
            if (isConnectMethod) {
              response2.upgrade = true;
              if (this.emit("connect", response2, stream, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream.destroy();
              }
            } else {
              stream.on("data", (chunk) => {
                if (!response2._dumped && !response2.push(chunk)) {
                  stream.pause();
                }
              });
              stream.once("end", () => {
                response2.push(null);
              });
              if (!this.emit("response", response2)) {
                response2._dump();
              }
            }
          }));
          stream.once("headers", waitForEnd(
            (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] })
          ));
          stream.once("trailers", waitForEnd((trailers, flags, rawTrailers) => {
            const { res } = this;
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          }));
          const { socket } = stream.session;
          this.socket = socket;
          this.connection = socket;
          for (const job of this[kJobs]) {
            job();
          }
          this.emit("socket", this.socket);
        };
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        } else {
          this.reusedSocket = true;
          try {
            onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        }
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value2) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
          throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
        }
        if (typeof value2 === "undefined") {
          throw new ERR_HTTP_INVALID_HEADER_VALUE(value2, name);
        }
        if (isInvalidHeaderValue.test(value2)) {
          throw new ERR_INVALID_CHAR("header content", name);
        }
        this[kHeaders][name.toLowerCase()] = value2;
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module.exports = ClientRequest;
  }
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS({
  "node_modules/resolve-alpn/index.js"(exports, module) {
    "use strict";
    var tls = __require("tls");
    module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      };
      const onTimeout = async () => {
        timeout = true;
        callback();
      };
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error) {
          reject(error);
        }
      })();
    });
  }
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports, module) {
    "use strict";
    var net = __require("net");
    module.exports = (options) => {
      let servername = options.host;
      const hostHeader = options.headers && options.headers.host;
      if (hostHeader) {
        if (hostHeader.startsWith("[")) {
          const index2 = hostHeader.indexOf("]");
          if (index2 === -1) {
            servername = hostHeader;
          } else {
            servername = hostHeader.slice(1, -1);
          }
        } else {
          servername = hostHeader.split(":", 1)[0];
        }
      }
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS({
  "node_modules/http2-wrapper/source/auto.js"(exports, module) {
    "use strict";
    var http = __require("http");
    var https = __require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var urlToOptions = require_url_to_options();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var resolveProtocol = async (options) => {
      const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache.has(name)) {
        if (queue.has(name)) {
          const result = await queue.get(name);
          return result.alpnProtocol;
        }
        const { path: path3, agent } = options;
        options.path = options.socketPath;
        const resultPromise = resolveALPN(options);
        queue.set(name, resultPromise);
        try {
          const { socket, alpnProtocol } = await resultPromise;
          cache.set(name, alpnProtocol);
          options.path = path3;
          if (alpnProtocol === "h2") {
            socket.destroy();
          } else {
            const { globalAgent } = https;
            const defaultCreateConnection = https.Agent.prototype.createConnection;
            if (agent) {
              if (agent.createConnection === defaultCreateConnection) {
                installSocket(agent, socket, options);
              } else {
                socket.destroy();
              }
            } else if (globalAgent.createConnection === defaultCreateConnection) {
              installSocket(globalAgent, socket, options);
            } else {
              socket.destroy();
            }
          }
          queue.delete(name);
          return alpnProtocol;
        } catch (error) {
          queue.delete(name);
          throw error;
        }
      }
      return cache.get(name);
    };
    module.exports = async (input, options, callback) => {
      if (typeof input === "string" || input instanceof URL) {
        input = urlToOptions(new URL(input));
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      options = {
        ALPNProtocols: ["h2", "http/1.1"],
        ...input,
        ...options,
        resolveSocket: true
      };
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;
      const agents = options.agent;
      if (agents) {
        if (agents.addRequest) {
          throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");
        }
        options.agent = agents[isHttps ? "https" : "http"];
      }
      if (isHttps) {
        const protocol = await resolveProtocol(options);
        if (protocol === "h2") {
          if (agents) {
            options.agent = agents.http2;
          }
          return new Http2ClientRequest(options, callback);
        }
      }
      return http.request(options, callback);
    };
    module.exports.protocolCache = cache;
  }
});

// node_modules/http2-wrapper/source/index.js
var require_source4 = __commonJS({
  "node_modules/http2-wrapper/source/index.js"(exports, module) {
    "use strict";
    var http2 = __require("http2");
    var agent = require_agent();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var request2 = (url6, options, callback) => {
      return new ClientRequest(url6, options, callback);
    };
    var get2 = (url6, options, callback) => {
      const req = new ClientRequest(url6, options, callback);
      req.end();
      return req;
    };
    module.exports = {
      ...http2,
      ClientRequest,
      IncomingMessage,
      ...agent,
      request: request2,
      get: get2,
      auto
    };
  }
});

// node_modules/got/dist/source/core/utils/is-form-data.js
var require_is_form_data = __commonJS({
  "node_modules/got/dist/source/core/utils/is-form-data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_dist();
    exports.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);
  }
});

// node_modules/got/dist/source/core/utils/get-body-size.js
var require_get_body_size = __commonJS({
  "node_modules/got/dist/source/core/utils/get-body-size.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = __require("fs");
    var util_1 = __require("util");
    var is_1 = require_dist();
    var is_form_data_1 = require_is_form_data();
    var statAsync = util_1.promisify(fs_1.stat);
    exports.default = async (body, headers) => {
      if (headers && "content-length" in headers) {
        return Number(headers["content-length"]);
      }
      if (!body) {
        return 0;
      }
      if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
      }
      if (is_1.default.buffer(body)) {
        return body.length;
      }
      if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
      }
      if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync(body.path);
        if (size === 0) {
          return void 0;
        }
        return size;
      }
      return void 0;
    };
  }
});

// node_modules/got/dist/source/core/utils/proxy-events.js
var require_proxy_events2 = __commonJS({
  "node_modules/got/dist/source/core/utils/proxy-events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function default_1(from, to, events) {
      const fns = {};
      for (const event of events) {
        fns[event] = (...args) => {
          to.emit(event, ...args);
        };
        from.on(event, fns[event]);
      }
      return () => {
        for (const event of events) {
          from.off(event, fns[event]);
        }
      };
    }
    exports.default = default_1;
  }
});

// node_modules/got/dist/source/core/utils/unhandle.js
var require_unhandle = __commonJS({
  "node_modules/got/dist/source/core/utils/unhandle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = () => {
      const handlers = [];
      return {
        once(origin, event, fn) {
          origin.once(event, fn);
          handlers.push({ origin, event, fn });
        },
        unhandleAll() {
          for (const handler of handlers) {
            const { origin, event, fn } = handler;
            origin.removeListener(event, fn);
          }
          handlers.length = 0;
        }
      };
    };
  }
});

// node_modules/got/dist/source/core/utils/timed-out.js
var require_timed_out = __commonJS({
  "node_modules/got/dist/source/core/utils/timed-out.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = void 0;
    var net = __require("net");
    var unhandle_1 = require_unhandle();
    var reentry = Symbol("reentry");
    var noop = () => {
    };
    var TimeoutError = class extends Error {
      constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
      }
    };
    exports.TimeoutError = TimeoutError;
    exports.default = (request2, delays, options) => {
      if (reentry in request2) {
        return noop;
      }
      request2[reentry] = true;
      const cancelers = [];
      const { once, unhandleAll } = unhandle_1.default();
      const addTimeout = (delay, callback, event) => {
        var _a2;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a2 = timeout.unref) === null || _a2 === void 0 ? void 0 : _a2.call(timeout);
        const cancel = () => {
          clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
      };
      const { host, hostname } = options;
      const timeoutHandler = (delay, event) => {
        request2.destroy(new TimeoutError(delay, event));
      };
      const cancelTimeouts = () => {
        for (const cancel of cancelers) {
          cancel();
        }
        unhandleAll();
      };
      request2.once("error", (error) => {
        cancelTimeouts();
        if (request2.listenerCount("error") === 0) {
          throw error;
        }
      });
      request2.once("close", cancelTimeouts);
      once(request2, "response", (response2) => {
        once(response2, "end", cancelTimeouts);
      });
      if (typeof delays.request !== "undefined") {
        addTimeout(delays.request, timeoutHandler, "request");
      }
      if (typeof delays.socket !== "undefined") {
        const socketTimeoutHandler = () => {
          timeoutHandler(delays.socket, "socket");
        };
        request2.setTimeout(delays.socket, socketTimeoutHandler);
        cancelers.push(() => {
          request2.removeListener("timeout", socketTimeoutHandler);
        });
      }
      once(request2, "socket", (socket) => {
        var _a2;
        const { socketPath } = request2;
        if (socket.connecting) {
          const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a2 = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a2 !== void 0 ? _a2 : "") !== 0);
          if (typeof delays.lookup !== "undefined" && !hasPath && typeof socket.address().address === "undefined") {
            const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
            once(socket, "lookup", cancelTimeout);
          }
          if (typeof delays.connect !== "undefined") {
            const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
            if (hasPath) {
              once(socket, "connect", timeConnect());
            } else {
              once(socket, "lookup", (error) => {
                if (error === null) {
                  once(socket, "connect", timeConnect());
                }
              });
            }
          }
          if (typeof delays.secureConnect !== "undefined" && options.protocol === "https:") {
            once(socket, "connect", () => {
              const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
              once(socket, "secureConnect", cancelTimeout);
            });
          }
        }
        if (typeof delays.send !== "undefined") {
          const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
          if (socket.connecting) {
            once(socket, "connect", () => {
              once(request2, "upload-complete", timeRequest());
            });
          } else {
            once(request2, "upload-complete", timeRequest());
          }
        }
      });
      if (typeof delays.response !== "undefined") {
        once(request2, "upload-complete", () => {
          const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
          once(request2, "response", cancelTimeout);
        });
      }
      return cancelTimeouts;
    };
  }
});

// node_modules/got/dist/source/core/utils/url-to-options.js
var require_url_to_options2 = __commonJS({
  "node_modules/got/dist/source/core/utils/url-to-options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_dist();
    exports.default = (url6) => {
      url6 = url6;
      const options = {
        protocol: url6.protocol,
        hostname: is_1.default.string(url6.hostname) && url6.hostname.startsWith("[") ? url6.hostname.slice(1, -1) : url6.hostname,
        host: url6.host,
        hash: url6.hash,
        search: url6.search,
        pathname: url6.pathname,
        href: url6.href,
        path: `${url6.pathname || ""}${url6.search || ""}`
      };
      if (is_1.default.string(url6.port) && url6.port.length > 0) {
        options.port = Number(url6.port);
      }
      if (url6.username || url6.password) {
        options.auth = `${url6.username || ""}:${url6.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/got/dist/source/core/utils/options-to-url.js
var require_options_to_url = __commonJS({
  "node_modules/got/dist/source/core/utils/options-to-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url_1 = __require("url");
    var keys4 = [
      "protocol",
      "host",
      "hostname",
      "port",
      "pathname",
      "search"
    ];
    exports.default = (origin, options) => {
      var _a2, _b;
      if (options.path) {
        if (options.pathname) {
          throw new TypeError("Parameters `path` and `pathname` are mutually exclusive.");
        }
        if (options.search) {
          throw new TypeError("Parameters `path` and `search` are mutually exclusive.");
        }
        if (options.searchParams) {
          throw new TypeError("Parameters `path` and `searchParams` are mutually exclusive.");
        }
      }
      if (options.search && options.searchParams) {
        throw new TypeError("Parameters `search` and `searchParams` are mutually exclusive.");
      }
      if (!origin) {
        if (!options.protocol) {
          throw new TypeError("No URL protocol specified");
        }
        origin = `${options.protocol}//${(_b = (_a2 = options.hostname) !== null && _a2 !== void 0 ? _a2 : options.host) !== null && _b !== void 0 ? _b : ""}`;
      }
      const url6 = new url_1.URL(origin);
      if (options.path) {
        const searchIndex = options.path.indexOf("?");
        if (searchIndex === -1) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.slice(0, searchIndex);
          options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
      }
      for (const key of keys4) {
        if (options[key]) {
          url6[key] = options[key].toString();
        }
      }
      return url6;
    };
  }
});

// node_modules/got/dist/source/core/utils/weakable-map.js
var require_weakable_map = __commonJS({
  "node_modules/got/dist/source/core/utils/weakable-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var WeakableMap = class {
      constructor() {
        this.weakMap = /* @__PURE__ */ new WeakMap();
        this.map = /* @__PURE__ */ new Map();
      }
      set(key, value2) {
        if (typeof key === "object") {
          this.weakMap.set(key, value2);
        } else {
          this.map.set(key, value2);
        }
      }
      get(key) {
        if (typeof key === "object") {
          return this.weakMap.get(key);
        }
        return this.map.get(key);
      }
      has(key) {
        if (typeof key === "object") {
          return this.weakMap.has(key);
        }
        return this.map.has(key);
      }
    };
    exports.default = WeakableMap;
  }
});

// node_modules/got/dist/source/core/utils/get-buffer.js
var require_get_buffer = __commonJS({
  "node_modules/got/dist/source/core/utils/get-buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getBuffer = async (stream) => {
      const chunks = [];
      let length = 0;
      for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
      }
      if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
      }
      return Buffer.from(chunks.join(""));
    };
    exports.default = getBuffer;
  }
});

// node_modules/got/dist/source/core/utils/dns-ip-version.js
var require_dns_ip_version = __commonJS({
  "node_modules/got/dist/source/core/utils/dns-ip-version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
    var conversionTable = {
      auto: 0,
      ipv4: 4,
      ipv6: 6
    };
    exports.isDnsLookupIpVersion = (value2) => {
      return value2 in conversionTable;
    };
    exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
      if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
      }
      throw new Error("Invalid DNS lookup IP version");
    };
  }
});

// node_modules/got/dist/source/core/utils/is-response-ok.js
var require_is_response_ok = __commonJS({
  "node_modules/got/dist/source/core/utils/is-response-ok.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isResponseOk = void 0;
    exports.isResponseOk = (response2) => {
      const { statusCode } = response2;
      const limitStatusCode = response2.request.options.followRedirect ? 299 : 399;
      return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
    };
  }
});

// node_modules/got/dist/source/utils/deprecation-warning.js
var require_deprecation_warning = __commonJS({
  "node_modules/got/dist/source/utils/deprecation-warning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var alreadyWarned = /* @__PURE__ */ new Set();
    exports.default = (message) => {
      if (alreadyWarned.has(message)) {
        return;
      }
      alreadyWarned.add(message);
      process.emitWarning(`Got: ${message}`, {
        type: "DeprecationWarning"
      });
    };
  }
});

// node_modules/got/dist/source/as-promise/normalize-arguments.js
var require_normalize_arguments = __commonJS({
  "node_modules/got/dist/source/as-promise/normalize-arguments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_dist();
    var normalizeArguments = (options, defaults) => {
      if (is_1.default.null_(options.encoding)) {
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      }
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
      if (options.responseType === void 0) {
        options.responseType = "text";
      }
      const { retry } = options;
      if (defaults) {
        options.retry = { ...defaults.retry };
      } else {
        options.retry = {
          calculateDelay: (retryObject) => retryObject.computedValue,
          limit: 0,
          methods: [],
          statusCodes: [],
          errorCodes: [],
          maxRetryAfter: void 0
        };
      }
      if (is_1.default.object(retry)) {
        options.retry = {
          ...options.retry,
          ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map((method) => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
      } else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
      }
      if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(
          ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number)
        );
      }
      if (is_1.default.object(options.pagination)) {
        if (defaults) {
          options.pagination = {
            ...defaults.pagination,
            ...options.pagination
          };
        }
        const { pagination } = options;
        if (!is_1.default.function_(pagination.transform)) {
          throw new Error("`options.pagination.transform` must be implemented");
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
          throw new Error("`options.pagination.shouldContinue` must be implemented");
        }
        if (!is_1.default.function_(pagination.filter)) {
          throw new TypeError("`options.pagination.filter` must be implemented");
        }
        if (!is_1.default.function_(pagination.paginate)) {
          throw new Error("`options.pagination.paginate` must be implemented");
        }
      }
      if (options.responseType === "json" && options.headers.accept === void 0) {
        options.headers.accept = "application/json";
      }
      return options;
    };
    exports.default = normalizeArguments;
  }
});

// node_modules/got/dist/source/core/calculate-retry-delay.js
var require_calculate_retry_delay = __commonJS({
  "node_modules/got/dist/source/core/calculate-retry-delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryAfterStatusCodes = void 0;
    exports.retryAfterStatusCodes = /* @__PURE__ */ new Set([413, 429, 503]);
    var calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
      if (attemptCount > retryOptions.limit) {
        return 0;
      }
      const hasMethod = retryOptions.methods.includes(error.options.method);
      const hasErrorCode = retryOptions.errorCodes.includes(error.code);
      const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
      if (!hasMethod || !hasErrorCode && !hasStatusCode) {
        return 0;
      }
      if (error.response) {
        if (retryAfter) {
          if (retryOptions.maxRetryAfter === void 0 || retryAfter > retryOptions.maxRetryAfter) {
            return 0;
          }
          return retryAfter;
        }
        if (error.response.statusCode === 413) {
          return 0;
        }
      }
      const noise = Math.random() * 100;
      return 2 ** (attemptCount - 1) * 1e3 + noise;
    };
    exports.default = calculateRetryDelay;
  }
});

// node_modules/got/dist/source/core/index.js
var require_core = __commonJS({
  "node_modules/got/dist/source/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
    var util_1 = __require("util");
    var stream_1 = __require("stream");
    var fs_1 = __require("fs");
    var url_1 = __require("url");
    var http = __require("http");
    var http_1 = __require("http");
    var https = __require("https");
    var http_timer_1 = require_source2();
    var cacheable_lookup_1 = require_source3();
    var CacheableRequest = require_src4();
    var decompressResponse = require_decompress_response();
    var http2wrapper = require_source4();
    var lowercaseKeys = require_lowercase_keys();
    var is_1 = require_dist();
    var get_body_size_1 = require_get_body_size();
    var is_form_data_1 = require_is_form_data();
    var proxy_events_1 = require_proxy_events2();
    var timed_out_1 = require_timed_out();
    var url_to_options_1 = require_url_to_options2();
    var options_to_url_1 = require_options_to_url();
    var weakable_map_1 = require_weakable_map();
    var get_buffer_1 = require_get_buffer();
    var dns_ip_version_1 = require_dns_ip_version();
    var is_response_ok_1 = require_is_response_ok();
    var deprecation_warning_1 = require_deprecation_warning();
    var normalize_arguments_1 = require_normalize_arguments();
    var calculate_retry_delay_1 = require_calculate_retry_delay();
    var globalDnsCache;
    var kRequest = Symbol("request");
    var kResponse = Symbol("response");
    var kResponseSize = Symbol("responseSize");
    var kDownloadedSize = Symbol("downloadedSize");
    var kBodySize = Symbol("bodySize");
    var kUploadedSize = Symbol("uploadedSize");
    var kServerResponsesPiped = Symbol("serverResponsesPiped");
    var kUnproxyEvents = Symbol("unproxyEvents");
    var kIsFromCache = Symbol("isFromCache");
    var kCancelTimeouts = Symbol("cancelTimeouts");
    var kStartedReading = Symbol("startedReading");
    var kStopReading = Symbol("stopReading");
    var kTriggerRead = Symbol("triggerRead");
    var kBody = Symbol("body");
    var kJobs = Symbol("jobs");
    var kOriginalResponse = Symbol("originalResponse");
    var kRetryTimeout = Symbol("retryTimeout");
    exports.kIsNormalizedAlready = Symbol("isNormalizedAlready");
    var supportsBrotli = is_1.default.string(process.versions.brotli);
    exports.withoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
    exports.knownHookEvents = [
      "init",
      "beforeRequest",
      "beforeRedirect",
      "beforeError",
      "beforeRetry",
      // Promise-Only
      "afterResponse"
    ];
    function validateSearchParameters(searchParameters) {
      for (const key in searchParameters) {
        const value2 = searchParameters[key];
        if (!is_1.default.string(value2) && !is_1.default.number(value2) && !is_1.default.boolean(value2) && !is_1.default.null_(value2) && !is_1.default.undefined(value2)) {
          throw new TypeError(`The \`searchParams\` value '${String(value2)}' must be a string, number, boolean or null`);
        }
      }
    }
    function isClientRequest(clientRequest) {
      return is_1.default.object(clientRequest) && !("statusCode" in clientRequest);
    }
    var cacheableStore = new weakable_map_1.default();
    var waitForOpenFile = async (file) => new Promise((resolve, reject) => {
      const onError = (error) => {
        reject(error);
      };
      if (!file.pending) {
        resolve();
      }
      file.once("error", onError);
      file.once("ready", () => {
        file.off("error", onError);
        resolve();
      });
    });
    var redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
    var nonEnumerableProperties = [
      "context",
      "body",
      "json",
      "form"
    ];
    exports.setNonEnumerableProperties = (sources, to) => {
      const properties = {};
      for (const source of sources) {
        if (!source) {
          continue;
        }
        for (const name of nonEnumerableProperties) {
          if (!(name in source)) {
            continue;
          }
          properties[name] = {
            writable: true,
            configurable: true,
            enumerable: false,
            // @ts-expect-error TS doesn't see the check above
            value: source[name]
          };
        }
      }
      Object.defineProperties(to, properties);
    };
    var RequestError = class extends Error {
      constructor(message, error, self2) {
        var _a2, _b;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = (_a2 = error.code) !== null && _a2 !== void 0 ? _a2 : "ERR_GOT_REQUEST_ERROR";
        if (self2 instanceof Request) {
          Object.defineProperty(this, "request", {
            enumerable: false,
            value: self2
          });
          Object.defineProperty(this, "response", {
            enumerable: false,
            value: self2[kResponse]
          });
          Object.defineProperty(this, "options", {
            // This fails because of TS 3.7.2 useDefineForClassFields
            // Ref: https://github.com/microsoft/TypeScript/issues/34972
            enumerable: false,
            value: self2.options
          });
        } else {
          Object.defineProperty(this, "options", {
            // This fails because of TS 3.7.2 useDefineForClassFields
            // Ref: https://github.com/microsoft/TypeScript/issues/34972
            enumerable: false,
            value: self2
          });
        }
        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;
        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {
          const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
          const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
          const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
          while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
            thisStackTrace.shift();
          }
          this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
      }
    };
    exports.RequestError = RequestError;
    var MaxRedirectsError = class extends RequestError {
      constructor(request2) {
        super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
        this.name = "MaxRedirectsError";
        this.code = "ERR_TOO_MANY_REDIRECTS";
      }
    };
    exports.MaxRedirectsError = MaxRedirectsError;
    var HTTPError = class extends RequestError {
      constructor(response2) {
        super(`Response code ${response2.statusCode} (${response2.statusMessage})`, {}, response2.request);
        this.name = "HTTPError";
        this.code = "ERR_NON_2XX_3XX_RESPONSE";
      }
    };
    exports.HTTPError = HTTPError;
    var CacheError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "CacheError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
      }
    };
    exports.CacheError = CacheError;
    var UploadError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "UploadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
      }
    };
    exports.UploadError = UploadError;
    var TimeoutError = class extends RequestError {
      constructor(error, timings, request2) {
        super(error.message, error, request2);
        this.name = "TimeoutError";
        this.event = error.event;
        this.timings = timings;
      }
    };
    exports.TimeoutError = TimeoutError;
    var ReadError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "ReadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
      }
    };
    exports.ReadError = ReadError;
    var UnsupportedProtocolError = class extends RequestError {
      constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = "UnsupportedProtocolError";
        this.code = "ERR_UNSUPPORTED_PROTOCOL";
      }
    };
    exports.UnsupportedProtocolError = UnsupportedProtocolError;
    var proxiedRequestEvents = [
      "socket",
      "connect",
      "continue",
      "information",
      "upgrade",
      "timeout"
    ];
    var Request = class extends stream_1.Duplex {
      constructor(url6, options = {}, defaults) {
        super({
          // This must be false, to enable throwing after destroy
          // It is used for retry logic in Promise API
          autoDestroy: false,
          // It needs to be zero because we're just proxying the data to another stream
          highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = /* @__PURE__ */ new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on("pipe", (source) => {
          source.prependListener("data", unlockWrite);
          source.on("data", lockWrite);
          source.prependListener("end", unlockWrite);
          source.on("end", lockWrite);
        });
        this.on("unpipe", (source) => {
          source.off("data", unlockWrite);
          source.off("data", lockWrite);
          source.off("end", unlockWrite);
          source.off("end", lockWrite);
        });
        this.on("pipe", (source) => {
          if (source instanceof http_1.IncomingMessage) {
            this.options.headers = {
              ...source.headers,
              ...this.options.headers
            };
          }
        });
        const { json, body, form } = options;
        if (json || body || form) {
          this._lockWrite();
        }
        if (exports.kIsNormalizedAlready in options) {
          this.options = options;
        } else {
          try {
            this.options = this.constructor.normalizeArguments(url6, options, defaults);
          } catch (error) {
            if (is_1.default.nodeStream(options.body)) {
              options.body.destroy();
            }
            this.destroy(error);
            return;
          }
        }
        (async () => {
          var _a2;
          try {
            if (this.options.body instanceof fs_1.ReadStream) {
              await waitForOpenFile(this.options.body);
            }
            const { url: normalizedURL } = this.options;
            if (!normalizedURL) {
              throw new TypeError("Missing `url` property");
            }
            this.requestUrl = normalizedURL.toString();
            decodeURI(this.requestUrl);
            await this._finalizeBody();
            await this._makeRequest();
            if (this.destroyed) {
              (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.destroy();
              return;
            }
            for (const job of this[kJobs]) {
              job();
            }
            this[kJobs].length = 0;
            this.requestInitialized = true;
          } catch (error) {
            if (error instanceof RequestError) {
              this._beforeError(error);
              return;
            }
            if (!this.destroyed) {
              this.destroy(error);
            }
          }
        })();
      }
      static normalizeArguments(url6, options, defaults) {
        var _a2, _b, _c, _d, _e;
        const rawOptions = options;
        if (is_1.default.object(url6) && !is_1.default.urlInstance(url6)) {
          options = { ...defaults, ...url6, ...options };
        } else {
          if (url6 && options && options.url !== void 0) {
            throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
          }
          options = { ...defaults, ...options };
          if (url6 !== void 0) {
            options.url = url6;
          }
          if (is_1.default.urlInstance(options.url)) {
            options.url = new url_1.URL(options.url.toString());
          }
        }
        if (options.cache === false) {
          options.cache = void 0;
        }
        if (options.dnsCache === false) {
          options.dnsCache = void 0;
        }
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
          is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
          is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
          is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
          is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        if (is_1.default.string(options.method)) {
          options.method = options.method.toUpperCase();
        } else {
          options.method = "GET";
        }
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
          options.headers = { ...options.headers };
        } else {
          options.headers = lowercaseKeys({ ...defaults === null || defaults === void 0 ? void 0 : defaults.headers, ...options.headers });
        }
        if ("slashes" in options) {
          throw new TypeError("The legacy `url.Url` has been deprecated. Use `URL` instead.");
        }
        if ("auth" in options) {
          throw new TypeError("Parameter `auth` is deprecated. Use `username` / `password` instead.");
        }
        if ("searchParams" in options) {
          if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
            let searchParameters;
            if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {
              searchParameters = new url_1.URLSearchParams(options.searchParams);
            } else {
              validateSearchParameters(options.searchParams);
              searchParameters = new url_1.URLSearchParams();
              for (const key in options.searchParams) {
                const value2 = options.searchParams[key];
                if (value2 === null) {
                  searchParameters.append(key, "");
                } else if (value2 !== void 0) {
                  searchParameters.append(key, value2);
                }
              }
            }
            (_a2 = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a2 === void 0 ? void 0 : _a2.forEach((value2, key) => {
              if (!searchParameters.has(key)) {
                searchParameters.append(key, value2);
              }
            });
            options.searchParams = searchParameters;
          }
        }
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : "";
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : "";
        if (is_1.default.undefined(options.prefixUrl)) {
          options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : "";
        } else {
          options.prefixUrl = options.prefixUrl.toString();
          if (options.prefixUrl !== "" && !options.prefixUrl.endsWith("/")) {
            options.prefixUrl += "/";
          }
        }
        if (is_1.default.string(options.url)) {
          if (options.url.startsWith("/")) {
            throw new Error("`input` must not start with a slash when using `prefixUrl`");
          }
          options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        } else if (is_1.default.undefined(options.url) && options.prefixUrl !== "" || options.protocol) {
          options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
          if ("port" in options) {
            delete options.port;
          }
          let { prefixUrl } = options;
          Object.defineProperty(options, "prefixUrl", {
            set: (value2) => {
              const url7 = options.url;
              if (!url7.href.startsWith(value2)) {
                throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value2}: ${url7.href}`);
              }
              options.url = new url_1.URL(value2 + url7.href.slice(prefixUrl.length));
              prefixUrl = value2;
            },
            get: () => prefixUrl
          });
          let { protocol } = options.url;
          if (protocol === "unix:") {
            protocol = "http:";
            options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
          }
          if (options.searchParams) {
            options.url.search = options.searchParams.toString();
          }
          if (protocol !== "http:" && protocol !== "https:") {
            throw new UnsupportedProtocolError(options);
          }
          if (options.username === "") {
            options.username = options.url.username;
          } else {
            options.url.username = options.username;
          }
          if (options.password === "") {
            options.password = options.url.password;
          } else {
            options.url.password = options.password;
          }
        }
        const { cookieJar } = options;
        if (cookieJar) {
          let { setCookie, getCookieString } = cookieJar;
          is_1.assert.function_(setCookie);
          is_1.assert.function_(getCookieString);
          if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
            getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
            options.cookieJar = {
              setCookie,
              getCookieString
            };
          }
        }
        const { cache } = options;
        if (cache) {
          if (!cacheableStore.has(cache)) {
            cacheableStore.set(cache, new CacheableRequest((requestOptions, handler) => {
              const result = requestOptions[kRequest](requestOptions, handler);
              if (is_1.default.promise(result)) {
                result.once = (event, handler2) => {
                  if (event === "error") {
                    result.catch(handler2);
                  } else if (event === "abort") {
                    (async () => {
                      try {
                        const request2 = await result;
                        request2.once("abort", handler2);
                      } catch (_a3) {
                      }
                    })();
                  } else {
                    throw new Error(`Unknown HTTP2 promise event: ${event}`);
                  }
                  return result;
                };
              }
              return result;
            }, cache));
          }
        }
        options.cacheOptions = { ...options.cacheOptions };
        if (options.dnsCache === true) {
          if (!globalDnsCache) {
            globalDnsCache = new cacheable_lookup_1.default();
          }
          options.dnsCache = globalDnsCache;
        } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
          throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        if (is_1.default.number(options.timeout)) {
          options.timeout = { request: options.timeout };
        } else if (defaults && options.timeout !== defaults.timeout) {
          options.timeout = {
            ...defaults.timeout,
            ...options.timeout
          };
        } else {
          options.timeout = { ...options.timeout };
        }
        if (!options.context) {
          options.context = {};
        }
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = { ...options.hooks };
        for (const event of exports.knownHookEvents) {
          if (event in options.hooks) {
            if (is_1.default.array(options.hooks[event])) {
              options.hooks[event] = [...options.hooks[event]];
            } else {
              throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
            }
          } else {
            options.hooks[event] = [];
          }
        }
        if (defaults && !areHooksDefault) {
          for (const event of exports.knownHookEvents) {
            const defaultHooks = defaults.hooks[event];
            if (defaultHooks.length > 0) {
              options.hooks[event] = [
                ...defaults.hooks[event],
                ...options.hooks[event]
              ];
            }
          }
        }
        if ("family" in options) {
          deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
          options.https = { ...defaults.https, ...options.https };
        }
        if ("rejectUnauthorized" in options) {
          deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ("checkServerIdentity" in options) {
          deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ("ca" in options) {
          deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ("key" in options) {
          deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ("cert" in options) {
          deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ("passphrase" in options) {
          deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ("pfx" in options) {
          deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        if ("followRedirects" in options) {
          throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
        }
        if (options.agent) {
          for (const key in options.agent) {
            if (key !== "http" && key !== "https" && key !== "http2") {
              throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
            }
          }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        exports.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalize_arguments_1.default(options, defaults);
      }
      _lockWrite() {
        const onLockedWrite = () => {
          throw new TypeError("The payload has been already provided");
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
      }
      _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
      }
      async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
          if (cannotHaveBody) {
            throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
          }
          if ([isBody, isForm, isJSON].filter((isTrue) => isTrue).length > 1) {
            throw new TypeError("The `body`, `json` and `form` options are mutually exclusive");
          }
          if (isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body)) {
            throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
          }
          if (isForm && !is_1.default.object(options.form)) {
            throw new TypeError("The `form` option must be an Object");
          }
          {
            const noContentType = !is_1.default.string(headers["content-type"]);
            if (isBody) {
              if (is_form_data_1.default(options.body) && noContentType) {
                headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
              }
              this[kBody] = options.body;
            } else if (isForm) {
              if (noContentType) {
                headers["content-type"] = "application/x-www-form-urlencoded";
              }
              this[kBody] = new url_1.URLSearchParams(options.form).toString();
            } else {
              if (noContentType) {
                headers["content-type"] = "application/json";
              }
              this[kBody] = options.stringifyJson(options.json);
            }
            const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
            if (is_1.default.undefined(headers["content-length"]) && is_1.default.undefined(headers["transfer-encoding"])) {
              if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                headers["content-length"] = String(uploadBodySize);
              }
            }
          }
        } else if (cannotHaveBody) {
          this._lockWrite();
        } else {
          this._unlockWrite();
        }
        this[kBodySize] = Number(headers["content-length"]) || void 0;
      }
      async _onResponseBase(response2) {
        const { options } = this;
        const { url: url6 } = options;
        this[kOriginalResponse] = response2;
        if (options.decompress) {
          response2 = decompressResponse(response2);
        }
        const statusCode = response2.statusCode;
        const typedResponse = response2;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response2.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response2.headers["content-length"]) || void 0;
        this[kResponse] = response2;
        response2.once("end", () => {
          this[kResponseSize] = this[kDownloadedSize];
          this.emit("downloadProgress", this.downloadProgress);
        });
        response2.once("error", (error) => {
          response2.destroy();
          this._beforeError(new ReadError(error, this));
        });
        response2.once("aborted", () => {
          this._beforeError(new ReadError({
            name: "Error",
            message: "The server aborted pending request",
            code: "ECONNRESET"
          }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response2.headers["set-cookie"];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
          let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url6.toString()));
          if (options.ignoreInvalidCookies) {
            promises = promises.map(async (p) => p.catch(() => {
            }));
          }
          try {
            await Promise.all(promises);
          } catch (error) {
            this._beforeError(error);
            return;
          }
        }
        if (options.followRedirect && response2.headers.location && redirectCodes.has(statusCode)) {
          response2.resume();
          if (this[kRequest]) {
            this[kCancelTimeouts]();
            delete this[kRequest];
            this[kUnproxyEvents]();
          }
          const shouldBeGet = statusCode === 303 && options.method !== "GET" && options.method !== "HEAD";
          if (shouldBeGet || !options.methodRewriting) {
            options.method = "GET";
            if ("body" in options) {
              delete options.body;
            }
            if ("json" in options) {
              delete options.json;
            }
            if ("form" in options) {
              delete options.form;
            }
            this[kBody] = void 0;
            delete options.headers["content-length"];
          }
          if (this.redirects.length >= options.maxRedirects) {
            this._beforeError(new MaxRedirectsError(this));
            return;
          }
          try {
            let isUnixSocketURL = function(url7) {
              return url7.protocol === "unix:" || url7.hostname === "unix";
            };
            const redirectBuffer = Buffer.from(response2.headers.location, "binary").toString();
            const redirectUrl = new url_1.URL(redirectBuffer, url6);
            const redirectString = redirectUrl.toString();
            decodeURI(redirectString);
            if (!isUnixSocketURL(url6) && isUnixSocketURL(redirectUrl)) {
              this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
              return;
            }
            if (redirectUrl.hostname !== url6.hostname || redirectUrl.port !== url6.port) {
              if ("host" in options.headers) {
                delete options.headers.host;
              }
              if ("cookie" in options.headers) {
                delete options.headers.cookie;
              }
              if ("authorization" in options.headers) {
                delete options.headers.authorization;
              }
              if (options.username || options.password) {
                options.username = "";
                options.password = "";
              }
            } else {
              redirectUrl.username = options.username;
              redirectUrl.password = options.password;
            }
            this.redirects.push(redirectString);
            options.url = redirectUrl;
            for (const hook of options.hooks.beforeRedirect) {
              await hook(options, typedResponse);
            }
            this.emit("redirect", typedResponse, options);
            await this._makeRequest();
          } catch (error) {
            this._beforeError(error);
            return;
          }
          return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
          this._beforeError(new HTTPError(typedResponse));
          return;
        }
        response2.on("readable", () => {
          if (this[kTriggerRead]) {
            this._read();
          }
        });
        this.on("resume", () => {
          response2.resume();
        });
        this.on("pause", () => {
          response2.pause();
        });
        response2.once("end", () => {
          this.push(null);
        });
        this.emit("response", response2);
        for (const destination of this[kServerResponsesPiped]) {
          if (destination.headersSent) {
            continue;
          }
          for (const key in response2.headers) {
            const isAllowed = options.decompress ? key !== "content-encoding" : true;
            const value2 = response2.headers[key];
            if (isAllowed) {
              destination.setHeader(key, value2);
            }
          }
          destination.statusCode = statusCode;
        }
      }
      async _onResponse(response2) {
        try {
          await this._onResponseBase(response2);
        } catch (error) {
          this._beforeError(error);
        }
      }
      _onRequest(request2) {
        const { options } = this;
        const { timeout, url: url6 } = options;
        http_timer_1.default(request2);
        this[kCancelTimeouts] = timed_out_1.default(request2, timeout, url6);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request2.once(responseEventName, (response2) => {
          void this._onResponse(response2);
        });
        request2.once("error", (error) => {
          var _a2;
          request2.destroy();
          (_a2 = request2.res) === null || _a2 === void 0 ? void 0 : _a2.removeAllListeners("end");
          error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
          this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request2, this, proxiedRequestEvents);
        this[kRequest] = request2;
        this.emit("uploadProgress", this.uploadProgress);
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request2;
        if (is_1.default.nodeStream(body)) {
          body.pipe(currentRequest);
          body.once("error", (error) => {
            this._beforeError(new UploadError(error, this));
          });
        } else {
          this._unlockWrite();
          if (!is_1.default.undefined(body)) {
            this._writeRequest(body, void 0, () => {
            });
            currentRequest.end();
            this._lockWrite();
          } else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();
            this._lockWrite();
          }
        }
        this.emit("request", request2);
      }
      async _createCacheableRequest(url6, options) {
        return new Promise((resolve, reject) => {
          Object.assign(options, url_to_options_1.default(url6));
          delete options.url;
          let request2;
          const cacheRequest = cacheableStore.get(options.cache)(options, async (response2) => {
            response2._readableState.autoDestroy = false;
            if (request2) {
              (await request2).emit("cacheableResponse", response2);
            }
            resolve(response2);
          });
          options.url = url6;
          cacheRequest.once("error", reject);
          cacheRequest.once("request", async (requestOrPromise) => {
            request2 = requestOrPromise;
            resolve(request2);
          });
        });
      }
      async _makeRequest() {
        var _a2, _b, _c, _d, _e;
        const { options } = this;
        const { headers } = options;
        for (const key in headers) {
          if (is_1.default.undefined(headers[key])) {
            delete headers[key];
          } else if (is_1.default.null_(headers[key])) {
            throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
          }
        }
        if (options.decompress && is_1.default.undefined(headers["accept-encoding"])) {
          headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
        }
        if (options.cookieJar) {
          const cookieString = await options.cookieJar.getCookieString(options.url.toString());
          if (is_1.default.nonEmptyString(cookieString)) {
            options.headers.cookie = cookieString;
          }
        }
        for (const hook of options.hooks.beforeRequest) {
          const result = await hook(options);
          if (!is_1.default.undefined(result)) {
            options.request = () => result;
            break;
          }
        }
        if (options.body && this[kBody] !== options.body) {
          this[kBody] = options.body;
        }
        const { agent, request: request2, timeout, url: url6 } = options;
        if (options.dnsCache && !("lookup" in options)) {
          options.lookup = options.dnsCache.lookup;
        }
        if (url6.hostname === "unix") {
          const matches2 = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url6.pathname}${url6.search}`);
          if (matches2 === null || matches2 === void 0 ? void 0 : matches2.groups) {
            const { socketPath, path: path3 } = matches2.groups;
            Object.assign(options, {
              socketPath,
              path: path3,
              host: ""
            });
          }
        }
        const isHttps = url6.protocol === "https:";
        let fallbackFn;
        if (options.http2) {
          fallbackFn = http2wrapper.auto;
        } else {
          fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a2 = options.request) !== null && _a2 !== void 0 ? _a2 : fallbackFn;
        const fn = options.cache ? this._createCacheableRequest : realFn;
        if (agent && !options.http2) {
          options.agent = agent[isHttps ? "https" : "http"];
        }
        options[kRequest] = realFn;
        delete options.request;
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        if (options.dnsLookupIpVersion !== void 0) {
          try {
            requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
          } catch (_f) {
            throw new Error("Invalid `dnsLookupIpVersion` option value");
          }
        }
        if (options.https) {
          if ("rejectUnauthorized" in options.https) {
            requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
          }
          if (options.https.checkServerIdentity) {
            requestOptions.checkServerIdentity = options.https.checkServerIdentity;
          }
          if (options.https.certificateAuthority) {
            requestOptions.ca = options.https.certificateAuthority;
          }
          if (options.https.certificate) {
            requestOptions.cert = options.https.certificate;
          }
          if (options.https.key) {
            requestOptions.key = options.https.key;
          }
          if (options.https.passphrase) {
            requestOptions.passphrase = options.https.passphrase;
          }
          if (options.https.pfx) {
            requestOptions.pfx = options.https.pfx;
          }
        }
        try {
          let requestOrResponse = await fn(url6, requestOptions);
          if (is_1.default.undefined(requestOrResponse)) {
            requestOrResponse = fallbackFn(url6, requestOptions);
          }
          options.request = request2;
          options.timeout = timeout;
          options.agent = agent;
          if (options.https) {
            if ("rejectUnauthorized" in options.https) {
              delete requestOptions.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
              delete requestOptions.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
              delete requestOptions.ca;
            }
            if (options.https.certificate) {
              delete requestOptions.cert;
            }
            if (options.https.key) {
              delete requestOptions.key;
            }
            if (options.https.passphrase) {
              delete requestOptions.passphrase;
            }
            if (options.https.pfx) {
              delete requestOptions.pfx;
            }
          }
          if (isClientRequest(requestOrResponse)) {
            this._onRequest(requestOrResponse);
          } else if (this.writable) {
            this.once("finish", () => {
              void this._onResponse(requestOrResponse);
            });
            this._unlockWrite();
            this.end();
            this._lockWrite();
          } else {
            void this._onResponse(requestOrResponse);
          }
        } catch (error) {
          if (error instanceof CacheableRequest.CacheError) {
            throw new CacheError(error, this);
          }
          throw new RequestError(error.message, error, this);
        }
      }
      async _error(error) {
        try {
          for (const hook of this.options.hooks.beforeError) {
            error = await hook(error);
          }
        } catch (error_) {
          error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
      }
      _beforeError(error) {
        if (this[kStopReading]) {
          return;
        }
        const { options } = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        const { response: response2 } = typedError;
        void (async () => {
          if (response2 && !response2.body) {
            response2.setEncoding(this._readableState.encoding);
            try {
              response2.rawBody = await get_buffer_1.default(response2);
              response2.body = response2.rawBody.toString();
            } catch (_a2) {
            }
          }
          if (this.listenerCount("retry") !== 0) {
            let backoff;
            try {
              let retryAfter;
              if (response2 && "retry-after" in response2.headers) {
                retryAfter = Number(response2.headers["retry-after"]);
                if (Number.isNaN(retryAfter)) {
                  retryAfter = Date.parse(response2.headers["retry-after"]) - Date.now();
                  if (retryAfter <= 0) {
                    retryAfter = 1;
                  }
                } else {
                  retryAfter *= 1e3;
                }
              }
              backoff = await options.retry.calculateDelay({
                attemptCount: retryCount,
                retryOptions: options.retry,
                error: typedError,
                retryAfter,
                computedValue: calculate_retry_delay_1.default({
                  attemptCount: retryCount,
                  retryOptions: options.retry,
                  error: typedError,
                  retryAfter,
                  computedValue: 0
                })
              });
            } catch (error_) {
              void this._error(new RequestError(error_.message, error_, this));
              return;
            }
            if (backoff) {
              const retry = async () => {
                try {
                  for (const hook of this.options.hooks.beforeRetry) {
                    await hook(this.options, typedError, retryCount);
                  }
                } catch (error_) {
                  void this._error(new RequestError(error_.message, error, this));
                  return;
                }
                if (this.destroyed) {
                  return;
                }
                this.destroy();
                this.emit("retry", retryCount, error);
              };
              this[kRetryTimeout] = setTimeout(retry, backoff);
              return;
            }
          }
          void this._error(typedError);
        })();
      }
      _read() {
        this[kTriggerRead] = true;
        const response2 = this[kResponse];
        if (response2 && !this[kStopReading]) {
          if (response2.readableLength) {
            this[kTriggerRead] = false;
          }
          let data3;
          while ((data3 = response2.read()) !== null) {
            this[kDownloadedSize] += data3.length;
            this[kStartedReading] = true;
            const progress = this.downloadProgress;
            if (progress.percent < 1) {
              this.emit("downloadProgress", progress);
            }
            this.push(data3);
          }
        }
      }
      // Node.js 12 has incorrect types, so the encoding must be a string
      _write(chunk, encoding, callback) {
        const write = () => {
          this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
          write();
        } else {
          this[kJobs].push(write);
        }
      }
      _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
          return;
        }
        this._progressCallbacks.push(() => {
          this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
          const progress = this.uploadProgress;
          if (progress.percent < 1) {
            this.emit("uploadProgress", progress);
          }
        });
        this[kRequest].write(chunk, encoding, (error) => {
          if (!error && this._progressCallbacks.length > 0) {
            this._progressCallbacks.shift()();
          }
          callback(error);
        });
      }
      _final(callback) {
        const endRequest = () => {
          while (this._progressCallbacks.length !== 0) {
            this._progressCallbacks.shift()();
          }
          if (!(kRequest in this)) {
            callback();
            return;
          }
          if (this[kRequest].destroyed) {
            callback();
            return;
          }
          this[kRequest].end((error) => {
            if (!error) {
              this[kBodySize] = this[kUploadedSize];
              this.emit("uploadProgress", this.uploadProgress);
              this[kRequest].emit("upload-complete");
            }
            callback(error);
          });
        };
        if (this.requestInitialized) {
          endRequest();
        } else {
          this[kJobs].push(endRequest);
        }
      }
      _destroy(error, callback) {
        var _a2;
        this[kStopReading] = true;
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
          this[kCancelTimeouts]();
          if (!((_a2 = this[kResponse]) === null || _a2 === void 0 ? void 0 : _a2.complete)) {
            this[kRequest].destroy();
          }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        callback(error);
      }
      get _isAboutToError() {
        return this[kStopReading];
      }
      /**
      The remote IP address.
      */
      get ip() {
        var _a2;
        return (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.remoteAddress;
      }
      /**
      Indicates whether the request has been aborted or not.
      */
      get aborted() {
        var _a2, _b, _c;
        return ((_b = (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
      }
      get socket() {
        var _a2, _b;
        return (_b = (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.socket) !== null && _b !== void 0 ? _b : void 0;
      }
      /**
      Progress event for downloading (receiving a response).
      */
      get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
          percent = this[kDownloadedSize] / this[kResponseSize];
        } else if (this[kResponseSize] === this[kDownloadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kDownloadedSize],
          total: this[kResponseSize]
        };
      }
      /**
      Progress event for uploading (sending a request).
      */
      get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
          percent = this[kUploadedSize] / this[kBodySize];
        } else if (this[kBodySize] === this[kUploadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kUploadedSize],
          total: this[kBodySize]
        };
      }
      /**
          The object contains the following properties:
      
          - `start` - Time when the request started.
          - `socket` - Time when a socket was assigned to the request.
          - `lookup` - Time when the DNS lookup finished.
          - `connect` - Time when the socket successfully connected.
          - `secureConnect` - Time when the socket securely connected.
          - `upload` - Time when the request finished uploading.
          - `response` - Time when the request fired `response` event.
          - `end` - Time when the response fired `end` event.
          - `error` - Time when the request fired `error` event.
          - `abort` - Time when the request fired `abort` event.
          - `phases`
              - `wait` - `timings.socket - timings.start`
              - `dns` - `timings.lookup - timings.socket`
              - `tcp` - `timings.connect - timings.lookup`
              - `tls` - `timings.secureConnect - timings.connect`
              - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
              - `firstByte` - `timings.response - timings.upload`
              - `download` - `timings.end - timings.response`
              - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
      
          If something has not been measured yet, it will be `undefined`.
      
          __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
          */
      get timings() {
        var _a2;
        return (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.timings;
      }
      /**
      Whether the response was retrieved from the cache.
      */
      get isFromCache() {
        return this[kIsFromCache];
      }
      pipe(destination, options) {
        if (this[kStartedReading]) {
          throw new Error("Failed to pipe. The response has been emitted already.");
        }
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
      }
      unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
      }
    };
    exports.default = Request;
  }
});

// node_modules/got/dist/source/as-promise/types.js
var require_types = __commonJS({
  "node_modules/got/dist/source/as-promise/types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancelError = exports.ParseError = void 0;
    var core_1 = require_core();
    var ParseError = class extends core_1.RequestError {
      constructor(error, response2) {
        const { options } = response2.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response2.request);
        this.name = "ParseError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_BODY_PARSE_FAILURE" : this.code;
      }
    };
    exports.ParseError = ParseError;
    var CancelError = class extends core_1.RequestError {
      constructor(request2) {
        super("Promise was canceled", {}, request2);
        this.name = "CancelError";
        this.code = "ERR_CANCELED";
      }
      get isCanceled() {
        return true;
      }
    };
    exports.CancelError = CancelError;
    __exportStar(require_core(), exports);
  }
});

// node_modules/got/dist/source/as-promise/parse-body.js
var require_parse_body = __commonJS({
  "node_modules/got/dist/source/as-promise/parse-body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var parseBody = (response2, responseType, parseJson, encoding) => {
      const { rawBody } = response2;
      try {
        if (responseType === "text") {
          return rawBody.toString(encoding);
        }
        if (responseType === "json") {
          return rawBody.length === 0 ? "" : parseJson(rawBody.toString());
        }
        if (responseType === "buffer") {
          return rawBody;
        }
        throw new types_1.ParseError({
          message: `Unknown body type '${responseType}'`,
          name: "Error"
        }, response2);
      } catch (error) {
        throw new types_1.ParseError(error, response2);
      }
    };
    exports.default = parseBody;
  }
});

// node_modules/got/dist/source/as-promise/index.js
var require_as_promise = __commonJS({
  "node_modules/got/dist/source/as-promise/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var is_1 = require_dist();
    var PCancelable = require_p_cancelable();
    var types_1 = require_types();
    var parse_body_1 = require_parse_body();
    var core_1 = require_core();
    var proxy_events_1 = require_proxy_events2();
    var get_buffer_1 = require_get_buffer();
    var is_response_ok_1 = require_is_response_ok();
    var proxiedRequestEvents = [
      "request",
      "response",
      "redirect",
      "uploadProgress",
      "downloadProgress"
    ];
    function asPromise(normalizedOptions) {
      let globalRequest;
      let globalResponse;
      const emitter = new events_1.EventEmitter();
      const promise = new PCancelable((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
          const request2 = new core_1.default(void 0, normalizedOptions);
          request2.retryCount = retryCount;
          request2._noPipe = true;
          onCancel(() => request2.destroy());
          onCancel.shouldReject = false;
          onCancel(() => reject(new types_1.CancelError(request2)));
          globalRequest = request2;
          request2.once("response", async (response2) => {
            var _a2;
            response2.retryCount = retryCount;
            if (response2.request.aborted) {
              return;
            }
            let rawBody;
            try {
              rawBody = await get_buffer_1.default(request2);
              response2.rawBody = rawBody;
            } catch (_b) {
              return;
            }
            if (request2._isAboutToError) {
              return;
            }
            const contentEncoding = ((_a2 = response2.headers["content-encoding"]) !== null && _a2 !== void 0 ? _a2 : "").toLowerCase();
            const isCompressed = ["gzip", "deflate", "br"].includes(contentEncoding);
            const { options } = request2;
            if (isCompressed && !options.decompress) {
              response2.body = rawBody;
            } else {
              try {
                response2.body = parse_body_1.default(response2, options.responseType, options.parseJson, options.encoding);
              } catch (error) {
                response2.body = rawBody.toString();
                if (is_response_ok_1.isResponseOk(response2)) {
                  request2._beforeError(error);
                  return;
                }
              }
            }
            try {
              for (const [index2, hook] of options.hooks.afterResponse.entries()) {
                response2 = await hook(response2, async (updatedOptions) => {
                  const typedOptions = core_1.default.normalizeArguments(void 0, {
                    ...updatedOptions,
                    retry: {
                      calculateDelay: () => 0
                    },
                    throwHttpErrors: false,
                    resolveBodyOnly: false
                  }, options);
                  typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index2);
                  for (const hook2 of typedOptions.hooks.beforeRetry) {
                    await hook2(typedOptions);
                  }
                  const promise2 = asPromise(typedOptions);
                  onCancel(() => {
                    promise2.catch(() => {
                    });
                    promise2.cancel();
                  });
                  return promise2;
                });
              }
            } catch (error) {
              request2._beforeError(new types_1.RequestError(error.message, error, request2));
              return;
            }
            globalResponse = response2;
            if (!is_response_ok_1.isResponseOk(response2)) {
              request2._beforeError(new types_1.HTTPError(response2));
              return;
            }
            request2.destroy();
            resolve(request2.options.resolveBodyOnly ? response2.body : response2);
          });
          const onError = (error) => {
            if (promise.isCanceled) {
              return;
            }
            const { options } = request2;
            if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
              const { response: response2 } = error;
              resolve(request2.options.resolveBodyOnly ? response2.body : response2);
              return;
            }
            reject(error);
          };
          request2.once("error", onError);
          const previousBody = request2.options.body;
          request2.once("retry", (newRetryCount, error) => {
            var _a2, _b;
            if (previousBody === ((_a2 = error.request) === null || _a2 === void 0 ? void 0 : _a2.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
              onError(error);
              return;
            }
            makeRequest(newRetryCount);
          });
          proxy_events_1.default(request2, emitter, proxiedRequestEvents);
        };
        makeRequest(0);
      });
      promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
      };
      const shortcut = (responseType) => {
        const newPromise = (async () => {
          await promise;
          const { options } = globalResponse.request;
          return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
      };
      promise.json = () => {
        const { headers } = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === void 0) {
          headers.accept = "application/json";
        }
        return shortcut("json");
      };
      promise.buffer = () => shortcut("buffer");
      promise.text = () => shortcut("text");
      return promise;
    }
    exports.default = asPromise;
    __exportStar(require_types(), exports);
  }
});

// node_modules/got/dist/source/as-promise/create-rejection.js
var require_create_rejection = __commonJS({
  "node_modules/got/dist/source/as-promise/create-rejection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    function createRejection(error, ...beforeErrorGroups) {
      const promise = (async () => {
        if (error instanceof types_1.RequestError) {
          try {
            for (const hooks of beforeErrorGroups) {
              if (hooks) {
                for (const hook of hooks) {
                  error = await hook(error);
                }
              }
            }
          } catch (error_) {
            error = error_;
          }
        }
        throw error;
      })();
      const returnPromise = () => promise;
      promise.json = returnPromise;
      promise.text = returnPromise;
      promise.buffer = returnPromise;
      promise.on = returnPromise;
      return promise;
    }
    exports.default = createRejection;
  }
});

// node_modules/got/dist/source/utils/deep-freeze.js
var require_deep_freeze = __commonJS({
  "node_modules/got/dist/source/utils/deep-freeze.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_dist();
    function deepFreeze(object) {
      for (const value2 of Object.values(object)) {
        if (is_1.default.plainObject(value2) || is_1.default.array(value2)) {
          deepFreeze(value2);
        }
      }
      return Object.freeze(object);
    }
    exports.default = deepFreeze;
  }
});

// node_modules/got/dist/source/types.js
var require_types2 = __commonJS({
  "node_modules/got/dist/source/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/got/dist/source/create.js
var require_create = __commonJS({
  "node_modules/got/dist/source/create.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultHandler = void 0;
    var is_1 = require_dist();
    var as_promise_1 = require_as_promise();
    var create_rejection_1 = require_create_rejection();
    var core_1 = require_core();
    var deep_freeze_1 = require_deep_freeze();
    var errors = {
      RequestError: as_promise_1.RequestError,
      CacheError: as_promise_1.CacheError,
      ReadError: as_promise_1.ReadError,
      HTTPError: as_promise_1.HTTPError,
      MaxRedirectsError: as_promise_1.MaxRedirectsError,
      TimeoutError: as_promise_1.TimeoutError,
      ParseError: as_promise_1.ParseError,
      CancelError: as_promise_1.CancelError,
      UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
      UploadError: as_promise_1.UploadError
    };
    var delay = async (ms) => new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
    var { normalizeArguments } = core_1.default;
    var mergeOptions = (...sources) => {
      let mergedOptions;
      for (const source of sources) {
        mergedOptions = normalizeArguments(void 0, source, mergedOptions);
      }
      return mergedOptions;
    };
    var getPromiseOrStream = (options) => options.isStream ? new core_1.default(void 0, options) : as_promise_1.default(options);
    var isGotInstance = (value2) => "defaults" in value2 && "options" in value2.defaults;
    var aliases2 = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    exports.defaultHandler = (options, next2) => next2(options);
    var callInitHooks = (hooks, options) => {
      if (hooks) {
        for (const hook of hooks) {
          hook(options);
        }
      }
    };
    var create = (defaults) => {
      defaults._rawHandlers = defaults.handlers;
      defaults.handlers = defaults.handlers.map((fn) => (options, next2) => {
        let root3;
        const result = fn(options, (newOptions) => {
          root3 = next2(newOptions);
          return root3;
        });
        if (result !== root3 && !options.isStream && root3) {
          const typedResult = result;
          const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
          Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root3));
          Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root3));
          typedResult.then = promiseThen;
          typedResult.catch = promiseCatch;
          typedResult.finally = promiseFianlly;
        }
        return result;
      });
      const got = (url6, options = {}, _defaults) => {
        var _a2, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
          return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        if (is_1.default.plainObject(url6)) {
          const mergedOptions = {
            ...url6,
            ...options
          };
          core_1.setNonEnumerableProperties([url6, options], mergedOptions);
          options = mergedOptions;
          url6 = void 0;
        }
        try {
          let initHookError;
          try {
            callInitHooks(defaults.options.hooks.init, options);
            callInitHooks((_a2 = options.hooks) === null || _a2 === void 0 ? void 0 : _a2.init, options);
          } catch (error) {
            initHookError = error;
          }
          const normalizedOptions = normalizeArguments(url6, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
          normalizedOptions[core_1.kIsNormalizedAlready] = true;
          if (initHookError) {
            throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
          }
          return iterateHandlers(normalizedOptions);
        } catch (error) {
          if (options.isStream) {
            throw error;
          } else {
            return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
          }
        }
      };
      got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value2 of instancesOrOptions) {
          if (isGotInstance(value2)) {
            optionsArray.push(value2.defaults.options);
            handlers.push(...value2.defaults._rawHandlers);
            isMutableDefaults = value2.defaults.mutableDefaults;
          } else {
            optionsArray.push(value2);
            if ("handlers" in value2) {
              handlers.push(...value2.handlers);
            }
            isMutableDefaults = value2.mutableDefaults;
          }
        }
        handlers = handlers.filter((handler) => handler !== exports.defaultHandler);
        if (handlers.length === 0) {
          handlers.push(exports.defaultHandler);
        }
        return create({
          options: mergeOptions(...optionsArray),
          handlers,
          mutableDefaults: Boolean(isMutableDefaults)
        });
      };
      const paginateEach = async function* (url6, options) {
        let normalizedOptions = normalizeArguments(url6, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
          throw new TypeError("`options.pagination` must be implemented");
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
          if (numberOfRequests !== 0) {
            await delay(pagination.backoff);
          }
          const result = await got(void 0, void 0, normalizedOptions);
          const parsed = await pagination.transform(result);
          const current = [];
          for (const item of parsed) {
            if (pagination.filter(item, all, current)) {
              if (!pagination.shouldContinue(item, all, current)) {
                return;
              }
              yield item;
              if (pagination.stackAllItems) {
                all.push(item);
              }
              current.push(item);
              if (--countLimit <= 0) {
                return;
              }
            }
          }
          const optionsToMerge = pagination.paginate(result, all, current);
          if (optionsToMerge === false) {
            return;
          }
          if (optionsToMerge === result.request.options) {
            normalizedOptions = result.request.options;
          } else if (optionsToMerge !== void 0) {
            normalizedOptions = normalizeArguments(void 0, optionsToMerge, normalizedOptions);
          }
          numberOfRequests++;
        }
      };
      got.paginate = paginateEach;
      got.paginate.all = async (url6, options) => {
        const results = [];
        for await (const item of paginateEach(url6, options)) {
          results.push(item);
        }
        return results;
      };
      got.paginate.each = paginateEach;
      got.stream = (url6, options) => got(url6, { ...options, isStream: true });
      for (const method of aliases2) {
        got[method] = (url6, options) => got(url6, { ...options, method });
        got.stream[method] = (url6, options) => {
          return got(url6, { ...options, method, isStream: true });
        };
      }
      Object.assign(got, errors);
      Object.defineProperty(got, "defaults", {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
      });
      got.mergeOptions = mergeOptions;
      return got;
    };
    exports.default = create;
    __exportStar(require_types2(), exports);
  }
});

// node_modules/got/dist/source/index.js
var require_source5 = __commonJS({
  "node_modules/got/dist/source/index.js"(exports, module) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var url_1 = __require("url");
    var create_1 = require_create();
    var defaults = {
      options: {
        method: "GET",
        retry: {
          limit: 2,
          methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
          ],
          statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
          ],
          errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
          ],
          maxRetryAfter: void 0,
          calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
          "user-agent": "got (https://github.com/sindresorhus/got)"
        },
        hooks: {
          init: [],
          beforeRequest: [],
          beforeRedirect: [],
          beforeRetry: [],
          beforeError: [],
          afterResponse: []
        },
        cache: void 0,
        dnsCache: void 0,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: "text",
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: "",
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        // TODO: Set this to `true` when Got 12 gets released
        http2: false,
        allowGetBody: false,
        https: void 0,
        pagination: {
          transform: (response2) => {
            if (response2.request.options.responseType === "json") {
              return response2.body;
            }
            return JSON.parse(response2.body);
          },
          paginate: (response2) => {
            if (!Reflect.has(response2.headers, "link")) {
              return false;
            }
            const items = response2.headers.link.split(",");
            let next2;
            for (const item of items) {
              const parsed = item.split(";");
              if (parsed[1].includes("next")) {
                next2 = parsed[0].trimStart().trim();
                next2 = next2.slice(1, -1);
                break;
              }
            }
            if (next2) {
              const options = {
                url: new url_1.URL(next2)
              };
              return options;
            }
            return false;
          },
          filter: () => true,
          shouldContinue: () => true,
          countLimit: Infinity,
          backoff: 0,
          requestLimit: 1e4,
          stackAllItems: true
        },
        parseJson: (text3) => JSON.parse(text3),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
      },
      handlers: [create_1.defaultHandler],
      mutableDefaults: false
    };
    var got = create_1.default(defaults);
    exports.default = got;
    module.exports = got;
    module.exports.default = got;
    module.exports.__esModule = true;
    __exportStar(require_create(), exports);
    __exportStar(require_as_promise(), exports);
  }
});

// node_modules/google-play-scraper/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/google-play-scraper/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val2, options) {
      options = options || {};
      var type3 = typeof val2;
      if (type3 === "string" && val2.length > 0) {
        return parse9(val2);
      } else if (type3 === "number" && isFinite(val2)) {
        return options.long ? fmtLong(val2) : fmtShort(val2);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val2)
      );
    };
    function parse9(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type3 = (match[2] || "ms").toLowerCase();
      switch (type3) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/google-play-scraper/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/google-play-scraper/node_modules/debug/src/common.js"(exports, module) {
    "use strict";
    function setup(env) {
      createDebug9.debug = createDebug9;
      createDebug9.default = createDebug9;
      createDebug9.coerce = coerce;
      createDebug9.disable = disable;
      createDebug9.enable = enable;
      createDebug9.enabled = enabled;
      createDebug9.humanize = require_ms();
      Object.keys(env).forEach(function(key) {
        createDebug9[key] = env[key];
      });
      createDebug9.instances = [];
      createDebug9.names = [];
      createDebug9.skips = [];
      createDebug9.formatters = {};
      function selectColor(namespace) {
        var hash = 0;
        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug9.colors[Math.abs(hash) % createDebug9.colors.length];
      }
      createDebug9.selectColor = selectColor;
      function createDebug9(namespace) {
        var prevTime;
        function debug9() {
          if (!debug9.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug9;
          var curr = Number(/* @__PURE__ */ new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug9.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") {
              return match;
            }
            index2++;
            var formatter = createDebug9.formatters[format];
            if (typeof formatter === "function") {
              var val2 = args[index2];
              match = formatter.call(self2, val2);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug9.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug9.log;
          logFn.apply(self2, args);
        }
        debug9.namespace = namespace;
        debug9.enabled = createDebug9.enabled(namespace);
        debug9.useColors = createDebug9.useColors();
        debug9.color = selectColor(namespace);
        debug9.destroy = destroy;
        debug9.extend = extend;
        if (typeof createDebug9.init === "function") {
          createDebug9.init(debug9);
        }
        createDebug9.instances.push(debug9);
        return debug9;
      }
      function destroy() {
        var index2 = createDebug9.instances.indexOf(this);
        if (index2 !== -1) {
          createDebug9.instances.splice(index2, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        return createDebug9(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      }
      function enable(namespaces) {
        createDebug9.save(namespaces);
        createDebug9.names = [];
        createDebug9.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug9.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug9.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug9.instances.length; i++) {
          var instance = createDebug9.instances[i];
          instance.enabled = createDebug9.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug9.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i;
        var len;
        for (i = 0, len = createDebug9.skips.length; i < len; i++) {
          if (createDebug9.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug9.names.length; i < len; i++) {
          if (createDebug9.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val2) {
        if (val2 instanceof Error) {
          return val2.stack || val2.message;
        }
        return val2;
      }
      createDebug9.enable(createDebug9.load());
      return createDebug9;
    }
    module.exports = setup;
  }
});

// node_modules/google-play-scraper/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/google-play-scraper/node_modules/debug/src/browser.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var formatters = module.exports.formatters;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../../../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../../../../node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../../../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../../../../node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/google-play-scraper/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/google-play-scraper/node_modules/debug/src/node.js"(exports, module) {
    "use strict";
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {
    }
    var supportsColor;
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop2 = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val2 = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val2)) {
        val2 = true;
      } else if (/^(no|off|false|disabled)$/i.test(val2)) {
        val2 = false;
      } else if (val2 === "null") {
        val2 = null;
      } else {
        val2 = Number(val2);
      }
      obj[prop2] = val2;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      var name = this.namespace, useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug9) {
      debug9.inspectOpts = {};
      var keys4 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys4.length; i++) {
        debug9.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
      }
    }
    module.exports = require_common()(exports);
    var formatters = module.exports.formatters;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/google-play-scraper/node_modules/debug/src/index.js
var require_src5 = __commonJS({
  "node_modules/google-play-scraper/node_modules/debug/src/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/css-what/lib/commonjs/types.js
var require_types3 = __commonJS({
  "node_modules/css-what/lib/commonjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = void 0;
    var SelectorType5;
    (function(SelectorType6) {
      SelectorType6["Attribute"] = "attribute";
      SelectorType6["Pseudo"] = "pseudo";
      SelectorType6["PseudoElement"] = "pseudo-element";
      SelectorType6["Tag"] = "tag";
      SelectorType6["Universal"] = "universal";
      SelectorType6["Adjacent"] = "adjacent";
      SelectorType6["Child"] = "child";
      SelectorType6["Descendant"] = "descendant";
      SelectorType6["Parent"] = "parent";
      SelectorType6["Sibling"] = "sibling";
      SelectorType6["ColumnCombinator"] = "column-combinator";
    })(SelectorType5 = exports.SelectorType || (exports.SelectorType = {}));
    exports.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction2;
    (function(AttributeAction3) {
      AttributeAction3["Any"] = "any";
      AttributeAction3["Element"] = "element";
      AttributeAction3["End"] = "end";
      AttributeAction3["Equals"] = "equals";
      AttributeAction3["Exists"] = "exists";
      AttributeAction3["Hyphen"] = "hyphen";
      AttributeAction3["Not"] = "not";
      AttributeAction3["Start"] = "start";
    })(AttributeAction2 = exports.AttributeAction || (exports.AttributeAction = {}));
  }
});

// node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS({
  "node_modules/css-what/lib/commonjs/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.isTraversal = void 0;
    var types_1 = require_types3();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal3(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports.isTraversal = isTraversal3;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
      return c === 39 || c === 34;
    }
    function isWhitespace3(c) {
      return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
    }
    function parse9(selector) {
      var subselects2 = [];
      var endIndex = parseSelector(subselects2, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects2;
    }
    exports.parse = parse9;
    function parseSelector(subselects2, selector, selectorIndex) {
      var tokens = [];
      function getName2(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace3(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal3(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type3) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type3;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type: type3 });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName2(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects2.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop:
        while (selectorIndex < selector.length) {
          var firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
            case 32:
            case 9:
            case 10:
            case 12:
            case 13: {
              if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
                ensureNotTraversal();
                tokens.push({ type: types_1.SelectorType.Descendant });
              }
              stripWhitespace(1);
              break;
            }
            case 62: {
              addTraversal(types_1.SelectorType.Child);
              stripWhitespace(1);
              break;
            }
            case 60: {
              addTraversal(types_1.SelectorType.Parent);
              stripWhitespace(1);
              break;
            }
            case 126: {
              addTraversal(types_1.SelectorType.Sibling);
              stripWhitespace(1);
              break;
            }
            case 43: {
              addTraversal(types_1.SelectorType.Adjacent);
              stripWhitespace(1);
              break;
            }
            case 46: {
              addSpecialAttribute("class", types_1.AttributeAction.Element);
              break;
            }
            case 35: {
              addSpecialAttribute("id", types_1.AttributeAction.Equals);
              break;
            }
            case 91: {
              stripWhitespace(1);
              var name_1 = void 0;
              var namespace = null;
              if (selector.charCodeAt(selectorIndex) === 124) {
                name_1 = getName2(1);
              } else if (selector.startsWith("*|", selectorIndex)) {
                namespace = "*";
                name_1 = getName2(2);
              } else {
                name_1 = getName2(0);
                if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                  namespace = name_1;
                  name_1 = getName2(1);
                }
              }
              stripWhitespace(0);
              var action = types_1.AttributeAction.Exists;
              var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
              if (possibleAction) {
                action = possibleAction;
                if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                  throw new Error("Expected `=`");
                }
                stripWhitespace(2);
              } else if (selector.charCodeAt(selectorIndex) === 61) {
                action = types_1.AttributeAction.Equals;
                stripWhitespace(1);
              }
              var value2 = "";
              var ignoreCase = null;
              if (action !== "exists") {
                if (isQuote(selector.charCodeAt(selectorIndex))) {
                  var quote = selector.charCodeAt(selectorIndex);
                  var sectionEnd = selectorIndex + 1;
                  while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                    sectionEnd += 1;
                  }
                  if (selector.charCodeAt(sectionEnd) !== quote) {
                    throw new Error("Attribute value didn't end");
                  }
                  value2 = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                  selectorIndex = sectionEnd + 1;
                } else {
                  var valueStart = selectorIndex;
                  while (selectorIndex < selector.length && (!isWhitespace3(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                    selectorIndex += 1;
                  }
                  value2 = unescapeCSS(selector.slice(valueStart, selectorIndex));
                }
                stripWhitespace(0);
                var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
                if (forceIgnore === 115) {
                  ignoreCase = false;
                  stripWhitespace(1);
                } else if (forceIgnore === 105) {
                  ignoreCase = true;
                  stripWhitespace(1);
                }
              }
              if (selector.charCodeAt(selectorIndex) !== 93) {
                throw new Error("Attribute selector didn't terminate");
              }
              selectorIndex += 1;
              var attributeSelector = {
                type: types_1.SelectorType.Attribute,
                name: name_1,
                action,
                value: value2,
                namespace,
                ignoreCase
              };
              tokens.push(attributeSelector);
              break;
            }
            case 58: {
              if (selector.charCodeAt(selectorIndex + 1) === 58) {
                tokens.push({
                  type: types_1.SelectorType.PseudoElement,
                  name: getName2(2).toLowerCase(),
                  data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
                });
                continue;
              }
              var name_2 = getName2(1).toLowerCase();
              var data3 = null;
              if (selector.charCodeAt(selectorIndex) === 40) {
                if (unpackPseudos.has(name_2)) {
                  if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                    throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                  }
                  data3 = [];
                  selectorIndex = parseSelector(data3, selector, selectorIndex + 1);
                  if (selector.charCodeAt(selectorIndex) !== 41) {
                    throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                  }
                  selectorIndex += 1;
                } else {
                  data3 = readValueWithParenthesis();
                  if (stripQuotesFromPseudos.has(name_2)) {
                    var quot = data3.charCodeAt(0);
                    if (quot === data3.charCodeAt(data3.length - 1) && isQuote(quot)) {
                      data3 = data3.slice(1, -1);
                    }
                  }
                  data3 = unescapeCSS(data3);
                }
              }
              tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data: data3 });
              break;
            }
            case 44: {
              finalizeSubselector();
              tokens = [];
              stripWhitespace(1);
              break;
            }
            default: {
              if (selector.startsWith("/*", selectorIndex)) {
                var endIndex = selector.indexOf("*/", selectorIndex + 2);
                if (endIndex < 0) {
                  throw new Error("Comment was not terminated");
                }
                selectorIndex = endIndex + 2;
                if (tokens.length === 0) {
                  stripWhitespace(0);
                }
                break;
              }
              var namespace = null;
              var name_3 = void 0;
              if (firstChar === 42) {
                selectorIndex += 1;
                name_3 = "*";
              } else if (firstChar === 124) {
                name_3 = "";
                if (selector.charCodeAt(selectorIndex + 1) === 124) {
                  addTraversal(types_1.SelectorType.ColumnCombinator);
                  stripWhitespace(2);
                  break;
                }
              } else if (reName.test(selector.slice(selectorIndex))) {
                name_3 = getName2(0);
              } else {
                break loop;
              }
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
                namespace = name_3;
                if (selector.charCodeAt(selectorIndex + 1) === 42) {
                  name_3 = "*";
                  selectorIndex += 2;
                } else {
                  name_3 = getName2(1);
                }
              }
              tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
            }
          }
        }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// node_modules/css-what/lib/commonjs/stringify.js
var require_stringify = __commonJS({
  "node_modules/css-what/lib/commonjs/stringify.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var types_1 = require_types3();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c) {
      return c.charCodeAt(0);
    }));
    function stringify2(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports.stringify = stringify2;
    function stringifyToken(token, index2, arr) {
      switch (token.type) {
        case types_1.SelectorType.Child:
          return index2 === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index2 === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index2 === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index2 === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index2 === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index2 + 1 < arr.length && "name" in arr[index2 + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify2(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
          ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
          lastIdx = i + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/css-what/lib/commonjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = exports.isTraversal = void 0;
    __exportStar(require_types3(), exports);
    var parse_1 = require_parse();
    Object.defineProperty(exports, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc2() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/ramda/dist/ramda.js
var require_ramda = __commonJS({
  "node_modules/ramda/dist/ramda.js"(exports, module) {
    (function() {
      "use strict";
      var __ = { "@@functional/placeholder": true };
      var _arity2 = function _arity3(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.apply(this, arguments);
            };
          case 1:
            return function(a0) {
              return fn.apply(this, arguments);
            };
          case 2:
            return function(a0, a1) {
              return fn.apply(this, arguments);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.apply(this, arguments);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.apply(this, arguments);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.apply(this, arguments);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.apply(this, arguments);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.apply(this, arguments);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.apply(this, arguments);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.apply(this, arguments);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.apply(this, arguments);
            };
          default:
            throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
        }
      };
      var _arrayFromIterator2 = function _arrayFromIterator3(iter) {
        var list2 = [];
        var next2;
        while (!(next2 = iter.next()).done) {
          list2.push(next2.value);
        }
        return list2;
      };
      var _arrayOf = function _arrayOf2() {
        return Array.prototype.slice.call(arguments);
      };
      var _cloneRegExp2 = function _cloneRegExp3(pattern) {
        return new RegExp(pattern.source, (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : ""));
      };
      var _complement2 = function _complement3(f) {
        return function() {
          return !f.apply(this, arguments);
        };
      };
      var _concat2 = function _concat3(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
          result[result.length] = set1[idx];
          idx += 1;
        }
        idx = 0;
        while (idx < len2) {
          result[result.length] = set2[idx];
          idx += 1;
        }
        return result;
      };
      var _containsWith = function _containsWith2(pred, x, list2) {
        var idx = 0;
        var len = list2.length;
        while (idx < len) {
          if (pred(x, list2[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      };
      var _filter2 = function _filter3(fn, list2) {
        var idx = 0;
        var len = list2.length;
        var result = [];
        while (idx < len) {
          if (fn(list2[idx])) {
            result[result.length] = list2[idx];
          }
          idx += 1;
        }
        return result;
      };
      var _forceReduced2 = function _forceReduced3(x) {
        return {
          "@@transducer/value": x,
          "@@transducer/reduced": true
        };
      };
      var _functionName2 = function _functionName3(f) {
        var match2 = String(f).match(/^function (\w*)/);
        return match2 == null ? "" : match2[1];
      };
      var _has2 = function _has3(prop3, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop3);
      };
      var _identity2 = function _identity3(x) {
        return x;
      };
      var _isArguments2 = function() {
        var toString4 = Object.prototype.toString;
        return toString4.call(arguments) === "[object Arguments]" ? function _isArguments3(x) {
          return toString4.call(x) === "[object Arguments]";
        } : function _isArguments3(x) {
          return _has2("callee", x);
        };
      }();
      var _isArray2 = Array.isArray || function _isArray3(val2) {
        return val2 != null && val2.length >= 0 && Object.prototype.toString.call(val2) === "[object Array]";
      };
      var _isFunction2 = function _isNumber3(x) {
        return Object.prototype.toString.call(x) === "[object Function]";
      };
      var _isInteger2 = Number.isInteger || function _isInteger3(n) {
        return n << 0 === n;
      };
      var _isNumber2 = function _isNumber3(x) {
        return Object.prototype.toString.call(x) === "[object Number]";
      };
      var _isObject2 = function _isObject3(x) {
        return Object.prototype.toString.call(x) === "[object Object]";
      };
      var _isPlaceholder2 = function _isPlaceholder3(a) {
        return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
      };
      var _isRegExp2 = function _isRegExp3(x) {
        return Object.prototype.toString.call(x) === "[object RegExp]";
      };
      var _isString2 = function _isString3(x) {
        return Object.prototype.toString.call(x) === "[object String]";
      };
      var _isTransformer2 = function _isTransformer3(obj) {
        return typeof obj["@@transducer/step"] === "function";
      };
      var _map2 = function _map3(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
          result[idx] = fn(functor[idx]);
          idx += 1;
        }
        return result;
      };
      var _objectAssign = function _objectAssign2(target) {
        if (target == null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        var idx = 1;
        var length2 = arguments.length;
        while (idx < length2) {
          var source = arguments[idx];
          if (source != null) {
            for (var nextKey in source) {
              if (_has2(nextKey, source)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
          idx += 1;
        }
        return output;
      };
      var _of = function _of2(x) {
        return [x];
      };
      var _pipe2 = function _pipe3(f, g) {
        return function() {
          return g.call(this, f.apply(this, arguments));
        };
      };
      var _pipeP = function _pipeP2(f, g) {
        return function() {
          var ctx = this;
          return f.apply(ctx, arguments).then(function(x) {
            return g.call(ctx, x);
          });
        };
      };
      var _quote2 = function _quote3(s) {
        var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
        return '"' + escaped.replace(/"/g, '\\"') + '"';
      };
      var _reduced2 = function _reduced3(x) {
        return x && x["@@transducer/reduced"] ? x : {
          "@@transducer/value": x,
          "@@transducer/reduced": true
        };
      };
      var _slice = function _slice2(args, from, to) {
        switch (arguments.length) {
          case 1:
            return _slice2(args, 0, args.length);
          case 2:
            return _slice2(args, from, args.length);
          default:
            var list2 = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
              list2[idx] = args[from + idx];
              idx += 1;
            }
            return list2;
        }
      };
      var _toISOString4 = function() {
        var pad3 = function pad4(n) {
          return (n < 10 ? "0" : "") + n;
        };
        return typeof Date.prototype.toISOString === "function" ? function _toISOString5(d) {
          return d.toISOString();
        } : function _toISOString5(d) {
          return d.getUTCFullYear() + "-" + pad3(d.getUTCMonth() + 1) + "-" + pad3(d.getUTCDate()) + "T" + pad3(d.getUTCHours()) + ":" + pad3(d.getUTCMinutes()) + ":" + pad3(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
        };
      }();
      var _xfBase = {
        init: function() {
          return this.xf["@@transducer/init"]();
        },
        result: function(result) {
          return this.xf["@@transducer/result"](result);
        }
      };
      var _xwrap2 = function() {
        function XWrap(fn) {
          this.f = fn;
        }
        XWrap.prototype["@@transducer/init"] = function() {
          throw new Error("init not implemented on XWrap");
        };
        XWrap.prototype["@@transducer/result"] = function(acc) {
          return acc;
        };
        XWrap.prototype["@@transducer/step"] = function(acc, x) {
          return this.f(acc, x);
        };
        return function _xwrap3(fn) {
          return new XWrap(fn);
        };
      }();
      var _aperture2 = function _aperture3(n, list2) {
        var idx = 0;
        var limit = list2.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
          acc[idx] = _slice(list2, idx, idx + n);
          idx += 1;
        }
        return acc;
      };
      var _assign = typeof Object.assign === "function" ? Object.assign : _objectAssign;
      var _checkForMethod2 = function _checkForMethod3(methodname, fn) {
        return function() {
          var length2 = arguments.length;
          if (length2 === 0) {
            return fn();
          }
          var obj = arguments[length2 - 1];
          return _isArray2(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length2 - 1));
        };
      };
      var _curry12 = function _curry13(fn) {
        return function f1(a) {
          if (arguments.length === 0 || _isPlaceholder2(a)) {
            return f1;
          } else {
            return fn.apply(this, arguments);
          }
        };
      };
      var _curry22 = function _curry23(fn) {
        return function f2(a, b) {
          switch (arguments.length) {
            case 0:
              return f2;
            case 1:
              return _isPlaceholder2(a) ? f2 : _curry12(function(_b) {
                return fn(a, _b);
              });
            default:
              return _isPlaceholder2(a) && _isPlaceholder2(b) ? f2 : _isPlaceholder2(a) ? _curry12(function(_a2) {
                return fn(_a2, b);
              }) : _isPlaceholder2(b) ? _curry12(function(_b) {
                return fn(a, _b);
              }) : fn(a, b);
          }
        };
      };
      var _curry32 = function _curry33(fn) {
        return function f3(a, b, c) {
          switch (arguments.length) {
            case 0:
              return f3;
            case 1:
              return _isPlaceholder2(a) ? f3 : _curry22(function(_b, _c) {
                return fn(a, _b, _c);
              });
            case 2:
              return _isPlaceholder2(a) && _isPlaceholder2(b) ? f3 : _isPlaceholder2(a) ? _curry22(function(_a2, _c) {
                return fn(_a2, b, _c);
              }) : _isPlaceholder2(b) ? _curry22(function(_b, _c) {
                return fn(a, _b, _c);
              }) : _curry12(function(_c) {
                return fn(a, b, _c);
              });
            default:
              return _isPlaceholder2(a) && _isPlaceholder2(b) && _isPlaceholder2(c) ? f3 : _isPlaceholder2(a) && _isPlaceholder2(b) ? _curry22(function(_a2, _b) {
                return fn(_a2, _b, c);
              }) : _isPlaceholder2(a) && _isPlaceholder2(c) ? _curry22(function(_a2, _c) {
                return fn(_a2, b, _c);
              }) : _isPlaceholder2(b) && _isPlaceholder2(c) ? _curry22(function(_b, _c) {
                return fn(a, _b, _c);
              }) : _isPlaceholder2(a) ? _curry12(function(_a2) {
                return fn(_a2, b, c);
              }) : _isPlaceholder2(b) ? _curry12(function(_b) {
                return fn(a, _b, c);
              }) : _isPlaceholder2(c) ? _curry12(function(_c) {
                return fn(a, b, _c);
              }) : fn(a, b, c);
          }
        };
      };
      var _curryN2 = function _curryN3(length2, received, fn) {
        return function() {
          var combined = [];
          var argsIdx = 0;
          var left = length2;
          var combinedIdx = 0;
          while (combinedIdx < received.length || argsIdx < arguments.length) {
            var result;
            if (combinedIdx < received.length && (!_isPlaceholder2(received[combinedIdx]) || argsIdx >= arguments.length)) {
              result = received[combinedIdx];
            } else {
              result = arguments[argsIdx];
              argsIdx += 1;
            }
            combined[combinedIdx] = result;
            if (!_isPlaceholder2(result)) {
              left -= 1;
            }
            combinedIdx += 1;
          }
          return left <= 0 ? fn.apply(this, combined) : _arity2(left, _curryN3(length2, combined, fn));
        };
      };
      var _dispatchable2 = function _dispatchable3(methodname, xf, fn) {
        return function() {
          var length2 = arguments.length;
          if (length2 === 0) {
            return fn();
          }
          var obj = arguments[length2 - 1];
          if (!_isArray2(obj)) {
            var args = _slice(arguments, 0, length2 - 1);
            if (typeof obj[methodname] === "function") {
              return obj[methodname].apply(obj, args);
            }
            if (_isTransformer2(obj)) {
              var transducer = xf.apply(null, args);
              return transducer(obj);
            }
          }
          return fn.apply(this, arguments);
        };
      };
      var _dropLastWhile = function dropLastWhile3(pred, list2) {
        var idx = list2.length - 1;
        while (idx >= 0 && pred(list2[idx])) {
          idx -= 1;
        }
        return _slice(list2, 0, idx + 1);
      };
      var _xall2 = function() {
        function XAll(f, xf) {
          this.xf = xf;
          this.f = f;
          this.all = true;
        }
        XAll.prototype["@@transducer/init"] = _xfBase.init;
        XAll.prototype["@@transducer/result"] = function(result) {
          if (this.all) {
            result = this.xf["@@transducer/step"](result, true);
          }
          return this.xf["@@transducer/result"](result);
        };
        XAll.prototype["@@transducer/step"] = function(result, input) {
          if (!this.f(input)) {
            this.all = false;
            result = _reduced2(this.xf["@@transducer/step"](result, false));
          }
          return result;
        };
        return _curry22(function _xall3(f, xf) {
          return new XAll(f, xf);
        });
      }();
      var _xany2 = function() {
        function XAny(f, xf) {
          this.xf = xf;
          this.f = f;
          this.any = false;
        }
        XAny.prototype["@@transducer/init"] = _xfBase.init;
        XAny.prototype["@@transducer/result"] = function(result) {
          if (!this.any) {
            result = this.xf["@@transducer/step"](result, false);
          }
          return this.xf["@@transducer/result"](result);
        };
        XAny.prototype["@@transducer/step"] = function(result, input) {
          if (this.f(input)) {
            this.any = true;
            result = _reduced2(this.xf["@@transducer/step"](result, true));
          }
          return result;
        };
        return _curry22(function _xany3(f, xf) {
          return new XAny(f, xf);
        });
      }();
      var _xaperture2 = function() {
        function XAperture(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }
        XAperture.prototype["@@transducer/init"] = _xfBase.init;
        XAperture.prototype["@@transducer/result"] = function(result) {
          this.acc = null;
          return this.xf["@@transducer/result"](result);
        };
        XAperture.prototype["@@transducer/step"] = function(result, input) {
          this.store(input);
          return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function(input) {
          this.acc[this.pos] = input;
          this.pos += 1;
          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };
        XAperture.prototype.getCopy = function() {
          return _concat2(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry22(function _xaperture3(n, xf) {
          return new XAperture(n, xf);
        });
      }();
      var _xdrop2 = function() {
        function XDrop(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XDrop.prototype["@@transducer/init"] = _xfBase.init;
        XDrop.prototype["@@transducer/result"] = _xfBase.result;
        XDrop.prototype["@@transducer/step"] = function(result, input) {
          if (this.n > 0) {
            this.n -= 1;
            return result;
          }
          return this.xf["@@transducer/step"](result, input);
        };
        return _curry22(function _xdrop3(n, xf) {
          return new XDrop(n, xf);
        });
      }();
      var _xdropLast2 = function() {
        function XDropLast(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }
        XDropLast.prototype["@@transducer/init"] = _xfBase.init;
        XDropLast.prototype["@@transducer/result"] = function(result) {
          this.acc = null;
          return this.xf["@@transducer/result"](result);
        };
        XDropLast.prototype["@@transducer/step"] = function(result, input) {
          if (this.full) {
            result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
          }
          this.store(input);
          return result;
        };
        XDropLast.prototype.store = function(input) {
          this.acc[this.pos] = input;
          this.pos += 1;
          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };
        return _curry22(function _xdropLast3(n, xf) {
          return new XDropLast(n, xf);
        });
      }();
      var _xdropRepeatsWith2 = function() {
        function XDropRepeatsWith(pred, xf) {
          this.xf = xf;
          this.pred = pred;
          this.lastValue = void 0;
          this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype["@@transducer/init"] = function() {
          return this.xf["@@transducer/init"]();
        };
        XDropRepeatsWith.prototype["@@transducer/result"] = function(result) {
          return this.xf["@@transducer/result"](result);
        };
        XDropRepeatsWith.prototype["@@transducer/step"] = function(result, input) {
          var sameAsLast = false;
          if (!this.seenFirstValue) {
            this.seenFirstValue = true;
          } else if (this.pred(this.lastValue, input)) {
            sameAsLast = true;
          }
          this.lastValue = input;
          return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
        };
        return _curry22(function _xdropRepeatsWith3(pred, xf) {
          return new XDropRepeatsWith(pred, xf);
        });
      }();
      var _xdropWhile2 = function() {
        function XDropWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XDropWhile.prototype["@@transducer/init"] = _xfBase.init;
        XDropWhile.prototype["@@transducer/result"] = _xfBase.result;
        XDropWhile.prototype["@@transducer/step"] = function(result, input) {
          if (this.f) {
            if (this.f(input)) {
              return result;
            }
            this.f = null;
          }
          return this.xf["@@transducer/step"](result, input);
        };
        return _curry22(function _xdropWhile3(f, xf) {
          return new XDropWhile(f, xf);
        });
      }();
      var _xfilter2 = function() {
        function XFilter(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFilter.prototype["@@transducer/init"] = _xfBase.init;
        XFilter.prototype["@@transducer/result"] = _xfBase.result;
        XFilter.prototype["@@transducer/step"] = function(result, input) {
          return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
        };
        return _curry22(function _xfilter3(f, xf) {
          return new XFilter(f, xf);
        });
      }();
      var _xfind2 = function() {
        function XFind(f, xf) {
          this.xf = xf;
          this.f = f;
          this.found = false;
        }
        XFind.prototype["@@transducer/init"] = _xfBase.init;
        XFind.prototype["@@transducer/result"] = function(result) {
          if (!this.found) {
            result = this.xf["@@transducer/step"](result, void 0);
          }
          return this.xf["@@transducer/result"](result);
        };
        XFind.prototype["@@transducer/step"] = function(result, input) {
          if (this.f(input)) {
            this.found = true;
            result = _reduced2(this.xf["@@transducer/step"](result, input));
          }
          return result;
        };
        return _curry22(function _xfind3(f, xf) {
          return new XFind(f, xf);
        });
      }();
      var _xfindIndex2 = function() {
        function XFindIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.found = false;
        }
        XFindIndex.prototype["@@transducer/init"] = _xfBase.init;
        XFindIndex.prototype["@@transducer/result"] = function(result) {
          if (!this.found) {
            result = this.xf["@@transducer/step"](result, -1);
          }
          return this.xf["@@transducer/result"](result);
        };
        XFindIndex.prototype["@@transducer/step"] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.found = true;
            result = _reduced2(this.xf["@@transducer/step"](result, this.idx));
          }
          return result;
        };
        return _curry22(function _xfindIndex3(f, xf) {
          return new XFindIndex(f, xf);
        });
      }();
      var _xfindLast2 = function() {
        function XFindLast(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFindLast.prototype["@@transducer/init"] = _xfBase.init;
        XFindLast.prototype["@@transducer/result"] = function(result) {
          return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
        };
        XFindLast.prototype["@@transducer/step"] = function(result, input) {
          if (this.f(input)) {
            this.last = input;
          }
          return result;
        };
        return _curry22(function _xfindLast3(f, xf) {
          return new XFindLast(f, xf);
        });
      }();
      var _xfindLastIndex2 = function() {
        function XFindLastIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.lastIdx = -1;
        }
        XFindLastIndex.prototype["@@transducer/init"] = _xfBase.init;
        XFindLastIndex.prototype["@@transducer/result"] = function(result) {
          return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
        };
        XFindLastIndex.prototype["@@transducer/step"] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.lastIdx = this.idx;
          }
          return result;
        };
        return _curry22(function _xfindLastIndex3(f, xf) {
          return new XFindLastIndex(f, xf);
        });
      }();
      var _xmap3 = function() {
        function XMap2(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XMap2.prototype["@@transducer/init"] = _xfBase.init;
        XMap2.prototype["@@transducer/result"] = _xfBase.result;
        XMap2.prototype["@@transducer/step"] = function(result, input) {
          return this.xf["@@transducer/step"](result, this.f(input));
        };
        return _curry22(function _xmap4(f, xf) {
          return new XMap2(f, xf);
        });
      }();
      var _xtake2 = function() {
        function XTake(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XTake.prototype["@@transducer/init"] = _xfBase.init;
        XTake.prototype["@@transducer/result"] = _xfBase.result;
        XTake.prototype["@@transducer/step"] = function(result, input) {
          if (this.n === 0) {
            return _reduced2(result);
          } else {
            this.n -= 1;
            return this.xf["@@transducer/step"](result, input);
          }
        };
        return _curry22(function _xtake3(n, xf) {
          return new XTake(n, xf);
        });
      }();
      var _xtakeWhile2 = function() {
        function XTakeWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XTakeWhile.prototype["@@transducer/init"] = _xfBase.init;
        XTakeWhile.prototype["@@transducer/result"] = _xfBase.result;
        XTakeWhile.prototype["@@transducer/step"] = function(result, input) {
          return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced2(result);
        };
        return _curry22(function _xtakeWhile3(f, xf) {
          return new XTakeWhile(f, xf);
        });
      }();
      var add2 = _curry22(function add3(a, b) {
        return Number(a) + Number(b);
      });
      var adjust = _curry32(function adjust2(fn, idx, list2) {
        if (idx >= list2.length || idx < -list2.length) {
          return list2;
        }
        var start = idx < 0 ? list2.length : 0;
        var _idx = start + idx;
        var _list = _concat2(list2);
        _list[_idx] = fn(list2[_idx]);
        return _list;
      });
      var all = _curry22(_dispatchable2("all", _xall2, function all2(fn, list2) {
        var idx = 0;
        while (idx < list2.length) {
          if (!fn(list2[idx])) {
            return false;
          }
          idx += 1;
        }
        return true;
      }));
      var always = _curry12(function always2(val2) {
        return function() {
          return val2;
        };
      });
      var and = _curry22(function and2(a, b) {
        return a && b;
      });
      var any = _curry22(_dispatchable2("any", _xany2, function any2(fn, list2) {
        var idx = 0;
        while (idx < list2.length) {
          if (fn(list2[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      }));
      var aperture = _curry22(_dispatchable2("aperture", _xaperture2, _aperture2));
      var append3 = _curry22(function append4(el, list2) {
        return _concat2(list2, [el]);
      });
      var apply = _curry22(function apply2(fn, args) {
        return fn.apply(this, args);
      });
      var assoc3 = _curry32(function assoc4(prop3, val2, obj) {
        var result = {};
        for (var p in obj) {
          result[p] = obj[p];
        }
        result[prop3] = val2;
        return result;
      });
      var assocPath3 = _curry32(function assocPath4(path4, val2, obj) {
        switch (path4.length) {
          case 0:
            return val2;
          case 1:
            return assoc3(path4[0], val2, obj);
          default:
            return assoc3(path4[0], assocPath4(_slice(path4, 1), val2, Object(obj[path4[0]])), obj);
        }
      });
      var bind3 = _curry22(function bind4(fn, thisObj) {
        return _arity2(fn.length, function() {
          return fn.apply(thisObj, arguments);
        });
      });
      var clamp = _curry32(function clamp2(min2, max2, value2) {
        if (min2 > max2) {
          throw new Error("min must not be greater than max in clamp(min, max, value)");
        }
        return value2 < min2 ? min2 : value2 > max2 ? max2 : value2;
      });
      var comparator = _curry12(function comparator2(pred) {
        return function(a, b) {
          return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
      });
      var curryN3 = _curry22(function curryN4(length2, fn) {
        if (length2 === 1) {
          return _curry12(fn);
        }
        return _arity2(length2, _curryN2(length2, [], fn));
      });
      var dec = add2(-1);
      var defaultTo = _curry22(function defaultTo2(d, v) {
        return v == null || v !== v ? d : v;
      });
      var differenceWith = _curry32(function differenceWith2(pred, first2, second) {
        var out = [];
        var idx = 0;
        var firstLen = first2.length;
        while (idx < firstLen) {
          if (!_containsWith(pred, first2[idx], second) && !_containsWith(pred, first2[idx], out)) {
            out.push(first2[idx]);
          }
          idx += 1;
        }
        return out;
      });
      var dissoc = _curry22(function dissoc2(prop3, obj) {
        var result = {};
        for (var p in obj) {
          if (p !== prop3) {
            result[p] = obj[p];
          }
        }
        return result;
      });
      var dissocPath = _curry22(function dissocPath2(path4, obj) {
        switch (path4.length) {
          case 0:
            return obj;
          case 1:
            return dissoc(path4[0], obj);
          default:
            var head2 = path4[0];
            var tail2 = _slice(path4, 1);
            return obj[head2] == null ? obj : assoc3(head2, dissocPath2(tail2, obj[head2]), obj);
        }
      });
      var divide = _curry22(function divide2(a, b) {
        return a / b;
      });
      var dropWhile = _curry22(_dispatchable2("dropWhile", _xdropWhile2, function dropWhile2(pred, list2) {
        var idx = 0;
        var len = list2.length;
        while (idx < len && pred(list2[idx])) {
          idx += 1;
        }
        return _slice(list2, idx);
      }));
      var empty2 = _curry12(function empty3(x) {
        return x != null && typeof x.empty === "function" ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === "function" ? x.constructor.empty() : _isArray2(x) ? [] : _isString2(x) ? "" : _isObject2(x) ? {} : _isArguments2(x) ? function() {
          return arguments;
        }() : (
          // else
          void 0
        );
      });
      var evolve = _curry22(function evolve2(transformations, object) {
        var result = {};
        var transformation, key, type4;
        for (key in object) {
          transformation = transformations[key];
          type4 = typeof transformation;
          result[key] = type4 === "function" ? transformation(object[key]) : type4 === "object" ? evolve2(transformations[key], object[key]) : object[key];
        }
        return result;
      });
      var find4 = _curry22(_dispatchable2("find", _xfind2, function find5(fn, list2) {
        var idx = 0;
        var len = list2.length;
        while (idx < len) {
          if (fn(list2[idx])) {
            return list2[idx];
          }
          idx += 1;
        }
      }));
      var findIndex = _curry22(_dispatchable2("findIndex", _xfindIndex2, function findIndex2(fn, list2) {
        var idx = 0;
        var len = list2.length;
        while (idx < len) {
          if (fn(list2[idx])) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      }));
      var findLast = _curry22(_dispatchable2("findLast", _xfindLast2, function findLast2(fn, list2) {
        var idx = list2.length - 1;
        while (idx >= 0) {
          if (fn(list2[idx])) {
            return list2[idx];
          }
          idx -= 1;
        }
      }));
      var findLastIndex = _curry22(_dispatchable2("findLastIndex", _xfindLastIndex2, function findLastIndex2(fn, list2) {
        var idx = list2.length - 1;
        while (idx >= 0) {
          if (fn(list2[idx])) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      }));
      var forEach = _curry22(_checkForMethod2("forEach", function forEach2(fn, list2) {
        var len = list2.length;
        var idx = 0;
        while (idx < len) {
          fn(list2[idx]);
          idx += 1;
        }
        return list2;
      }));
      var fromPairs = _curry12(function fromPairs2(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
          if (_isArray2(pairs[idx]) && pairs[idx].length) {
            out[pairs[idx][0]] = pairs[idx][1];
          }
          idx += 1;
        }
        return out;
      });
      var groupWith = _curry22(function(fn, list2) {
        var res = [];
        var idx = 0;
        var len = list2.length;
        while (idx < len) {
          var nextidx = idx + 1;
          while (nextidx < len && fn(list2[idx], list2[nextidx])) {
            nextidx += 1;
          }
          res.push(list2.slice(idx, nextidx));
          idx = nextidx;
        }
        return res;
      });
      var gt = _curry22(function gt2(a, b) {
        return a > b;
      });
      var gte = _curry22(function gte2(a, b) {
        return a >= b;
      });
      var has2 = _curry22(_has2);
      var hasIn = _curry22(function hasIn2(prop3, obj) {
        return prop3 in obj;
      });
      var identical = _curry22(function identical2(a, b) {
        if (a === b) {
          return a !== 0 || 1 / a === 1 / b;
        } else {
          return a !== a && b !== b;
        }
      });
      var identity = _curry12(_identity2);
      var ifElse = _curry32(function ifElse2(condition, onTrue, onFalse) {
        return curryN3(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
          return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
      });
      var inc = add2(1);
      var insert = _curry32(function insert2(idx, elt, list2) {
        idx = idx < list2.length && idx >= 0 ? idx : list2.length;
        var result = _slice(list2);
        result.splice(idx, 0, elt);
        return result;
      });
      var insertAll = _curry32(function insertAll2(idx, elts, list2) {
        idx = idx < list2.length && idx >= 0 ? idx : list2.length;
        return _concat2(_concat2(_slice(list2, 0, idx), elts), _slice(list2, idx));
      });
      var intersperse = _curry22(_checkForMethod2("intersperse", function intersperse2(separator, list2) {
        var out = [];
        var idx = 0;
        var length2 = list2.length;
        while (idx < length2) {
          if (idx === length2 - 1) {
            out.push(list2[idx]);
          } else {
            out.push(list2[idx], separator);
          }
          idx += 1;
        }
        return out;
      }));
      var is6 = _curry22(function is7(Ctor, val2) {
        return val2 != null && val2.constructor === Ctor || val2 instanceof Ctor;
      });
      var isArrayLike3 = _curry12(function isArrayLike4(x) {
        if (_isArray2(x)) {
          return true;
        }
        if (!x) {
          return false;
        }
        if (typeof x !== "object") {
          return false;
        }
        if (x instanceof String) {
          return false;
        }
        if (x.nodeType === 1) {
          return !!x.length;
        }
        if (x.length === 0) {
          return true;
        }
        if (x.length > 0) {
          return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
      });
      var isNil3 = _curry12(function isNil4(x) {
        return x == null;
      });
      var keys4 = function() {
        var hasEnumBug2 = !{ toString: null }.propertyIsEnumerable("toString");
        var nonEnumerableProps2 = [
          "constructor",
          "valueOf",
          "isPrototypeOf",
          "toString",
          "propertyIsEnumerable",
          "hasOwnProperty",
          "toLocaleString"
        ];
        var hasArgsEnumBug2 = function() {
          "use strict";
          return arguments.propertyIsEnumerable("length");
        }();
        var contains6 = function contains7(list2, item) {
          var idx = 0;
          while (idx < list2.length) {
            if (list2[idx] === item) {
              return true;
            }
            idx += 1;
          }
          return false;
        };
        return typeof Object.keys === "function" && !hasArgsEnumBug2 ? _curry12(function keys5(obj) {
          return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry12(function keys5(obj) {
          if (Object(obj) !== obj) {
            return [];
          }
          var prop3, nIdx;
          var ks = [];
          var checkArgsLength = hasArgsEnumBug2 && _isArguments2(obj);
          for (prop3 in obj) {
            if (_has2(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
              ks[ks.length] = prop3;
            }
          }
          if (hasEnumBug2) {
            nIdx = nonEnumerableProps2.length - 1;
            while (nIdx >= 0) {
              prop3 = nonEnumerableProps2[nIdx];
              if (_has2(prop3, obj) && !contains6(ks, prop3)) {
                ks[ks.length] = prop3;
              }
              nIdx -= 1;
            }
          }
          return ks;
        });
      }();
      var keysIn = _curry12(function keysIn2(obj) {
        var prop3;
        var ks = [];
        for (prop3 in obj) {
          ks[ks.length] = prop3;
        }
        return ks;
      });
      var length = _curry12(function length2(list2) {
        return list2 != null && is6(Number, list2.length) ? list2.length : NaN;
      });
      var lt = _curry22(function lt2(a, b) {
        return a < b;
      });
      var lte = _curry22(function lte2(a, b) {
        return a <= b;
      });
      var mapAccum = _curry32(function mapAccum2(fn, acc, list2) {
        var idx = 0;
        var len = list2.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
          tuple = fn(tuple[0], list2[idx]);
          result[idx] = tuple[1];
          idx += 1;
        }
        return [
          tuple[0],
          result
        ];
      });
      var mapAccumRight = _curry32(function mapAccumRight2(fn, acc, list2) {
        var idx = list2.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
          tuple = fn(tuple[0], list2[idx]);
          result[idx] = tuple[1];
          idx -= 1;
        }
        return [
          tuple[0],
          result
        ];
      });
      var match = _curry22(function match2(rx, str) {
        return str.match(rx) || [];
      });
      var mathMod = _curry22(function mathMod2(m, p) {
        if (!_isInteger2(m)) {
          return NaN;
        }
        if (!_isInteger2(p) || p < 1) {
          return NaN;
        }
        return (m % p + p) % p;
      });
      var max = _curry22(function max2(a, b) {
        return b > a ? b : a;
      });
      var maxBy = _curry32(function maxBy2(f, a, b) {
        return f(b) > f(a) ? b : a;
      });
      var merge3 = _curry22(function merge4(l, r) {
        return _assign({}, l, r);
      });
      var mergeAll = _curry12(function mergeAll2(list2) {
        return _assign.apply(null, [{}].concat(list2));
      });
      var mergeWithKey = _curry32(function mergeWithKey2(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
          if (_has2(k, l)) {
            result[k] = _has2(k, r) ? fn(k, l[k], r[k]) : l[k];
          }
        }
        for (k in r) {
          if (_has2(k, r) && !_has2(k, result)) {
            result[k] = r[k];
          }
        }
        return result;
      });
      var min = _curry22(function min2(a, b) {
        return b < a ? b : a;
      });
      var minBy = _curry32(function minBy2(f, a, b) {
        return f(b) < f(a) ? b : a;
      });
      var modulo = _curry22(function modulo2(a, b) {
        return a % b;
      });
      var multiply = _curry22(function multiply2(a, b) {
        return a * b;
      });
      var nAry = _curry22(function nAry2(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.call(this);
            };
          case 1:
            return function(a0) {
              return fn.call(this, a0);
            };
          case 2:
            return function(a0, a1) {
              return fn.call(this, a0, a1);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.call(this, a0, a1, a2);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.call(this, a0, a1, a2, a3);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.call(this, a0, a1, a2, a3, a4);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
          default:
            throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
        }
      });
      var negate = _curry12(function negate2(n) {
        return -n;
      });
      var none = _curry22(_complement2(_dispatchable2("any", _xany2, any)));
      var not2 = _curry12(function not3(a) {
        return !a;
      });
      var nth3 = _curry22(function nth4(offset, list2) {
        var idx = offset < 0 ? list2.length + offset : offset;
        return _isString2(list2) ? list2.charAt(idx) : list2[idx];
      });
      var nthArg = _curry12(function nthArg2(n) {
        return function() {
          return nth3(n, arguments);
        };
      });
      var objOf = _curry22(function objOf2(key, val2) {
        var obj = {};
        obj[key] = val2;
        return obj;
      });
      var of = _curry12(_of);
      var once = _curry12(function once2(fn) {
        var called = false;
        var result;
        return _arity2(fn.length, function() {
          if (called) {
            return result;
          }
          called = true;
          result = fn.apply(this, arguments);
          return result;
        });
      });
      var or = _curry22(function or2(a, b) {
        return a || b;
      });
      var over = function() {
        var Identity = function(x) {
          return {
            value: x,
            map: function(f) {
              return Identity(f(x));
            }
          };
        };
        return _curry32(function over2(lens2, f, x) {
          return lens2(function(y) {
            return Identity(f(y));
          })(x).value;
        });
      }();
      var pair = _curry22(function pair2(fst, snd) {
        return [
          fst,
          snd
        ];
      });
      var path3 = _curry22(function path4(paths3, obj) {
        var val2 = obj;
        var idx = 0;
        while (idx < paths3.length) {
          if (val2 == null) {
            return;
          }
          val2 = val2[paths3[idx]];
          idx += 1;
        }
        return val2;
      });
      var pathOr = _curry32(function pathOr2(d, p, obj) {
        return defaultTo(d, path3(p, obj));
      });
      var pathSatisfies = _curry32(function pathSatisfies2(pred, propPath, obj) {
        return propPath.length > 0 && pred(path3(propPath, obj));
      });
      var pick = _curry22(function pick2(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
          if (names[idx] in obj) {
            result[names[idx]] = obj[names[idx]];
          }
          idx += 1;
        }
        return result;
      });
      var pickAll = _curry22(function pickAll2(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
          var name = names[idx];
          result[name] = obj[name];
          idx += 1;
        }
        return result;
      });
      var pickBy = _curry22(function pickBy2(test2, obj) {
        var result = {};
        for (var prop3 in obj) {
          if (test2(obj[prop3], prop3, obj)) {
            result[prop3] = obj[prop3];
          }
        }
        return result;
      });
      var prepend3 = _curry22(function prepend4(el, list2) {
        return _concat2([el], list2);
      });
      var prop2 = _curry22(function prop3(p, obj) {
        return obj[p];
      });
      var propOr = _curry32(function propOr2(val2, p, obj) {
        return obj != null && _has2(p, obj) ? obj[p] : val2;
      });
      var propSatisfies = _curry32(function propSatisfies2(pred, name, obj) {
        return pred(obj[name]);
      });
      var props = _curry22(function props2(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
          out[idx] = obj[ps[idx]];
          idx += 1;
        }
        return out;
      });
      var range = _curry22(function range2(from, to) {
        if (!(_isNumber2(from) && _isNumber2(to))) {
          throw new TypeError("Both arguments to range must be numbers");
        }
        var result = [];
        var n = from;
        while (n < to) {
          result.push(n);
          n += 1;
        }
        return result;
      });
      var reduceRight = _curry32(function reduceRight2(fn, acc, list2) {
        var idx = list2.length - 1;
        while (idx >= 0) {
          acc = fn(acc, list2[idx]);
          idx -= 1;
        }
        return acc;
      });
      var reduced = _curry12(_reduced2);
      var remove2 = _curry32(function remove3(start, count, list2) {
        return _concat2(_slice(list2, 0, Math.min(start, list2.length)), _slice(list2, Math.min(list2.length, start + count)));
      });
      var replace = _curry32(function replace2(regex, replacement, str) {
        return str.replace(regex, replacement);
      });
      var reverse = _curry12(function reverse2(list2) {
        return _isString2(list2) ? list2.split("").reverse().join("") : _slice(list2).reverse();
      });
      var scan = _curry32(function scan2(fn, acc, list2) {
        var idx = 0;
        var len = list2.length;
        var result = [acc];
        while (idx < len) {
          acc = fn(acc, list2[idx]);
          result[idx + 1] = acc;
          idx += 1;
        }
        return result;
      });
      var set = _curry32(function set2(lens2, v, x) {
        return over(lens2, always(v), x);
      });
      var slice2 = _curry32(_checkForMethod2("slice", function slice3(fromIndex, toIndex, list2) {
        return Array.prototype.slice.call(list2, fromIndex, toIndex);
      }));
      var sort = _curry22(function sort2(comparator2, list2) {
        return _slice(list2).sort(comparator2);
      });
      var sortBy = _curry22(function sortBy2(fn, list2) {
        return _slice(list2).sort(function(a, b) {
          var aa = fn(a);
          var bb = fn(b);
          return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
      });
      var splitAt = _curry22(function splitAt2(index2, array) {
        return [
          slice2(0, index2, array),
          slice2(index2, length(array), array)
        ];
      });
      var splitEvery = _curry22(function splitEvery2(n, list2) {
        if (n <= 0) {
          throw new Error("First argument to splitEvery must be a positive integer");
        }
        var result = [];
        var idx = 0;
        while (idx < list2.length) {
          result.push(slice2(idx, idx += n, list2));
        }
        return result;
      });
      var splitWhen = _curry22(function splitWhen2(pred, list2) {
        var idx = 0;
        var len = list2.length;
        var prefix = [];
        while (idx < len && !pred(list2[idx])) {
          prefix.push(list2[idx]);
          idx += 1;
        }
        return [
          prefix,
          _slice(list2, idx)
        ];
      });
      var subtract = _curry22(function subtract2(a, b) {
        return Number(a) - Number(b);
      });
      var tail = _checkForMethod2("tail", slice2(1, Infinity));
      var take = _curry22(_dispatchable2("take", _xtake2, function take2(n, xs) {
        return slice2(0, n < 0 ? Infinity : n, xs);
      }));
      var takeLastWhile = _curry22(function takeLastWhile2(fn, list2) {
        var idx = list2.length - 1;
        while (idx >= 0 && fn(list2[idx])) {
          idx -= 1;
        }
        return _slice(list2, idx + 1, Infinity);
      });
      var takeWhile = _curry22(_dispatchable2("takeWhile", _xtakeWhile2, function takeWhile2(fn, list2) {
        var idx = 0;
        var len = list2.length;
        while (idx < len && fn(list2[idx])) {
          idx += 1;
        }
        return _slice(list2, 0, idx);
      }));
      var tap = _curry22(function tap2(fn, x) {
        fn(x);
        return x;
      });
      var times = _curry22(function times2(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list2;
        if (len < 0 || isNaN(len)) {
          throw new RangeError("n must be a non-negative number");
        }
        list2 = new Array(len);
        while (idx < len) {
          list2[idx] = fn(idx);
          idx += 1;
        }
        return list2;
      });
      var toPairs = _curry12(function toPairs2(obj) {
        var pairs = [];
        for (var prop3 in obj) {
          if (_has2(prop3, obj)) {
            pairs[pairs.length] = [
              prop3,
              obj[prop3]
            ];
          }
        }
        return pairs;
      });
      var toPairsIn = _curry12(function toPairsIn2(obj) {
        var pairs = [];
        for (var prop3 in obj) {
          pairs[pairs.length] = [
            prop3,
            obj[prop3]
          ];
        }
        return pairs;
      });
      var transpose = _curry12(function transpose2(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
          var innerlist = outerlist[i];
          var j = 0;
          while (j < innerlist.length) {
            if (typeof result[j] === "undefined") {
              result[j] = [];
            }
            result[j].push(innerlist[j]);
            j += 1;
          }
          i += 1;
        }
        return result;
      });
      var trim = function() {
        var ws = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        var zeroWidth = "\u200B";
        var hasProtoTrim2 = typeof String.prototype.trim === "function";
        if (!hasProtoTrim2 || (ws.trim() || !zeroWidth.trim())) {
          return _curry12(function trim2(str) {
            var beginRx = new RegExp("^[" + ws + "][" + ws + "]*");
            var endRx = new RegExp("[" + ws + "][" + ws + "]*$");
            return str.replace(beginRx, "").replace(endRx, "");
          });
        } else {
          return _curry12(function trim2(str) {
            return str.trim();
          });
        }
      }();
      var tryCatch = _curry22(function _tryCatch(tryer, catcher) {
        return _arity2(tryer.length, function() {
          try {
            return tryer.apply(this, arguments);
          } catch (e) {
            return catcher.apply(this, _concat2([e], arguments));
          }
        });
      });
      var type3 = _curry12(function type4(val2) {
        return val2 === null ? "Null" : val2 === void 0 ? "Undefined" : Object.prototype.toString.call(val2).slice(8, -1);
      });
      var unapply = _curry12(function unapply2(fn) {
        return function() {
          return fn(_slice(arguments));
        };
      });
      var unary = _curry12(function unary2(fn) {
        return nAry(1, fn);
      });
      var uncurryN = _curry22(function uncurryN2(depth, fn) {
        return curryN3(depth, function() {
          var currentDepth = 1;
          var value2 = fn;
          var idx = 0;
          var endIdx;
          while (currentDepth <= depth && typeof value2 === "function") {
            endIdx = currentDepth === depth ? arguments.length : idx + value2.length;
            value2 = value2.apply(this, _slice(arguments, idx, endIdx));
            currentDepth += 1;
            idx = endIdx;
          }
          return value2;
        });
      });
      var unfold = _curry22(function unfold2(fn, seed) {
        var pair2 = fn(seed);
        var result = [];
        while (pair2 && pair2.length) {
          result[result.length] = pair2[0];
          pair2 = fn(pair2[1]);
        }
        return result;
      });
      var uniqWith = _curry22(function uniqWith2(pred, list2) {
        var idx = 0;
        var len = list2.length;
        var result = [];
        var item;
        while (idx < len) {
          item = list2[idx];
          if (!_containsWith(pred, item, result)) {
            result[result.length] = item;
          }
          idx += 1;
        }
        return result;
      });
      var unless = _curry32(function unless2(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
      });
      var until = _curry32(function until2(pred, fn, init2) {
        var val2 = init2;
        while (!pred(val2)) {
          val2 = fn(val2);
        }
        return val2;
      });
      var update2 = _curry32(function update3(idx, x, list2) {
        return adjust(always(x), idx, list2);
      });
      var useWith = _curry22(function useWith2(fn, transformers) {
        return curryN3(transformers.length, function() {
          var args = [];
          var idx = 0;
          while (idx < transformers.length) {
            args.push(transformers[idx].call(this, arguments[idx]));
            idx += 1;
          }
          return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
      });
      var values3 = _curry12(function values4(obj) {
        var props2 = keys4(obj);
        var len = props2.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
          vals[idx] = obj[props2[idx]];
          idx += 1;
        }
        return vals;
      });
      var valuesIn = _curry12(function valuesIn2(obj) {
        var prop3;
        var vs = [];
        for (prop3 in obj) {
          vs[vs.length] = obj[prop3];
        }
        return vs;
      });
      var view = function() {
        var Const = function(x) {
          return {
            value: x,
            map: function() {
              return this;
            }
          };
        };
        return _curry22(function view2(lens2, x) {
          return lens2(Const)(x).value;
        });
      }();
      var when = _curry32(function when2(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
      });
      var where = _curry22(function where2(spec, testObj) {
        for (var prop3 in spec) {
          if (_has2(prop3, spec) && !spec[prop3](testObj[prop3])) {
            return false;
          }
        }
        return true;
      });
      var wrap2 = _curry22(function wrap3(fn, wrapper) {
        return curryN3(fn.length, function() {
          return wrapper.apply(this, _concat2([fn], arguments));
        });
      });
      var xprod = _curry22(function xprod2(a, b) {
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
          j = 0;
          while (j < jlen) {
            result[result.length] = [
              a[idx],
              b[j]
            ];
            j += 1;
          }
          idx += 1;
        }
        return result;
      });
      var zip = _curry22(function zip2(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = [
            a[idx],
            b[idx]
          ];
          idx += 1;
        }
        return rv;
      });
      var zipObj = _curry22(function zipObj2(keys5, values4) {
        var idx = 0;
        var len = Math.min(keys5.length, values4.length);
        var out = {};
        while (idx < len) {
          out[keys5[idx]] = values4[idx];
          idx += 1;
        }
        return out;
      });
      var zipWith = _curry32(function zipWith2(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = fn(a[idx], b[idx]);
          idx += 1;
        }
        return rv;
      });
      var F = always(false);
      var T = always(true);
      var _clone2 = function _clone3(value2, refFrom, refTo, deep) {
        var copy = function copy2(copiedValue) {
          var len = refFrom.length;
          var idx = 0;
          while (idx < len) {
            if (value2 === refFrom[idx]) {
              return refTo[idx];
            }
            idx += 1;
          }
          refFrom[idx + 1] = value2;
          refTo[idx + 1] = copiedValue;
          for (var key in value2) {
            copiedValue[key] = deep ? _clone3(value2[key], refFrom, refTo, true) : value2[key];
          }
          return copiedValue;
        };
        switch (type3(value2)) {
          case "Object":
            return copy({});
          case "Array":
            return copy([]);
          case "Date":
            return new Date(value2.valueOf());
          case "RegExp":
            return _cloneRegExp2(value2);
          default:
            return value2;
        }
      };
      var _createPartialApplicator2 = function _createPartialApplicator3(concat2) {
        return _curry22(function(fn, args) {
          return _arity2(Math.max(0, fn.length - args.length), function() {
            return fn.apply(this, concat2(args, arguments));
          });
        });
      };
      var _dropLast = function dropLast3(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
      };
      var _equals2 = function _equals3(a, b, stackA, stackB) {
        if (identical(a, b)) {
          return true;
        }
        if (type3(a) !== type3(b)) {
          return false;
        }
        if (a == null || b == null) {
          return false;
        }
        if (typeof a.equals === "function" || typeof b.equals === "function") {
          return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
        }
        switch (type3(a)) {
          case "Arguments":
          case "Array":
          case "Object":
            if (typeof a.constructor === "function" && _functionName2(a.constructor) === "Promise") {
              return a === b;
            }
            break;
          case "Boolean":
          case "Number":
          case "String":
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
              return false;
            }
            break;
          case "Date":
            if (!identical(a.valueOf(), b.valueOf())) {
              return false;
            }
            break;
          case "Error":
            return a.name === b.name && a.message === b.message;
          case "RegExp":
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
              return false;
            }
            break;
          case "Map":
          case "Set":
            if (!_equals3(_arrayFromIterator2(a.entries()), _arrayFromIterator2(b.entries()), stackA, stackB)) {
              return false;
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
            break;
          case "ArrayBuffer":
            break;
          default:
            return false;
        }
        var keysA = keys4(a);
        if (keysA.length !== keys4(b).length) {
          return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
          if (stackA[idx] === a) {
            return stackB[idx] === b;
          }
          idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
          var key = keysA[idx];
          if (!(_has2(key, b) && _equals3(b[key], a[key], stackA, stackB))) {
            return false;
          }
          idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
      };
      var _makeFlat2 = function _makeFlat3(recursive) {
        return function flatt(list2) {
          var value2, jlen, j;
          var result = [];
          var idx = 0;
          var ilen = list2.length;
          while (idx < ilen) {
            if (isArrayLike3(list2[idx])) {
              value2 = recursive ? flatt(list2[idx]) : list2[idx];
              j = 0;
              jlen = value2.length;
              while (j < jlen) {
                result[result.length] = value2[j];
                j += 1;
              }
            } else {
              result[result.length] = list2[idx];
            }
            idx += 1;
          }
          return result;
        };
      };
      var _reduce = function() {
        function _arrayReduce2(xf, acc, list2) {
          var idx = 0;
          var len = list2.length;
          while (idx < len) {
            acc = xf["@@transducer/step"](acc, list2[idx]);
            if (acc && acc["@@transducer/reduced"]) {
              acc = acc["@@transducer/value"];
              break;
            }
            idx += 1;
          }
          return xf["@@transducer/result"](acc);
        }
        function _iterableReduce(xf, acc, iter) {
          var step = iter.next();
          while (!step.done) {
            acc = xf["@@transducer/step"](acc, step.value);
            if (acc && acc["@@transducer/reduced"]) {
              acc = acc["@@transducer/value"];
              break;
            }
            step = iter.next();
          }
          return xf["@@transducer/result"](acc);
        }
        function _methodReduce(xf, acc, obj) {
          return xf["@@transducer/result"](obj.reduce(bind3(xf["@@transducer/step"], xf), acc));
        }
        var symIterator2 = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
        return function _reduce2(fn, acc, list2) {
          if (typeof fn === "function") {
            fn = _xwrap2(fn);
          }
          if (isArrayLike3(list2)) {
            return _arrayReduce2(fn, acc, list2);
          }
          if (typeof list2.reduce === "function") {
            return _methodReduce(fn, acc, list2);
          }
          if (list2[symIterator2] != null) {
            return _iterableReduce(fn, acc, list2[symIterator2]());
          }
          if (typeof list2.next === "function") {
            return _iterableReduce(fn, acc, list2);
          }
          throw new TypeError("reduce: list must be array or iterable");
        };
      }();
      var _stepCat2 = function() {
        var _stepCatArray = {
          "@@transducer/init": Array,
          "@@transducer/step": function(xs, x) {
            xs.push(x);
            return xs;
          },
          "@@transducer/result": _identity2
        };
        var _stepCatString = {
          "@@transducer/init": String,
          "@@transducer/step": function(a, b) {
            return a + b;
          },
          "@@transducer/result": _identity2
        };
        var _stepCatObject = {
          "@@transducer/init": Object,
          "@@transducer/step": function(result, input) {
            return _assign(result, isArrayLike3(input) ? objOf(input[0], input[1]) : input);
          },
          "@@transducer/result": _identity2
        };
        return function _stepCat3(obj) {
          if (_isTransformer2(obj)) {
            return obj;
          }
          if (isArrayLike3(obj)) {
            return _stepCatArray;
          }
          if (typeof obj === "string") {
            return _stepCatString;
          }
          if (typeof obj === "object") {
            return _stepCatObject;
          }
          throw new Error("Cannot create transformer for " + obj);
        };
      }();
      var _xdropLastWhile2 = function() {
        function XDropLastWhile(fn, xf) {
          this.f = fn;
          this.retained = [];
          this.xf = xf;
        }
        XDropLastWhile.prototype["@@transducer/init"] = _xfBase.init;
        XDropLastWhile.prototype["@@transducer/result"] = function(result) {
          this.retained = null;
          return this.xf["@@transducer/result"](result);
        };
        XDropLastWhile.prototype["@@transducer/step"] = function(result, input) {
          return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function(result, input) {
          result = _reduce(this.xf["@@transducer/step"], result, this.retained);
          this.retained = [];
          return this.xf["@@transducer/step"](result, input);
        };
        XDropLastWhile.prototype.retain = function(result, input) {
          this.retained.push(input);
          return result;
        };
        return _curry22(function _xdropLastWhile3(fn, xf) {
          return new XDropLastWhile(fn, xf);
        });
      }();
      var _xgroupBy = function() {
        function XGroupBy(f, xf) {
          this.xf = xf;
          this.f = f;
          this.inputs = {};
        }
        XGroupBy.prototype["@@transducer/init"] = _xfBase.init;
        XGroupBy.prototype["@@transducer/result"] = function(result) {
          var key;
          for (key in this.inputs) {
            if (_has2(key, this.inputs)) {
              result = this.xf["@@transducer/step"](result, this.inputs[key]);
              if (result["@@transducer/reduced"]) {
                result = result["@@transducer/value"];
                break;
              }
            }
          }
          this.inputs = null;
          return this.xf["@@transducer/result"](result);
        };
        XGroupBy.prototype["@@transducer/step"] = function(result, input) {
          var key = this.f(input);
          this.inputs[key] = this.inputs[key] || [
            key,
            []
          ];
          this.inputs[key][1] = append3(input, this.inputs[key][1]);
          return result;
        };
        return _curry22(function _xgroupBy2(f, xf) {
          return new XGroupBy(f, xf);
        });
      }();
      var addIndex = _curry12(function addIndex2(fn) {
        return curryN3(fn.length, function() {
          var idx = 0;
          var origFn = arguments[0];
          var list2 = arguments[arguments.length - 1];
          var args = _slice(arguments);
          args[0] = function() {
            var result = origFn.apply(this, _concat2(arguments, [
              idx,
              list2
            ]));
            idx += 1;
            return result;
          };
          return fn.apply(this, args);
        });
      });
      var binary = _curry12(function binary2(fn) {
        return nAry(2, fn);
      });
      var clone2 = _curry12(function clone3(value2) {
        return value2 != null && typeof value2.clone === "function" ? value2.clone() : _clone2(value2, [], [], true);
      });
      var curry = _curry12(function curry2(fn) {
        return curryN3(fn.length, fn);
      });
      var drop = _curry22(_dispatchable2("drop", _xdrop2, function drop2(n, xs) {
        return slice2(Math.max(0, n), Infinity, xs);
      }));
      var dropLast2 = _curry22(_dispatchable2("dropLast", _xdropLast2, _dropLast));
      var dropLastWhile2 = _curry22(_dispatchable2("dropLastWhile", _xdropLastWhile2, _dropLastWhile));
      var equals3 = _curry22(function equals4(a, b) {
        return _equals2(a, b, [], []);
      });
      var filter4 = _curry22(_dispatchable2("filter", _xfilter2, function(pred, filterable) {
        return _isObject2(filterable) ? _reduce(function(acc, key) {
          if (pred(filterable[key])) {
            acc[key] = filterable[key];
          }
          return acc;
        }, {}, keys4(filterable)) : (
          // else
          _filter2(pred, filterable)
        );
      }));
      var flatten2 = _curry12(_makeFlat2(true));
      var flip = _curry12(function flip2(fn) {
        return curry(function(a, b) {
          var args = _slice(arguments);
          args[0] = b;
          args[1] = a;
          return fn.apply(this, args);
        });
      });
      var head = nth3(0);
      var init = slice2(0, -1);
      var intersectionWith = _curry32(function intersectionWith2(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
          lookupList = list1;
          filteredList = list2;
        } else {
          lookupList = list2;
          filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
          if (_containsWith(pred, filteredList[idx], lookupList)) {
            results[results.length] = filteredList[idx];
          }
          idx += 1;
        }
        return uniqWith(pred, results);
      });
      var into = _curry32(function into2(acc, xf, list2) {
        return _isTransformer2(acc) ? _reduce(xf(acc), acc["@@transducer/init"](), list2) : _reduce(xf(_stepCat2(acc)), _clone2(acc, [], [], false), list2);
      });
      var invert = _curry12(function invert2(obj) {
        var props2 = keys4(obj);
        var len = props2.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props2[idx];
          var val2 = obj[key];
          var list2 = _has2(val2, out) ? out[val2] : out[val2] = [];
          list2[list2.length] = key;
          idx += 1;
        }
        return out;
      });
      var invertObj = _curry12(function invertObj2(obj) {
        var props2 = keys4(obj);
        var len = props2.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props2[idx];
          out[obj[key]] = key;
          idx += 1;
        }
        return out;
      });
      var isEmpty = _curry12(function isEmpty2(x) {
        return x != null && equals3(x, empty2(x));
      });
      var last2 = nth3(-1);
      var lastIndexOf = _curry22(function lastIndexOf2(target, xs) {
        if (typeof xs.lastIndexOf === "function" && !_isArray2(xs)) {
          return xs.lastIndexOf(target);
        } else {
          var idx = xs.length - 1;
          while (idx >= 0) {
            if (equals3(xs[idx], target)) {
              return idx;
            }
            idx -= 1;
          }
          return -1;
        }
      });
      var map4 = _curry22(_dispatchable2("map", _xmap3, function map5(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
          case "[object Function]":
            return curryN3(functor.length, function() {
              return fn.call(this, functor.apply(this, arguments));
            });
          case "[object Object]":
            return _reduce(function(acc, key) {
              acc[key] = fn(functor[key]);
              return acc;
            }, {}, keys4(functor));
          default:
            return _map2(fn, functor);
        }
      }));
      var mapObjIndexed = _curry22(function mapObjIndexed2(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key], key, obj);
          return acc;
        }, {}, keys4(obj));
      });
      var mergeWith = _curry32(function mergeWith2(fn, l, r) {
        return mergeWithKey(function(_, _l, _r) {
          return fn(_l, _r);
        }, l, r);
      });
      var partial2 = _createPartialApplicator2(_concat2);
      var partialRight = _createPartialApplicator2(flip(_concat2));
      var pathEq = _curry32(function pathEq2(_path, val2, obj) {
        return equals3(path3(_path, obj), val2);
      });
      var pluck = _curry22(function pluck2(p, list2) {
        return map4(prop2(p), list2);
      });
      var project = useWith(_map2, [
        pickAll,
        identity
      ]);
      var propEq = _curry32(function propEq2(name, val2, obj) {
        return propSatisfies(equals3(val2), name, obj);
      });
      var propIs = _curry32(function propIs2(type4, name, obj) {
        return propSatisfies(is6(type4), name, obj);
      });
      var reduce = _curry32(_reduce);
      var reduceBy = _curryN2(4, [], function reduceBy2(valueFn, valueAcc, keyFn, list2) {
        return _reduce(function(acc, elt) {
          var key = keyFn(elt);
          acc[key] = valueFn(_has2(key, acc) ? acc[key] : valueAcc, elt);
          return acc;
        }, {}, list2);
      });
      var reject = _curry22(function reject2(pred, filterable) {
        return filter4(_complement2(pred), filterable);
      });
      var repeat = _curry22(function repeat2(value2, n) {
        return times(always(value2), n);
      });
      var sum = reduce(add2, 0);
      var takeLast = _curry22(function takeLast2(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
      });
      var transduce = curryN3(4, function transduce2(xf, fn, acc, list2) {
        return _reduce(xf(typeof fn === "function" ? _xwrap2(fn) : fn), acc, list2);
      });
      var unionWith = _curry32(function unionWith2(pred, list1, list2) {
        return uniqWith(pred, _concat2(list1, list2));
      });
      var whereEq = _curry22(function whereEq2(spec, testObj) {
        return where(map4(equals3, spec), testObj);
      });
      var _flatCat2 = function() {
        var preservingReduced = function(xf) {
          return {
            "@@transducer/init": _xfBase.init,
            "@@transducer/result": function(result) {
              return xf["@@transducer/result"](result);
            },
            "@@transducer/step": function(result, input) {
              var ret = xf["@@transducer/step"](result, input);
              return ret["@@transducer/reduced"] ? _forceReduced2(ret) : ret;
            }
          };
        };
        return function _xcat2(xf) {
          var rxf = preservingReduced(xf);
          return {
            "@@transducer/init": _xfBase.init,
            "@@transducer/result": function(result) {
              return rxf["@@transducer/result"](result);
            },
            "@@transducer/step": function(result, input) {
              return !isArrayLike3(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
            }
          };
        };
      }();
      var _indexOf2 = function _indexOf3(list2, a, idx) {
        var inf, item;
        if (typeof list2.indexOf === "function") {
          switch (typeof a) {
            case "number":
              if (a === 0) {
                inf = 1 / a;
                while (idx < list2.length) {
                  item = list2[idx];
                  if (item === 0 && 1 / item === inf) {
                    return idx;
                  }
                  idx += 1;
                }
                return -1;
              } else if (a !== a) {
                while (idx < list2.length) {
                  item = list2[idx];
                  if (typeof item === "number" && item !== item) {
                    return idx;
                  }
                  idx += 1;
                }
                return -1;
              }
              return list2.indexOf(a, idx);
            case "string":
            case "boolean":
            case "function":
            case "undefined":
              return list2.indexOf(a, idx);
            case "object":
              if (a === null) {
                return list2.indexOf(a, idx);
              }
          }
        }
        while (idx < list2.length) {
          if (equals3(list2[idx], a)) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      };
      var _xchain2 = _curry22(function _xchain3(f, xf) {
        return map4(f, _flatCat2(xf));
      });
      var allPass = _curry12(function allPass2(preds) {
        return curryN3(reduce(max, 0, pluck("length", preds)), function() {
          var idx = 0;
          var len = preds.length;
          while (idx < len) {
            if (!preds[idx].apply(this, arguments)) {
              return false;
            }
            idx += 1;
          }
          return true;
        });
      });
      var allUniq = _curry12(function allUniq2(list2) {
        var len = list2.length;
        var idx = 0;
        while (idx < len) {
          if (_indexOf2(list2, list2[idx], idx + 1) >= 0) {
            return false;
          }
          idx += 1;
        }
        return true;
      });
      var anyPass = _curry12(function anyPass2(preds) {
        return curryN3(reduce(max, 0, pluck("length", preds)), function() {
          var idx = 0;
          var len = preds.length;
          while (idx < len) {
            if (preds[idx].apply(this, arguments)) {
              return true;
            }
            idx += 1;
          }
          return false;
        });
      });
      var ap = _curry22(function ap2(applicative, fn) {
        return typeof applicative.ap === "function" ? applicative.ap(fn) : typeof applicative === "function" ? curryN3(Math.max(applicative.length, fn.length), function() {
          return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : (
          // else
          _reduce(function(acc, f) {
            return _concat2(acc, map4(f, fn));
          }, [], applicative)
        );
      });
      var applySpec = _curry12(function applySpec2(spec) {
        spec = map4(function(v) {
          return typeof v == "function" ? v : applySpec2(v);
        }, spec);
        return curryN3(reduce(max, 0, pluck("length", values3(spec))), function() {
          var args = arguments;
          return map4(function(f) {
            return apply(f, args);
          }, spec);
        });
      });
      var call = curry(function call2(fn) {
        return fn.apply(this, _slice(arguments, 1));
      });
      var chain3 = _curry22(_dispatchable2("chain", _xchain2, function chain4(fn, monad) {
        if (typeof monad === "function") {
          return function() {
            return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
          };
        }
        return _makeFlat2(false)(map4(fn, monad));
      }));
      var cond = _curry12(function cond2(pairs) {
        var arity = reduce(max, 0, map4(function(pair2) {
          return pair2[0].length;
        }, pairs));
        return _arity2(arity, function() {
          var idx = 0;
          while (idx < pairs.length) {
            if (pairs[idx][0].apply(this, arguments)) {
              return pairs[idx][1].apply(this, arguments);
            }
            idx += 1;
          }
        });
      });
      var constructN = _curry22(function constructN2(n, Fn) {
        if (n > 10) {
          throw new Error("Constructor with greater than ten arguments");
        }
        if (n === 0) {
          return function() {
            return new Fn();
          };
        }
        return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
          switch (arguments.length) {
            case 1:
              return new Fn($0);
            case 2:
              return new Fn($0, $1);
            case 3:
              return new Fn($0, $1, $2);
            case 4:
              return new Fn($0, $1, $2, $3);
            case 5:
              return new Fn($0, $1, $2, $3, $4);
            case 6:
              return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
              return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
          }
        }));
      });
      var converge = _curry22(function converge2(after2, fns) {
        return curryN3(reduce(max, 0, pluck("length", fns)), function() {
          var args = arguments;
          var context = this;
          return after2.apply(context, _map2(function(fn) {
            return fn.apply(context, args);
          }, fns));
        });
      });
      var countBy = reduceBy(function(acc, elem) {
        return acc + 1;
      }, 0);
      var dropRepeatsWith = _curry22(_dispatchable2("dropRepeatsWith", _xdropRepeatsWith2, function dropRepeatsWith2(pred, list2) {
        var result = [];
        var idx = 1;
        var len = list2.length;
        if (len !== 0) {
          result[0] = list2[0];
          while (idx < len) {
            if (!pred(last2(result), list2[idx])) {
              result[result.length] = list2[idx];
            }
            idx += 1;
          }
        }
        return result;
      }));
      var eqBy = _curry32(function eqBy2(f, x, y) {
        return equals3(f(x), f(y));
      });
      var eqProps = _curry32(function eqProps2(prop3, obj1, obj2) {
        return equals3(obj1[prop3], obj2[prop3]);
      });
      var groupBy = _curry22(_dispatchable2("groupBy", _xgroupBy, reduceBy(function(acc, item) {
        if (acc == null) {
          acc = [];
        }
        acc.push(item);
        return acc;
      }, null)));
      var indexBy = reduceBy(function(acc, elem) {
        return elem;
      }, null);
      var indexOf = _curry22(function indexOf2(target, xs) {
        return typeof xs.indexOf === "function" && !_isArray2(xs) ? xs.indexOf(target) : _indexOf2(xs, target, 0);
      });
      var juxt = _curry12(function juxt2(fns) {
        return converge(_arrayOf, fns);
      });
      var lens = _curry22(function lens2(getter, setter) {
        return function(toFunctorFn) {
          return function(target) {
            return map4(function(focus) {
              return setter(focus, target);
            }, toFunctorFn(getter(target)));
          };
        };
      });
      var lensIndex = _curry12(function lensIndex2(n) {
        return lens(nth3(n), update2(n));
      });
      var lensPath = _curry12(function lensPath2(p) {
        return lens(path3(p), assocPath3(p));
      });
      var lensProp = _curry12(function lensProp2(k) {
        return lens(prop2(k), assoc3(k));
      });
      var liftN = _curry22(function liftN2(arity, fn) {
        var lifted = curryN3(arity, fn);
        return curryN3(arity, function() {
          return _reduce(ap, map4(lifted, arguments[0]), _slice(arguments, 1));
        });
      });
      var mean = _curry12(function mean2(list2) {
        return sum(list2) / list2.length;
      });
      var median = _curry12(function median2(list2) {
        var len = list2.length;
        if (len === 0) {
          return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list2).sort(function(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
      });
      var partition = juxt([
        filter4,
        reject
      ]);
      var pipe2 = function pipe3() {
        if (arguments.length === 0) {
          throw new Error("pipe requires at least one argument");
        }
        return _arity2(arguments[0].length, reduce(_pipe2, arguments[0], tail(arguments)));
      };
      var pipeP = function pipeP2() {
        if (arguments.length === 0) {
          throw new Error("pipeP requires at least one argument");
        }
        return _arity2(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
      };
      var product = reduce(multiply, 1);
      var sequence = _curry22(function sequence2(of2, traversable) {
        return typeof traversable.sequence === "function" ? traversable.sequence(of2) : reduceRight(function(acc, x) {
          return ap(map4(prepend3, x), acc);
        }, of2([]), traversable);
      });
      var traverse = _curry32(function traverse2(of2, f, traversable) {
        return sequence(of2, map4(f, traversable));
      });
      var unnest = chain3(_identity2);
      var _contains = function _contains2(a, list2) {
        return _indexOf2(list2, a, 0) >= 0;
      };
      var _toString2 = function _toString3(x, seen) {
        var recur = function recur2(y) {
          var xs = seen.concat([x]);
          return _contains(y, xs) ? "<Circular>" : _toString3(y, xs);
        };
        var mapPairs = function(obj, keys5) {
          return _map2(function(k) {
            return _quote2(k) + ": " + recur(obj[k]);
          }, keys5.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
          case "[object Arguments]":
            return "(function() { return arguments; }(" + _map2(recur, x).join(", ") + "))";
          case "[object Array]":
            return "[" + _map2(recur, x).concat(mapPairs(x, reject(function(k) {
              return /^\d+$/.test(k);
            }, keys4(x)))).join(", ") + "]";
          case "[object Boolean]":
            return typeof x === "object" ? "new Boolean(" + recur(x.valueOf()) + ")" : x.toString();
          case "[object Date]":
            return "new Date(" + (isNaN(x.valueOf()) ? recur(NaN) : _quote2(_toISOString4(x))) + ")";
          case "[object Null]":
            return "null";
          case "[object Number]":
            return typeof x === "object" ? "new Number(" + recur(x.valueOf()) + ")" : 1 / x === -Infinity ? "-0" : x.toString(10);
          case "[object String]":
            return typeof x === "object" ? "new String(" + recur(x.valueOf()) + ")" : _quote2(x);
          case "[object Undefined]":
            return "undefined";
          default:
            if (typeof x.toString === "function") {
              var repr = x.toString();
              if (repr !== "[object Object]") {
                return repr;
              }
            }
            return "{" + mapPairs(x, keys4(x)).join(", ") + "}";
        }
      };
      var compose2 = function compose3() {
        if (arguments.length === 0) {
          throw new Error("compose requires at least one argument");
        }
        return pipe2.apply(this, reverse(arguments));
      };
      var composeK = function composeK2() {
        return compose2.apply(this, prepend3(identity, map4(chain3, arguments)));
      };
      var composeP = function composeP2() {
        if (arguments.length === 0) {
          throw new Error("composeP requires at least one argument");
        }
        return pipeP.apply(this, reverse(arguments));
      };
      var construct = _curry12(function construct2(Fn) {
        return constructN(Fn.length, Fn);
      });
      var contains5 = _curry22(_contains);
      var difference = _curry22(function difference2(first2, second) {
        var out = [];
        var idx = 0;
        var firstLen = first2.length;
        while (idx < firstLen) {
          if (!_contains(first2[idx], second) && !_contains(first2[idx], out)) {
            out[out.length] = first2[idx];
          }
          idx += 1;
        }
        return out;
      });
      var dropRepeats = _curry12(_dispatchable2("dropRepeats", _xdropRepeatsWith2(equals3), dropRepeatsWith(equals3)));
      var lift = _curry12(function lift2(fn) {
        return liftN(fn.length, fn);
      });
      var omit = _curry22(function omit2(names, obj) {
        var result = {};
        for (var prop3 in obj) {
          if (!_contains(prop3, names)) {
            result[prop3] = obj[prop3];
          }
        }
        return result;
      });
      var pipeK = function pipeK2() {
        return composeK.apply(this, reverse(arguments));
      };
      var toString3 = _curry12(function toString4(val2) {
        return _toString2(val2, []);
      });
      var without = _curry22(function(xs, list2) {
        return reject(flip(_contains)(xs), list2);
      });
      var _Set = function() {
        function _Set2() {
          this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
          this._items = {};
        }
        _Set2.prototype.add = function(item) {
          return hasOrAdd(item, true, this);
        };
        _Set2.prototype.has = function(item) {
          return hasOrAdd(item, false, this);
        };
        function hasOrAdd(item, shouldAdd, set2) {
          var type4 = typeof item;
          var prevSize, newSize;
          switch (type4) {
            case "string":
            case "number":
              if (item === 0 && !set2._items["-0"] && 1 / item === -Infinity) {
                if (shouldAdd) {
                  set2._items["-0"] = true;
                }
                return shouldAdd;
              }
              if (set2._nativeSet !== null) {
                if (shouldAdd) {
                  prevSize = set2._nativeSet.size;
                  set2._nativeSet.add(item);
                  newSize = set2._nativeSet.size;
                  return newSize > prevSize;
                } else {
                  return set2._nativeSet.has(item);
                }
              } else {
                if (!(type4 in set2._items)) {
                  if (shouldAdd) {
                    set2._items[type4] = {};
                    set2._items[type4][item] = true;
                  }
                  return shouldAdd;
                } else if (item in set2._items[type4]) {
                  return !shouldAdd;
                } else {
                  if (shouldAdd) {
                    set2._items[type4][item] = true;
                  }
                  return shouldAdd;
                }
              }
            case "boolean":
              if (type4 in set2._items) {
                var bIdx = item ? 1 : 0;
                if (set2._items[type4][bIdx]) {
                  return !shouldAdd;
                } else {
                  if (shouldAdd) {
                    set2._items[type4][bIdx] = true;
                  }
                  return shouldAdd;
                }
              } else {
                if (shouldAdd) {
                  set2._items[type4] = item ? [
                    false,
                    true
                  ] : [
                    true,
                    false
                  ];
                }
                return shouldAdd;
              }
            case "function":
              if (set2._nativeSet !== null) {
                if (shouldAdd) {
                  prevSize = set2._nativeSet.size;
                  set2._nativeSet.add(item);
                  newSize = set2._nativeSet.size;
                  return newSize > prevSize;
                } else {
                  return set2._nativeSet.has(item);
                }
              } else {
                if (!(type4 in set2._items)) {
                  if (shouldAdd) {
                    set2._items[type4] = [item];
                  }
                  return shouldAdd;
                }
                if (!_contains(item, set2._items[type4])) {
                  if (shouldAdd) {
                    set2._items[type4].push(item);
                  }
                  return shouldAdd;
                }
              }
              return !shouldAdd;
            case "undefined":
              if (set2._items[type4]) {
                return !shouldAdd;
              } else {
                if (shouldAdd) {
                  set2._items[type4] = true;
                }
                return shouldAdd;
              }
            case "object":
              if (item === null) {
                if (!set2._items["null"]) {
                  if (shouldAdd) {
                    set2._items["null"] = true;
                  }
                  return shouldAdd;
                }
                return !shouldAdd;
              }
            default:
              type4 = Object.prototype.toString.call(item);
              if (!(type4 in set2._items)) {
                if (shouldAdd) {
                  set2._items[type4] = [item];
                }
                return shouldAdd;
              }
              if (!_contains(item, set2._items[type4])) {
                if (shouldAdd) {
                  set2._items[type4].push(item);
                }
                return shouldAdd;
              }
              return !shouldAdd;
          }
        }
        return _Set2;
      }();
      var both = _curry22(function both2(f, g) {
        return _isFunction2(f) ? function _both() {
          return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
      });
      var complement = lift(not2);
      var either = _curry22(function either2(f, g) {
        return _isFunction2(f) ? function _either() {
          return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
      });
      var invoker = _curry22(function invoker2(arity, method) {
        return curryN3(arity + 1, function() {
          var target = arguments[arity];
          if (target != null && is6(Function, target[method])) {
            return target[method].apply(target, _slice(arguments, 0, arity));
          }
          throw new TypeError(toString3(target) + ' does not have a method named "' + method + '"');
        });
      });
      var join = invoker(1, "join");
      var memoize = _curry12(function memoize2(fn) {
        var cache = {};
        return _arity2(fn.length, function() {
          var key = toString3(arguments);
          if (!_has2(key, cache)) {
            cache[key] = fn.apply(this, arguments);
          }
          return cache[key];
        });
      });
      var split = invoker(1, "split");
      var test = _curry22(function test2(pattern, str) {
        if (!_isRegExp2(pattern)) {
          throw new TypeError("\u2018test\u2019 requires a value of type RegExp as its first argument; received " + toString3(pattern));
        }
        return _cloneRegExp2(pattern).test(str);
      });
      var toLower = invoker(0, "toLowerCase");
      var toUpper = invoker(0, "toUpperCase");
      var uniqBy = _curry22(function uniqBy2(fn, list2) {
        var set2 = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list2.length) {
          item = list2[idx];
          appliedItem = fn(item);
          if (set2.add(appliedItem)) {
            result.push(item);
          }
          idx += 1;
        }
        return result;
      });
      var concat = flip(invoker(1, "concat"));
      var symmetricDifference = _curry22(function symmetricDifference2(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
      });
      var symmetricDifferenceWith = _curry32(function symmetricDifferenceWith2(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
      });
      var uniq = uniqBy(identity);
      var intersection = _curry22(function intersection2(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
          lookupList = list1;
          filteredList = list2;
        } else {
          lookupList = list2;
          filteredList = list1;
        }
        return uniq(_filter2(flip(_contains)(lookupList), filteredList));
      });
      var union = _curry22(compose2(uniq, _concat2));
      var R = {
        F,
        T,
        __,
        add: add2,
        addIndex,
        adjust,
        all,
        allPass,
        allUniq,
        always,
        and,
        any,
        anyPass,
        ap,
        aperture,
        append: append3,
        apply,
        applySpec,
        assoc: assoc3,
        assocPath: assocPath3,
        binary,
        bind: bind3,
        both,
        call,
        chain: chain3,
        clamp,
        clone: clone2,
        comparator,
        complement,
        compose: compose2,
        composeK,
        composeP,
        concat,
        cond,
        construct,
        constructN,
        contains: contains5,
        converge,
        countBy,
        curry,
        curryN: curryN3,
        dec,
        defaultTo,
        difference,
        differenceWith,
        dissoc,
        dissocPath,
        divide,
        drop,
        dropLast: dropLast2,
        dropLastWhile: dropLastWhile2,
        dropRepeats,
        dropRepeatsWith,
        dropWhile,
        either,
        empty: empty2,
        eqBy,
        eqProps,
        equals: equals3,
        evolve,
        filter: filter4,
        find: find4,
        findIndex,
        findLast,
        findLastIndex,
        flatten: flatten2,
        flip,
        forEach,
        fromPairs,
        groupBy,
        groupWith,
        gt,
        gte,
        has: has2,
        hasIn,
        head,
        identical,
        identity,
        ifElse,
        inc,
        indexBy,
        indexOf,
        init,
        insert,
        insertAll,
        intersection,
        intersectionWith,
        intersperse,
        into,
        invert,
        invertObj,
        invoker,
        is: is6,
        isArrayLike: isArrayLike3,
        isEmpty,
        isNil: isNil3,
        join,
        juxt,
        keys: keys4,
        keysIn,
        last: last2,
        lastIndexOf,
        length,
        lens,
        lensIndex,
        lensPath,
        lensProp,
        lift,
        liftN,
        lt,
        lte,
        map: map4,
        mapAccum,
        mapAccumRight,
        mapObjIndexed,
        match,
        mathMod,
        max,
        maxBy,
        mean,
        median,
        memoize,
        merge: merge3,
        mergeAll,
        mergeWith,
        mergeWithKey,
        min,
        minBy,
        modulo,
        multiply,
        nAry,
        negate,
        none,
        not: not2,
        nth: nth3,
        nthArg,
        objOf,
        of,
        omit,
        once,
        or,
        over,
        pair,
        partial: partial2,
        partialRight,
        partition,
        path: path3,
        pathEq,
        pathOr,
        pathSatisfies,
        pick,
        pickAll,
        pickBy,
        pipe: pipe2,
        pipeK,
        pipeP,
        pluck,
        prepend: prepend3,
        product,
        project,
        prop: prop2,
        propEq,
        propIs,
        propOr,
        propSatisfies,
        props,
        range,
        reduce,
        reduceBy,
        reduceRight,
        reduced,
        reject,
        remove: remove2,
        repeat,
        replace,
        reverse,
        scan,
        sequence,
        set,
        slice: slice2,
        sort,
        sortBy,
        split,
        splitAt,
        splitEvery,
        splitWhen,
        subtract,
        sum,
        symmetricDifference,
        symmetricDifferenceWith,
        tail,
        take,
        takeLast,
        takeLastWhile,
        takeWhile,
        tap,
        test,
        times,
        toLower,
        toPairs,
        toPairsIn,
        toString: toString3,
        toUpper,
        transduce,
        transpose,
        traverse,
        trim,
        tryCatch,
        type: type3,
        unapply,
        unary,
        uncurryN,
        unfold,
        union,
        unionWith,
        uniq,
        uniqBy,
        uniqWith,
        unless,
        unnest,
        until,
        update: update2,
        useWith,
        values: values3,
        valuesIn,
        view,
        when,
        where,
        whereEq,
        without,
        wrap: wrap2,
        xprod,
        zip,
        zipObj,
        zipWith
      };
      if (typeof exports === "object") {
        module.exports = R;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return R;
        });
      } else {
        this.R = R;
      }
    }).call(exports);
  }
});

// node_modules/memoizee/lib/resolve-length.js
var require_resolve_length2 = __commonJS({
  "node_modules/memoizee/lib/resolve-length.js"(exports, module) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    module.exports = function(optsLength, fnLength, isAsync) {
      var length;
      if (isNaN(optsLength)) {
        length = fnLength;
        if (!(length >= 0))
          return 1;
        if (isAsync && length)
          return length - 1;
        return length;
      }
      if (optsLength === false)
        return false;
      return toPosInt(optsLength);
    };
  }
});

// node_modules/memoizee/lib/registered-extensions.js
var require_registered_extensions2 = __commonJS({
  "node_modules/memoizee/lib/registered-extensions.js"() {
    "use strict";
  }
});

// node_modules/memoizee/node_modules/d/index.js
var require_d2 = __commonJS({
  "node_modules/memoizee/node_modules/d/index.js"(exports, module) {
    "use strict";
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var isCallable = require_is_callable();
    var contains5 = require_contains();
    var d;
    d = module.exports = function(dscr, value2) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value2;
        value2 = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (dscr == null) {
        c = w = true;
        e = false;
      } else {
        c = contains5.call(dscr, "c");
        e = contains5.call(dscr, "e");
        w = contains5.call(dscr, "w");
      }
      desc = { value: value2, configurable: c, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get2, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get2;
        get2 = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (get2 == null) {
        get2 = void 0;
      } else if (!isCallable(get2)) {
        options = get2;
        get2 = set = void 0;
      } else if (set == null) {
        set = void 0;
      } else if (!isCallable(set)) {
        options = set;
        set = void 0;
      }
      if (dscr == null) {
        c = true;
        e = false;
      } else {
        c = contains5.call(dscr, "c");
        e = contains5.call(dscr, "e");
      }
      desc = { get: get2, set, configurable: c, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// node_modules/memoizee/lib/resolve-resolve.js
var require_resolve_resolve2 = __commonJS({
  "node_modules/memoizee/lib/resolve-resolve.js"(exports, module) {
    "use strict";
    var toArray2 = require_to_array();
    var callable = require_valid_callable();
    var slice2 = Array.prototype.slice;
    var resolveArgs;
    resolveArgs = function(args) {
      return this.map(function(r, i) {
        return r ? r(args[i]) : args[i];
      }).concat(slice2.call(args, this.length));
    };
    module.exports = function(resolvers) {
      resolvers = toArray2(resolvers);
      resolvers.forEach(function(r) {
        if (r != null)
          callable(r);
      });
      return resolveArgs.bind(resolvers);
    };
  }
});

// node_modules/memoizee/lib/resolve-normalize.js
var require_resolve_normalize2 = __commonJS({
  "node_modules/memoizee/lib/resolve-normalize.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    module.exports = function(userNormalizer) {
      var normalizer;
      if (typeof userNormalizer === "function")
        return { set: userNormalizer, get: userNormalizer };
      normalizer = { get: callable(userNormalizer.get) };
      if (userNormalizer.set !== void 0) {
        normalizer.set = callable(userNormalizer.set);
        normalizer.delete = callable(userNormalizer.delete);
        normalizer.clear = callable(userNormalizer.clear);
        return normalizer;
      }
      normalizer.set = normalizer.get;
      return normalizer;
    };
  }
});

// node_modules/memoizee/lib/configure-map.js
var require_configure_map2 = __commonJS({
  "node_modules/memoizee/lib/configure-map.js"(exports, module) {
    "use strict";
    var customError = require_custom();
    var defineLength = require_define_length();
    var d = require_d2();
    var ee = require_event_emitter().methods;
    var resolveResolve = require_resolve_resolve2();
    var resolveNormalize = require_resolve_normalize2();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var defineProperties = Object.defineProperties;
    var on = ee.on;
    var emit = ee.emit;
    module.exports = function(original, length, options) {
      var cache = create(null), conf, memLength, get2, set, del, clear, extDel, normalizer, getListeners, setListeners, deleteListeners, memoized2, resolve;
      if (length !== false)
        memLength = length;
      else if (isNaN(original.length))
        memLength = 1;
      else
        memLength = original.length;
      if (options.normalizer) {
        normalizer = resolveNormalize(options.normalizer);
        get2 = normalizer.get;
        set = normalizer.set;
        del = normalizer.delete;
        clear = normalizer.clear;
      }
      if (options.resolvers != null)
        resolve = resolveResolve(options.resolvers);
      if (get2) {
        memoized2 = defineLength(function(arg) {
          var id, result, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get2(args);
          if (id !== null) {
            if (hasOwnProperty2.call(cache, id)) {
              if (getListeners)
                conf.emit("get", id, args, this);
              return cache[id];
            }
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (id === null) {
            id = get2(args);
            if (id !== null)
              throw customError("Circular invocation", "CIRCULAR_INVOCATION");
            id = set(args);
          } else if (hasOwnProperty2.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id);
          return result;
        }, memLength);
      } else if (length === 0) {
        memoized2 = function() {
          var result;
          if (hasOwnProperty2.call(cache, "data")) {
            if (getListeners)
              conf.emit("get", "data", arguments, this);
            return cache.data;
          }
          if (!arguments.length)
            result = call.call(original, this);
          else
            result = apply.call(original, this, arguments);
          if (hasOwnProperty2.call(cache, "data")) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache.data = result;
          if (setListeners)
            conf.emit("set", "data");
          return result;
        };
      } else {
        memoized2 = function(arg) {
          var result, args = arguments, id;
          if (resolve)
            args = resolve(arguments);
          id = String(args[0]);
          if (hasOwnProperty2.call(cache, id)) {
            if (getListeners)
              conf.emit("get", id, args, this);
            return cache[id];
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (hasOwnProperty2.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id);
          return result;
        };
      }
      conf = {
        original,
        memoized: memoized2,
        get: function(args) {
          if (resolve)
            args = resolve(args);
          if (get2)
            return get2(args);
          return String(args[0]);
        },
        has: function(id) {
          return hasOwnProperty2.call(cache, id);
        },
        delete: function(id) {
          var result;
          if (!hasOwnProperty2.call(cache, id))
            return;
          if (del)
            del(id);
          result = cache[id];
          delete cache[id];
          if (deleteListeners)
            conf.emit("delete", id, result);
        },
        clear: function() {
          var oldCache = cache;
          if (clear)
            clear();
          cache = create(null);
          conf.emit("clear", oldCache);
        },
        on: function(type3, listener) {
          if (type3 === "get")
            getListeners = true;
          else if (type3 === "set")
            setListeners = true;
          else if (type3 === "delete")
            deleteListeners = true;
          return on.call(this, type3, listener);
        },
        emit,
        updateEnv: function() {
          original = conf.original;
        }
      };
      if (get2) {
        extDel = defineLength(function(arg) {
          var id, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get2(args);
          if (id === null)
            return;
          conf.delete(id);
        }, memLength);
      } else if (length === 0) {
        extDel = function() {
          return conf.delete("data");
        };
      } else {
        extDel = function(arg) {
          if (resolve)
            arg = resolve(arguments)[0];
          return conf.delete(arg);
        };
      }
      defineProperties(memoized2, {
        __memoized__: d(true),
        delete: d(extDel),
        clear: d(conf.clear)
      });
      return conf;
    };
  }
});

// node_modules/memoizee/plain.js
var require_plain2 = __commonJS({
  "node_modules/memoizee/plain.js"(exports, module) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions2();
    var configure = require_configure_map2();
    var resolveLength = require_resolve_length2();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module.exports = function self2(fn) {
      var options, length, conf;
      callable(fn);
      options = Object(arguments[1]);
      if (hasOwnProperty2.call(fn, "__memoized__") && !options.force)
        return fn;
      length = resolveLength(options.length, fn.length, options.async && extensions.async);
      conf = configure(fn, length, options);
      forEach(extensions, function(fn2, name) {
        if (options[name])
          fn2(options[name], conf, options);
      });
      if (self2.__profiler__)
        self2.__profiler__(conf);
      conf.updateEnv();
      return conf.memoized;
    };
  }
});

// node_modules/memoizee/normalizers/primitive.js
var require_primitive2 = __commonJS({
  "node_modules/memoizee/normalizers/primitive.js"(exports, module) {
    "use strict";
    module.exports = function(args) {
      var id, i, length = args.length;
      if (!length)
        return "";
      id = String(args[i = 0]);
      while (--length)
        id += "" + args[++i];
      return id;
    };
  }
});

// node_modules/memoizee/normalizers/get-primitive-fixed.js
var require_get_primitive_fixed2 = __commonJS({
  "node_modules/memoizee/normalizers/get-primitive-fixed.js"(exports, module) {
    "use strict";
    module.exports = function(length) {
      if (!length) {
        return function() {
          return "";
        };
      }
      return function(args) {
        var id = String(args[0]), i = 0, l = length;
        while (--l) {
          id += "" + args[++i];
        }
        return id;
      };
    };
  }
});

// node_modules/memoizee/normalizers/get.js
var require_get2 = __commonJS({
  "node_modules/memoizee/normalizers/get.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module.exports = function() {
      var lastId = 0, map4 = [], cache = create(null);
      return {
        get: function(args) {
          var index2 = 0, set = map4, i, length = args.length;
          if (length === 0)
            return set[length] || null;
          if (set = set[length]) {
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1)
                return null;
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1)
              return null;
            return set[1][i] || null;
          }
          return null;
        },
        set: function(args) {
          var index2 = 0, set = map4, i, length = args.length;
          if (length === 0) {
            set[length] = ++lastId;
          } else {
            if (!set[length]) {
              set[length] = [[], []];
            }
            set = set[length];
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1) {
                i = set[0].push(args[index2]) - 1;
                set[1].push([[], []]);
              }
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              i = set[0].push(args[index2]) - 1;
            }
            set[1][i] = ++lastId;
          }
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index2 = 0, set = map4, i, args = cache[id], length = args.length, path3 = [];
          if (length === 0) {
            delete set[length];
          } else if (set = set[length]) {
            while (index2 < length - 1) {
              i = indexOf.call(set[0], args[index2]);
              if (i === -1) {
                return;
              }
              path3.push(set, i);
              set = set[1][i];
              ++index2;
            }
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              return;
            }
            id = set[1][i];
            set[0].splice(i, 1);
            set[1].splice(i, 1);
            while (!set[0].length && path3.length) {
              i = path3.pop();
              set = path3.pop();
              set[0].splice(i, 1);
              set[1].splice(i, 1);
            }
          }
          delete cache[id];
        },
        clear: function() {
          map4 = [];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/memoizee/normalizers/get-1.js
var require_get_12 = __commonJS({
  "node_modules/memoizee/normalizers/get-1.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    module.exports = function() {
      var lastId = 0, argsMap = [], cache = [];
      return {
        get: function(args) {
          var index2 = indexOf.call(argsMap, args[0]);
          return index2 === -1 ? null : cache[index2];
        },
        set: function(args) {
          argsMap.push(args[0]);
          cache.push(++lastId);
          return lastId;
        },
        delete: function(id) {
          var index2 = indexOf.call(cache, id);
          if (index2 !== -1) {
            argsMap.splice(index2, 1);
            cache.splice(index2, 1);
          }
        },
        clear: function() {
          argsMap = [];
          cache = [];
        }
      };
    };
  }
});

// node_modules/memoizee/normalizers/get-fixed.js
var require_get_fixed2 = __commonJS({
  "node_modules/memoizee/normalizers/get-fixed.js"(exports, module) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module.exports = function(length) {
      var lastId = 0, map4 = [[], []], cache = create(null);
      return {
        get: function(args) {
          var index2 = 0, set = map4, i;
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1)
              return null;
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1)
            return null;
          return set[1][i] || null;
        },
        set: function(args) {
          var index2 = 0, set = map4, i;
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              i = set[0].push(args[index2]) - 1;
              set[1].push([[], []]);
            }
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1) {
            i = set[0].push(args[index2]) - 1;
          }
          set[1][i] = ++lastId;
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index2 = 0, set = map4, i, path3 = [], args = cache[id];
          while (index2 < length - 1) {
            i = indexOf.call(set[0], args[index2]);
            if (i === -1) {
              return;
            }
            path3.push(set, i);
            set = set[1][i];
            ++index2;
          }
          i = indexOf.call(set[0], args[index2]);
          if (i === -1) {
            return;
          }
          id = set[1][i];
          set[0].splice(i, 1);
          set[1].splice(i, 1);
          while (!set[0].length && path3.length) {
            i = path3.pop();
            set = path3.pop();
            set[0].splice(i, 1);
            set[1].splice(i, 1);
          }
          delete cache[id];
        },
        clear: function() {
          map4 = [[], []];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/memoizee/node_modules/next-tick/index.js
var require_next_tick2 = __commonJS({
  "node_modules/memoizee/node_modules/next-tick/index.js"(exports, module) {
    "use strict";
    var callable;
    var byObserver;
    callable = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
    byObserver = function(Observer) {
      var node = document.createTextNode(""), queue, i = 0;
      new Observer(function() {
        var data3;
        if (!queue)
          return;
        data3 = queue;
        queue = null;
        if (typeof data3 === "function") {
          data3();
          return;
        }
        data3.forEach(function(fn) {
          fn();
        });
      }).observe(node, { characterData: true });
      return function(fn) {
        callable(fn);
        if (queue) {
          if (typeof queue === "function")
            queue = [queue, fn];
          else
            queue.push(fn);
          return;
        }
        queue = fn;
        node.data = i = ++i % 2;
      };
    };
    module.exports = function() {
      if (typeof process !== "undefined" && process && typeof process.nextTick === "function") {
        return process.nextTick;
      }
      if (typeof document === "object" && document) {
        if (typeof MutationObserver === "function") {
          return byObserver(MutationObserver);
        }
        if (typeof WebKitMutationObserver === "function") {
          return byObserver(WebKitMutationObserver);
        }
      }
      if (typeof setImmediate === "function") {
        return function(cb) {
          setImmediate(callable(cb));
        };
      }
      if (typeof setTimeout === "function") {
        return function(cb) {
          setTimeout(callable(cb), 0);
        };
      }
      return null;
    }();
  }
});

// node_modules/memoizee/ext/async.js
var require_async2 = __commonJS({
  "node_modules/memoizee/ext/async.js"() {
    "use strict";
    var aFrom = require_from();
    var mixin = require_mixin();
    var defineLength = require_define_length();
    var nextTick = require_next_tick2();
    var slice2 = Array.prototype.slice;
    var apply = Function.prototype.apply;
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    require_registered_extensions2().async = function(tbi, conf) {
      var waiting = create(null), cache = create(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
      conf.memoized = defineLength(function(arg) {
        var args = arguments, last2 = args[args.length - 1];
        if (typeof last2 === "function") {
          currentCallback = last2;
          args = slice2.call(args, 0, -1);
        }
        return base.apply(currentContext = this, currentArgs = args);
      }, base);
      try {
        mixin(conf.memoized, base);
      } catch (ignore) {
      }
      conf.on("get", function(id) {
        var cb, context, args;
        if (!currentCallback)
          return;
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback];
          else
            waiting[id].push(currentCallback);
          currentCallback = null;
          return;
        }
        cb = currentCallback;
        context = currentContext;
        args = currentArgs;
        currentCallback = currentContext = currentArgs = null;
        nextTick(function() {
          var data3;
          if (hasOwnProperty2.call(cache, id)) {
            data3 = cache[id];
            conf.emit("getasync", id, args, context);
            apply.call(cb, data3.context, data3.args);
          } else {
            currentCallback = cb;
            currentContext = context;
            currentArgs = args;
            base.apply(context, args);
          }
        });
      });
      conf.original = function() {
        var args, cb, origCb, result;
        if (!currentCallback)
          return apply.call(original, this, arguments);
        args = aFrom(arguments);
        cb = function self2(err) {
          var cb2, args2, id = self2.id;
          if (id == null) {
            nextTick(apply.bind(self2, this, arguments));
            return;
          }
          delete self2.id;
          cb2 = waiting[id];
          delete waiting[id];
          if (!cb2) {
            return;
          }
          args2 = aFrom(arguments);
          if (conf.has(id)) {
            if (err) {
              conf.delete(id);
            } else {
              cache[id] = { context: this, args: args2 };
              conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
            }
          }
          if (typeof cb2 === "function") {
            result = apply.call(cb2, this, args2);
          } else {
            cb2.forEach(function(cb3) {
              result = apply.call(cb3, this, args2);
            }, this);
          }
          return result;
        };
        origCb = currentCallback;
        currentCallback = currentContext = currentArgs = null;
        args.push(cb);
        result = apply.call(original, this, args);
        cb.cb = origCb;
        currentCallback = cb;
        return result;
      };
      conf.on("set", function(id) {
        if (!currentCallback) {
          conf.delete(id);
          return;
        }
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback.cb];
          else
            waiting[id].push(currentCallback.cb);
        } else {
          waiting[id] = currentCallback.cb;
        }
        delete currentCallback.cb;
        currentCallback.id = id;
        currentCallback = null;
      });
      conf.on("delete", function(id) {
        var result;
        if (hasOwnProperty2.call(waiting, id))
          return;
        if (!cache[id])
          return;
        result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, result);
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        conf.emit("clearasync", oldCache);
      });
    };
  }
});

// node_modules/memoizee/ext/dispose.js
var require_dispose2 = __commonJS({
  "node_modules/memoizee/ext/dispose.js"() {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions2();
    var slice2 = Array.prototype.slice;
    var apply = Function.prototype.apply;
    extensions.dispose = function(dispose, conf, options) {
      var del;
      callable(dispose);
      if (options.async && extensions.async) {
        conf.on("deleteasync", del = function(id, result) {
          apply.call(dispose, null, slice2.call(result.args, 1));
        });
        conf.on("clearasync", function(cache) {
          forEach(cache, function(result, id) {
            del(id, result);
          });
        });
        return;
      }
      conf.on("delete", del = function(id, result) {
        dispose(result);
      });
      conf.on("clear", function(cache) {
        forEach(cache, function(result, id) {
          del(id, result);
        });
      });
    };
  }
});

// node_modules/memoizee/ext/max-age.js
var require_max_age2 = __commonJS({
  "node_modules/memoizee/ext/max-age.js"() {
    "use strict";
    var aFrom = require_from();
    var noop = require_noop();
    var forEach = require_for_each();
    var timeout = require_valid_timeout();
    var extensions = require_registered_extensions2();
    var max = Math.max;
    var min = Math.min;
    var create = Object.create;
    extensions.maxAge = function(maxAge, conf, options) {
      var timeouts, postfix, preFetchAge, preFetchTimeouts;
      maxAge = timeout(maxAge);
      if (!maxAge)
        return;
      timeouts = create(null);
      postfix = options.async && extensions.async ? "async" : "";
      conf.on("set" + postfix, function(id) {
        timeouts[id] = setTimeout(function() {
          conf.delete(id);
        }, maxAge);
        if (!preFetchTimeouts)
          return;
        if (preFetchTimeouts[id])
          clearTimeout(preFetchTimeouts[id]);
        preFetchTimeouts[id] = setTimeout(function() {
          delete preFetchTimeouts[id];
        }, preFetchAge);
      });
      conf.on("delete" + postfix, function(id) {
        clearTimeout(timeouts[id]);
        delete timeouts[id];
        if (!preFetchTimeouts)
          return;
        clearTimeout(preFetchTimeouts[id]);
        delete preFetchTimeouts[id];
      });
      if (options.preFetch) {
        if (options.preFetch === true || isNaN(options.preFetch)) {
          preFetchAge = 0.333;
        } else {
          preFetchAge = max(min(Number(options.preFetch), 1), 0);
        }
        if (preFetchAge) {
          preFetchTimeouts = {};
          preFetchAge = (1 - preFetchAge) * maxAge;
          conf.on("get" + postfix, function(id, args, context) {
            if (!preFetchTimeouts[id]) {
              preFetchTimeouts[id] = setTimeout(function() {
                delete preFetchTimeouts[id];
                conf.delete(id);
                if (options.async) {
                  args = aFrom(args);
                  args.push(noop);
                }
                conf.memoized.apply(context, args);
              }, 0);
            }
          });
        }
      }
      conf.on("clear" + postfix, function() {
        forEach(timeouts, function(id) {
          clearTimeout(id);
        });
        timeouts = {};
        if (preFetchTimeouts) {
          forEach(preFetchTimeouts, function(id) {
            clearTimeout(id);
          });
          preFetchTimeouts = {};
        }
      });
    };
  }
});

// node_modules/memoizee/ext/max.js
var require_max2 = __commonJS({
  "node_modules/memoizee/ext/max.js"() {
    "use strict";
    var toPosInteger = require_to_pos_integer();
    var lruQueue = require_lru_queue();
    var extensions = require_registered_extensions2();
    extensions.max = function(max, conf, options) {
      var postfix, queue, hit;
      max = toPosInteger(max);
      if (!max)
        return;
      queue = lruQueue(max);
      postfix = options.async && extensions.async ? "async" : "";
      conf.on("set" + postfix, hit = function(id) {
        id = queue.hit(id);
        if (id === void 0)
          return;
        conf.delete(id);
      });
      conf.on("get" + postfix, hit);
      conf.on("delete" + postfix, queue.delete);
      conf.on("clear" + postfix, queue.clear);
    };
  }
});

// node_modules/memoizee/ext/ref-counter.js
var require_ref_counter2 = __commonJS({
  "node_modules/memoizee/ext/ref-counter.js"() {
    "use strict";
    var d = require_d2();
    var extensions = require_registered_extensions2();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    extensions.refCounter = function(ignore, conf, options) {
      var cache, postfix;
      cache = create(null);
      postfix = options.async && extensions.async ? "async" : "";
      conf.on("set" + postfix, function(id, length) {
        cache[id] = length || 1;
      });
      conf.on("get" + postfix, function(id) {
        ++cache[id];
      });
      conf.on("delete" + postfix, function(id) {
        delete cache[id];
      });
      conf.on("clear" + postfix, function() {
        cache = {};
      });
      defineProperties(conf.memoized, {
        deleteRef: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return null;
          if (!cache[id])
            return null;
          if (!--cache[id]) {
            conf.delete(id);
            return true;
          }
          return false;
        }),
        getRefCount: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return 0;
          if (!cache[id])
            return 0;
          return cache[id];
        })
      });
    };
  }
});

// node_modules/memoizee/index.js
var require_memoizee2 = __commonJS({
  "node_modules/memoizee/index.js"(exports, module) {
    "use strict";
    var normalizeOpts = require_normalize_options();
    var resolveLength = require_resolve_length2();
    var plain = require_plain2();
    module.exports = function(fn) {
      var options = normalizeOpts(arguments[1]), length;
      if (!options.normalizer) {
        length = options.length = resolveLength(options.length, fn.length, options.async);
        if (length !== 0) {
          if (options.primitive) {
            if (length === false) {
              options.normalizer = require_primitive2();
            } else if (length > 1) {
              options.normalizer = require_get_primitive_fixed2()(length);
            }
          } else {
            if (length === false)
              options.normalizer = require_get2()();
            else if (length === 1)
              options.normalizer = require_get_12()();
            else
              options.normalizer = require_get_fixed2()(length);
          }
        }
      }
      if (options.async)
        require_async2();
      if (options.dispose)
        require_dispose2();
      if (options.maxAge)
        require_max_age2();
      if (options.max)
        require_max2();
      if (options.refCounter)
        require_ref_counter2();
      return plain(fn, options);
    };
  }
});

// node_modules/app-store-scraper/lib/constants.js
var require_constants = __commonJS({
  "node_modules/app-store-scraper/lib/constants.js"(exports, module) {
    "use strict";
    var collection = {
      TOP_MAC: "topmacapps",
      TOP_FREE_MAC: "topfreemacapps",
      TOP_GROSSING_MAC: "topgrossingmacapps",
      TOP_PAID_MAC: "toppaidmacapps",
      NEW_IOS: "newapplications",
      NEW_FREE_IOS: "newfreeapplications",
      NEW_PAID_IOS: "newpaidapplications",
      TOP_FREE_IOS: "topfreeapplications",
      TOP_FREE_IPAD: "topfreeipadapplications",
      TOP_GROSSING_IOS: "topgrossingapplications",
      TOP_GROSSING_IPAD: "topgrossingipadapplications",
      TOP_PAID_IOS: "toppaidapplications",
      TOP_PAID_IPAD: "toppaidipadapplications"
    };
    var category = {
      BOOKS: 6018,
      BUSINESS: 6e3,
      CATALOGS: 6022,
      EDUCATION: 6017,
      ENTERTAINMENT: 6016,
      FINANCE: 6015,
      FOOD_AND_DRINK: 6023,
      GAMES: 6014,
      GAMES_ACTION: 7001,
      GAMES_ADVENTURE: 7002,
      GAMES_ARCADE: 7003,
      GAMES_BOARD: 7004,
      GAMES_CARD: 7005,
      GAMES_CASINO: 7006,
      GAMES_DICE: 7007,
      GAMES_EDUCATIONAL: 7008,
      GAMES_FAMILY: 7009,
      GAMES_MUSIC: 7011,
      GAMES_PUZZLE: 7012,
      GAMES_RACING: 7013,
      GAMES_ROLE_PLAYING: 7014,
      GAMES_SIMULATION: 7015,
      GAMES_SPORTS: 7016,
      GAMES_STRATEGY: 7017,
      GAMES_TRIVIA: 7018,
      GAMES_WORD: 7019,
      HEALTH_AND_FITNESS: 6013,
      LIFESTYLE: 6012,
      MAGAZINES_AND_NEWSPAPERS: 6021,
      MAGAZINES_ARTS: 13007,
      MAGAZINES_AUTOMOTIVE: 13006,
      MAGAZINES_WEDDINGS: 13008,
      MAGAZINES_BUSINESS: 13009,
      MAGAZINES_CHILDREN: 13010,
      MAGAZINES_COMPUTER: 13011,
      MAGAZINES_FOOD: 13012,
      MAGAZINES_CRAFTS: 13013,
      MAGAZINES_ELECTRONICS: 13014,
      MAGAZINES_ENTERTAINMENT: 13015,
      MAGAZINES_FASHION: 13002,
      MAGAZINES_HEALTH: 13017,
      MAGAZINES_HISTORY: 13018,
      MAGAZINES_HOME: 13003,
      MAGAZINES_LITERARY: 13019,
      MAGAZINES_MEN: 13020,
      MAGAZINES_MOVIES_AND_MUSIC: 13021,
      MAGAZINES_POLITICS: 13001,
      MAGAZINES_OUTDOORS: 13004,
      MAGAZINES_FAMILY: 13023,
      MAGAZINES_PETS: 13024,
      MAGAZINES_PROFESSIONAL: 13025,
      MAGAZINES_REGIONAL: 13026,
      MAGAZINES_SCIENCE: 13027,
      MAGAZINES_SPORTS: 13005,
      MAGAZINES_TEENS: 13028,
      MAGAZINES_TRAVEL: 13029,
      MAGAZINES_WOMEN: 13030,
      MEDICAL: 6020,
      MUSIC: 6011,
      NAVIGATION: 6010,
      NEWS: 6009,
      PHOTO_AND_VIDEO: 6008,
      PRODUCTIVITY: 6007,
      REFERENCE: 6006,
      SHOPPING: 6024,
      SOCIAL_NETWORKING: 6005,
      SPORTS: 6004,
      TRAVEL: 6003,
      UTILITIES: 6002,
      WEATHER: 6001
    };
    var device = {
      IPAD: "iPadSoftware",
      MAC: "macSoftware",
      ALL: "software"
    };
    var sort = {
      RECENT: "mostRecent",
      HELPFUL: "mostHelpful"
    };
    var markets = {
      DZ: 143563,
      AO: 143564,
      AI: 143538,
      AR: 143505,
      AM: 143524,
      AU: 143460,
      AT: 143445,
      AZ: 143568,
      BH: 143559,
      BB: 143541,
      BY: 143565,
      BE: 143446,
      BZ: 143555,
      BM: 143542,
      BO: 143556,
      BW: 143525,
      BR: 143503,
      VG: 143543,
      BN: 143560,
      BG: 143526,
      CA: 143455,
      KY: 143544,
      CL: 143483,
      CN: 143465,
      CO: 143501,
      CR: 143495,
      HR: 143494,
      CY: 143557,
      CZ: 143489,
      DK: 143458,
      DM: 143545,
      EC: 143509,
      EG: 143516,
      SV: 143506,
      EE: 143518,
      FI: 143447,
      FR: 143442,
      DE: 143443,
      GB: 143444,
      GH: 143573,
      GR: 143448,
      GD: 143546,
      GT: 143504,
      GY: 143553,
      HN: 143510,
      HK: 143463,
      HU: 143482,
      IS: 143558,
      IN: 143467,
      ID: 143476,
      IE: 143449,
      IL: 143491,
      IT: 143450,
      JM: 143511,
      JP: 143462,
      JO: 143528,
      KE: 143529,
      KW: 143493,
      LV: 143519,
      LB: 143497,
      LT: 143520,
      LU: 143451,
      MO: 143515,
      MK: 143530,
      MG: 143531,
      MY: 143473,
      ML: 143532,
      MT: 143521,
      MU: 143533,
      MX: 143468,
      MS: 143547,
      NP: 143484,
      NL: 143452,
      NZ: 143461,
      NI: 143512,
      NE: 143534,
      NG: 143561,
      NO: 143457,
      OM: 143562,
      PK: 143477,
      PA: 143485,
      PY: 143513,
      PE: 143507,
      PH: 143474,
      PL: 143478,
      PT: 143453,
      QA: 143498,
      RO: 143487,
      RU: 143469,
      SA: 143479,
      SN: 143535,
      SG: 143464,
      SK: 143496,
      SI: 143499,
      ZA: 143472,
      ES: 143454,
      LK: 143486,
      SR: 143554,
      SE: 143456,
      CH: 143459,
      TW: 143470,
      TZ: 143572,
      TH: 143475,
      TN: 143536,
      TR: 143480,
      UG: 143537,
      UA: 143492,
      AE: 143481,
      US: 143441,
      UY: 143514,
      UZ: 143566,
      VE: 143502,
      VN: 143471,
      YE: 143571
    };
    module.exports = { collection, category, device, sort, markets };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn2.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn2.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn2.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/psl/data/rules.json
var require_rules = __commonJS({
  "node_modules/psl/data/rules.json"(exports, module) {
    module.exports = [
      "ac",
      "com.ac",
      "edu.ac",
      "gov.ac",
      "net.ac",
      "mil.ac",
      "org.ac",
      "ad",
      "nom.ad",
      "ae",
      "co.ae",
      "net.ae",
      "org.ae",
      "sch.ae",
      "ac.ae",
      "gov.ae",
      "mil.ae",
      "aero",
      "accident-investigation.aero",
      "accident-prevention.aero",
      "aerobatic.aero",
      "aeroclub.aero",
      "aerodrome.aero",
      "agents.aero",
      "aircraft.aero",
      "airline.aero",
      "airport.aero",
      "air-surveillance.aero",
      "airtraffic.aero",
      "air-traffic-control.aero",
      "ambulance.aero",
      "amusement.aero",
      "association.aero",
      "author.aero",
      "ballooning.aero",
      "broker.aero",
      "caa.aero",
      "cargo.aero",
      "catering.aero",
      "certification.aero",
      "championship.aero",
      "charter.aero",
      "civilaviation.aero",
      "club.aero",
      "conference.aero",
      "consultant.aero",
      "consulting.aero",
      "control.aero",
      "council.aero",
      "crew.aero",
      "design.aero",
      "dgca.aero",
      "educator.aero",
      "emergency.aero",
      "engine.aero",
      "engineer.aero",
      "entertainment.aero",
      "equipment.aero",
      "exchange.aero",
      "express.aero",
      "federation.aero",
      "flight.aero",
      "fuel.aero",
      "gliding.aero",
      "government.aero",
      "groundhandling.aero",
      "group.aero",
      "hanggliding.aero",
      "homebuilt.aero",
      "insurance.aero",
      "journal.aero",
      "journalist.aero",
      "leasing.aero",
      "logistics.aero",
      "magazine.aero",
      "maintenance.aero",
      "media.aero",
      "microlight.aero",
      "modelling.aero",
      "navigation.aero",
      "parachuting.aero",
      "paragliding.aero",
      "passenger-association.aero",
      "pilot.aero",
      "press.aero",
      "production.aero",
      "recreation.aero",
      "repbody.aero",
      "res.aero",
      "research.aero",
      "rotorcraft.aero",
      "safety.aero",
      "scientist.aero",
      "services.aero",
      "show.aero",
      "skydiving.aero",
      "software.aero",
      "student.aero",
      "trader.aero",
      "trading.aero",
      "trainer.aero",
      "union.aero",
      "workinggroup.aero",
      "works.aero",
      "af",
      "gov.af",
      "com.af",
      "org.af",
      "net.af",
      "edu.af",
      "ag",
      "com.ag",
      "org.ag",
      "net.ag",
      "co.ag",
      "nom.ag",
      "ai",
      "off.ai",
      "com.ai",
      "net.ai",
      "org.ai",
      "al",
      "com.al",
      "edu.al",
      "gov.al",
      "mil.al",
      "net.al",
      "org.al",
      "am",
      "co.am",
      "com.am",
      "commune.am",
      "net.am",
      "org.am",
      "ao",
      "ed.ao",
      "gv.ao",
      "og.ao",
      "co.ao",
      "pb.ao",
      "it.ao",
      "aq",
      "ar",
      "bet.ar",
      "com.ar",
      "coop.ar",
      "edu.ar",
      "gob.ar",
      "gov.ar",
      "int.ar",
      "mil.ar",
      "musica.ar",
      "mutual.ar",
      "net.ar",
      "org.ar",
      "senasa.ar",
      "tur.ar",
      "arpa",
      "e164.arpa",
      "in-addr.arpa",
      "ip6.arpa",
      "iris.arpa",
      "uri.arpa",
      "urn.arpa",
      "as",
      "gov.as",
      "asia",
      "at",
      "ac.at",
      "co.at",
      "gv.at",
      "or.at",
      "sth.ac.at",
      "au",
      "com.au",
      "net.au",
      "org.au",
      "edu.au",
      "gov.au",
      "asn.au",
      "id.au",
      "info.au",
      "conf.au",
      "oz.au",
      "act.au",
      "nsw.au",
      "nt.au",
      "qld.au",
      "sa.au",
      "tas.au",
      "vic.au",
      "wa.au",
      "act.edu.au",
      "catholic.edu.au",
      "nsw.edu.au",
      "nt.edu.au",
      "qld.edu.au",
      "sa.edu.au",
      "tas.edu.au",
      "vic.edu.au",
      "wa.edu.au",
      "qld.gov.au",
      "sa.gov.au",
      "tas.gov.au",
      "vic.gov.au",
      "wa.gov.au",
      "schools.nsw.edu.au",
      "aw",
      "com.aw",
      "ax",
      "az",
      "com.az",
      "net.az",
      "int.az",
      "gov.az",
      "org.az",
      "edu.az",
      "info.az",
      "pp.az",
      "mil.az",
      "name.az",
      "pro.az",
      "biz.az",
      "ba",
      "com.ba",
      "edu.ba",
      "gov.ba",
      "mil.ba",
      "net.ba",
      "org.ba",
      "bb",
      "biz.bb",
      "co.bb",
      "com.bb",
      "edu.bb",
      "gov.bb",
      "info.bb",
      "net.bb",
      "org.bb",
      "store.bb",
      "tv.bb",
      "*.bd",
      "be",
      "ac.be",
      "bf",
      "gov.bf",
      "bg",
      "a.bg",
      "b.bg",
      "c.bg",
      "d.bg",
      "e.bg",
      "f.bg",
      "g.bg",
      "h.bg",
      "i.bg",
      "j.bg",
      "k.bg",
      "l.bg",
      "m.bg",
      "n.bg",
      "o.bg",
      "p.bg",
      "q.bg",
      "r.bg",
      "s.bg",
      "t.bg",
      "u.bg",
      "v.bg",
      "w.bg",
      "x.bg",
      "y.bg",
      "z.bg",
      "0.bg",
      "1.bg",
      "2.bg",
      "3.bg",
      "4.bg",
      "5.bg",
      "6.bg",
      "7.bg",
      "8.bg",
      "9.bg",
      "bh",
      "com.bh",
      "edu.bh",
      "net.bh",
      "org.bh",
      "gov.bh",
      "bi",
      "co.bi",
      "com.bi",
      "edu.bi",
      "or.bi",
      "org.bi",
      "biz",
      "bj",
      "asso.bj",
      "barreau.bj",
      "gouv.bj",
      "bm",
      "com.bm",
      "edu.bm",
      "gov.bm",
      "net.bm",
      "org.bm",
      "bn",
      "com.bn",
      "edu.bn",
      "gov.bn",
      "net.bn",
      "org.bn",
      "bo",
      "com.bo",
      "edu.bo",
      "gob.bo",
      "int.bo",
      "org.bo",
      "net.bo",
      "mil.bo",
      "tv.bo",
      "web.bo",
      "academia.bo",
      "agro.bo",
      "arte.bo",
      "blog.bo",
      "bolivia.bo",
      "ciencia.bo",
      "cooperativa.bo",
      "democracia.bo",
      "deporte.bo",
      "ecologia.bo",
      "economia.bo",
      "empresa.bo",
      "indigena.bo",
      "industria.bo",
      "info.bo",
      "medicina.bo",
      "movimiento.bo",
      "musica.bo",
      "natural.bo",
      "nombre.bo",
      "noticias.bo",
      "patria.bo",
      "politica.bo",
      "profesional.bo",
      "plurinacional.bo",
      "pueblo.bo",
      "revista.bo",
      "salud.bo",
      "tecnologia.bo",
      "tksat.bo",
      "transporte.bo",
      "wiki.bo",
      "br",
      "9guacu.br",
      "abc.br",
      "adm.br",
      "adv.br",
      "agr.br",
      "aju.br",
      "am.br",
      "anani.br",
      "aparecida.br",
      "app.br",
      "arq.br",
      "art.br",
      "ato.br",
      "b.br",
      "barueri.br",
      "belem.br",
      "bhz.br",
      "bib.br",
      "bio.br",
      "blog.br",
      "bmd.br",
      "boavista.br",
      "bsb.br",
      "campinagrande.br",
      "campinas.br",
      "caxias.br",
      "cim.br",
      "cng.br",
      "cnt.br",
      "com.br",
      "contagem.br",
      "coop.br",
      "coz.br",
      "cri.br",
      "cuiaba.br",
      "curitiba.br",
      "def.br",
      "des.br",
      "det.br",
      "dev.br",
      "ecn.br",
      "eco.br",
      "edu.br",
      "emp.br",
      "enf.br",
      "eng.br",
      "esp.br",
      "etc.br",
      "eti.br",
      "far.br",
      "feira.br",
      "flog.br",
      "floripa.br",
      "fm.br",
      "fnd.br",
      "fortal.br",
      "fot.br",
      "foz.br",
      "fst.br",
      "g12.br",
      "geo.br",
      "ggf.br",
      "goiania.br",
      "gov.br",
      "ac.gov.br",
      "al.gov.br",
      "am.gov.br",
      "ap.gov.br",
      "ba.gov.br",
      "ce.gov.br",
      "df.gov.br",
      "es.gov.br",
      "go.gov.br",
      "ma.gov.br",
      "mg.gov.br",
      "ms.gov.br",
      "mt.gov.br",
      "pa.gov.br",
      "pb.gov.br",
      "pe.gov.br",
      "pi.gov.br",
      "pr.gov.br",
      "rj.gov.br",
      "rn.gov.br",
      "ro.gov.br",
      "rr.gov.br",
      "rs.gov.br",
      "sc.gov.br",
      "se.gov.br",
      "sp.gov.br",
      "to.gov.br",
      "gru.br",
      "imb.br",
      "ind.br",
      "inf.br",
      "jab.br",
      "jampa.br",
      "jdf.br",
      "joinville.br",
      "jor.br",
      "jus.br",
      "leg.br",
      "lel.br",
      "log.br",
      "londrina.br",
      "macapa.br",
      "maceio.br",
      "manaus.br",
      "maringa.br",
      "mat.br",
      "med.br",
      "mil.br",
      "morena.br",
      "mp.br",
      "mus.br",
      "natal.br",
      "net.br",
      "niteroi.br",
      "*.nom.br",
      "not.br",
      "ntr.br",
      "odo.br",
      "ong.br",
      "org.br",
      "osasco.br",
      "palmas.br",
      "poa.br",
      "ppg.br",
      "pro.br",
      "psc.br",
      "psi.br",
      "pvh.br",
      "qsl.br",
      "radio.br",
      "rec.br",
      "recife.br",
      "rep.br",
      "ribeirao.br",
      "rio.br",
      "riobranco.br",
      "riopreto.br",
      "salvador.br",
      "sampa.br",
      "santamaria.br",
      "santoandre.br",
      "saobernardo.br",
      "saogonca.br",
      "seg.br",
      "sjc.br",
      "slg.br",
      "slz.br",
      "sorocaba.br",
      "srv.br",
      "taxi.br",
      "tc.br",
      "tec.br",
      "teo.br",
      "the.br",
      "tmp.br",
      "trd.br",
      "tur.br",
      "tv.br",
      "udi.br",
      "vet.br",
      "vix.br",
      "vlog.br",
      "wiki.br",
      "zlg.br",
      "bs",
      "com.bs",
      "net.bs",
      "org.bs",
      "edu.bs",
      "gov.bs",
      "bt",
      "com.bt",
      "edu.bt",
      "gov.bt",
      "net.bt",
      "org.bt",
      "bv",
      "bw",
      "co.bw",
      "org.bw",
      "by",
      "gov.by",
      "mil.by",
      "com.by",
      "of.by",
      "bz",
      "com.bz",
      "net.bz",
      "org.bz",
      "edu.bz",
      "gov.bz",
      "ca",
      "ab.ca",
      "bc.ca",
      "mb.ca",
      "nb.ca",
      "nf.ca",
      "nl.ca",
      "ns.ca",
      "nt.ca",
      "nu.ca",
      "on.ca",
      "pe.ca",
      "qc.ca",
      "sk.ca",
      "yk.ca",
      "gc.ca",
      "cat",
      "cc",
      "cd",
      "gov.cd",
      "cf",
      "cg",
      "ch",
      "ci",
      "org.ci",
      "or.ci",
      "com.ci",
      "co.ci",
      "edu.ci",
      "ed.ci",
      "ac.ci",
      "net.ci",
      "go.ci",
      "asso.ci",
      "a\xE9roport.ci",
      "int.ci",
      "presse.ci",
      "md.ci",
      "gouv.ci",
      "*.ck",
      "!www.ck",
      "cl",
      "co.cl",
      "gob.cl",
      "gov.cl",
      "mil.cl",
      "cm",
      "co.cm",
      "com.cm",
      "gov.cm",
      "net.cm",
      "cn",
      "ac.cn",
      "com.cn",
      "edu.cn",
      "gov.cn",
      "net.cn",
      "org.cn",
      "mil.cn",
      "\u516C\u53F8.cn",
      "\u7F51\u7EDC.cn",
      "\u7DB2\u7D61.cn",
      "ah.cn",
      "bj.cn",
      "cq.cn",
      "fj.cn",
      "gd.cn",
      "gs.cn",
      "gz.cn",
      "gx.cn",
      "ha.cn",
      "hb.cn",
      "he.cn",
      "hi.cn",
      "hl.cn",
      "hn.cn",
      "jl.cn",
      "js.cn",
      "jx.cn",
      "ln.cn",
      "nm.cn",
      "nx.cn",
      "qh.cn",
      "sc.cn",
      "sd.cn",
      "sh.cn",
      "sn.cn",
      "sx.cn",
      "tj.cn",
      "xj.cn",
      "xz.cn",
      "yn.cn",
      "zj.cn",
      "hk.cn",
      "mo.cn",
      "tw.cn",
      "co",
      "arts.co",
      "com.co",
      "edu.co",
      "firm.co",
      "gov.co",
      "info.co",
      "int.co",
      "mil.co",
      "net.co",
      "nom.co",
      "org.co",
      "rec.co",
      "web.co",
      "com",
      "coop",
      "cr",
      "ac.cr",
      "co.cr",
      "ed.cr",
      "fi.cr",
      "go.cr",
      "or.cr",
      "sa.cr",
      "cu",
      "com.cu",
      "edu.cu",
      "org.cu",
      "net.cu",
      "gov.cu",
      "inf.cu",
      "cv",
      "com.cv",
      "edu.cv",
      "int.cv",
      "nome.cv",
      "org.cv",
      "cw",
      "com.cw",
      "edu.cw",
      "net.cw",
      "org.cw",
      "cx",
      "gov.cx",
      "cy",
      "ac.cy",
      "biz.cy",
      "com.cy",
      "ekloges.cy",
      "gov.cy",
      "ltd.cy",
      "mil.cy",
      "net.cy",
      "org.cy",
      "press.cy",
      "pro.cy",
      "tm.cy",
      "cz",
      "de",
      "dj",
      "dk",
      "dm",
      "com.dm",
      "net.dm",
      "org.dm",
      "edu.dm",
      "gov.dm",
      "do",
      "art.do",
      "com.do",
      "edu.do",
      "gob.do",
      "gov.do",
      "mil.do",
      "net.do",
      "org.do",
      "sld.do",
      "web.do",
      "dz",
      "art.dz",
      "asso.dz",
      "com.dz",
      "edu.dz",
      "gov.dz",
      "org.dz",
      "net.dz",
      "pol.dz",
      "soc.dz",
      "tm.dz",
      "ec",
      "com.ec",
      "info.ec",
      "net.ec",
      "fin.ec",
      "k12.ec",
      "med.ec",
      "pro.ec",
      "org.ec",
      "edu.ec",
      "gov.ec",
      "gob.ec",
      "mil.ec",
      "edu",
      "ee",
      "edu.ee",
      "gov.ee",
      "riik.ee",
      "lib.ee",
      "med.ee",
      "com.ee",
      "pri.ee",
      "aip.ee",
      "org.ee",
      "fie.ee",
      "eg",
      "com.eg",
      "edu.eg",
      "eun.eg",
      "gov.eg",
      "mil.eg",
      "name.eg",
      "net.eg",
      "org.eg",
      "sci.eg",
      "*.er",
      "es",
      "com.es",
      "nom.es",
      "org.es",
      "gob.es",
      "edu.es",
      "et",
      "com.et",
      "gov.et",
      "org.et",
      "edu.et",
      "biz.et",
      "name.et",
      "info.et",
      "net.et",
      "eu",
      "fi",
      "aland.fi",
      "fj",
      "ac.fj",
      "biz.fj",
      "com.fj",
      "gov.fj",
      "info.fj",
      "mil.fj",
      "name.fj",
      "net.fj",
      "org.fj",
      "pro.fj",
      "*.fk",
      "com.fm",
      "edu.fm",
      "net.fm",
      "org.fm",
      "fm",
      "fo",
      "fr",
      "asso.fr",
      "com.fr",
      "gouv.fr",
      "nom.fr",
      "prd.fr",
      "tm.fr",
      "aeroport.fr",
      "avocat.fr",
      "avoues.fr",
      "cci.fr",
      "chambagri.fr",
      "chirurgiens-dentistes.fr",
      "experts-comptables.fr",
      "geometre-expert.fr",
      "greta.fr",
      "huissier-justice.fr",
      "medecin.fr",
      "notaires.fr",
      "pharmacien.fr",
      "port.fr",
      "veterinaire.fr",
      "ga",
      "gb",
      "edu.gd",
      "gov.gd",
      "gd",
      "ge",
      "com.ge",
      "edu.ge",
      "gov.ge",
      "org.ge",
      "mil.ge",
      "net.ge",
      "pvt.ge",
      "gf",
      "gg",
      "co.gg",
      "net.gg",
      "org.gg",
      "gh",
      "com.gh",
      "edu.gh",
      "gov.gh",
      "org.gh",
      "mil.gh",
      "gi",
      "com.gi",
      "ltd.gi",
      "gov.gi",
      "mod.gi",
      "edu.gi",
      "org.gi",
      "gl",
      "co.gl",
      "com.gl",
      "edu.gl",
      "net.gl",
      "org.gl",
      "gm",
      "gn",
      "ac.gn",
      "com.gn",
      "edu.gn",
      "gov.gn",
      "org.gn",
      "net.gn",
      "gov",
      "gp",
      "com.gp",
      "net.gp",
      "mobi.gp",
      "edu.gp",
      "org.gp",
      "asso.gp",
      "gq",
      "gr",
      "com.gr",
      "edu.gr",
      "net.gr",
      "org.gr",
      "gov.gr",
      "gs",
      "gt",
      "com.gt",
      "edu.gt",
      "gob.gt",
      "ind.gt",
      "mil.gt",
      "net.gt",
      "org.gt",
      "gu",
      "com.gu",
      "edu.gu",
      "gov.gu",
      "guam.gu",
      "info.gu",
      "net.gu",
      "org.gu",
      "web.gu",
      "gw",
      "gy",
      "co.gy",
      "com.gy",
      "edu.gy",
      "gov.gy",
      "net.gy",
      "org.gy",
      "hk",
      "com.hk",
      "edu.hk",
      "gov.hk",
      "idv.hk",
      "net.hk",
      "org.hk",
      "\u516C\u53F8.hk",
      "\u6559\u80B2.hk",
      "\u654E\u80B2.hk",
      "\u653F\u5E9C.hk",
      "\u500B\u4EBA.hk",
      "\u4E2A\uFFFD\uFFFD.hk",
      "\u7B87\u4EBA.hk",
      "\u7DB2\u7EDC.hk",
      "\u7F51\u7EDC.hk",
      "\u7EC4\u7E54.hk",
      "\u7DB2\u7D61.hk",
      "\u7F51\u7D61.hk",
      "\u7EC4\u7EC7.hk",
      "\u7D44\u7E54.hk",
      "\u7D44\u7EC7.hk",
      "hm",
      "hn",
      "com.hn",
      "edu.hn",
      "org.hn",
      "net.hn",
      "mil.hn",
      "gob.hn",
      "hr",
      "iz.hr",
      "from.hr",
      "name.hr",
      "com.hr",
      "ht",
      "com.ht",
      "shop.ht",
      "firm.ht",
      "info.ht",
      "adult.ht",
      "net.ht",
      "pro.ht",
      "org.ht",
      "med.ht",
      "art.ht",
      "coop.ht",
      "pol.ht",
      "asso.ht",
      "edu.ht",
      "rel.ht",
      "gouv.ht",
      "perso.ht",
      "hu",
      "co.hu",
      "info.hu",
      "org.hu",
      "priv.hu",
      "sport.hu",
      "tm.hu",
      "2000.hu",
      "agrar.hu",
      "bolt.hu",
      "casino.hu",
      "city.hu",
      "erotica.hu",
      "erotika.hu",
      "film.hu",
      "forum.hu",
      "games.hu",
      "hotel.hu",
      "ingatlan.hu",
      "jogasz.hu",
      "konyvelo.hu",
      "lakas.hu",
      "media.hu",
      "news.hu",
      "reklam.hu",
      "sex.hu",
      "shop.hu",
      "suli.hu",
      "szex.hu",
      "tozsde.hu",
      "utazas.hu",
      "video.hu",
      "id",
      "ac.id",
      "biz.id",
      "co.id",
      "desa.id",
      "go.id",
      "mil.id",
      "my.id",
      "net.id",
      "or.id",
      "ponpes.id",
      "sch.id",
      "web.id",
      "ie",
      "gov.ie",
      "il",
      "ac.il",
      "co.il",
      "gov.il",
      "idf.il",
      "k12.il",
      "muni.il",
      "net.il",
      "org.il",
      "im",
      "ac.im",
      "co.im",
      "com.im",
      "ltd.co.im",
      "net.im",
      "org.im",
      "plc.co.im",
      "tt.im",
      "tv.im",
      "in",
      "co.in",
      "firm.in",
      "net.in",
      "org.in",
      "gen.in",
      "ind.in",
      "nic.in",
      "ac.in",
      "edu.in",
      "res.in",
      "gov.in",
      "mil.in",
      "info",
      "int",
      "eu.int",
      "io",
      "com.io",
      "iq",
      "gov.iq",
      "edu.iq",
      "mil.iq",
      "com.iq",
      "org.iq",
      "net.iq",
      "ir",
      "ac.ir",
      "co.ir",
      "gov.ir",
      "id.ir",
      "net.ir",
      "org.ir",
      "sch.ir",
      "\u0627\u06CC\u0631\u0627\u0646.ir",
      "\u0627\u064A\u0631\u0627\u0646.ir",
      "is",
      "net.is",
      "com.is",
      "edu.is",
      "gov.is",
      "org.is",
      "int.is",
      "it",
      "gov.it",
      "edu.it",
      "abr.it",
      "abruzzo.it",
      "aosta-valley.it",
      "aostavalley.it",
      "bas.it",
      "basilicata.it",
      "cal.it",
      "calabria.it",
      "cam.it",
      "campania.it",
      "emilia-romagna.it",
      "emiliaromagna.it",
      "emr.it",
      "friuli-v-giulia.it",
      "friuli-ve-giulia.it",
      "friuli-vegiulia.it",
      "friuli-venezia-giulia.it",
      "friuli-veneziagiulia.it",
      "friuli-vgiulia.it",
      "friuliv-giulia.it",
      "friulive-giulia.it",
      "friulivegiulia.it",
      "friulivenezia-giulia.it",
      "friuliveneziagiulia.it",
      "friulivgiulia.it",
      "fvg.it",
      "laz.it",
      "lazio.it",
      "lig.it",
      "liguria.it",
      "lom.it",
      "lombardia.it",
      "lombardy.it",
      "lucania.it",
      "mar.it",
      "marche.it",
      "mol.it",
      "molise.it",
      "piedmont.it",
      "piemonte.it",
      "pmn.it",
      "pug.it",
      "puglia.it",
      "sar.it",
      "sardegna.it",
      "sardinia.it",
      "sic.it",
      "sicilia.it",
      "sicily.it",
      "taa.it",
      "tos.it",
      "toscana.it",
      "trentin-sud-tirol.it",
      "trentin-s\xFCd-tirol.it",
      "trentin-sudtirol.it",
      "trentin-s\xFCdtirol.it",
      "trentin-sued-tirol.it",
      "trentin-suedtirol.it",
      "trentino-a-adige.it",
      "trentino-aadige.it",
      "trentino-alto-adige.it",
      "trentino-altoadige.it",
      "trentino-s-tirol.it",
      "trentino-stirol.it",
      "trentino-sud-tirol.it",
      "trentino-s\xFCd-tirol.it",
      "trentino-sudtirol.it",
      "trentino-s\xFCdtirol.it",
      "trentino-sued-tirol.it",
      "trentino-suedtirol.it",
      "trentino.it",
      "trentinoa-adige.it",
      "trentinoaadige.it",
      "trentinoalto-adige.it",
      "trentinoaltoadige.it",
      "trentinos-tirol.it",
      "trentinostirol.it",
      "trentinosud-tirol.it",
      "trentinos\xFCd-tirol.it",
      "trentinosudtirol.it",
      "trentinos\xFCdtirol.it",
      "trentinosued-tirol.it",
      "trentinosuedtirol.it",
      "trentinsud-tirol.it",
      "trentins\xFCd-tirol.it",
      "trentinsudtirol.it",
      "trentins\xFCdtirol.it",
      "trentinsued-tirol.it",
      "trentinsuedtirol.it",
      "tuscany.it",
      "umb.it",
      "umbria.it",
      "val-d-aosta.it",
      "val-daosta.it",
      "vald-aosta.it",
      "valdaosta.it",
      "valle-aosta.it",
      "valle-d-aosta.it",
      "valle-daosta.it",
      "valleaosta.it",
      "valled-aosta.it",
      "valledaosta.it",
      "vallee-aoste.it",
      "vall\xE9e-aoste.it",
      "vallee-d-aoste.it",
      "vall\xE9e-d-aoste.it",
      "valleeaoste.it",
      "vall\xE9eaoste.it",
      "valleedaoste.it",
      "vall\xE9edaoste.it",
      "vao.it",
      "vda.it",
      "ven.it",
      "veneto.it",
      "ag.it",
      "agrigento.it",
      "al.it",
      "alessandria.it",
      "alto-adige.it",
      "altoadige.it",
      "an.it",
      "ancona.it",
      "andria-barletta-trani.it",
      "andria-trani-barletta.it",
      "andriabarlettatrani.it",
      "andriatranibarletta.it",
      "ao.it",
      "aosta.it",
      "aoste.it",
      "ap.it",
      "aq.it",
      "aquila.it",
      "ar.it",
      "arezzo.it",
      "ascoli-piceno.it",
      "ascolipiceno.it",
      "asti.it",
      "at.it",
      "av.it",
      "avellino.it",
      "ba.it",
      "balsan-sudtirol.it",
      "balsan-s\xFCdtirol.it",
      "balsan-suedtirol.it",
      "balsan.it",
      "bari.it",
      "barletta-trani-andria.it",
      "barlettatraniandria.it",
      "belluno.it",
      "benevento.it",
      "bergamo.it",
      "bg.it",
      "bi.it",
      "biella.it",
      "bl.it",
      "bn.it",
      "bo.it",
      "bologna.it",
      "bolzano-altoadige.it",
      "bolzano.it",
      "bozen-sudtirol.it",
      "bozen-s\xFCdtirol.it",
      "bozen-suedtirol.it",
      "bozen.it",
      "br.it",
      "brescia.it",
      "brindisi.it",
      "bs.it",
      "bt.it",
      "bulsan-sudtirol.it",
      "bulsan-s\xFCdtirol.it",
      "bulsan-suedtirol.it",
      "bulsan.it",
      "bz.it",
      "ca.it",
      "cagliari.it",
      "caltanissetta.it",
      "campidano-medio.it",
      "campidanomedio.it",
      "campobasso.it",
      "carbonia-iglesias.it",
      "carboniaiglesias.it",
      "carrara-massa.it",
      "carraramassa.it",
      "caserta.it",
      "catania.it",
      "catanzaro.it",
      "cb.it",
      "ce.it",
      "cesena-forli.it",
      "cesena-forl\xEC.it",
      "cesenaforli.it",
      "cesenaforl\xEC.it",
      "ch.it",
      "chieti.it",
      "ci.it",
      "cl.it",
      "cn.it",
      "co.it",
      "como.it",
      "cosenza.it",
      "cr.it",
      "cremona.it",
      "crotone.it",
      "cs.it",
      "ct.it",
      "cuneo.it",
      "cz.it",
      "dell-ogliastra.it",
      "dellogliastra.it",
      "en.it",
      "enna.it",
      "fc.it",
      "fe.it",
      "fermo.it",
      "ferrara.it",
      "fg.it",
      "fi.it",
      "firenze.it",
      "florence.it",
      "fm.it",
      "foggia.it",
      "forli-cesena.it",
      "forl\xEC-cesena.it",
      "forlicesena.it",
      "forl\xECcesena.it",
      "fr.it",
      "frosinone.it",
      "ge.it",
      "genoa.it",
      "genova.it",
      "go.it",
      "gorizia.it",
      "gr.it",
      "grosseto.it",
      "iglesias-carbonia.it",
      "iglesiascarbonia.it",
      "im.it",
      "imperia.it",
      "is.it",
      "isernia.it",
      "kr.it",
      "la-spezia.it",
      "laquila.it",
      "laspezia.it",
      "latina.it",
      "lc.it",
      "le.it",
      "lecce.it",
      "lecco.it",
      "li.it",
      "livorno.it",
      "lo.it",
      "lodi.it",
      "lt.it",
      "lu.it",
      "lucca.it",
      "macerata.it",
      "mantova.it",
      "massa-carrara.it",
      "massacarrara.it",
      "matera.it",
      "mb.it",
      "mc.it",
      "me.it",
      "medio-campidano.it",
      "mediocampidano.it",
      "messina.it",
      "mi.it",
      "milan.it",
      "milano.it",
      "mn.it",
      "mo.it",
      "modena.it",
      "monza-brianza.it",
      "monza-e-della-brianza.it",
      "monza.it",
      "monzabrianza.it",
      "monzaebrianza.it",
      "monzaedellabrianza.it",
      "ms.it",
      "mt.it",
      "na.it",
      "naples.it",
      "napoli.it",
      "no.it",
      "novara.it",
      "nu.it",
      "nuoro.it",
      "og.it",
      "ogliastra.it",
      "olbia-tempio.it",
      "olbiatempio.it",
      "or.it",
      "oristano.it",
      "ot.it",
      "pa.it",
      "padova.it",
      "padua.it",
      "palermo.it",
      "parma.it",
      "pavia.it",
      "pc.it",
      "pd.it",
      "pe.it",
      "perugia.it",
      "pesaro-urbino.it",
      "pesarourbino.it",
      "pescara.it",
      "pg.it",
      "pi.it",
      "piacenza.it",
      "pisa.it",
      "pistoia.it",
      "pn.it",
      "po.it",
      "pordenone.it",
      "potenza.it",
      "pr.it",
      "prato.it",
      "pt.it",
      "pu.it",
      "pv.it",
      "pz.it",
      "ra.it",
      "ragusa.it",
      "ravenna.it",
      "rc.it",
      "re.it",
      "reggio-calabria.it",
      "reggio-emilia.it",
      "reggiocalabria.it",
      "reggioemilia.it",
      "rg.it",
      "ri.it",
      "rieti.it",
      "rimini.it",
      "rm.it",
      "rn.it",
      "ro.it",
      "roma.it",
      "rome.it",
      "rovigo.it",
      "sa.it",
      "salerno.it",
      "sassari.it",
      "savona.it",
      "si.it",
      "siena.it",
      "siracusa.it",
      "so.it",
      "sondrio.it",
      "sp.it",
      "sr.it",
      "ss.it",
      "suedtirol.it",
      "s\xFCdtirol.it",
      "sv.it",
      "ta.it",
      "taranto.it",
      "te.it",
      "tempio-olbia.it",
      "tempioolbia.it",
      "teramo.it",
      "terni.it",
      "tn.it",
      "to.it",
      "torino.it",
      "tp.it",
      "tr.it",
      "trani-andria-barletta.it",
      "trani-barletta-andria.it",
      "traniandriabarletta.it",
      "tranibarlettaandria.it",
      "trapani.it",
      "trento.it",
      "treviso.it",
      "trieste.it",
      "ts.it",
      "turin.it",
      "tv.it",
      "ud.it",
      "udine.it",
      "urbino-pesaro.it",
      "urbinopesaro.it",
      "va.it",
      "varese.it",
      "vb.it",
      "vc.it",
      "ve.it",
      "venezia.it",
      "venice.it",
      "verbania.it",
      "vercelli.it",
      "verona.it",
      "vi.it",
      "vibo-valentia.it",
      "vibovalentia.it",
      "vicenza.it",
      "viterbo.it",
      "vr.it",
      "vs.it",
      "vt.it",
      "vv.it",
      "je",
      "co.je",
      "net.je",
      "org.je",
      "*.jm",
      "jo",
      "com.jo",
      "org.jo",
      "net.jo",
      "edu.jo",
      "sch.jo",
      "gov.jo",
      "mil.jo",
      "name.jo",
      "jobs",
      "jp",
      "ac.jp",
      "ad.jp",
      "co.jp",
      "ed.jp",
      "go.jp",
      "gr.jp",
      "lg.jp",
      "ne.jp",
      "or.jp",
      "aichi.jp",
      "akita.jp",
      "aomori.jp",
      "chiba.jp",
      "ehime.jp",
      "fukui.jp",
      "fukuoka.jp",
      "fukushima.jp",
      "gifu.jp",
      "gunma.jp",
      "hiroshima.jp",
      "hokkaido.jp",
      "hyogo.jp",
      "ibaraki.jp",
      "ishikawa.jp",
      "iwate.jp",
      "kagawa.jp",
      "kagoshima.jp",
      "kanagawa.jp",
      "kochi.jp",
      "kumamoto.jp",
      "kyoto.jp",
      "mie.jp",
      "miyagi.jp",
      "miyazaki.jp",
      "nagano.jp",
      "nagasaki.jp",
      "nara.jp",
      "niigata.jp",
      "oita.jp",
      "okayama.jp",
      "okinawa.jp",
      "osaka.jp",
      "saga.jp",
      "saitama.jp",
      "shiga.jp",
      "shimane.jp",
      "shizuoka.jp",
      "tochigi.jp",
      "tokushima.jp",
      "tokyo.jp",
      "tottori.jp",
      "toyama.jp",
      "wakayama.jp",
      "yamagata.jp",
      "yamaguchi.jp",
      "yamanashi.jp",
      "\u6803\u6728.jp",
      "\u611B\u77E5.jp",
      "\u611B\u5A9B.jp",
      "\u5175\u5EAB.jp",
      "\u718A\u672C.jp",
      "\u8328\u57CE.jp",
      "\u5317\u6D77\u9053.jp",
      "\u5343\u8449.jp",
      "\u548C\u6B4C\u5C71.jp",
      "\u9577\u5D0E.jp",
      "\u9577\u91CE.jp",
      "\u65B0\u6F5F.jp",
      "\u9752\u68EE.jp",
      "\u9759\u5CA1.jp",
      "\u6771\u4EAC.jp",
      "\u77F3\u5DDD.jp",
      "\u57FC\u7389.jp",
      "\u4E09\u91CD.jp",
      "\u4EAC\u90FD.jp",
      "\u4F50\u8CC0.jp",
      "\u5927\u5206.jp",
      "\u5927\u962A.jp",
      "\u5948\u826F.jp",
      "\u5BAE\u57CE.jp",
      "\u5BAE\u5D0E.jp",
      "\u5BCC\u5C71.jp",
      "\u5C71\u53E3.jp",
      "\u5C71\u5F62.jp",
      "\u5C71\u68A8.jp",
      "\u5CA9\u624B.jp",
      "\u5C90\u961C.jp",
      "\u5CA1\u5C71.jp",
      "\u5CF6\u6839.jp",
      "\u5E83\u5CF6.jp",
      "\u5FB3\u5CF6.jp",
      "\u6C96\u7E04.jp",
      "\u6ECB\u8CC0.jp",
      "\u795E\u5948\u5DDD.jp",
      "\u798F\u4E95.jp",
      "\u798F\u5CA1.jp",
      "\u798F\u5CF6.jp",
      "\u79CB\u7530.jp",
      "\u7FA4\u99AC.jp",
      "\u9999\u5DDD.jp",
      "\u9AD8\u77E5.jp",
      "\u9CE5\u53D6.jp",
      "\u9E7F\u5150\u5CF6.jp",
      "*.kawasaki.jp",
      "*.kitakyushu.jp",
      "*.kobe.jp",
      "*.nagoya.jp",
      "*.sapporo.jp",
      "*.sendai.jp",
      "*.yokohama.jp",
      "!city.kawasaki.jp",
      "!city.kitakyushu.jp",
      "!city.kobe.jp",
      "!city.nagoya.jp",
      "!city.sapporo.jp",
      "!city.sendai.jp",
      "!city.yokohama.jp",
      "aisai.aichi.jp",
      "ama.aichi.jp",
      "anjo.aichi.jp",
      "asuke.aichi.jp",
      "chiryu.aichi.jp",
      "chita.aichi.jp",
      "fuso.aichi.jp",
      "gamagori.aichi.jp",
      "handa.aichi.jp",
      "hazu.aichi.jp",
      "hekinan.aichi.jp",
      "higashiura.aichi.jp",
      "ichinomiya.aichi.jp",
      "inazawa.aichi.jp",
      "inuyama.aichi.jp",
      "isshiki.aichi.jp",
      "iwakura.aichi.jp",
      "kanie.aichi.jp",
      "kariya.aichi.jp",
      "kasugai.aichi.jp",
      "kira.aichi.jp",
      "kiyosu.aichi.jp",
      "komaki.aichi.jp",
      "konan.aichi.jp",
      "kota.aichi.jp",
      "mihama.aichi.jp",
      "miyoshi.aichi.jp",
      "nishio.aichi.jp",
      "nisshin.aichi.jp",
      "obu.aichi.jp",
      "oguchi.aichi.jp",
      "oharu.aichi.jp",
      "okazaki.aichi.jp",
      "owariasahi.aichi.jp",
      "seto.aichi.jp",
      "shikatsu.aichi.jp",
      "shinshiro.aichi.jp",
      "shitara.aichi.jp",
      "tahara.aichi.jp",
      "takahama.aichi.jp",
      "tobishima.aichi.jp",
      "toei.aichi.jp",
      "togo.aichi.jp",
      "tokai.aichi.jp",
      "tokoname.aichi.jp",
      "toyoake.aichi.jp",
      "toyohashi.aichi.jp",
      "toyokawa.aichi.jp",
      "toyone.aichi.jp",
      "toyota.aichi.jp",
      "tsushima.aichi.jp",
      "yatomi.aichi.jp",
      "akita.akita.jp",
      "daisen.akita.jp",
      "fujisato.akita.jp",
      "gojome.akita.jp",
      "hachirogata.akita.jp",
      "happou.akita.jp",
      "higashinaruse.akita.jp",
      "honjo.akita.jp",
      "honjyo.akita.jp",
      "ikawa.akita.jp",
      "kamikoani.akita.jp",
      "kamioka.akita.jp",
      "katagami.akita.jp",
      "kazuno.akita.jp",
      "kitaakita.akita.jp",
      "kosaka.akita.jp",
      "kyowa.akita.jp",
      "misato.akita.jp",
      "mitane.akita.jp",
      "moriyoshi.akita.jp",
      "nikaho.akita.jp",
      "noshiro.akita.jp",
      "odate.akita.jp",
      "oga.akita.jp",
      "ogata.akita.jp",
      "semboku.akita.jp",
      "yokote.akita.jp",
      "yurihonjo.akita.jp",
      "aomori.aomori.jp",
      "gonohe.aomori.jp",
      "hachinohe.aomori.jp",
      "hashikami.aomori.jp",
      "hiranai.aomori.jp",
      "hirosaki.aomori.jp",
      "itayanagi.aomori.jp",
      "kuroishi.aomori.jp",
      "misawa.aomori.jp",
      "mutsu.aomori.jp",
      "nakadomari.aomori.jp",
      "noheji.aomori.jp",
      "oirase.aomori.jp",
      "owani.aomori.jp",
      "rokunohe.aomori.jp",
      "sannohe.aomori.jp",
      "shichinohe.aomori.jp",
      "shingo.aomori.jp",
      "takko.aomori.jp",
      "towada.aomori.jp",
      "tsugaru.aomori.jp",
      "tsuruta.aomori.jp",
      "abiko.chiba.jp",
      "asahi.chiba.jp",
      "chonan.chiba.jp",
      "chosei.chiba.jp",
      "choshi.chiba.jp",
      "chuo.chiba.jp",
      "funabashi.chiba.jp",
      "futtsu.chiba.jp",
      "hanamigawa.chiba.jp",
      "ichihara.chiba.jp",
      "ichikawa.chiba.jp",
      "ichinomiya.chiba.jp",
      "inzai.chiba.jp",
      "isumi.chiba.jp",
      "kamagaya.chiba.jp",
      "kamogawa.chiba.jp",
      "kashiwa.chiba.jp",
      "katori.chiba.jp",
      "katsuura.chiba.jp",
      "kimitsu.chiba.jp",
      "kisarazu.chiba.jp",
      "kozaki.chiba.jp",
      "kujukuri.chiba.jp",
      "kyonan.chiba.jp",
      "matsudo.chiba.jp",
      "midori.chiba.jp",
      "mihama.chiba.jp",
      "minamiboso.chiba.jp",
      "mobara.chiba.jp",
      "mutsuzawa.chiba.jp",
      "nagara.chiba.jp",
      "nagareyama.chiba.jp",
      "narashino.chiba.jp",
      "narita.chiba.jp",
      "noda.chiba.jp",
      "oamishirasato.chiba.jp",
      "omigawa.chiba.jp",
      "onjuku.chiba.jp",
      "otaki.chiba.jp",
      "sakae.chiba.jp",
      "sakura.chiba.jp",
      "shimofusa.chiba.jp",
      "shirako.chiba.jp",
      "shiroi.chiba.jp",
      "shisui.chiba.jp",
      "sodegaura.chiba.jp",
      "sosa.chiba.jp",
      "tako.chiba.jp",
      "tateyama.chiba.jp",
      "togane.chiba.jp",
      "tohnosho.chiba.jp",
      "tomisato.chiba.jp",
      "urayasu.chiba.jp",
      "yachimata.chiba.jp",
      "yachiyo.chiba.jp",
      "yokaichiba.chiba.jp",
      "yokoshibahikari.chiba.jp",
      "yotsukaido.chiba.jp",
      "ainan.ehime.jp",
      "honai.ehime.jp",
      "ikata.ehime.jp",
      "imabari.ehime.jp",
      "iyo.ehime.jp",
      "kamijima.ehime.jp",
      "kihoku.ehime.jp",
      "kumakogen.ehime.jp",
      "masaki.ehime.jp",
      "matsuno.ehime.jp",
      "matsuyama.ehime.jp",
      "namikata.ehime.jp",
      "niihama.ehime.jp",
      "ozu.ehime.jp",
      "saijo.ehime.jp",
      "seiyo.ehime.jp",
      "shikokuchuo.ehime.jp",
      "tobe.ehime.jp",
      "toon.ehime.jp",
      "uchiko.ehime.jp",
      "uwajima.ehime.jp",
      "yawatahama.ehime.jp",
      "echizen.fukui.jp",
      "eiheiji.fukui.jp",
      "fukui.fukui.jp",
      "ikeda.fukui.jp",
      "katsuyama.fukui.jp",
      "mihama.fukui.jp",
      "minamiechizen.fukui.jp",
      "obama.fukui.jp",
      "ohi.fukui.jp",
      "ono.fukui.jp",
      "sabae.fukui.jp",
      "sakai.fukui.jp",
      "takahama.fukui.jp",
      "tsuruga.fukui.jp",
      "wakasa.fukui.jp",
      "ashiya.fukuoka.jp",
      "buzen.fukuoka.jp",
      "chikugo.fukuoka.jp",
      "chikuho.fukuoka.jp",
      "chikujo.fukuoka.jp",
      "chikushino.fukuoka.jp",
      "chikuzen.fukuoka.jp",
      "chuo.fukuoka.jp",
      "dazaifu.fukuoka.jp",
      "fukuchi.fukuoka.jp",
      "hakata.fukuoka.jp",
      "higashi.fukuoka.jp",
      "hirokawa.fukuoka.jp",
      "hisayama.fukuoka.jp",
      "iizuka.fukuoka.jp",
      "inatsuki.fukuoka.jp",
      "kaho.fukuoka.jp",
      "kasuga.fukuoka.jp",
      "kasuya.fukuoka.jp",
      "kawara.fukuoka.jp",
      "keisen.fukuoka.jp",
      "koga.fukuoka.jp",
      "kurate.fukuoka.jp",
      "kurogi.fukuoka.jp",
      "kurume.fukuoka.jp",
      "minami.fukuoka.jp",
      "miyako.fukuoka.jp",
      "miyama.fukuoka.jp",
      "miyawaka.fukuoka.jp",
      "mizumaki.fukuoka.jp",
      "munakata.fukuoka.jp",
      "nakagawa.fukuoka.jp",
      "nakama.fukuoka.jp",
      "nishi.fukuoka.jp",
      "nogata.fukuoka.jp",
      "ogori.fukuoka.jp",
      "okagaki.fukuoka.jp",
      "okawa.fukuoka.jp",
      "oki.fukuoka.jp",
      "omuta.fukuoka.jp",
      "onga.fukuoka.jp",
      "onojo.fukuoka.jp",
      "oto.fukuoka.jp",
      "saigawa.fukuoka.jp",
      "sasaguri.fukuoka.jp",
      "shingu.fukuoka.jp",
      "shinyoshitomi.fukuoka.jp",
      "shonai.fukuoka.jp",
      "soeda.fukuoka.jp",
      "sue.fukuoka.jp",
      "tachiarai.fukuoka.jp",
      "tagawa.fukuoka.jp",
      "takata.fukuoka.jp",
      "toho.fukuoka.jp",
      "toyotsu.fukuoka.jp",
      "tsuiki.fukuoka.jp",
      "ukiha.fukuoka.jp",
      "umi.fukuoka.jp",
      "usui.fukuoka.jp",
      "yamada.fukuoka.jp",
      "yame.fukuoka.jp",
      "yanagawa.fukuoka.jp",
      "yukuhashi.fukuoka.jp",
      "aizubange.fukushima.jp",
      "aizumisato.fukushima.jp",
      "aizuwakamatsu.fukushima.jp",
      "asakawa.fukushima.jp",
      "bandai.fukushima.jp",
      "date.fukushima.jp",
      "fukushima.fukushima.jp",
      "furudono.fukushima.jp",
      "futaba.fukushima.jp",
      "hanawa.fukushima.jp",
      "higashi.fukushima.jp",
      "hirata.fukushima.jp",
      "hirono.fukushima.jp",
      "iitate.fukushima.jp",
      "inawashiro.fukushima.jp",
      "ishikawa.fukushima.jp",
      "iwaki.fukushima.jp",
      "izumizaki.fukushima.jp",
      "kagamiishi.fukushima.jp",
      "kaneyama.fukushima.jp",
      "kawamata.fukushima.jp",
      "kitakata.fukushima.jp",
      "kitashiobara.fukushima.jp",
      "koori.fukushima.jp",
      "koriyama.fukushima.jp",
      "kunimi.fukushima.jp",
      "miharu.fukushima.jp",
      "mishima.fukushima.jp",
      "namie.fukushima.jp",
      "nango.fukushima.jp",
      "nishiaizu.fukushima.jp",
      "nishigo.fukushima.jp",
      "okuma.fukushima.jp",
      "omotego.fukushima.jp",
      "ono.fukushima.jp",
      "otama.fukushima.jp",
      "samegawa.fukushima.jp",
      "shimogo.fukushima.jp",
      "shirakawa.fukushima.jp",
      "showa.fukushima.jp",
      "soma.fukushima.jp",
      "sukagawa.fukushima.jp",
      "taishin.fukushima.jp",
      "tamakawa.fukushima.jp",
      "tanagura.fukushima.jp",
      "tenei.fukushima.jp",
      "yabuki.fukushima.jp",
      "yamato.fukushima.jp",
      "yamatsuri.fukushima.jp",
      "yanaizu.fukushima.jp",
      "yugawa.fukushima.jp",
      "anpachi.gifu.jp",
      "ena.gifu.jp",
      "gifu.gifu.jp",
      "ginan.gifu.jp",
      "godo.gifu.jp",
      "gujo.gifu.jp",
      "hashima.gifu.jp",
      "hichiso.gifu.jp",
      "hida.gifu.jp",
      "higashishirakawa.gifu.jp",
      "ibigawa.gifu.jp",
      "ikeda.gifu.jp",
      "kakamigahara.gifu.jp",
      "kani.gifu.jp",
      "kasahara.gifu.jp",
      "kasamatsu.gifu.jp",
      "kawaue.gifu.jp",
      "kitagata.gifu.jp",
      "mino.gifu.jp",
      "minokamo.gifu.jp",
      "mitake.gifu.jp",
      "mizunami.gifu.jp",
      "motosu.gifu.jp",
      "nakatsugawa.gifu.jp",
      "ogaki.gifu.jp",
      "sakahogi.gifu.jp",
      "seki.gifu.jp",
      "sekigahara.gifu.jp",
      "shirakawa.gifu.jp",
      "tajimi.gifu.jp",
      "takayama.gifu.jp",
      "tarui.gifu.jp",
      "toki.gifu.jp",
      "tomika.gifu.jp",
      "wanouchi.gifu.jp",
      "yamagata.gifu.jp",
      "yaotsu.gifu.jp",
      "yoro.gifu.jp",
      "annaka.gunma.jp",
      "chiyoda.gunma.jp",
      "fujioka.gunma.jp",
      "higashiagatsuma.gunma.jp",
      "isesaki.gunma.jp",
      "itakura.gunma.jp",
      "kanna.gunma.jp",
      "kanra.gunma.jp",
      "katashina.gunma.jp",
      "kawaba.gunma.jp",
      "kiryu.gunma.jp",
      "kusatsu.gunma.jp",
      "maebashi.gunma.jp",
      "meiwa.gunma.jp",
      "midori.gunma.jp",
      "minakami.gunma.jp",
      "naganohara.gunma.jp",
      "nakanojo.gunma.jp",
      "nanmoku.gunma.jp",
      "numata.gunma.jp",
      "oizumi.gunma.jp",
      "ora.gunma.jp",
      "ota.gunma.jp",
      "shibukawa.gunma.jp",
      "shimonita.gunma.jp",
      "shinto.gunma.jp",
      "showa.gunma.jp",
      "takasaki.gunma.jp",
      "takayama.gunma.jp",
      "tamamura.gunma.jp",
      "tatebayashi.gunma.jp",
      "tomioka.gunma.jp",
      "tsukiyono.gunma.jp",
      "tsumagoi.gunma.jp",
      "ueno.gunma.jp",
      "yoshioka.gunma.jp",
      "asaminami.hiroshima.jp",
      "daiwa.hiroshima.jp",
      "etajima.hiroshima.jp",
      "fuchu.hiroshima.jp",
      "fukuyama.hiroshima.jp",
      "hatsukaichi.hiroshima.jp",
      "higashihiroshima.hiroshima.jp",
      "hongo.hiroshima.jp",
      "jinsekikogen.hiroshima.jp",
      "kaita.hiroshima.jp",
      "kui.hiroshima.jp",
      "kumano.hiroshima.jp",
      "kure.hiroshima.jp",
      "mihara.hiroshima.jp",
      "miyoshi.hiroshima.jp",
      "naka.hiroshima.jp",
      "onomichi.hiroshima.jp",
      "osakikamijima.hiroshima.jp",
      "otake.hiroshima.jp",
      "saka.hiroshima.jp",
      "sera.hiroshima.jp",
      "seranishi.hiroshima.jp",
      "shinichi.hiroshima.jp",
      "shobara.hiroshima.jp",
      "takehara.hiroshima.jp",
      "abashiri.hokkaido.jp",
      "abira.hokkaido.jp",
      "aibetsu.hokkaido.jp",
      "akabira.hokkaido.jp",
      "akkeshi.hokkaido.jp",
      "asahikawa.hokkaido.jp",
      "ashibetsu.hokkaido.jp",
      "ashoro.hokkaido.jp",
      "assabu.hokkaido.jp",
      "atsuma.hokkaido.jp",
      "bibai.hokkaido.jp",
      "biei.hokkaido.jp",
      "bifuka.hokkaido.jp",
      "bihoro.hokkaido.jp",
      "biratori.hokkaido.jp",
      "chippubetsu.hokkaido.jp",
      "chitose.hokkaido.jp",
      "date.hokkaido.jp",
      "ebetsu.hokkaido.jp",
      "embetsu.hokkaido.jp",
      "eniwa.hokkaido.jp",
      "erimo.hokkaido.jp",
      "esan.hokkaido.jp",
      "esashi.hokkaido.jp",
      "fukagawa.hokkaido.jp",
      "fukushima.hokkaido.jp",
      "furano.hokkaido.jp",
      "furubira.hokkaido.jp",
      "haboro.hokkaido.jp",
      "hakodate.hokkaido.jp",
      "hamatonbetsu.hokkaido.jp",
      "hidaka.hokkaido.jp",
      "higashikagura.hokkaido.jp",
      "higashikawa.hokkaido.jp",
      "hiroo.hokkaido.jp",
      "hokuryu.hokkaido.jp",
      "hokuto.hokkaido.jp",
      "honbetsu.hokkaido.jp",
      "horokanai.hokkaido.jp",
      "horonobe.hokkaido.jp",
      "ikeda.hokkaido.jp",
      "imakane.hokkaido.jp",
      "ishikari.hokkaido.jp",
      "iwamizawa.hokkaido.jp",
      "iwanai.hokkaido.jp",
      "kamifurano.hokkaido.jp",
      "kamikawa.hokkaido.jp",
      "kamishihoro.hokkaido.jp",
      "kamisunagawa.hokkaido.jp",
      "kamoenai.hokkaido.jp",
      "kayabe.hokkaido.jp",
      "kembuchi.hokkaido.jp",
      "kikonai.hokkaido.jp",
      "kimobetsu.hokkaido.jp",
      "kitahiroshima.hokkaido.jp",
      "kitami.hokkaido.jp",
      "kiyosato.hokkaido.jp",
      "koshimizu.hokkaido.jp",
      "kunneppu.hokkaido.jp",
      "kuriyama.hokkaido.jp",
      "kuromatsunai.hokkaido.jp",
      "kushiro.hokkaido.jp",
      "kutchan.hokkaido.jp",
      "kyowa.hokkaido.jp",
      "mashike.hokkaido.jp",
      "matsumae.hokkaido.jp",
      "mikasa.hokkaido.jp",
      "minamifurano.hokkaido.jp",
      "mombetsu.hokkaido.jp",
      "moseushi.hokkaido.jp",
      "mukawa.hokkaido.jp",
      "muroran.hokkaido.jp",
      "naie.hokkaido.jp",
      "nakagawa.hokkaido.jp",
      "nakasatsunai.hokkaido.jp",
      "nakatombetsu.hokkaido.jp",
      "nanae.hokkaido.jp",
      "nanporo.hokkaido.jp",
      "nayoro.hokkaido.jp",
      "nemuro.hokkaido.jp",
      "niikappu.hokkaido.jp",
      "niki.hokkaido.jp",
      "nishiokoppe.hokkaido.jp",
      "noboribetsu.hokkaido.jp",
      "numata.hokkaido.jp",
      "obihiro.hokkaido.jp",
      "obira.hokkaido.jp",
      "oketo.hokkaido.jp",
      "okoppe.hokkaido.jp",
      "otaru.hokkaido.jp",
      "otobe.hokkaido.jp",
      "otofuke.hokkaido.jp",
      "otoineppu.hokkaido.jp",
      "oumu.hokkaido.jp",
      "ozora.hokkaido.jp",
      "pippu.hokkaido.jp",
      "rankoshi.hokkaido.jp",
      "rebun.hokkaido.jp",
      "rikubetsu.hokkaido.jp",
      "rishiri.hokkaido.jp",
      "rishirifuji.hokkaido.jp",
      "saroma.hokkaido.jp",
      "sarufutsu.hokkaido.jp",
      "shakotan.hokkaido.jp",
      "shari.hokkaido.jp",
      "shibecha.hokkaido.jp",
      "shibetsu.hokkaido.jp",
      "shikabe.hokkaido.jp",
      "shikaoi.hokkaido.jp",
      "shimamaki.hokkaido.jp",
      "shimizu.hokkaido.jp",
      "shimokawa.hokkaido.jp",
      "shinshinotsu.hokkaido.jp",
      "shintoku.hokkaido.jp",
      "shiranuka.hokkaido.jp",
      "shiraoi.hokkaido.jp",
      "shiriuchi.hokkaido.jp",
      "sobetsu.hokkaido.jp",
      "sunagawa.hokkaido.jp",
      "taiki.hokkaido.jp",
      "takasu.hokkaido.jp",
      "takikawa.hokkaido.jp",
      "takinoue.hokkaido.jp",
      "teshikaga.hokkaido.jp",
      "tobetsu.hokkaido.jp",
      "tohma.hokkaido.jp",
      "tomakomai.hokkaido.jp",
      "tomari.hokkaido.jp",
      "toya.hokkaido.jp",
      "toyako.hokkaido.jp",
      "toyotomi.hokkaido.jp",
      "toyoura.hokkaido.jp",
      "tsubetsu.hokkaido.jp",
      "tsukigata.hokkaido.jp",
      "urakawa.hokkaido.jp",
      "urausu.hokkaido.jp",
      "uryu.hokkaido.jp",
      "utashinai.hokkaido.jp",
      "wakkanai.hokkaido.jp",
      "wassamu.hokkaido.jp",
      "yakumo.hokkaido.jp",
      "yoichi.hokkaido.jp",
      "aioi.hyogo.jp",
      "akashi.hyogo.jp",
      "ako.hyogo.jp",
      "amagasaki.hyogo.jp",
      "aogaki.hyogo.jp",
      "asago.hyogo.jp",
      "ashiya.hyogo.jp",
      "awaji.hyogo.jp",
      "fukusaki.hyogo.jp",
      "goshiki.hyogo.jp",
      "harima.hyogo.jp",
      "himeji.hyogo.jp",
      "ichikawa.hyogo.jp",
      "inagawa.hyogo.jp",
      "itami.hyogo.jp",
      "kakogawa.hyogo.jp",
      "kamigori.hyogo.jp",
      "kamikawa.hyogo.jp",
      "kasai.hyogo.jp",
      "kasuga.hyogo.jp",
      "kawanishi.hyogo.jp",
      "miki.hyogo.jp",
      "minamiawaji.hyogo.jp",
      "nishinomiya.hyogo.jp",
      "nishiwaki.hyogo.jp",
      "ono.hyogo.jp",
      "sanda.hyogo.jp",
      "sannan.hyogo.jp",
      "sasayama.hyogo.jp",
      "sayo.hyogo.jp",
      "shingu.hyogo.jp",
      "shinonsen.hyogo.jp",
      "shiso.hyogo.jp",
      "sumoto.hyogo.jp",
      "taishi.hyogo.jp",
      "taka.hyogo.jp",
      "takarazuka.hyogo.jp",
      "takasago.hyogo.jp",
      "takino.hyogo.jp",
      "tamba.hyogo.jp",
      "tatsuno.hyogo.jp",
      "toyooka.hyogo.jp",
      "yabu.hyogo.jp",
      "yashiro.hyogo.jp",
      "yoka.hyogo.jp",
      "yokawa.hyogo.jp",
      "ami.ibaraki.jp",
      "asahi.ibaraki.jp",
      "bando.ibaraki.jp",
      "chikusei.ibaraki.jp",
      "daigo.ibaraki.jp",
      "fujishiro.ibaraki.jp",
      "hitachi.ibaraki.jp",
      "hitachinaka.ibaraki.jp",
      "hitachiomiya.ibaraki.jp",
      "hitachiota.ibaraki.jp",
      "ibaraki.ibaraki.jp",
      "ina.ibaraki.jp",
      "inashiki.ibaraki.jp",
      "itako.ibaraki.jp",
      "iwama.ibaraki.jp",
      "joso.ibaraki.jp",
      "kamisu.ibaraki.jp",
      "kasama.ibaraki.jp",
      "kashima.ibaraki.jp",
      "kasumigaura.ibaraki.jp",
      "koga.ibaraki.jp",
      "miho.ibaraki.jp",
      "mito.ibaraki.jp",
      "moriya.ibaraki.jp",
      "naka.ibaraki.jp",
      "namegata.ibaraki.jp",
      "oarai.ibaraki.jp",
      "ogawa.ibaraki.jp",
      "omitama.ibaraki.jp",
      "ryugasaki.ibaraki.jp",
      "sakai.ibaraki.jp",
      "sakuragawa.ibaraki.jp",
      "shimodate.ibaraki.jp",
      "shimotsuma.ibaraki.jp",
      "shirosato.ibaraki.jp",
      "sowa.ibaraki.jp",
      "suifu.ibaraki.jp",
      "takahagi.ibaraki.jp",
      "tamatsukuri.ibaraki.jp",
      "tokai.ibaraki.jp",
      "tomobe.ibaraki.jp",
      "tone.ibaraki.jp",
      "toride.ibaraki.jp",
      "tsuchiura.ibaraki.jp",
      "tsukuba.ibaraki.jp",
      "uchihara.ibaraki.jp",
      "ushiku.ibaraki.jp",
      "yachiyo.ibaraki.jp",
      "yamagata.ibaraki.jp",
      "yawara.ibaraki.jp",
      "yuki.ibaraki.jp",
      "anamizu.ishikawa.jp",
      "hakui.ishikawa.jp",
      "hakusan.ishikawa.jp",
      "kaga.ishikawa.jp",
      "kahoku.ishikawa.jp",
      "kanazawa.ishikawa.jp",
      "kawakita.ishikawa.jp",
      "komatsu.ishikawa.jp",
      "nakanoto.ishikawa.jp",
      "nanao.ishikawa.jp",
      "nomi.ishikawa.jp",
      "nonoichi.ishikawa.jp",
      "noto.ishikawa.jp",
      "shika.ishikawa.jp",
      "suzu.ishikawa.jp",
      "tsubata.ishikawa.jp",
      "tsurugi.ishikawa.jp",
      "uchinada.ishikawa.jp",
      "wajima.ishikawa.jp",
      "fudai.iwate.jp",
      "fujisawa.iwate.jp",
      "hanamaki.iwate.jp",
      "hiraizumi.iwate.jp",
      "hirono.iwate.jp",
      "ichinohe.iwate.jp",
      "ichinoseki.iwate.jp",
      "iwaizumi.iwate.jp",
      "iwate.iwate.jp",
      "joboji.iwate.jp",
      "kamaishi.iwate.jp",
      "kanegasaki.iwate.jp",
      "karumai.iwate.jp",
      "kawai.iwate.jp",
      "kitakami.iwate.jp",
      "kuji.iwate.jp",
      "kunohe.iwate.jp",
      "kuzumaki.iwate.jp",
      "miyako.iwate.jp",
      "mizusawa.iwate.jp",
      "morioka.iwate.jp",
      "ninohe.iwate.jp",
      "noda.iwate.jp",
      "ofunato.iwate.jp",
      "oshu.iwate.jp",
      "otsuchi.iwate.jp",
      "rikuzentakata.iwate.jp",
      "shiwa.iwate.jp",
      "shizukuishi.iwate.jp",
      "sumita.iwate.jp",
      "tanohata.iwate.jp",
      "tono.iwate.jp",
      "yahaba.iwate.jp",
      "yamada.iwate.jp",
      "ayagawa.kagawa.jp",
      "higashikagawa.kagawa.jp",
      "kanonji.kagawa.jp",
      "kotohira.kagawa.jp",
      "manno.kagawa.jp",
      "marugame.kagawa.jp",
      "mitoyo.kagawa.jp",
      "naoshima.kagawa.jp",
      "sanuki.kagawa.jp",
      "tadotsu.kagawa.jp",
      "takamatsu.kagawa.jp",
      "tonosho.kagawa.jp",
      "uchinomi.kagawa.jp",
      "utazu.kagawa.jp",
      "zentsuji.kagawa.jp",
      "akune.kagoshima.jp",
      "amami.kagoshima.jp",
      "hioki.kagoshima.jp",
      "isa.kagoshima.jp",
      "isen.kagoshima.jp",
      "izumi.kagoshima.jp",
      "kagoshima.kagoshima.jp",
      "kanoya.kagoshima.jp",
      "kawanabe.kagoshima.jp",
      "kinko.kagoshima.jp",
      "kouyama.kagoshima.jp",
      "makurazaki.kagoshima.jp",
      "matsumoto.kagoshima.jp",
      "minamitane.kagoshima.jp",
      "nakatane.kagoshima.jp",
      "nishinoomote.kagoshima.jp",
      "satsumasendai.kagoshima.jp",
      "soo.kagoshima.jp",
      "tarumizu.kagoshima.jp",
      "yusui.kagoshima.jp",
      "aikawa.kanagawa.jp",
      "atsugi.kanagawa.jp",
      "ayase.kanagawa.jp",
      "chigasaki.kanagawa.jp",
      "ebina.kanagawa.jp",
      "fujisawa.kanagawa.jp",
      "hadano.kanagawa.jp",
      "hakone.kanagawa.jp",
      "hiratsuka.kanagawa.jp",
      "isehara.kanagawa.jp",
      "kaisei.kanagawa.jp",
      "kamakura.kanagawa.jp",
      "kiyokawa.kanagawa.jp",
      "matsuda.kanagawa.jp",
      "minamiashigara.kanagawa.jp",
      "miura.kanagawa.jp",
      "nakai.kanagawa.jp",
      "ninomiya.kanagawa.jp",
      "odawara.kanagawa.jp",
      "oi.kanagawa.jp",
      "oiso.kanagawa.jp",
      "sagamihara.kanagawa.jp",
      "samukawa.kanagawa.jp",
      "tsukui.kanagawa.jp",
      "yamakita.kanagawa.jp",
      "yamato.kanagawa.jp",
      "yokosuka.kanagawa.jp",
      "yugawara.kanagawa.jp",
      "zama.kanagawa.jp",
      "zushi.kanagawa.jp",
      "aki.kochi.jp",
      "geisei.kochi.jp",
      "hidaka.kochi.jp",
      "higashitsuno.kochi.jp",
      "ino.kochi.jp",
      "kagami.kochi.jp",
      "kami.kochi.jp",
      "kitagawa.kochi.jp",
      "kochi.kochi.jp",
      "mihara.kochi.jp",
      "motoyama.kochi.jp",
      "muroto.kochi.jp",
      "nahari.kochi.jp",
      "nakamura.kochi.jp",
      "nankoku.kochi.jp",
      "nishitosa.kochi.jp",
      "niyodogawa.kochi.jp",
      "ochi.kochi.jp",
      "okawa.kochi.jp",
      "otoyo.kochi.jp",
      "otsuki.kochi.jp",
      "sakawa.kochi.jp",
      "sukumo.kochi.jp",
      "susaki.kochi.jp",
      "tosa.kochi.jp",
      "tosashimizu.kochi.jp",
      "toyo.kochi.jp",
      "tsuno.kochi.jp",
      "umaji.kochi.jp",
      "yasuda.kochi.jp",
      "yusuhara.kochi.jp",
      "amakusa.kumamoto.jp",
      "arao.kumamoto.jp",
      "aso.kumamoto.jp",
      "choyo.kumamoto.jp",
      "gyokuto.kumamoto.jp",
      "kamiamakusa.kumamoto.jp",
      "kikuchi.kumamoto.jp",
      "kumamoto.kumamoto.jp",
      "mashiki.kumamoto.jp",
      "mifune.kumamoto.jp",
      "minamata.kumamoto.jp",
      "minamioguni.kumamoto.jp",
      "nagasu.kumamoto.jp",
      "nishihara.kumamoto.jp",
      "oguni.kumamoto.jp",
      "ozu.kumamoto.jp",
      "sumoto.kumamoto.jp",
      "takamori.kumamoto.jp",
      "uki.kumamoto.jp",
      "uto.kumamoto.jp",
      "yamaga.kumamoto.jp",
      "yamato.kumamoto.jp",
      "yatsushiro.kumamoto.jp",
      "ayabe.kyoto.jp",
      "fukuchiyama.kyoto.jp",
      "higashiyama.kyoto.jp",
      "ide.kyoto.jp",
      "ine.kyoto.jp",
      "joyo.kyoto.jp",
      "kameoka.kyoto.jp",
      "kamo.kyoto.jp",
      "kita.kyoto.jp",
      "kizu.kyoto.jp",
      "kumiyama.kyoto.jp",
      "kyotamba.kyoto.jp",
      "kyotanabe.kyoto.jp",
      "kyotango.kyoto.jp",
      "maizuru.kyoto.jp",
      "minami.kyoto.jp",
      "minamiyamashiro.kyoto.jp",
      "miyazu.kyoto.jp",
      "muko.kyoto.jp",
      "nagaokakyo.kyoto.jp",
      "nakagyo.kyoto.jp",
      "nantan.kyoto.jp",
      "oyamazaki.kyoto.jp",
      "sakyo.kyoto.jp",
      "seika.kyoto.jp",
      "tanabe.kyoto.jp",
      "uji.kyoto.jp",
      "ujitawara.kyoto.jp",
      "wazuka.kyoto.jp",
      "yamashina.kyoto.jp",
      "yawata.kyoto.jp",
      "asahi.mie.jp",
      "inabe.mie.jp",
      "ise.mie.jp",
      "kameyama.mie.jp",
      "kawagoe.mie.jp",
      "kiho.mie.jp",
      "kisosaki.mie.jp",
      "kiwa.mie.jp",
      "komono.mie.jp",
      "kumano.mie.jp",
      "kuwana.mie.jp",
      "matsusaka.mie.jp",
      "meiwa.mie.jp",
      "mihama.mie.jp",
      "minamiise.mie.jp",
      "misugi.mie.jp",
      "miyama.mie.jp",
      "nabari.mie.jp",
      "shima.mie.jp",
      "suzuka.mie.jp",
      "tado.mie.jp",
      "taiki.mie.jp",
      "taki.mie.jp",
      "tamaki.mie.jp",
      "toba.mie.jp",
      "tsu.mie.jp",
      "udono.mie.jp",
      "ureshino.mie.jp",
      "watarai.mie.jp",
      "yokkaichi.mie.jp",
      "furukawa.miyagi.jp",
      "higashimatsushima.miyagi.jp",
      "ishinomaki.miyagi.jp",
      "iwanuma.miyagi.jp",
      "kakuda.miyagi.jp",
      "kami.miyagi.jp",
      "kawasaki.miyagi.jp",
      "marumori.miyagi.jp",
      "matsushima.miyagi.jp",
      "minamisanriku.miyagi.jp",
      "misato.miyagi.jp",
      "murata.miyagi.jp",
      "natori.miyagi.jp",
      "ogawara.miyagi.jp",
      "ohira.miyagi.jp",
      "onagawa.miyagi.jp",
      "osaki.miyagi.jp",
      "rifu.miyagi.jp",
      "semine.miyagi.jp",
      "shibata.miyagi.jp",
      "shichikashuku.miyagi.jp",
      "shikama.miyagi.jp",
      "shiogama.miyagi.jp",
      "shiroishi.miyagi.jp",
      "tagajo.miyagi.jp",
      "taiwa.miyagi.jp",
      "tome.miyagi.jp",
      "tomiya.miyagi.jp",
      "wakuya.miyagi.jp",
      "watari.miyagi.jp",
      "yamamoto.miyagi.jp",
      "zao.miyagi.jp",
      "aya.miyazaki.jp",
      "ebino.miyazaki.jp",
      "gokase.miyazaki.jp",
      "hyuga.miyazaki.jp",
      "kadogawa.miyazaki.jp",
      "kawaminami.miyazaki.jp",
      "kijo.miyazaki.jp",
      "kitagawa.miyazaki.jp",
      "kitakata.miyazaki.jp",
      "kitaura.miyazaki.jp",
      "kobayashi.miyazaki.jp",
      "kunitomi.miyazaki.jp",
      "kushima.miyazaki.jp",
      "mimata.miyazaki.jp",
      "miyakonojo.miyazaki.jp",
      "miyazaki.miyazaki.jp",
      "morotsuka.miyazaki.jp",
      "nichinan.miyazaki.jp",
      "nishimera.miyazaki.jp",
      "nobeoka.miyazaki.jp",
      "saito.miyazaki.jp",
      "shiiba.miyazaki.jp",
      "shintomi.miyazaki.jp",
      "takaharu.miyazaki.jp",
      "takanabe.miyazaki.jp",
      "takazaki.miyazaki.jp",
      "tsuno.miyazaki.jp",
      "achi.nagano.jp",
      "agematsu.nagano.jp",
      "anan.nagano.jp",
      "aoki.nagano.jp",
      "asahi.nagano.jp",
      "azumino.nagano.jp",
      "chikuhoku.nagano.jp",
      "chikuma.nagano.jp",
      "chino.nagano.jp",
      "fujimi.nagano.jp",
      "hakuba.nagano.jp",
      "hara.nagano.jp",
      "hiraya.nagano.jp",
      "iida.nagano.jp",
      "iijima.nagano.jp",
      "iiyama.nagano.jp",
      "iizuna.nagano.jp",
      "ikeda.nagano.jp",
      "ikusaka.nagano.jp",
      "ina.nagano.jp",
      "karuizawa.nagano.jp",
      "kawakami.nagano.jp",
      "kiso.nagano.jp",
      "kisofukushima.nagano.jp",
      "kitaaiki.nagano.jp",
      "komagane.nagano.jp",
      "komoro.nagano.jp",
      "matsukawa.nagano.jp",
      "matsumoto.nagano.jp",
      "miasa.nagano.jp",
      "minamiaiki.nagano.jp",
      "minamimaki.nagano.jp",
      "minamiminowa.nagano.jp",
      "minowa.nagano.jp",
      "miyada.nagano.jp",
      "miyota.nagano.jp",
      "mochizuki.nagano.jp",
      "nagano.nagano.jp",
      "nagawa.nagano.jp",
      "nagiso.nagano.jp",
      "nakagawa.nagano.jp",
      "nakano.nagano.jp",
      "nozawaonsen.nagano.jp",
      "obuse.nagano.jp",
      "ogawa.nagano.jp",
      "okaya.nagano.jp",
      "omachi.nagano.jp",
      "omi.nagano.jp",
      "ookuwa.nagano.jp",
      "ooshika.nagano.jp",
      "otaki.nagano.jp",
      "otari.nagano.jp",
      "sakae.nagano.jp",
      "sakaki.nagano.jp",
      "saku.nagano.jp",
      "sakuho.nagano.jp",
      "shimosuwa.nagano.jp",
      "shinanomachi.nagano.jp",
      "shiojiri.nagano.jp",
      "suwa.nagano.jp",
      "suzaka.nagano.jp",
      "takagi.nagano.jp",
      "takamori.nagano.jp",
      "takayama.nagano.jp",
      "tateshina.nagano.jp",
      "tatsuno.nagano.jp",
      "togakushi.nagano.jp",
      "togura.nagano.jp",
      "tomi.nagano.jp",
      "ueda.nagano.jp",
      "wada.nagano.jp",
      "yamagata.nagano.jp",
      "yamanouchi.nagano.jp",
      "yasaka.nagano.jp",
      "yasuoka.nagano.jp",
      "chijiwa.nagasaki.jp",
      "futsu.nagasaki.jp",
      "goto.nagasaki.jp",
      "hasami.nagasaki.jp",
      "hirado.nagasaki.jp",
      "iki.nagasaki.jp",
      "isahaya.nagasaki.jp",
      "kawatana.nagasaki.jp",
      "kuchinotsu.nagasaki.jp",
      "matsuura.nagasaki.jp",
      "nagasaki.nagasaki.jp",
      "obama.nagasaki.jp",
      "omura.nagasaki.jp",
      "oseto.nagasaki.jp",
      "saikai.nagasaki.jp",
      "sasebo.nagasaki.jp",
      "seihi.nagasaki.jp",
      "shimabara.nagasaki.jp",
      "shinkamigoto.nagasaki.jp",
      "togitsu.nagasaki.jp",
      "tsushima.nagasaki.jp",
      "unzen.nagasaki.jp",
      "ando.nara.jp",
      "gose.nara.jp",
      "heguri.nara.jp",
      "higashiyoshino.nara.jp",
      "ikaruga.nara.jp",
      "ikoma.nara.jp",
      "kamikitayama.nara.jp",
      "kanmaki.nara.jp",
      "kashiba.nara.jp",
      "kashihara.nara.jp",
      "katsuragi.nara.jp",
      "kawai.nara.jp",
      "kawakami.nara.jp",
      "kawanishi.nara.jp",
      "koryo.nara.jp",
      "kurotaki.nara.jp",
      "mitsue.nara.jp",
      "miyake.nara.jp",
      "nara.nara.jp",
      "nosegawa.nara.jp",
      "oji.nara.jp",
      "ouda.nara.jp",
      "oyodo.nara.jp",
      "sakurai.nara.jp",
      "sango.nara.jp",
      "shimoichi.nara.jp",
      "shimokitayama.nara.jp",
      "shinjo.nara.jp",
      "soni.nara.jp",
      "takatori.nara.jp",
      "tawaramoto.nara.jp",
      "tenkawa.nara.jp",
      "tenri.nara.jp",
      "uda.nara.jp",
      "yamatokoriyama.nara.jp",
      "yamatotakada.nara.jp",
      "yamazoe.nara.jp",
      "yoshino.nara.jp",
      "aga.niigata.jp",
      "agano.niigata.jp",
      "gosen.niigata.jp",
      "itoigawa.niigata.jp",
      "izumozaki.niigata.jp",
      "joetsu.niigata.jp",
      "kamo.niigata.jp",
      "kariwa.niigata.jp",
      "kashiwazaki.niigata.jp",
      "minamiuonuma.niigata.jp",
      "mitsuke.niigata.jp",
      "muika.niigata.jp",
      "murakami.niigata.jp",
      "myoko.niigata.jp",
      "nagaoka.niigata.jp",
      "niigata.niigata.jp",
      "ojiya.niigata.jp",
      "omi.niigata.jp",
      "sado.niigata.jp",
      "sanjo.niigata.jp",
      "seiro.niigata.jp",
      "seirou.niigata.jp",
      "sekikawa.niigata.jp",
      "shibata.niigata.jp",
      "tagami.niigata.jp",
      "tainai.niigata.jp",
      "tochio.niigata.jp",
      "tokamachi.niigata.jp",
      "tsubame.niigata.jp",
      "tsunan.niigata.jp",
      "uonuma.niigata.jp",
      "yahiko.niigata.jp",
      "yoita.niigata.jp",
      "yuzawa.niigata.jp",
      "beppu.oita.jp",
      "bungoono.oita.jp",
      "bungotakada.oita.jp",
      "hasama.oita.jp",
      "hiji.oita.jp",
      "himeshima.oita.jp",
      "hita.oita.jp",
      "kamitsue.oita.jp",
      "kokonoe.oita.jp",
      "kuju.oita.jp",
      "kunisaki.oita.jp",
      "kusu.oita.jp",
      "oita.oita.jp",
      "saiki.oita.jp",
      "taketa.oita.jp",
      "tsukumi.oita.jp",
      "usa.oita.jp",
      "usuki.oita.jp",
      "yufu.oita.jp",
      "akaiwa.okayama.jp",
      "asakuchi.okayama.jp",
      "bizen.okayama.jp",
      "hayashima.okayama.jp",
      "ibara.okayama.jp",
      "kagamino.okayama.jp",
      "kasaoka.okayama.jp",
      "kibichuo.okayama.jp",
      "kumenan.okayama.jp",
      "kurashiki.okayama.jp",
      "maniwa.okayama.jp",
      "misaki.okayama.jp",
      "nagi.okayama.jp",
      "niimi.okayama.jp",
      "nishiawakura.okayama.jp",
      "okayama.okayama.jp",
      "satosho.okayama.jp",
      "setouchi.okayama.jp",
      "shinjo.okayama.jp",
      "shoo.okayama.jp",
      "soja.okayama.jp",
      "takahashi.okayama.jp",
      "tamano.okayama.jp",
      "tsuyama.okayama.jp",
      "wake.okayama.jp",
      "yakage.okayama.jp",
      "aguni.okinawa.jp",
      "ginowan.okinawa.jp",
      "ginoza.okinawa.jp",
      "gushikami.okinawa.jp",
      "haebaru.okinawa.jp",
      "higashi.okinawa.jp",
      "hirara.okinawa.jp",
      "iheya.okinawa.jp",
      "ishigaki.okinawa.jp",
      "ishikawa.okinawa.jp",
      "itoman.okinawa.jp",
      "izena.okinawa.jp",
      "kadena.okinawa.jp",
      "kin.okinawa.jp",
      "kitadaito.okinawa.jp",
      "kitanakagusuku.okinawa.jp",
      "kumejima.okinawa.jp",
      "kunigami.okinawa.jp",
      "minamidaito.okinawa.jp",
      "motobu.okinawa.jp",
      "nago.okinawa.jp",
      "naha.okinawa.jp",
      "nakagusuku.okinawa.jp",
      "nakijin.okinawa.jp",
      "nanjo.okinawa.jp",
      "nishihara.okinawa.jp",
      "ogimi.okinawa.jp",
      "okinawa.okinawa.jp",
      "onna.okinawa.jp",
      "shimoji.okinawa.jp",
      "taketomi.okinawa.jp",
      "tarama.okinawa.jp",
      "tokashiki.okinawa.jp",
      "tomigusuku.okinawa.jp",
      "tonaki.okinawa.jp",
      "urasoe.okinawa.jp",
      "uruma.okinawa.jp",
      "yaese.okinawa.jp",
      "yomitan.okinawa.jp",
      "yonabaru.okinawa.jp",
      "yonaguni.okinawa.jp",
      "zamami.okinawa.jp",
      "abeno.osaka.jp",
      "chihayaakasaka.osaka.jp",
      "chuo.osaka.jp",
      "daito.osaka.jp",
      "fujiidera.osaka.jp",
      "habikino.osaka.jp",
      "hannan.osaka.jp",
      "higashiosaka.osaka.jp",
      "higashisumiyoshi.osaka.jp",
      "higashiyodogawa.osaka.jp",
      "hirakata.osaka.jp",
      "ibaraki.osaka.jp",
      "ikeda.osaka.jp",
      "izumi.osaka.jp",
      "izumiotsu.osaka.jp",
      "izumisano.osaka.jp",
      "kadoma.osaka.jp",
      "kaizuka.osaka.jp",
      "kanan.osaka.jp",
      "kashiwara.osaka.jp",
      "katano.osaka.jp",
      "kawachinagano.osaka.jp",
      "kishiwada.osaka.jp",
      "kita.osaka.jp",
      "kumatori.osaka.jp",
      "matsubara.osaka.jp",
      "minato.osaka.jp",
      "minoh.osaka.jp",
      "misaki.osaka.jp",
      "moriguchi.osaka.jp",
      "neyagawa.osaka.jp",
      "nishi.osaka.jp",
      "nose.osaka.jp",
      "osakasayama.osaka.jp",
      "sakai.osaka.jp",
      "sayama.osaka.jp",
      "sennan.osaka.jp",
      "settsu.osaka.jp",
      "shijonawate.osaka.jp",
      "shimamoto.osaka.jp",
      "suita.osaka.jp",
      "tadaoka.osaka.jp",
      "taishi.osaka.jp",
      "tajiri.osaka.jp",
      "takaishi.osaka.jp",
      "takatsuki.osaka.jp",
      "tondabayashi.osaka.jp",
      "toyonaka.osaka.jp",
      "toyono.osaka.jp",
      "yao.osaka.jp",
      "ariake.saga.jp",
      "arita.saga.jp",
      "fukudomi.saga.jp",
      "genkai.saga.jp",
      "hamatama.saga.jp",
      "hizen.saga.jp",
      "imari.saga.jp",
      "kamimine.saga.jp",
      "kanzaki.saga.jp",
      "karatsu.saga.jp",
      "kashima.saga.jp",
      "kitagata.saga.jp",
      "kitahata.saga.jp",
      "kiyama.saga.jp",
      "kouhoku.saga.jp",
      "kyuragi.saga.jp",
      "nishiarita.saga.jp",
      "ogi.saga.jp",
      "omachi.saga.jp",
      "ouchi.saga.jp",
      "saga.saga.jp",
      "shiroishi.saga.jp",
      "taku.saga.jp",
      "tara.saga.jp",
      "tosu.saga.jp",
      "yoshinogari.saga.jp",
      "arakawa.saitama.jp",
      "asaka.saitama.jp",
      "chichibu.saitama.jp",
      "fujimi.saitama.jp",
      "fujimino.saitama.jp",
      "fukaya.saitama.jp",
      "hanno.saitama.jp",
      "hanyu.saitama.jp",
      "hasuda.saitama.jp",
      "hatogaya.saitama.jp",
      "hatoyama.saitama.jp",
      "hidaka.saitama.jp",
      "higashichichibu.saitama.jp",
      "higashimatsuyama.saitama.jp",
      "honjo.saitama.jp",
      "ina.saitama.jp",
      "iruma.saitama.jp",
      "iwatsuki.saitama.jp",
      "kamiizumi.saitama.jp",
      "kamikawa.saitama.jp",
      "kamisato.saitama.jp",
      "kasukabe.saitama.jp",
      "kawagoe.saitama.jp",
      "kawaguchi.saitama.jp",
      "kawajima.saitama.jp",
      "kazo.saitama.jp",
      "kitamoto.saitama.jp",
      "koshigaya.saitama.jp",
      "kounosu.saitama.jp",
      "kuki.saitama.jp",
      "kumagaya.saitama.jp",
      "matsubushi.saitama.jp",
      "minano.saitama.jp",
      "misato.saitama.jp",
      "miyashiro.saitama.jp",
      "miyoshi.saitama.jp",
      "moroyama.saitama.jp",
      "nagatoro.saitama.jp",
      "namegawa.saitama.jp",
      "niiza.saitama.jp",
      "ogano.saitama.jp",
      "ogawa.saitama.jp",
      "ogose.saitama.jp",
      "okegawa.saitama.jp",
      "omiya.saitama.jp",
      "otaki.saitama.jp",
      "ranzan.saitama.jp",
      "ryokami.saitama.jp",
      "saitama.saitama.jp",
      "sakado.saitama.jp",
      "satte.saitama.jp",
      "sayama.saitama.jp",
      "shiki.saitama.jp",
      "shiraoka.saitama.jp",
      "soka.saitama.jp",
      "sugito.saitama.jp",
      "toda.saitama.jp",
      "tokigawa.saitama.jp",
      "tokorozawa.saitama.jp",
      "tsurugashima.saitama.jp",
      "urawa.saitama.jp",
      "warabi.saitama.jp",
      "yashio.saitama.jp",
      "yokoze.saitama.jp",
      "yono.saitama.jp",
      "yorii.saitama.jp",
      "yoshida.saitama.jp",
      "yoshikawa.saitama.jp",
      "yoshimi.saitama.jp",
      "aisho.shiga.jp",
      "gamo.shiga.jp",
      "higashiomi.shiga.jp",
      "hikone.shiga.jp",
      "koka.shiga.jp",
      "konan.shiga.jp",
      "kosei.shiga.jp",
      "koto.shiga.jp",
      "kusatsu.shiga.jp",
      "maibara.shiga.jp",
      "moriyama.shiga.jp",
      "nagahama.shiga.jp",
      "nishiazai.shiga.jp",
      "notogawa.shiga.jp",
      "omihachiman.shiga.jp",
      "otsu.shiga.jp",
      "ritto.shiga.jp",
      "ryuoh.shiga.jp",
      "takashima.shiga.jp",
      "takatsuki.shiga.jp",
      "torahime.shiga.jp",
      "toyosato.shiga.jp",
      "yasu.shiga.jp",
      "akagi.shimane.jp",
      "ama.shimane.jp",
      "gotsu.shimane.jp",
      "hamada.shimane.jp",
      "higashiizumo.shimane.jp",
      "hikawa.shimane.jp",
      "hikimi.shimane.jp",
      "izumo.shimane.jp",
      "kakinoki.shimane.jp",
      "masuda.shimane.jp",
      "matsue.shimane.jp",
      "misato.shimane.jp",
      "nishinoshima.shimane.jp",
      "ohda.shimane.jp",
      "okinoshima.shimane.jp",
      "okuizumo.shimane.jp",
      "shimane.shimane.jp",
      "tamayu.shimane.jp",
      "tsuwano.shimane.jp",
      "unnan.shimane.jp",
      "yakumo.shimane.jp",
      "yasugi.shimane.jp",
      "yatsuka.shimane.jp",
      "arai.shizuoka.jp",
      "atami.shizuoka.jp",
      "fuji.shizuoka.jp",
      "fujieda.shizuoka.jp",
      "fujikawa.shizuoka.jp",
      "fujinomiya.shizuoka.jp",
      "fukuroi.shizuoka.jp",
      "gotemba.shizuoka.jp",
      "haibara.shizuoka.jp",
      "hamamatsu.shizuoka.jp",
      "higashiizu.shizuoka.jp",
      "ito.shizuoka.jp",
      "iwata.shizuoka.jp",
      "izu.shizuoka.jp",
      "izunokuni.shizuoka.jp",
      "kakegawa.shizuoka.jp",
      "kannami.shizuoka.jp",
      "kawanehon.shizuoka.jp",
      "kawazu.shizuoka.jp",
      "kikugawa.shizuoka.jp",
      "kosai.shizuoka.jp",
      "makinohara.shizuoka.jp",
      "matsuzaki.shizuoka.jp",
      "minamiizu.shizuoka.jp",
      "mishima.shizuoka.jp",
      "morimachi.shizuoka.jp",
      "nishiizu.shizuoka.jp",
      "numazu.shizuoka.jp",
      "omaezaki.shizuoka.jp",
      "shimada.shizuoka.jp",
      "shimizu.shizuoka.jp",
      "shimoda.shizuoka.jp",
      "shizuoka.shizuoka.jp",
      "susono.shizuoka.jp",
      "yaizu.shizuoka.jp",
      "yoshida.shizuoka.jp",
      "ashikaga.tochigi.jp",
      "bato.tochigi.jp",
      "haga.tochigi.jp",
      "ichikai.tochigi.jp",
      "iwafune.tochigi.jp",
      "kaminokawa.tochigi.jp",
      "kanuma.tochigi.jp",
      "karasuyama.tochigi.jp",
      "kuroiso.tochigi.jp",
      "mashiko.tochigi.jp",
      "mibu.tochigi.jp",
      "moka.tochigi.jp",
      "motegi.tochigi.jp",
      "nasu.tochigi.jp",
      "nasushiobara.tochigi.jp",
      "nikko.tochigi.jp",
      "nishikata.tochigi.jp",
      "nogi.tochigi.jp",
      "ohira.tochigi.jp",
      "ohtawara.tochigi.jp",
      "oyama.tochigi.jp",
      "sakura.tochigi.jp",
      "sano.tochigi.jp",
      "shimotsuke.tochigi.jp",
      "shioya.tochigi.jp",
      "takanezawa.tochigi.jp",
      "tochigi.tochigi.jp",
      "tsuga.tochigi.jp",
      "ujiie.tochigi.jp",
      "utsunomiya.tochigi.jp",
      "yaita.tochigi.jp",
      "aizumi.tokushima.jp",
      "anan.tokushima.jp",
      "ichiba.tokushima.jp",
      "itano.tokushima.jp",
      "kainan.tokushima.jp",
      "komatsushima.tokushima.jp",
      "matsushige.tokushima.jp",
      "mima.tokushima.jp",
      "minami.tokushima.jp",
      "miyoshi.tokushima.jp",
      "mugi.tokushima.jp",
      "nakagawa.tokushima.jp",
      "naruto.tokushima.jp",
      "sanagochi.tokushima.jp",
      "shishikui.tokushima.jp",
      "tokushima.tokushima.jp",
      "wajiki.tokushima.jp",
      "adachi.tokyo.jp",
      "akiruno.tokyo.jp",
      "akishima.tokyo.jp",
      "aogashima.tokyo.jp",
      "arakawa.tokyo.jp",
      "bunkyo.tokyo.jp",
      "chiyoda.tokyo.jp",
      "chofu.tokyo.jp",
      "chuo.tokyo.jp",
      "edogawa.tokyo.jp",
      "fuchu.tokyo.jp",
      "fussa.tokyo.jp",
      "hachijo.tokyo.jp",
      "hachioji.tokyo.jp",
      "hamura.tokyo.jp",
      "higashikurume.tokyo.jp",
      "higashimurayama.tokyo.jp",
      "higashiyamato.tokyo.jp",
      "hino.tokyo.jp",
      "hinode.tokyo.jp",
      "hinohara.tokyo.jp",
      "inagi.tokyo.jp",
      "itabashi.tokyo.jp",
      "katsushika.tokyo.jp",
      "kita.tokyo.jp",
      "kiyose.tokyo.jp",
      "kodaira.tokyo.jp",
      "koganei.tokyo.jp",
      "kokubunji.tokyo.jp",
      "komae.tokyo.jp",
      "koto.tokyo.jp",
      "kouzushima.tokyo.jp",
      "kunitachi.tokyo.jp",
      "machida.tokyo.jp",
      "meguro.tokyo.jp",
      "minato.tokyo.jp",
      "mitaka.tokyo.jp",
      "mizuho.tokyo.jp",
      "musashimurayama.tokyo.jp",
      "musashino.tokyo.jp",
      "nakano.tokyo.jp",
      "nerima.tokyo.jp",
      "ogasawara.tokyo.jp",
      "okutama.tokyo.jp",
      "ome.tokyo.jp",
      "oshima.tokyo.jp",
      "ota.tokyo.jp",
      "setagaya.tokyo.jp",
      "shibuya.tokyo.jp",
      "shinagawa.tokyo.jp",
      "shinjuku.tokyo.jp",
      "suginami.tokyo.jp",
      "sumida.tokyo.jp",
      "tachikawa.tokyo.jp",
      "taito.tokyo.jp",
      "tama.tokyo.jp",
      "toshima.tokyo.jp",
      "chizu.tottori.jp",
      "hino.tottori.jp",
      "kawahara.tottori.jp",
      "koge.tottori.jp",
      "kotoura.tottori.jp",
      "misasa.tottori.jp",
      "nanbu.tottori.jp",
      "nichinan.tottori.jp",
      "sakaiminato.tottori.jp",
      "tottori.tottori.jp",
      "wakasa.tottori.jp",
      "yazu.tottori.jp",
      "yonago.tottori.jp",
      "asahi.toyama.jp",
      "fuchu.toyama.jp",
      "fukumitsu.toyama.jp",
      "funahashi.toyama.jp",
      "himi.toyama.jp",
      "imizu.toyama.jp",
      "inami.toyama.jp",
      "johana.toyama.jp",
      "kamiichi.toyama.jp",
      "kurobe.toyama.jp",
      "nakaniikawa.toyama.jp",
      "namerikawa.toyama.jp",
      "nanto.toyama.jp",
      "nyuzen.toyama.jp",
      "oyabe.toyama.jp",
      "taira.toyama.jp",
      "takaoka.toyama.jp",
      "tateyama.toyama.jp",
      "toga.toyama.jp",
      "tonami.toyama.jp",
      "toyama.toyama.jp",
      "unazuki.toyama.jp",
      "uozu.toyama.jp",
      "yamada.toyama.jp",
      "arida.wakayama.jp",
      "aridagawa.wakayama.jp",
      "gobo.wakayama.jp",
      "hashimoto.wakayama.jp",
      "hidaka.wakayama.jp",
      "hirogawa.wakayama.jp",
      "inami.wakayama.jp",
      "iwade.wakayama.jp",
      "kainan.wakayama.jp",
      "kamitonda.wakayama.jp",
      "katsuragi.wakayama.jp",
      "kimino.wakayama.jp",
      "kinokawa.wakayama.jp",
      "kitayama.wakayama.jp",
      "koya.wakayama.jp",
      "koza.wakayama.jp",
      "kozagawa.wakayama.jp",
      "kudoyama.wakayama.jp",
      "kushimoto.wakayama.jp",
      "mihama.wakayama.jp",
      "misato.wakayama.jp",
      "nachikatsuura.wakayama.jp",
      "shingu.wakayama.jp",
      "shirahama.wakayama.jp",
      "taiji.wakayama.jp",
      "tanabe.wakayama.jp",
      "wakayama.wakayama.jp",
      "yuasa.wakayama.jp",
      "yura.wakayama.jp",
      "asahi.yamagata.jp",
      "funagata.yamagata.jp",
      "higashine.yamagata.jp",
      "iide.yamagata.jp",
      "kahoku.yamagata.jp",
      "kaminoyama.yamagata.jp",
      "kaneyama.yamagata.jp",
      "kawanishi.yamagata.jp",
      "mamurogawa.yamagata.jp",
      "mikawa.yamagata.jp",
      "murayama.yamagata.jp",
      "nagai.yamagata.jp",
      "nakayama.yamagata.jp",
      "nanyo.yamagata.jp",
      "nishikawa.yamagata.jp",
      "obanazawa.yamagata.jp",
      "oe.yamagata.jp",
      "oguni.yamagata.jp",
      "ohkura.yamagata.jp",
      "oishida.yamagata.jp",
      "sagae.yamagata.jp",
      "sakata.yamagata.jp",
      "sakegawa.yamagata.jp",
      "shinjo.yamagata.jp",
      "shirataka.yamagata.jp",
      "shonai.yamagata.jp",
      "takahata.yamagata.jp",
      "tendo.yamagata.jp",
      "tozawa.yamagata.jp",
      "tsuruoka.yamagata.jp",
      "yamagata.yamagata.jp",
      "yamanobe.yamagata.jp",
      "yonezawa.yamagata.jp",
      "yuza.yamagata.jp",
      "abu.yamaguchi.jp",
      "hagi.yamaguchi.jp",
      "hikari.yamaguchi.jp",
      "hofu.yamaguchi.jp",
      "iwakuni.yamaguchi.jp",
      "kudamatsu.yamaguchi.jp",
      "mitou.yamaguchi.jp",
      "nagato.yamaguchi.jp",
      "oshima.yamaguchi.jp",
      "shimonoseki.yamaguchi.jp",
      "shunan.yamaguchi.jp",
      "tabuse.yamaguchi.jp",
      "tokuyama.yamaguchi.jp",
      "toyota.yamaguchi.jp",
      "ube.yamaguchi.jp",
      "yuu.yamaguchi.jp",
      "chuo.yamanashi.jp",
      "doshi.yamanashi.jp",
      "fuefuki.yamanashi.jp",
      "fujikawa.yamanashi.jp",
      "fujikawaguchiko.yamanashi.jp",
      "fujiyoshida.yamanashi.jp",
      "hayakawa.yamanashi.jp",
      "hokuto.yamanashi.jp",
      "ichikawamisato.yamanashi.jp",
      "kai.yamanashi.jp",
      "kofu.yamanashi.jp",
      "koshu.yamanashi.jp",
      "kosuge.yamanashi.jp",
      "minami-alps.yamanashi.jp",
      "minobu.yamanashi.jp",
      "nakamichi.yamanashi.jp",
      "nanbu.yamanashi.jp",
      "narusawa.yamanashi.jp",
      "nirasaki.yamanashi.jp",
      "nishikatsura.yamanashi.jp",
      "oshino.yamanashi.jp",
      "otsuki.yamanashi.jp",
      "showa.yamanashi.jp",
      "tabayama.yamanashi.jp",
      "tsuru.yamanashi.jp",
      "uenohara.yamanashi.jp",
      "yamanakako.yamanashi.jp",
      "yamanashi.yamanashi.jp",
      "ke",
      "ac.ke",
      "co.ke",
      "go.ke",
      "info.ke",
      "me.ke",
      "mobi.ke",
      "ne.ke",
      "or.ke",
      "sc.ke",
      "kg",
      "org.kg",
      "net.kg",
      "com.kg",
      "edu.kg",
      "gov.kg",
      "mil.kg",
      "*.kh",
      "ki",
      "edu.ki",
      "biz.ki",
      "net.ki",
      "org.ki",
      "gov.ki",
      "info.ki",
      "com.ki",
      "km",
      "org.km",
      "nom.km",
      "gov.km",
      "prd.km",
      "tm.km",
      "edu.km",
      "mil.km",
      "ass.km",
      "com.km",
      "coop.km",
      "asso.km",
      "presse.km",
      "medecin.km",
      "notaires.km",
      "pharmaciens.km",
      "veterinaire.km",
      "gouv.km",
      "kn",
      "net.kn",
      "org.kn",
      "edu.kn",
      "gov.kn",
      "kp",
      "com.kp",
      "edu.kp",
      "gov.kp",
      "org.kp",
      "rep.kp",
      "tra.kp",
      "kr",
      "ac.kr",
      "co.kr",
      "es.kr",
      "go.kr",
      "hs.kr",
      "kg.kr",
      "mil.kr",
      "ms.kr",
      "ne.kr",
      "or.kr",
      "pe.kr",
      "re.kr",
      "sc.kr",
      "busan.kr",
      "chungbuk.kr",
      "chungnam.kr",
      "daegu.kr",
      "daejeon.kr",
      "gangwon.kr",
      "gwangju.kr",
      "gyeongbuk.kr",
      "gyeonggi.kr",
      "gyeongnam.kr",
      "incheon.kr",
      "jeju.kr",
      "jeonbuk.kr",
      "jeonnam.kr",
      "seoul.kr",
      "ulsan.kr",
      "kw",
      "com.kw",
      "edu.kw",
      "emb.kw",
      "gov.kw",
      "ind.kw",
      "net.kw",
      "org.kw",
      "ky",
      "com.ky",
      "edu.ky",
      "net.ky",
      "org.ky",
      "kz",
      "org.kz",
      "edu.kz",
      "net.kz",
      "gov.kz",
      "mil.kz",
      "com.kz",
      "la",
      "int.la",
      "net.la",
      "info.la",
      "edu.la",
      "gov.la",
      "per.la",
      "com.la",
      "org.la",
      "lb",
      "com.lb",
      "edu.lb",
      "gov.lb",
      "net.lb",
      "org.lb",
      "lc",
      "com.lc",
      "net.lc",
      "co.lc",
      "org.lc",
      "edu.lc",
      "gov.lc",
      "li",
      "lk",
      "gov.lk",
      "sch.lk",
      "net.lk",
      "int.lk",
      "com.lk",
      "org.lk",
      "edu.lk",
      "ngo.lk",
      "soc.lk",
      "web.lk",
      "ltd.lk",
      "assn.lk",
      "grp.lk",
      "hotel.lk",
      "ac.lk",
      "lr",
      "com.lr",
      "edu.lr",
      "gov.lr",
      "org.lr",
      "net.lr",
      "ls",
      "ac.ls",
      "biz.ls",
      "co.ls",
      "edu.ls",
      "gov.ls",
      "info.ls",
      "net.ls",
      "org.ls",
      "sc.ls",
      "lt",
      "gov.lt",
      "lu",
      "lv",
      "com.lv",
      "edu.lv",
      "gov.lv",
      "org.lv",
      "mil.lv",
      "id.lv",
      "net.lv",
      "asn.lv",
      "conf.lv",
      "ly",
      "com.ly",
      "net.ly",
      "gov.ly",
      "plc.ly",
      "edu.ly",
      "sch.ly",
      "med.ly",
      "org.ly",
      "id.ly",
      "ma",
      "co.ma",
      "net.ma",
      "gov.ma",
      "org.ma",
      "ac.ma",
      "press.ma",
      "mc",
      "tm.mc",
      "asso.mc",
      "md",
      "me",
      "co.me",
      "net.me",
      "org.me",
      "edu.me",
      "ac.me",
      "gov.me",
      "its.me",
      "priv.me",
      "mg",
      "org.mg",
      "nom.mg",
      "gov.mg",
      "prd.mg",
      "tm.mg",
      "edu.mg",
      "mil.mg",
      "com.mg",
      "co.mg",
      "mh",
      "mil",
      "mk",
      "com.mk",
      "org.mk",
      "net.mk",
      "edu.mk",
      "gov.mk",
      "inf.mk",
      "name.mk",
      "ml",
      "com.ml",
      "edu.ml",
      "gouv.ml",
      "gov.ml",
      "net.ml",
      "org.ml",
      "presse.ml",
      "*.mm",
      "mn",
      "gov.mn",
      "edu.mn",
      "org.mn",
      "mo",
      "com.mo",
      "net.mo",
      "org.mo",
      "edu.mo",
      "gov.mo",
      "mobi",
      "mp",
      "mq",
      "mr",
      "gov.mr",
      "ms",
      "com.ms",
      "edu.ms",
      "gov.ms",
      "net.ms",
      "org.ms",
      "mt",
      "com.mt",
      "edu.mt",
      "net.mt",
      "org.mt",
      "mu",
      "com.mu",
      "net.mu",
      "org.mu",
      "gov.mu",
      "ac.mu",
      "co.mu",
      "or.mu",
      "museum",
      "academy.museum",
      "agriculture.museum",
      "air.museum",
      "airguard.museum",
      "alabama.museum",
      "alaska.museum",
      "amber.museum",
      "ambulance.museum",
      "american.museum",
      "americana.museum",
      "americanantiques.museum",
      "americanart.museum",
      "amsterdam.museum",
      "and.museum",
      "annefrank.museum",
      "anthro.museum",
      "anthropology.museum",
      "antiques.museum",
      "aquarium.museum",
      "arboretum.museum",
      "archaeological.museum",
      "archaeology.museum",
      "architecture.museum",
      "art.museum",
      "artanddesign.museum",
      "artcenter.museum",
      "artdeco.museum",
      "arteducation.museum",
      "artgallery.museum",
      "arts.museum",
      "artsandcrafts.museum",
      "asmatart.museum",
      "assassination.museum",
      "assisi.museum",
      "association.museum",
      "astronomy.museum",
      "atlanta.museum",
      "austin.museum",
      "australia.museum",
      "automotive.museum",
      "aviation.museum",
      "axis.museum",
      "badajoz.museum",
      "baghdad.museum",
      "bahn.museum",
      "bale.museum",
      "baltimore.museum",
      "barcelona.museum",
      "baseball.museum",
      "basel.museum",
      "baths.museum",
      "bauern.museum",
      "beauxarts.museum",
      "beeldengeluid.museum",
      "bellevue.museum",
      "bergbau.museum",
      "berkeley.museum",
      "berlin.museum",
      "bern.museum",
      "bible.museum",
      "bilbao.museum",
      "bill.museum",
      "birdart.museum",
      "birthplace.museum",
      "bonn.museum",
      "boston.museum",
      "botanical.museum",
      "botanicalgarden.museum",
      "botanicgarden.museum",
      "botany.museum",
      "brandywinevalley.museum",
      "brasil.museum",
      "bristol.museum",
      "british.museum",
      "britishcolumbia.museum",
      "broadcast.museum",
      "brunel.museum",
      "brussel.museum",
      "brussels.museum",
      "bruxelles.museum",
      "building.museum",
      "burghof.museum",
      "bus.museum",
      "bushey.museum",
      "cadaques.museum",
      "california.museum",
      "cambridge.museum",
      "can.museum",
      "canada.museum",
      "capebreton.museum",
      "carrier.museum",
      "cartoonart.museum",
      "casadelamoneda.museum",
      "castle.museum",
      "castres.museum",
      "celtic.museum",
      "center.museum",
      "chattanooga.museum",
      "cheltenham.museum",
      "chesapeakebay.museum",
      "chicago.museum",
      "children.museum",
      "childrens.museum",
      "childrensgarden.museum",
      "chiropractic.museum",
      "chocolate.museum",
      "christiansburg.museum",
      "cincinnati.museum",
      "cinema.museum",
      "circus.museum",
      "civilisation.museum",
      "civilization.museum",
      "civilwar.museum",
      "clinton.museum",
      "clock.museum",
      "coal.museum",
      "coastaldefence.museum",
      "cody.museum",
      "coldwar.museum",
      "collection.museum",
      "colonialwilliamsburg.museum",
      "coloradoplateau.museum",
      "columbia.museum",
      "columbus.museum",
      "communication.museum",
      "communications.museum",
      "community.museum",
      "computer.museum",
      "computerhistory.museum",
      "comunica\xE7\xF5es.museum",
      "contemporary.museum",
      "contemporaryart.museum",
      "convent.museum",
      "copenhagen.museum",
      "corporation.museum",
      "correios-e-telecomunica\xE7\xF5es.museum",
      "corvette.museum",
      "costume.museum",
      "countryestate.museum",
      "county.museum",
      "crafts.museum",
      "cranbrook.museum",
      "creation.museum",
      "cultural.museum",
      "culturalcenter.museum",
      "culture.museum",
      "cyber.museum",
      "cymru.museum",
      "dali.museum",
      "dallas.museum",
      "database.museum",
      "ddr.museum",
      "decorativearts.museum",
      "delaware.museum",
      "delmenhorst.museum",
      "denmark.museum",
      "depot.museum",
      "design.museum",
      "detroit.museum",
      "dinosaur.museum",
      "discovery.museum",
      "dolls.museum",
      "donostia.museum",
      "durham.museum",
      "eastafrica.museum",
      "eastcoast.museum",
      "education.museum",
      "educational.museum",
      "egyptian.museum",
      "eisenbahn.museum",
      "elburg.museum",
      "elvendrell.museum",
      "embroidery.museum",
      "encyclopedic.museum",
      "england.museum",
      "entomology.museum",
      "environment.museum",
      "environmentalconservation.museum",
      "epilepsy.museum",
      "essex.museum",
      "estate.museum",
      "ethnology.museum",
      "exeter.museum",
      "exhibition.museum",
      "family.museum",
      "farm.museum",
      "farmequipment.museum",
      "farmers.museum",
      "farmstead.museum",
      "field.museum",
      "figueres.museum",
      "filatelia.museum",
      "film.museum",
      "fineart.museum",
      "finearts.museum",
      "finland.museum",
      "flanders.museum",
      "florida.museum",
      "force.museum",
      "fortmissoula.museum",
      "fortworth.museum",
      "foundation.museum",
      "francaise.museum",
      "frankfurt.museum",
      "franziskaner.museum",
      "freemasonry.museum",
      "freiburg.museum",
      "fribourg.museum",
      "frog.museum",
      "fundacio.museum",
      "furniture.museum",
      "gallery.museum",
      "garden.museum",
      "gateway.museum",
      "geelvinck.museum",
      "gemological.museum",
      "geology.museum",
      "georgia.museum",
      "giessen.museum",
      "glas.museum",
      "glass.museum",
      "gorge.museum",
      "grandrapids.museum",
      "graz.museum",
      "guernsey.museum",
      "halloffame.museum",
      "hamburg.museum",
      "handson.museum",
      "harvestcelebration.museum",
      "hawaii.museum",
      "health.museum",
      "heimatunduhren.museum",
      "hellas.museum",
      "helsinki.museum",
      "hembygdsforbund.museum",
      "heritage.museum",
      "histoire.museum",
      "historical.museum",
      "historicalsociety.museum",
      "historichouses.museum",
      "historisch.museum",
      "historisches.museum",
      "history.museum",
      "historyofscience.museum",
      "horology.museum",
      "house.museum",
      "humanities.museum",
      "illustration.museum",
      "imageandsound.museum",
      "indian.museum",
      "indiana.museum",
      "indianapolis.museum",
      "indianmarket.museum",
      "intelligence.museum",
      "interactive.museum",
      "iraq.museum",
      "iron.museum",
      "isleofman.museum",
      "jamison.museum",
      "jefferson.museum",
      "jerusalem.museum",
      "jewelry.museum",
      "jewish.museum",
      "jewishart.museum",
      "jfk.museum",
      "journalism.museum",
      "judaica.museum",
      "judygarland.museum",
      "juedisches.museum",
      "juif.museum",
      "karate.museum",
      "karikatur.museum",
      "kids.museum",
      "koebenhavn.museum",
      "koeln.museum",
      "kunst.museum",
      "kunstsammlung.museum",
      "kunstunddesign.museum",
      "labor.museum",
      "labour.museum",
      "lajolla.museum",
      "lancashire.museum",
      "landes.museum",
      "lans.museum",
      "l\xE4ns.museum",
      "larsson.museum",
      "lewismiller.museum",
      "lincoln.museum",
      "linz.museum",
      "living.museum",
      "livinghistory.museum",
      "localhistory.museum",
      "london.museum",
      "losangeles.museum",
      "louvre.museum",
      "loyalist.museum",
      "lucerne.museum",
      "luxembourg.museum",
      "luzern.museum",
      "mad.museum",
      "madrid.museum",
      "mallorca.museum",
      "manchester.museum",
      "mansion.museum",
      "mansions.museum",
      "manx.museum",
      "marburg.museum",
      "maritime.museum",
      "maritimo.museum",
      "maryland.museum",
      "marylhurst.museum",
      "media.museum",
      "medical.museum",
      "medizinhistorisches.museum",
      "meeres.museum",
      "memorial.museum",
      "mesaverde.museum",
      "michigan.museum",
      "midatlantic.museum",
      "military.museum",
      "mill.museum",
      "miners.museum",
      "mining.museum",
      "minnesota.museum",
      "missile.museum",
      "missoula.museum",
      "modern.museum",
      "moma.museum",
      "money.museum",
      "monmouth.museum",
      "monticello.museum",
      "montreal.museum",
      "moscow.museum",
      "motorcycle.museum",
      "muenchen.museum",
      "muenster.museum",
      "mulhouse.museum",
      "muncie.museum",
      "museet.museum",
      "museumcenter.museum",
      "museumvereniging.museum",
      "music.museum",
      "national.museum",
      "nationalfirearms.museum",
      "nationalheritage.museum",
      "nativeamerican.museum",
      "naturalhistory.museum",
      "naturalhistorymuseum.museum",
      "naturalsciences.museum",
      "nature.museum",
      "naturhistorisches.museum",
      "natuurwetenschappen.museum",
      "naumburg.museum",
      "naval.museum",
      "nebraska.museum",
      "neues.museum",
      "newhampshire.museum",
      "newjersey.museum",
      "newmexico.museum",
      "newport.museum",
      "newspaper.museum",
      "newyork.museum",
      "niepce.museum",
      "norfolk.museum",
      "north.museum",
      "nrw.museum",
      "nyc.museum",
      "nyny.museum",
      "oceanographic.museum",
      "oceanographique.museum",
      "omaha.museum",
      "online.museum",
      "ontario.museum",
      "openair.museum",
      "oregon.museum",
      "oregontrail.museum",
      "otago.museum",
      "oxford.museum",
      "pacific.museum",
      "paderborn.museum",
      "palace.museum",
      "paleo.museum",
      "palmsprings.museum",
      "panama.museum",
      "paris.museum",
      "pasadena.museum",
      "pharmacy.museum",
      "philadelphia.museum",
      "philadelphiaarea.museum",
      "philately.museum",
      "phoenix.museum",
      "photography.museum",
      "pilots.museum",
      "pittsburgh.museum",
      "planetarium.museum",
      "plantation.museum",
      "plants.museum",
      "plaza.museum",
      "portal.museum",
      "portland.museum",
      "portlligat.museum",
      "posts-and-telecommunications.museum",
      "preservation.museum",
      "presidio.museum",
      "press.museum",
      "project.museum",
      "public.museum",
      "pubol.museum",
      "quebec.museum",
      "railroad.museum",
      "railway.museum",
      "research.museum",
      "resistance.museum",
      "riodejaneiro.museum",
      "rochester.museum",
      "rockart.museum",
      "roma.museum",
      "russia.museum",
      "saintlouis.museum",
      "salem.museum",
      "salvadordali.museum",
      "salzburg.museum",
      "sandiego.museum",
      "sanfrancisco.museum",
      "santabarbara.museum",
      "santacruz.museum",
      "santafe.museum",
      "saskatchewan.museum",
      "satx.museum",
      "savannahga.museum",
      "schlesisches.museum",
      "schoenbrunn.museum",
      "schokoladen.museum",
      "school.museum",
      "schweiz.museum",
      "science.museum",
      "scienceandhistory.museum",
      "scienceandindustry.museum",
      "sciencecenter.museum",
      "sciencecenters.museum",
      "science-fiction.museum",
      "sciencehistory.museum",
      "sciences.museum",
      "sciencesnaturelles.museum",
      "scotland.museum",
      "seaport.museum",
      "settlement.museum",
      "settlers.museum",
      "shell.museum",
      "sherbrooke.museum",
      "sibenik.museum",
      "silk.museum",
      "ski.museum",
      "skole.museum",
      "society.museum",
      "sologne.museum",
      "soundandvision.museum",
      "southcarolina.museum",
      "southwest.museum",
      "space.museum",
      "spy.museum",
      "square.museum",
      "stadt.museum",
      "stalbans.museum",
      "starnberg.museum",
      "state.museum",
      "stateofdelaware.museum",
      "station.museum",
      "steam.museum",
      "steiermark.museum",
      "stjohn.museum",
      "stockholm.museum",
      "stpetersburg.museum",
      "stuttgart.museum",
      "suisse.museum",
      "surgeonshall.museum",
      "surrey.museum",
      "svizzera.museum",
      "sweden.museum",
      "sydney.museum",
      "tank.museum",
      "tcm.museum",
      "technology.museum",
      "telekommunikation.museum",
      "television.museum",
      "texas.museum",
      "textile.museum",
      "theater.museum",
      "time.museum",
      "timekeeping.museum",
      "topology.museum",
      "torino.museum",
      "touch.museum",
      "town.museum",
      "transport.museum",
      "tree.museum",
      "trolley.museum",
      "trust.museum",
      "trustee.museum",
      "uhren.museum",
      "ulm.museum",
      "undersea.museum",
      "university.museum",
      "usa.museum",
      "usantiques.museum",
      "usarts.museum",
      "uscountryestate.museum",
      "usculture.museum",
      "usdecorativearts.museum",
      "usgarden.museum",
      "ushistory.museum",
      "ushuaia.museum",
      "uslivinghistory.museum",
      "utah.museum",
      "uvic.museum",
      "valley.museum",
      "vantaa.museum",
      "versailles.museum",
      "viking.museum",
      "village.museum",
      "virginia.museum",
      "virtual.museum",
      "virtuel.museum",
      "vlaanderen.museum",
      "volkenkunde.museum",
      "wales.museum",
      "wallonie.museum",
      "war.museum",
      "washingtondc.museum",
      "watchandclock.museum",
      "watch-and-clock.museum",
      "western.museum",
      "westfalen.museum",
      "whaling.museum",
      "wildlife.museum",
      "williamsburg.museum",
      "windmill.museum",
      "workshop.museum",
      "york.museum",
      "yorkshire.museum",
      "yosemite.museum",
      "youth.museum",
      "zoological.museum",
      "zoology.museum",
      "\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum",
      "\u0438\u043A\u043E\u043C.museum",
      "mv",
      "aero.mv",
      "biz.mv",
      "com.mv",
      "coop.mv",
      "edu.mv",
      "gov.mv",
      "info.mv",
      "int.mv",
      "mil.mv",
      "museum.mv",
      "name.mv",
      "net.mv",
      "org.mv",
      "pro.mv",
      "mw",
      "ac.mw",
      "biz.mw",
      "co.mw",
      "com.mw",
      "coop.mw",
      "edu.mw",
      "gov.mw",
      "int.mw",
      "museum.mw",
      "net.mw",
      "org.mw",
      "mx",
      "com.mx",
      "org.mx",
      "gob.mx",
      "edu.mx",
      "net.mx",
      "my",
      "biz.my",
      "com.my",
      "edu.my",
      "gov.my",
      "mil.my",
      "name.my",
      "net.my",
      "org.my",
      "mz",
      "ac.mz",
      "adv.mz",
      "co.mz",
      "edu.mz",
      "gov.mz",
      "mil.mz",
      "net.mz",
      "org.mz",
      "na",
      "info.na",
      "pro.na",
      "name.na",
      "school.na",
      "or.na",
      "dr.na",
      "us.na",
      "mx.na",
      "ca.na",
      "in.na",
      "cc.na",
      "tv.na",
      "ws.na",
      "mobi.na",
      "co.na",
      "com.na",
      "org.na",
      "name",
      "nc",
      "asso.nc",
      "nom.nc",
      "ne",
      "net",
      "nf",
      "com.nf",
      "net.nf",
      "per.nf",
      "rec.nf",
      "web.nf",
      "arts.nf",
      "firm.nf",
      "info.nf",
      "other.nf",
      "store.nf",
      "ng",
      "com.ng",
      "edu.ng",
      "gov.ng",
      "i.ng",
      "mil.ng",
      "mobi.ng",
      "name.ng",
      "net.ng",
      "org.ng",
      "sch.ng",
      "ni",
      "ac.ni",
      "biz.ni",
      "co.ni",
      "com.ni",
      "edu.ni",
      "gob.ni",
      "in.ni",
      "info.ni",
      "int.ni",
      "mil.ni",
      "net.ni",
      "nom.ni",
      "org.ni",
      "web.ni",
      "nl",
      "no",
      "fhs.no",
      "vgs.no",
      "fylkesbibl.no",
      "folkebibl.no",
      "museum.no",
      "idrett.no",
      "priv.no",
      "mil.no",
      "stat.no",
      "dep.no",
      "kommune.no",
      "herad.no",
      "aa.no",
      "ah.no",
      "bu.no",
      "fm.no",
      "hl.no",
      "hm.no",
      "jan-mayen.no",
      "mr.no",
      "nl.no",
      "nt.no",
      "of.no",
      "ol.no",
      "oslo.no",
      "rl.no",
      "sf.no",
      "st.no",
      "svalbard.no",
      "tm.no",
      "tr.no",
      "va.no",
      "vf.no",
      "gs.aa.no",
      "gs.ah.no",
      "gs.bu.no",
      "gs.fm.no",
      "gs.hl.no",
      "gs.hm.no",
      "gs.jan-mayen.no",
      "gs.mr.no",
      "gs.nl.no",
      "gs.nt.no",
      "gs.of.no",
      "gs.ol.no",
      "gs.oslo.no",
      "gs.rl.no",
      "gs.sf.no",
      "gs.st.no",
      "gs.svalbard.no",
      "gs.tm.no",
      "gs.tr.no",
      "gs.va.no",
      "gs.vf.no",
      "akrehamn.no",
      "\xE5krehamn.no",
      "algard.no",
      "\xE5lg\xE5rd.no",
      "arna.no",
      "brumunddal.no",
      "bryne.no",
      "bronnoysund.no",
      "br\xF8nn\xF8ysund.no",
      "drobak.no",
      "dr\xF8bak.no",
      "egersund.no",
      "fetsund.no",
      "floro.no",
      "flor\xF8.no",
      "fredrikstad.no",
      "hokksund.no",
      "honefoss.no",
      "h\xF8nefoss.no",
      "jessheim.no",
      "jorpeland.no",
      "j\xF8rpeland.no",
      "kirkenes.no",
      "kopervik.no",
      "krokstadelva.no",
      "langevag.no",
      "langev\xE5g.no",
      "leirvik.no",
      "mjondalen.no",
      "mj\xF8ndalen.no",
      "mo-i-rana.no",
      "mosjoen.no",
      "mosj\xF8en.no",
      "nesoddtangen.no",
      "orkanger.no",
      "osoyro.no",
      "os\xF8yro.no",
      "raholt.no",
      "r\xE5holt.no",
      "sandnessjoen.no",
      "sandnessj\xF8en.no",
      "skedsmokorset.no",
      "slattum.no",
      "spjelkavik.no",
      "stathelle.no",
      "stavern.no",
      "stjordalshalsen.no",
      "stj\xF8rdalshalsen.no",
      "tananger.no",
      "tranby.no",
      "vossevangen.no",
      "afjord.no",
      "\xE5fjord.no",
      "agdenes.no",
      "al.no",
      "\xE5l.no",
      "alesund.no",
      "\xE5lesund.no",
      "alstahaug.no",
      "alta.no",
      "\xE1lt\xE1.no",
      "alaheadju.no",
      "\xE1laheadju.no",
      "alvdal.no",
      "amli.no",
      "\xE5mli.no",
      "amot.no",
      "\xE5mot.no",
      "andebu.no",
      "andoy.no",
      "and\xF8y.no",
      "andasuolo.no",
      "ardal.no",
      "\xE5rdal.no",
      "aremark.no",
      "arendal.no",
      "\xE5s.no",
      "aseral.no",
      "\xE5seral.no",
      "asker.no",
      "askim.no",
      "askvoll.no",
      "askoy.no",
      "ask\xF8y.no",
      "asnes.no",
      "\xE5snes.no",
      "audnedaln.no",
      "aukra.no",
      "aure.no",
      "aurland.no",
      "aurskog-holand.no",
      "aurskog-h\xF8land.no",
      "austevoll.no",
      "austrheim.no",
      "averoy.no",
      "aver\xF8y.no",
      "balestrand.no",
      "ballangen.no",
      "balat.no",
      "b\xE1l\xE1t.no",
      "balsfjord.no",
      "bahccavuotna.no",
      "b\xE1hccavuotna.no",
      "bamble.no",
      "bardu.no",
      "beardu.no",
      "beiarn.no",
      "bajddar.no",
      "b\xE1jddar.no",
      "baidar.no",
      "b\xE1id\xE1r.no",
      "berg.no",
      "bergen.no",
      "berlevag.no",
      "berlev\xE5g.no",
      "bearalvahki.no",
      "bearalv\xE1hki.no",
      "bindal.no",
      "birkenes.no",
      "bjarkoy.no",
      "bjark\xF8y.no",
      "bjerkreim.no",
      "bjugn.no",
      "bodo.no",
      "bod\xF8.no",
      "badaddja.no",
      "b\xE5d\xE5ddj\xE5.no",
      "budejju.no",
      "bokn.no",
      "bremanger.no",
      "bronnoy.no",
      "br\xF8nn\xF8y.no",
      "bygland.no",
      "bykle.no",
      "barum.no",
      "b\xE6rum.no",
      "bo.telemark.no",
      "b\xF8.telemark.no",
      "bo.nordland.no",
      "b\xF8.nordland.no",
      "bievat.no",
      "biev\xE1t.no",
      "bomlo.no",
      "b\xF8mlo.no",
      "batsfjord.no",
      "b\xE5tsfjord.no",
      "bahcavuotna.no",
      "b\xE1hcavuotna.no",
      "dovre.no",
      "drammen.no",
      "drangedal.no",
      "dyroy.no",
      "dyr\xF8y.no",
      "donna.no",
      "d\xF8nna.no",
      "eid.no",
      "eidfjord.no",
      "eidsberg.no",
      "eidskog.no",
      "eidsvoll.no",
      "eigersund.no",
      "elverum.no",
      "enebakk.no",
      "engerdal.no",
      "etne.no",
      "etnedal.no",
      "evenes.no",
      "evenassi.no",
      "even\xE1\u0161\u0161i.no",
      "evje-og-hornnes.no",
      "farsund.no",
      "fauske.no",
      "fuossko.no",
      "fuoisku.no",
      "fedje.no",
      "fet.no",
      "finnoy.no",
      "finn\xF8y.no",
      "fitjar.no",
      "fjaler.no",
      "fjell.no",
      "flakstad.no",
      "flatanger.no",
      "flekkefjord.no",
      "flesberg.no",
      "flora.no",
      "fla.no",
      "fl\xE5.no",
      "folldal.no",
      "forsand.no",
      "fosnes.no",
      "frei.no",
      "frogn.no",
      "froland.no",
      "frosta.no",
      "frana.no",
      "fr\xE6na.no",
      "froya.no",
      "fr\xF8ya.no",
      "fusa.no",
      "fyresdal.no",
      "forde.no",
      "f\xF8rde.no",
      "gamvik.no",
      "gangaviika.no",
      "g\xE1\u014Bgaviika.no",
      "gaular.no",
      "gausdal.no",
      "gildeskal.no",
      "gildesk\xE5l.no",
      "giske.no",
      "gjemnes.no",
      "gjerdrum.no",
      "gjerstad.no",
      "gjesdal.no",
      "gjovik.no",
      "gj\xF8vik.no",
      "gloppen.no",
      "gol.no",
      "gran.no",
      "grane.no",
      "granvin.no",
      "gratangen.no",
      "grimstad.no",
      "grong.no",
      "kraanghke.no",
      "kr\xE5anghke.no",
      "grue.no",
      "gulen.no",
      "hadsel.no",
      "halden.no",
      "halsa.no",
      "hamar.no",
      "hamaroy.no",
      "habmer.no",
      "h\xE1bmer.no",
      "hapmir.no",
      "h\xE1pmir.no",
      "hammerfest.no",
      "hammarfeasta.no",
      "h\xE1mm\xE1rfeasta.no",
      "haram.no",
      "hareid.no",
      "harstad.no",
      "hasvik.no",
      "aknoluokta.no",
      "\xE1k\u014Boluokta.no",
      "hattfjelldal.no",
      "aarborte.no",
      "haugesund.no",
      "hemne.no",
      "hemnes.no",
      "hemsedal.no",
      "heroy.more-og-romsdal.no",
      "her\xF8y.m\xF8re-og-romsdal.no",
      "heroy.nordland.no",
      "her\xF8y.nordland.no",
      "hitra.no",
      "hjartdal.no",
      "hjelmeland.no",
      "hobol.no",
      "hob\xF8l.no",
      "hof.no",
      "hol.no",
      "hole.no",
      "holmestrand.no",
      "holtalen.no",
      "holt\xE5len.no",
      "hornindal.no",
      "horten.no",
      "hurdal.no",
      "hurum.no",
      "hvaler.no",
      "hyllestad.no",
      "hagebostad.no",
      "h\xE6gebostad.no",
      "hoyanger.no",
      "h\xF8yanger.no",
      "hoylandet.no",
      "h\xF8ylandet.no",
      "ha.no",
      "h\xE5.no",
      "ibestad.no",
      "inderoy.no",
      "inder\xF8y.no",
      "iveland.no",
      "jevnaker.no",
      "jondal.no",
      "jolster.no",
      "j\xF8lster.no",
      "karasjok.no",
      "karasjohka.no",
      "k\xE1r\xE1\u0161johka.no",
      "karlsoy.no",
      "galsa.no",
      "g\xE1ls\xE1.no",
      "karmoy.no",
      "karm\xF8y.no",
      "kautokeino.no",
      "guovdageaidnu.no",
      "klepp.no",
      "klabu.no",
      "kl\xE6bu.no",
      "kongsberg.no",
      "kongsvinger.no",
      "kragero.no",
      "krager\xF8.no",
      "kristiansand.no",
      "kristiansund.no",
      "krodsherad.no",
      "kr\xF8dsherad.no",
      "kvalsund.no",
      "rahkkeravju.no",
      "r\xE1hkker\xE1vju.no",
      "kvam.no",
      "kvinesdal.no",
      "kvinnherad.no",
      "kviteseid.no",
      "kvitsoy.no",
      "kvits\xF8y.no",
      "kvafjord.no",
      "kv\xE6fjord.no",
      "giehtavuoatna.no",
      "kvanangen.no",
      "kv\xE6nangen.no",
      "navuotna.no",
      "n\xE1vuotna.no",
      "kafjord.no",
      "k\xE5fjord.no",
      "gaivuotna.no",
      "g\xE1ivuotna.no",
      "larvik.no",
      "lavangen.no",
      "lavagis.no",
      "loabat.no",
      "loab\xE1t.no",
      "lebesby.no",
      "davvesiida.no",
      "leikanger.no",
      "leirfjord.no",
      "leka.no",
      "leksvik.no",
      "lenvik.no",
      "leangaviika.no",
      "lea\u014Bgaviika.no",
      "lesja.no",
      "levanger.no",
      "lier.no",
      "lierne.no",
      "lillehammer.no",
      "lillesand.no",
      "lindesnes.no",
      "lindas.no",
      "lind\xE5s.no",
      "lom.no",
      "loppa.no",
      "lahppi.no",
      "l\xE1hppi.no",
      "lund.no",
      "lunner.no",
      "luroy.no",
      "lur\xF8y.no",
      "luster.no",
      "lyngdal.no",
      "lyngen.no",
      "ivgu.no",
      "lardal.no",
      "lerdal.no",
      "l\xE6rdal.no",
      "lodingen.no",
      "l\xF8dingen.no",
      "lorenskog.no",
      "l\xF8renskog.no",
      "loten.no",
      "l\xF8ten.no",
      "malvik.no",
      "masoy.no",
      "m\xE5s\xF8y.no",
      "muosat.no",
      "muos\xE1t.no",
      "mandal.no",
      "marker.no",
      "marnardal.no",
      "masfjorden.no",
      "meland.no",
      "meldal.no",
      "melhus.no",
      "meloy.no",
      "mel\xF8y.no",
      "meraker.no",
      "mer\xE5ker.no",
      "moareke.no",
      "mo\xE5reke.no",
      "midsund.no",
      "midtre-gauldal.no",
      "modalen.no",
      "modum.no",
      "molde.no",
      "moskenes.no",
      "moss.no",
      "mosvik.no",
      "malselv.no",
      "m\xE5lselv.no",
      "malatvuopmi.no",
      "m\xE1latvuopmi.no",
      "namdalseid.no",
      "aejrie.no",
      "namsos.no",
      "namsskogan.no",
      "naamesjevuemie.no",
      "n\xE5\xE5mesjevuemie.no",
      "laakesvuemie.no",
      "nannestad.no",
      "narvik.no",
      "narviika.no",
      "naustdal.no",
      "nedre-eiker.no",
      "nes.akershus.no",
      "nes.buskerud.no",
      "nesna.no",
      "nesodden.no",
      "nesseby.no",
      "unjarga.no",
      "unj\xE1rga.no",
      "nesset.no",
      "nissedal.no",
      "nittedal.no",
      "nord-aurdal.no",
      "nord-fron.no",
      "nord-odal.no",
      "norddal.no",
      "nordkapp.no",
      "davvenjarga.no",
      "davvenj\xE1rga.no",
      "nordre-land.no",
      "nordreisa.no",
      "raisa.no",
      "r\xE1isa.no",
      "nore-og-uvdal.no",
      "notodden.no",
      "naroy.no",
      "n\xE6r\xF8y.no",
      "notteroy.no",
      "n\xF8tter\xF8y.no",
      "odda.no",
      "oksnes.no",
      "\xF8ksnes.no",
      "oppdal.no",
      "oppegard.no",
      "oppeg\xE5rd.no",
      "orkdal.no",
      "orland.no",
      "\xF8rland.no",
      "orskog.no",
      "\xF8rskog.no",
      "orsta.no",
      "\xF8rsta.no",
      "os.hedmark.no",
      "os.hordaland.no",
      "osen.no",
      "osteroy.no",
      "oster\xF8y.no",
      "ostre-toten.no",
      "\xF8stre-toten.no",
      "overhalla.no",
      "ovre-eiker.no",
      "\xF8vre-eiker.no",
      "oyer.no",
      "\xF8yer.no",
      "oygarden.no",
      "\xF8ygarden.no",
      "oystre-slidre.no",
      "\xF8ystre-slidre.no",
      "porsanger.no",
      "porsangu.no",
      "pors\xE1\u014Bgu.no",
      "porsgrunn.no",
      "radoy.no",
      "rad\xF8y.no",
      "rakkestad.no",
      "rana.no",
      "ruovat.no",
      "randaberg.no",
      "rauma.no",
      "rendalen.no",
      "rennebu.no",
      "rennesoy.no",
      "rennes\xF8y.no",
      "rindal.no",
      "ringebu.no",
      "ringerike.no",
      "ringsaker.no",
      "rissa.no",
      "risor.no",
      "ris\xF8r.no",
      "roan.no",
      "rollag.no",
      "rygge.no",
      "ralingen.no",
      "r\xE6lingen.no",
      "rodoy.no",
      "r\xF8d\xF8y.no",
      "romskog.no",
      "r\xF8mskog.no",
      "roros.no",
      "r\xF8ros.no",
      "rost.no",
      "r\xF8st.no",
      "royken.no",
      "r\xF8yken.no",
      "royrvik.no",
      "r\xF8yrvik.no",
      "rade.no",
      "r\xE5de.no",
      "salangen.no",
      "siellak.no",
      "saltdal.no",
      "salat.no",
      "s\xE1l\xE1t.no",
      "s\xE1lat.no",
      "samnanger.no",
      "sande.more-og-romsdal.no",
      "sande.m\xF8re-og-romsdal.no",
      "sande.vestfold.no",
      "sandefjord.no",
      "sandnes.no",
      "sandoy.no",
      "sand\xF8y.no",
      "sarpsborg.no",
      "sauda.no",
      "sauherad.no",
      "sel.no",
      "selbu.no",
      "selje.no",
      "seljord.no",
      "sigdal.no",
      "siljan.no",
      "sirdal.no",
      "skaun.no",
      "skedsmo.no",
      "ski.no",
      "skien.no",
      "skiptvet.no",
      "skjervoy.no",
      "skjerv\xF8y.no",
      "skierva.no",
      "skierv\xE1.no",
      "skjak.no",
      "skj\xE5k.no",
      "skodje.no",
      "skanland.no",
      "sk\xE5nland.no",
      "skanit.no",
      "sk\xE1nit.no",
      "smola.no",
      "sm\xF8la.no",
      "snillfjord.no",
      "snasa.no",
      "sn\xE5sa.no",
      "snoasa.no",
      "snaase.no",
      "sn\xE5ase.no",
      "sogndal.no",
      "sokndal.no",
      "sola.no",
      "solund.no",
      "songdalen.no",
      "sortland.no",
      "spydeberg.no",
      "stange.no",
      "stavanger.no",
      "steigen.no",
      "steinkjer.no",
      "stjordal.no",
      "stj\xF8rdal.no",
      "stokke.no",
      "stor-elvdal.no",
      "stord.no",
      "stordal.no",
      "storfjord.no",
      "omasvuotna.no",
      "strand.no",
      "stranda.no",
      "stryn.no",
      "sula.no",
      "suldal.no",
      "sund.no",
      "sunndal.no",
      "surnadal.no",
      "sveio.no",
      "svelvik.no",
      "sykkylven.no",
      "sogne.no",
      "s\xF8gne.no",
      "somna.no",
      "s\xF8mna.no",
      "sondre-land.no",
      "s\xF8ndre-land.no",
      "sor-aurdal.no",
      "s\xF8r-aurdal.no",
      "sor-fron.no",
      "s\xF8r-fron.no",
      "sor-odal.no",
      "s\xF8r-odal.no",
      "sor-varanger.no",
      "s\xF8r-varanger.no",
      "matta-varjjat.no",
      "m\xE1tta-v\xE1rjjat.no",
      "sorfold.no",
      "s\xF8rfold.no",
      "sorreisa.no",
      "s\xF8rreisa.no",
      "sorum.no",
      "s\xF8rum.no",
      "tana.no",
      "deatnu.no",
      "time.no",
      "tingvoll.no",
      "tinn.no",
      "tjeldsund.no",
      "dielddanuorri.no",
      "tjome.no",
      "tj\xF8me.no",
      "tokke.no",
      "tolga.no",
      "torsken.no",
      "tranoy.no",
      "tran\xF8y.no",
      "tromso.no",
      "troms\xF8.no",
      "tromsa.no",
      "romsa.no",
      "trondheim.no",
      "troandin.no",
      "trysil.no",
      "trana.no",
      "tr\xE6na.no",
      "trogstad.no",
      "tr\xF8gstad.no",
      "tvedestrand.no",
      "tydal.no",
      "tynset.no",
      "tysfjord.no",
      "divtasvuodna.no",
      "divttasvuotna.no",
      "tysnes.no",
      "tysvar.no",
      "tysv\xE6r.no",
      "tonsberg.no",
      "t\xF8nsberg.no",
      "ullensaker.no",
      "ullensvang.no",
      "ulvik.no",
      "utsira.no",
      "vadso.no",
      "vads\xF8.no",
      "cahcesuolo.no",
      "\u010D\xE1hcesuolo.no",
      "vaksdal.no",
      "valle.no",
      "vang.no",
      "vanylven.no",
      "vardo.no",
      "vard\xF8.no",
      "varggat.no",
      "v\xE1rgg\xE1t.no",
      "vefsn.no",
      "vaapste.no",
      "vega.no",
      "vegarshei.no",
      "veg\xE5rshei.no",
      "vennesla.no",
      "verdal.no",
      "verran.no",
      "vestby.no",
      "vestnes.no",
      "vestre-slidre.no",
      "vestre-toten.no",
      "vestvagoy.no",
      "vestv\xE5g\xF8y.no",
      "vevelstad.no",
      "vik.no",
      "vikna.no",
      "vindafjord.no",
      "volda.no",
      "voss.no",
      "varoy.no",
      "v\xE6r\xF8y.no",
      "vagan.no",
      "v\xE5gan.no",
      "voagat.no",
      "vagsoy.no",
      "v\xE5gs\xF8y.no",
      "vaga.no",
      "v\xE5g\xE5.no",
      "valer.ostfold.no",
      "v\xE5ler.\xF8stfold.no",
      "valer.hedmark.no",
      "v\xE5ler.hedmark.no",
      "*.np",
      "nr",
      "biz.nr",
      "info.nr",
      "gov.nr",
      "edu.nr",
      "org.nr",
      "net.nr",
      "com.nr",
      "nu",
      "nz",
      "ac.nz",
      "co.nz",
      "cri.nz",
      "geek.nz",
      "gen.nz",
      "govt.nz",
      "health.nz",
      "iwi.nz",
      "kiwi.nz",
      "maori.nz",
      "mil.nz",
      "m\u0101ori.nz",
      "net.nz",
      "org.nz",
      "parliament.nz",
      "school.nz",
      "om",
      "co.om",
      "com.om",
      "edu.om",
      "gov.om",
      "med.om",
      "museum.om",
      "net.om",
      "org.om",
      "pro.om",
      "onion",
      "org",
      "pa",
      "ac.pa",
      "gob.pa",
      "com.pa",
      "org.pa",
      "sld.pa",
      "edu.pa",
      "net.pa",
      "ing.pa",
      "abo.pa",
      "med.pa",
      "nom.pa",
      "pe",
      "edu.pe",
      "gob.pe",
      "nom.pe",
      "mil.pe",
      "org.pe",
      "com.pe",
      "net.pe",
      "pf",
      "com.pf",
      "org.pf",
      "edu.pf",
      "*.pg",
      "ph",
      "com.ph",
      "net.ph",
      "org.ph",
      "gov.ph",
      "edu.ph",
      "ngo.ph",
      "mil.ph",
      "i.ph",
      "pk",
      "com.pk",
      "net.pk",
      "edu.pk",
      "org.pk",
      "fam.pk",
      "biz.pk",
      "web.pk",
      "gov.pk",
      "gob.pk",
      "gok.pk",
      "gon.pk",
      "gop.pk",
      "gos.pk",
      "info.pk",
      "pl",
      "com.pl",
      "net.pl",
      "org.pl",
      "aid.pl",
      "agro.pl",
      "atm.pl",
      "auto.pl",
      "biz.pl",
      "edu.pl",
      "gmina.pl",
      "gsm.pl",
      "info.pl",
      "mail.pl",
      "miasta.pl",
      "media.pl",
      "mil.pl",
      "nieruchomosci.pl",
      "nom.pl",
      "pc.pl",
      "powiat.pl",
      "priv.pl",
      "realestate.pl",
      "rel.pl",
      "sex.pl",
      "shop.pl",
      "sklep.pl",
      "sos.pl",
      "szkola.pl",
      "targi.pl",
      "tm.pl",
      "tourism.pl",
      "travel.pl",
      "turystyka.pl",
      "gov.pl",
      "ap.gov.pl",
      "ic.gov.pl",
      "is.gov.pl",
      "us.gov.pl",
      "kmpsp.gov.pl",
      "kppsp.gov.pl",
      "kwpsp.gov.pl",
      "psp.gov.pl",
      "wskr.gov.pl",
      "kwp.gov.pl",
      "mw.gov.pl",
      "ug.gov.pl",
      "um.gov.pl",
      "umig.gov.pl",
      "ugim.gov.pl",
      "upow.gov.pl",
      "uw.gov.pl",
      "starostwo.gov.pl",
      "pa.gov.pl",
      "po.gov.pl",
      "psse.gov.pl",
      "pup.gov.pl",
      "rzgw.gov.pl",
      "sa.gov.pl",
      "so.gov.pl",
      "sr.gov.pl",
      "wsa.gov.pl",
      "sko.gov.pl",
      "uzs.gov.pl",
      "wiih.gov.pl",
      "winb.gov.pl",
      "pinb.gov.pl",
      "wios.gov.pl",
      "witd.gov.pl",
      "wzmiuw.gov.pl",
      "piw.gov.pl",
      "wiw.gov.pl",
      "griw.gov.pl",
      "wif.gov.pl",
      "oum.gov.pl",
      "sdn.gov.pl",
      "zp.gov.pl",
      "uppo.gov.pl",
      "mup.gov.pl",
      "wuoz.gov.pl",
      "konsulat.gov.pl",
      "oirm.gov.pl",
      "augustow.pl",
      "babia-gora.pl",
      "bedzin.pl",
      "beskidy.pl",
      "bialowieza.pl",
      "bialystok.pl",
      "bielawa.pl",
      "bieszczady.pl",
      "boleslawiec.pl",
      "bydgoszcz.pl",
      "bytom.pl",
      "cieszyn.pl",
      "czeladz.pl",
      "czest.pl",
      "dlugoleka.pl",
      "elblag.pl",
      "elk.pl",
      "glogow.pl",
      "gniezno.pl",
      "gorlice.pl",
      "grajewo.pl",
      "ilawa.pl",
      "jaworzno.pl",
      "jelenia-gora.pl",
      "jgora.pl",
      "kalisz.pl",
      "kazimierz-dolny.pl",
      "karpacz.pl",
      "kartuzy.pl",
      "kaszuby.pl",
      "katowice.pl",
      "kepno.pl",
      "ketrzyn.pl",
      "klodzko.pl",
      "kobierzyce.pl",
      "kolobrzeg.pl",
      "konin.pl",
      "konskowola.pl",
      "kutno.pl",
      "lapy.pl",
      "lebork.pl",
      "legnica.pl",
      "lezajsk.pl",
      "limanowa.pl",
      "lomza.pl",
      "lowicz.pl",
      "lubin.pl",
      "lukow.pl",
      "malbork.pl",
      "malopolska.pl",
      "mazowsze.pl",
      "mazury.pl",
      "mielec.pl",
      "mielno.pl",
      "mragowo.pl",
      "naklo.pl",
      "nowaruda.pl",
      "nysa.pl",
      "olawa.pl",
      "olecko.pl",
      "olkusz.pl",
      "olsztyn.pl",
      "opoczno.pl",
      "opole.pl",
      "ostroda.pl",
      "ostroleka.pl",
      "ostrowiec.pl",
      "ostrowwlkp.pl",
      "pila.pl",
      "pisz.pl",
      "podhale.pl",
      "podlasie.pl",
      "polkowice.pl",
      "pomorze.pl",
      "pomorskie.pl",
      "prochowice.pl",
      "pruszkow.pl",
      "przeworsk.pl",
      "pulawy.pl",
      "radom.pl",
      "rawa-maz.pl",
      "rybnik.pl",
      "rzeszow.pl",
      "sanok.pl",
      "sejny.pl",
      "slask.pl",
      "slupsk.pl",
      "sosnowiec.pl",
      "stalowa-wola.pl",
      "skoczow.pl",
      "starachowice.pl",
      "stargard.pl",
      "suwalki.pl",
      "swidnica.pl",
      "swiebodzin.pl",
      "swinoujscie.pl",
      "szczecin.pl",
      "szczytno.pl",
      "tarnobrzeg.pl",
      "tgory.pl",
      "turek.pl",
      "tychy.pl",
      "ustka.pl",
      "walbrzych.pl",
      "warmia.pl",
      "warszawa.pl",
      "waw.pl",
      "wegrow.pl",
      "wielun.pl",
      "wlocl.pl",
      "wloclawek.pl",
      "wodzislaw.pl",
      "wolomin.pl",
      "wroclaw.pl",
      "zachpomor.pl",
      "zagan.pl",
      "zarow.pl",
      "zgora.pl",
      "zgorzelec.pl",
      "pm",
      "pn",
      "gov.pn",
      "co.pn",
      "org.pn",
      "edu.pn",
      "net.pn",
      "post",
      "pr",
      "com.pr",
      "net.pr",
      "org.pr",
      "gov.pr",
      "edu.pr",
      "isla.pr",
      "pro.pr",
      "biz.pr",
      "info.pr",
      "name.pr",
      "est.pr",
      "prof.pr",
      "ac.pr",
      "pro",
      "aaa.pro",
      "aca.pro",
      "acct.pro",
      "avocat.pro",
      "bar.pro",
      "cpa.pro",
      "eng.pro",
      "jur.pro",
      "law.pro",
      "med.pro",
      "recht.pro",
      "ps",
      "edu.ps",
      "gov.ps",
      "sec.ps",
      "plo.ps",
      "com.ps",
      "org.ps",
      "net.ps",
      "pt",
      "net.pt",
      "gov.pt",
      "org.pt",
      "edu.pt",
      "int.pt",
      "publ.pt",
      "com.pt",
      "nome.pt",
      "pw",
      "co.pw",
      "ne.pw",
      "or.pw",
      "ed.pw",
      "go.pw",
      "belau.pw",
      "py",
      "com.py",
      "coop.py",
      "edu.py",
      "gov.py",
      "mil.py",
      "net.py",
      "org.py",
      "qa",
      "com.qa",
      "edu.qa",
      "gov.qa",
      "mil.qa",
      "name.qa",
      "net.qa",
      "org.qa",
      "sch.qa",
      "re",
      "asso.re",
      "com.re",
      "nom.re",
      "ro",
      "arts.ro",
      "com.ro",
      "firm.ro",
      "info.ro",
      "nom.ro",
      "nt.ro",
      "org.ro",
      "rec.ro",
      "store.ro",
      "tm.ro",
      "www.ro",
      "rs",
      "ac.rs",
      "co.rs",
      "edu.rs",
      "gov.rs",
      "in.rs",
      "org.rs",
      "ru",
      "rw",
      "ac.rw",
      "co.rw",
      "coop.rw",
      "gov.rw",
      "mil.rw",
      "net.rw",
      "org.rw",
      "sa",
      "com.sa",
      "net.sa",
      "org.sa",
      "gov.sa",
      "med.sa",
      "pub.sa",
      "edu.sa",
      "sch.sa",
      "sb",
      "com.sb",
      "edu.sb",
      "gov.sb",
      "net.sb",
      "org.sb",
      "sc",
      "com.sc",
      "gov.sc",
      "net.sc",
      "org.sc",
      "edu.sc",
      "sd",
      "com.sd",
      "net.sd",
      "org.sd",
      "edu.sd",
      "med.sd",
      "tv.sd",
      "gov.sd",
      "info.sd",
      "se",
      "a.se",
      "ac.se",
      "b.se",
      "bd.se",
      "brand.se",
      "c.se",
      "d.se",
      "e.se",
      "f.se",
      "fh.se",
      "fhsk.se",
      "fhv.se",
      "g.se",
      "h.se",
      "i.se",
      "k.se",
      "komforb.se",
      "kommunalforbund.se",
      "komvux.se",
      "l.se",
      "lanbib.se",
      "m.se",
      "n.se",
      "naturbruksgymn.se",
      "o.se",
      "org.se",
      "p.se",
      "parti.se",
      "pp.se",
      "press.se",
      "r.se",
      "s.se",
      "t.se",
      "tm.se",
      "u.se",
      "w.se",
      "x.se",
      "y.se",
      "z.se",
      "sg",
      "com.sg",
      "net.sg",
      "org.sg",
      "gov.sg",
      "edu.sg",
      "per.sg",
      "sh",
      "com.sh",
      "net.sh",
      "gov.sh",
      "org.sh",
      "mil.sh",
      "si",
      "sj",
      "sk",
      "sl",
      "com.sl",
      "net.sl",
      "edu.sl",
      "gov.sl",
      "org.sl",
      "sm",
      "sn",
      "art.sn",
      "com.sn",
      "edu.sn",
      "gouv.sn",
      "org.sn",
      "perso.sn",
      "univ.sn",
      "so",
      "com.so",
      "edu.so",
      "gov.so",
      "me.so",
      "net.so",
      "org.so",
      "sr",
      "ss",
      "biz.ss",
      "com.ss",
      "edu.ss",
      "gov.ss",
      "me.ss",
      "net.ss",
      "org.ss",
      "sch.ss",
      "st",
      "co.st",
      "com.st",
      "consulado.st",
      "edu.st",
      "embaixada.st",
      "mil.st",
      "net.st",
      "org.st",
      "principe.st",
      "saotome.st",
      "store.st",
      "su",
      "sv",
      "com.sv",
      "edu.sv",
      "gob.sv",
      "org.sv",
      "red.sv",
      "sx",
      "gov.sx",
      "sy",
      "edu.sy",
      "gov.sy",
      "net.sy",
      "mil.sy",
      "com.sy",
      "org.sy",
      "sz",
      "co.sz",
      "ac.sz",
      "org.sz",
      "tc",
      "td",
      "tel",
      "tf",
      "tg",
      "th",
      "ac.th",
      "co.th",
      "go.th",
      "in.th",
      "mi.th",
      "net.th",
      "or.th",
      "tj",
      "ac.tj",
      "biz.tj",
      "co.tj",
      "com.tj",
      "edu.tj",
      "go.tj",
      "gov.tj",
      "int.tj",
      "mil.tj",
      "name.tj",
      "net.tj",
      "nic.tj",
      "org.tj",
      "test.tj",
      "web.tj",
      "tk",
      "tl",
      "gov.tl",
      "tm",
      "com.tm",
      "co.tm",
      "org.tm",
      "net.tm",
      "nom.tm",
      "gov.tm",
      "mil.tm",
      "edu.tm",
      "tn",
      "com.tn",
      "ens.tn",
      "fin.tn",
      "gov.tn",
      "ind.tn",
      "info.tn",
      "intl.tn",
      "mincom.tn",
      "nat.tn",
      "net.tn",
      "org.tn",
      "perso.tn",
      "tourism.tn",
      "to",
      "com.to",
      "gov.to",
      "net.to",
      "org.to",
      "edu.to",
      "mil.to",
      "tr",
      "av.tr",
      "bbs.tr",
      "bel.tr",
      "biz.tr",
      "com.tr",
      "dr.tr",
      "edu.tr",
      "gen.tr",
      "gov.tr",
      "info.tr",
      "mil.tr",
      "k12.tr",
      "kep.tr",
      "name.tr",
      "net.tr",
      "org.tr",
      "pol.tr",
      "tel.tr",
      "tsk.tr",
      "tv.tr",
      "web.tr",
      "nc.tr",
      "gov.nc.tr",
      "tt",
      "co.tt",
      "com.tt",
      "org.tt",
      "net.tt",
      "biz.tt",
      "info.tt",
      "pro.tt",
      "int.tt",
      "coop.tt",
      "jobs.tt",
      "mobi.tt",
      "travel.tt",
      "museum.tt",
      "aero.tt",
      "name.tt",
      "gov.tt",
      "edu.tt",
      "tv",
      "tw",
      "edu.tw",
      "gov.tw",
      "mil.tw",
      "com.tw",
      "net.tw",
      "org.tw",
      "idv.tw",
      "game.tw",
      "ebiz.tw",
      "club.tw",
      "\u7DB2\u8DEF.tw",
      "\u7D44\u7E54.tw",
      "\u5546\u696D.tw",
      "tz",
      "ac.tz",
      "co.tz",
      "go.tz",
      "hotel.tz",
      "info.tz",
      "me.tz",
      "mil.tz",
      "mobi.tz",
      "ne.tz",
      "or.tz",
      "sc.tz",
      "tv.tz",
      "ua",
      "com.ua",
      "edu.ua",
      "gov.ua",
      "in.ua",
      "net.ua",
      "org.ua",
      "cherkassy.ua",
      "cherkasy.ua",
      "chernigov.ua",
      "chernihiv.ua",
      "chernivtsi.ua",
      "chernovtsy.ua",
      "ck.ua",
      "cn.ua",
      "cr.ua",
      "crimea.ua",
      "cv.ua",
      "dn.ua",
      "dnepropetrovsk.ua",
      "dnipropetrovsk.ua",
      "donetsk.ua",
      "dp.ua",
      "if.ua",
      "ivano-frankivsk.ua",
      "kh.ua",
      "kharkiv.ua",
      "kharkov.ua",
      "kherson.ua",
      "khmelnitskiy.ua",
      "khmelnytskyi.ua",
      "kiev.ua",
      "kirovograd.ua",
      "km.ua",
      "kr.ua",
      "krym.ua",
      "ks.ua",
      "kv.ua",
      "kyiv.ua",
      "lg.ua",
      "lt.ua",
      "lugansk.ua",
      "lutsk.ua",
      "lv.ua",
      "lviv.ua",
      "mk.ua",
      "mykolaiv.ua",
      "nikolaev.ua",
      "od.ua",
      "odesa.ua",
      "odessa.ua",
      "pl.ua",
      "poltava.ua",
      "rivne.ua",
      "rovno.ua",
      "rv.ua",
      "sb.ua",
      "sebastopol.ua",
      "sevastopol.ua",
      "sm.ua",
      "sumy.ua",
      "te.ua",
      "ternopil.ua",
      "uz.ua",
      "uzhgorod.ua",
      "vinnica.ua",
      "vinnytsia.ua",
      "vn.ua",
      "volyn.ua",
      "yalta.ua",
      "zaporizhzhe.ua",
      "zaporizhzhia.ua",
      "zhitomir.ua",
      "zhytomyr.ua",
      "zp.ua",
      "zt.ua",
      "ug",
      "co.ug",
      "or.ug",
      "ac.ug",
      "sc.ug",
      "go.ug",
      "ne.ug",
      "com.ug",
      "org.ug",
      "uk",
      "ac.uk",
      "co.uk",
      "gov.uk",
      "ltd.uk",
      "me.uk",
      "net.uk",
      "nhs.uk",
      "org.uk",
      "plc.uk",
      "police.uk",
      "*.sch.uk",
      "us",
      "dni.us",
      "fed.us",
      "isa.us",
      "kids.us",
      "nsn.us",
      "ak.us",
      "al.us",
      "ar.us",
      "as.us",
      "az.us",
      "ca.us",
      "co.us",
      "ct.us",
      "dc.us",
      "de.us",
      "fl.us",
      "ga.us",
      "gu.us",
      "hi.us",
      "ia.us",
      "id.us",
      "il.us",
      "in.us",
      "ks.us",
      "ky.us",
      "la.us",
      "ma.us",
      "md.us",
      "me.us",
      "mi.us",
      "mn.us",
      "mo.us",
      "ms.us",
      "mt.us",
      "nc.us",
      "nd.us",
      "ne.us",
      "nh.us",
      "nj.us",
      "nm.us",
      "nv.us",
      "ny.us",
      "oh.us",
      "ok.us",
      "or.us",
      "pa.us",
      "pr.us",
      "ri.us",
      "sc.us",
      "sd.us",
      "tn.us",
      "tx.us",
      "ut.us",
      "vi.us",
      "vt.us",
      "va.us",
      "wa.us",
      "wi.us",
      "wv.us",
      "wy.us",
      "k12.ak.us",
      "k12.al.us",
      "k12.ar.us",
      "k12.as.us",
      "k12.az.us",
      "k12.ca.us",
      "k12.co.us",
      "k12.ct.us",
      "k12.dc.us",
      "k12.de.us",
      "k12.fl.us",
      "k12.ga.us",
      "k12.gu.us",
      "k12.ia.us",
      "k12.id.us",
      "k12.il.us",
      "k12.in.us",
      "k12.ks.us",
      "k12.ky.us",
      "k12.la.us",
      "k12.ma.us",
      "k12.md.us",
      "k12.me.us",
      "k12.mi.us",
      "k12.mn.us",
      "k12.mo.us",
      "k12.ms.us",
      "k12.mt.us",
      "k12.nc.us",
      "k12.ne.us",
      "k12.nh.us",
      "k12.nj.us",
      "k12.nm.us",
      "k12.nv.us",
      "k12.ny.us",
      "k12.oh.us",
      "k12.ok.us",
      "k12.or.us",
      "k12.pa.us",
      "k12.pr.us",
      "k12.sc.us",
      "k12.tn.us",
      "k12.tx.us",
      "k12.ut.us",
      "k12.vi.us",
      "k12.vt.us",
      "k12.va.us",
      "k12.wa.us",
      "k12.wi.us",
      "k12.wy.us",
      "cc.ak.us",
      "cc.al.us",
      "cc.ar.us",
      "cc.as.us",
      "cc.az.us",
      "cc.ca.us",
      "cc.co.us",
      "cc.ct.us",
      "cc.dc.us",
      "cc.de.us",
      "cc.fl.us",
      "cc.ga.us",
      "cc.gu.us",
      "cc.hi.us",
      "cc.ia.us",
      "cc.id.us",
      "cc.il.us",
      "cc.in.us",
      "cc.ks.us",
      "cc.ky.us",
      "cc.la.us",
      "cc.ma.us",
      "cc.md.us",
      "cc.me.us",
      "cc.mi.us",
      "cc.mn.us",
      "cc.mo.us",
      "cc.ms.us",
      "cc.mt.us",
      "cc.nc.us",
      "cc.nd.us",
      "cc.ne.us",
      "cc.nh.us",
      "cc.nj.us",
      "cc.nm.us",
      "cc.nv.us",
      "cc.ny.us",
      "cc.oh.us",
      "cc.ok.us",
      "cc.or.us",
      "cc.pa.us",
      "cc.pr.us",
      "cc.ri.us",
      "cc.sc.us",
      "cc.sd.us",
      "cc.tn.us",
      "cc.tx.us",
      "cc.ut.us",
      "cc.vi.us",
      "cc.vt.us",
      "cc.va.us",
      "cc.wa.us",
      "cc.wi.us",
      "cc.wv.us",
      "cc.wy.us",
      "lib.ak.us",
      "lib.al.us",
      "lib.ar.us",
      "lib.as.us",
      "lib.az.us",
      "lib.ca.us",
      "lib.co.us",
      "lib.ct.us",
      "lib.dc.us",
      "lib.fl.us",
      "lib.ga.us",
      "lib.gu.us",
      "lib.hi.us",
      "lib.ia.us",
      "lib.id.us",
      "lib.il.us",
      "lib.in.us",
      "lib.ks.us",
      "lib.ky.us",
      "lib.la.us",
      "lib.ma.us",
      "lib.md.us",
      "lib.me.us",
      "lib.mi.us",
      "lib.mn.us",
      "lib.mo.us",
      "lib.ms.us",
      "lib.mt.us",
      "lib.nc.us",
      "lib.nd.us",
      "lib.ne.us",
      "lib.nh.us",
      "lib.nj.us",
      "lib.nm.us",
      "lib.nv.us",
      "lib.ny.us",
      "lib.oh.us",
      "lib.ok.us",
      "lib.or.us",
      "lib.pa.us",
      "lib.pr.us",
      "lib.ri.us",
      "lib.sc.us",
      "lib.sd.us",
      "lib.tn.us",
      "lib.tx.us",
      "lib.ut.us",
      "lib.vi.us",
      "lib.vt.us",
      "lib.va.us",
      "lib.wa.us",
      "lib.wi.us",
      "lib.wy.us",
      "pvt.k12.ma.us",
      "chtr.k12.ma.us",
      "paroch.k12.ma.us",
      "ann-arbor.mi.us",
      "cog.mi.us",
      "dst.mi.us",
      "eaton.mi.us",
      "gen.mi.us",
      "mus.mi.us",
      "tec.mi.us",
      "washtenaw.mi.us",
      "uy",
      "com.uy",
      "edu.uy",
      "gub.uy",
      "mil.uy",
      "net.uy",
      "org.uy",
      "uz",
      "co.uz",
      "com.uz",
      "net.uz",
      "org.uz",
      "va",
      "vc",
      "com.vc",
      "net.vc",
      "org.vc",
      "gov.vc",
      "mil.vc",
      "edu.vc",
      "ve",
      "arts.ve",
      "bib.ve",
      "co.ve",
      "com.ve",
      "e12.ve",
      "edu.ve",
      "firm.ve",
      "gob.ve",
      "gov.ve",
      "info.ve",
      "int.ve",
      "mil.ve",
      "net.ve",
      "nom.ve",
      "org.ve",
      "rar.ve",
      "rec.ve",
      "store.ve",
      "tec.ve",
      "web.ve",
      "vg",
      "vi",
      "co.vi",
      "com.vi",
      "k12.vi",
      "net.vi",
      "org.vi",
      "vn",
      "com.vn",
      "net.vn",
      "org.vn",
      "edu.vn",
      "gov.vn",
      "int.vn",
      "ac.vn",
      "biz.vn",
      "info.vn",
      "name.vn",
      "pro.vn",
      "health.vn",
      "vu",
      "com.vu",
      "edu.vu",
      "net.vu",
      "org.vu",
      "wf",
      "ws",
      "com.ws",
      "net.ws",
      "org.ws",
      "gov.ws",
      "edu.ws",
      "yt",
      "\u0627\u0645\u0627\u0631\u0627\u062A",
      "\u0570\u0561\u0575",
      "\u09AC\u09BE\u0982\u09B2\u09BE",
      "\u0431\u0433",
      "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
      "\u0431\u0435\u043B",
      "\u4E2D\u56FD",
      "\u4E2D\u570B",
      "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
      "\u0645\u0635\u0631",
      "\u0435\u044E",
      "\u03B5\u03C5",
      "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
      "\u10D2\u10D4",
      "\u03B5\u03BB",
      "\u9999\u6E2F",
      "\u516C\u53F8.\u9999\u6E2F",
      "\u6559\u80B2.\u9999\u6E2F",
      "\u653F\u5E9C.\u9999\u6E2F",
      "\u500B\u4EBA.\u9999\u6E2F",
      "\u7DB2\u7D61.\u9999\u6E2F",
      "\u7D44\u7E54.\u9999\u6E2F",
      "\u0CAD\u0CBE\u0CB0\u0CA4",
      "\u0B2D\u0B3E\u0B30\u0B24",
      "\u09AD\u09BE\u09F0\u09A4",
      "\u092D\u093E\u0930\u0924\u092E\u094D",
      "\u092D\u093E\u0930\u094B\u0924",
      "\u0680\u0627\u0631\u062A",
      "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
      "\u092D\u093E\u0930\u0924",
      "\u0628\u0627\u0631\u062A",
      "\u0628\u06BE\u0627\u0631\u062A",
      "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
      "\u0AAD\u0ABE\u0AB0\u0AA4",
      "\u0A2D\u0A3E\u0A30\u0A24",
      "\u09AD\u09BE\u09B0\u09A4",
      "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
      "\u0627\u06CC\u0631\u0627\u0646",
      "\u0627\u064A\u0631\u0627\u0646",
      "\u0639\u0631\u0627\u0642",
      "\u0627\u0644\u0627\u0631\u062F\u0646",
      "\uD55C\uAD6D",
      "\u049B\u0430\u0437",
      "\u0EA5\u0EB2\u0EA7",
      "\u0DBD\u0D82\u0D9A\u0DCF",
      "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
      "\u0627\u0644\u0645\u063A\u0631\u0628",
      "\u043C\u043A\u0434",
      "\u043C\u043E\u043D",
      "\u6FB3\u9580",
      "\u6FB3\u95E8",
      "\u0645\u0644\u064A\u0633\u064A\u0627",
      "\u0639\u0645\u0627\u0646",
      "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
      "\u067E\u0627\u0643\u0633\u062A\u0627\u0646",
      "\u0641\u0644\u0633\u0637\u064A\u0646",
      "\u0441\u0440\u0431",
      "\u043F\u0440.\u0441\u0440\u0431",
      "\u043E\u0440\u0433.\u0441\u0440\u0431",
      "\u043E\u0431\u0440.\u0441\u0440\u0431",
      "\u043E\u0434.\u0441\u0440\u0431",
      "\u0443\u043F\u0440.\u0441\u0440\u0431",
      "\u0430\u043A.\u0441\u0440\u0431",
      "\u0440\u0444",
      "\u0642\u0637\u0631",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647",
      "\u0633\u0648\u062F\u0627\u0646",
      "\u65B0\u52A0\u5761",
      "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
      "\u0633\u0648\u0631\u064A\u0629",
      "\u0633\u0648\u0631\u064A\u0627",
      "\u0E44\u0E17\u0E22",
      "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22",
      "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22",
      "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22",
      "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22",
      "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22",
      "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22",
      "\u062A\u0648\u0646\u0633",
      "\u53F0\u7063",
      "\u53F0\u6E7E",
      "\u81FA\u7063",
      "\u0443\u043A\u0440",
      "\u0627\u0644\u064A\u0645\u0646",
      "xxx",
      "ye",
      "com.ye",
      "edu.ye",
      "gov.ye",
      "net.ye",
      "mil.ye",
      "org.ye",
      "ac.za",
      "agric.za",
      "alt.za",
      "co.za",
      "edu.za",
      "gov.za",
      "grondar.za",
      "law.za",
      "mil.za",
      "net.za",
      "ngo.za",
      "nic.za",
      "nis.za",
      "nom.za",
      "org.za",
      "school.za",
      "tm.za",
      "web.za",
      "zm",
      "ac.zm",
      "biz.zm",
      "co.zm",
      "com.zm",
      "edu.zm",
      "gov.zm",
      "info.zm",
      "mil.zm",
      "net.zm",
      "org.zm",
      "sch.zm",
      "zw",
      "ac.zw",
      "co.zw",
      "gov.zw",
      "mil.zw",
      "org.zw",
      "aaa",
      "aarp",
      "abarth",
      "abb",
      "abbott",
      "abbvie",
      "abc",
      "able",
      "abogado",
      "abudhabi",
      "academy",
      "accenture",
      "accountant",
      "accountants",
      "aco",
      "actor",
      "adac",
      "ads",
      "adult",
      "aeg",
      "aetna",
      "afl",
      "africa",
      "agakhan",
      "agency",
      "aig",
      "airbus",
      "airforce",
      "airtel",
      "akdn",
      "alfaromeo",
      "alibaba",
      "alipay",
      "allfinanz",
      "allstate",
      "ally",
      "alsace",
      "alstom",
      "amazon",
      "americanexpress",
      "americanfamily",
      "amex",
      "amfam",
      "amica",
      "amsterdam",
      "analytics",
      "android",
      "anquan",
      "anz",
      "aol",
      "apartments",
      "app",
      "apple",
      "aquarelle",
      "arab",
      "aramco",
      "archi",
      "army",
      "art",
      "arte",
      "asda",
      "associates",
      "athleta",
      "attorney",
      "auction",
      "audi",
      "audible",
      "audio",
      "auspost",
      "author",
      "auto",
      "autos",
      "avianca",
      "aws",
      "axa",
      "azure",
      "baby",
      "baidu",
      "banamex",
      "bananarepublic",
      "band",
      "bank",
      "bar",
      "barcelona",
      "barclaycard",
      "barclays",
      "barefoot",
      "bargains",
      "baseball",
      "basketball",
      "bauhaus",
      "bayern",
      "bbc",
      "bbt",
      "bbva",
      "bcg",
      "bcn",
      "beats",
      "beauty",
      "beer",
      "bentley",
      "berlin",
      "best",
      "bestbuy",
      "bet",
      "bharti",
      "bible",
      "bid",
      "bike",
      "bing",
      "bingo",
      "bio",
      "black",
      "blackfriday",
      "blockbuster",
      "blog",
      "bloomberg",
      "blue",
      "bms",
      "bmw",
      "bnpparibas",
      "boats",
      "boehringer",
      "bofa",
      "bom",
      "bond",
      "boo",
      "book",
      "booking",
      "bosch",
      "bostik",
      "boston",
      "bot",
      "boutique",
      "box",
      "bradesco",
      "bridgestone",
      "broadway",
      "broker",
      "brother",
      "brussels",
      "bugatti",
      "build",
      "builders",
      "business",
      "buy",
      "buzz",
      "bzh",
      "cab",
      "cafe",
      "cal",
      "call",
      "calvinklein",
      "cam",
      "camera",
      "camp",
      "cancerresearch",
      "canon",
      "capetown",
      "capital",
      "capitalone",
      "car",
      "caravan",
      "cards",
      "care",
      "career",
      "careers",
      "cars",
      "casa",
      "case",
      "cash",
      "casino",
      "catering",
      "catholic",
      "cba",
      "cbn",
      "cbre",
      "cbs",
      "center",
      "ceo",
      "cern",
      "cfa",
      "cfd",
      "chanel",
      "channel",
      "charity",
      "chase",
      "chat",
      "cheap",
      "chintai",
      "christmas",
      "chrome",
      "church",
      "cipriani",
      "circle",
      "cisco",
      "citadel",
      "citi",
      "citic",
      "city",
      "cityeats",
      "claims",
      "cleaning",
      "click",
      "clinic",
      "clinique",
      "clothing",
      "cloud",
      "club",
      "clubmed",
      "coach",
      "codes",
      "coffee",
      "college",
      "cologne",
      "comcast",
      "commbank",
      "community",
      "company",
      "compare",
      "computer",
      "comsec",
      "condos",
      "construction",
      "consulting",
      "contact",
      "contractors",
      "cooking",
      "cookingchannel",
      "cool",
      "corsica",
      "country",
      "coupon",
      "coupons",
      "courses",
      "cpa",
      "credit",
      "creditcard",
      "creditunion",
      "cricket",
      "crown",
      "crs",
      "cruise",
      "cruises",
      "cuisinella",
      "cymru",
      "cyou",
      "dabur",
      "dad",
      "dance",
      "data",
      "date",
      "dating",
      "datsun",
      "day",
      "dclk",
      "dds",
      "deal",
      "dealer",
      "deals",
      "degree",
      "delivery",
      "dell",
      "deloitte",
      "delta",
      "democrat",
      "dental",
      "dentist",
      "desi",
      "design",
      "dev",
      "dhl",
      "diamonds",
      "diet",
      "digital",
      "direct",
      "directory",
      "discount",
      "discover",
      "dish",
      "diy",
      "dnp",
      "docs",
      "doctor",
      "dog",
      "domains",
      "dot",
      "download",
      "drive",
      "dtv",
      "dubai",
      "dunlop",
      "dupont",
      "durban",
      "dvag",
      "dvr",
      "earth",
      "eat",
      "eco",
      "edeka",
      "education",
      "email",
      "emerck",
      "energy",
      "engineer",
      "engineering",
      "enterprises",
      "epson",
      "equipment",
      "ericsson",
      "erni",
      "esq",
      "estate",
      "etisalat",
      "eurovision",
      "eus",
      "events",
      "exchange",
      "expert",
      "exposed",
      "express",
      "extraspace",
      "fage",
      "fail",
      "fairwinds",
      "faith",
      "family",
      "fan",
      "fans",
      "farm",
      "farmers",
      "fashion",
      "fast",
      "fedex",
      "feedback",
      "ferrari",
      "ferrero",
      "fiat",
      "fidelity",
      "fido",
      "film",
      "final",
      "finance",
      "financial",
      "fire",
      "firestone",
      "firmdale",
      "fish",
      "fishing",
      "fit",
      "fitness",
      "flickr",
      "flights",
      "flir",
      "florist",
      "flowers",
      "fly",
      "foo",
      "food",
      "foodnetwork",
      "football",
      "ford",
      "forex",
      "forsale",
      "forum",
      "foundation",
      "fox",
      "free",
      "fresenius",
      "frl",
      "frogans",
      "frontdoor",
      "frontier",
      "ftr",
      "fujitsu",
      "fun",
      "fund",
      "furniture",
      "futbol",
      "fyi",
      "gal",
      "gallery",
      "gallo",
      "gallup",
      "game",
      "games",
      "gap",
      "garden",
      "gay",
      "gbiz",
      "gdn",
      "gea",
      "gent",
      "genting",
      "george",
      "ggee",
      "gift",
      "gifts",
      "gives",
      "giving",
      "glass",
      "gle",
      "global",
      "globo",
      "gmail",
      "gmbh",
      "gmo",
      "gmx",
      "godaddy",
      "gold",
      "goldpoint",
      "golf",
      "goo",
      "goodyear",
      "goog",
      "google",
      "gop",
      "got",
      "grainger",
      "graphics",
      "gratis",
      "green",
      "gripe",
      "grocery",
      "group",
      "guardian",
      "gucci",
      "guge",
      "guide",
      "guitars",
      "guru",
      "hair",
      "hamburg",
      "hangout",
      "haus",
      "hbo",
      "hdfc",
      "hdfcbank",
      "health",
      "healthcare",
      "help",
      "helsinki",
      "here",
      "hermes",
      "hgtv",
      "hiphop",
      "hisamitsu",
      "hitachi",
      "hiv",
      "hkt",
      "hockey",
      "holdings",
      "holiday",
      "homedepot",
      "homegoods",
      "homes",
      "homesense",
      "honda",
      "horse",
      "hospital",
      "host",
      "hosting",
      "hot",
      "hoteles",
      "hotels",
      "hotmail",
      "house",
      "how",
      "hsbc",
      "hughes",
      "hyatt",
      "hyundai",
      "ibm",
      "icbc",
      "ice",
      "icu",
      "ieee",
      "ifm",
      "ikano",
      "imamat",
      "imdb",
      "immo",
      "immobilien",
      "inc",
      "industries",
      "infiniti",
      "ing",
      "ink",
      "institute",
      "insurance",
      "insure",
      "international",
      "intuit",
      "investments",
      "ipiranga",
      "irish",
      "ismaili",
      "ist",
      "istanbul",
      "itau",
      "itv",
      "jaguar",
      "java",
      "jcb",
      "jeep",
      "jetzt",
      "jewelry",
      "jio",
      "jll",
      "jmp",
      "jnj",
      "joburg",
      "jot",
      "joy",
      "jpmorgan",
      "jprs",
      "juegos",
      "juniper",
      "kaufen",
      "kddi",
      "kerryhotels",
      "kerrylogistics",
      "kerryproperties",
      "kfh",
      "kia",
      "kids",
      "kim",
      "kinder",
      "kindle",
      "kitchen",
      "kiwi",
      "koeln",
      "komatsu",
      "kosher",
      "kpmg",
      "kpn",
      "krd",
      "kred",
      "kuokgroup",
      "kyoto",
      "lacaixa",
      "lamborghini",
      "lamer",
      "lancaster",
      "lancia",
      "land",
      "landrover",
      "lanxess",
      "lasalle",
      "lat",
      "latino",
      "latrobe",
      "law",
      "lawyer",
      "lds",
      "lease",
      "leclerc",
      "lefrak",
      "legal",
      "lego",
      "lexus",
      "lgbt",
      "lidl",
      "life",
      "lifeinsurance",
      "lifestyle",
      "lighting",
      "like",
      "lilly",
      "limited",
      "limo",
      "lincoln",
      "linde",
      "link",
      "lipsy",
      "live",
      "living",
      "llc",
      "llp",
      "loan",
      "loans",
      "locker",
      "locus",
      "loft",
      "lol",
      "london",
      "lotte",
      "lotto",
      "love",
      "lpl",
      "lplfinancial",
      "ltd",
      "ltda",
      "lundbeck",
      "luxe",
      "luxury",
      "macys",
      "madrid",
      "maif",
      "maison",
      "makeup",
      "man",
      "management",
      "mango",
      "map",
      "market",
      "marketing",
      "markets",
      "marriott",
      "marshalls",
      "maserati",
      "mattel",
      "mba",
      "mckinsey",
      "med",
      "media",
      "meet",
      "melbourne",
      "meme",
      "memorial",
      "men",
      "menu",
      "merckmsd",
      "miami",
      "microsoft",
      "mini",
      "mint",
      "mit",
      "mitsubishi",
      "mlb",
      "mls",
      "mma",
      "mobile",
      "moda",
      "moe",
      "moi",
      "mom",
      "monash",
      "money",
      "monster",
      "mormon",
      "mortgage",
      "moscow",
      "moto",
      "motorcycles",
      "mov",
      "movie",
      "msd",
      "mtn",
      "mtr",
      "music",
      "mutual",
      "nab",
      "nagoya",
      "natura",
      "navy",
      "nba",
      "nec",
      "netbank",
      "netflix",
      "network",
      "neustar",
      "new",
      "news",
      "next",
      "nextdirect",
      "nexus",
      "nfl",
      "ngo",
      "nhk",
      "nico",
      "nike",
      "nikon",
      "ninja",
      "nissan",
      "nissay",
      "nokia",
      "northwesternmutual",
      "norton",
      "now",
      "nowruz",
      "nowtv",
      "nra",
      "nrw",
      "ntt",
      "nyc",
      "obi",
      "observer",
      "office",
      "okinawa",
      "olayan",
      "olayangroup",
      "oldnavy",
      "ollo",
      "omega",
      "one",
      "ong",
      "onl",
      "online",
      "ooo",
      "open",
      "oracle",
      "orange",
      "organic",
      "origins",
      "osaka",
      "otsuka",
      "ott",
      "ovh",
      "page",
      "panasonic",
      "paris",
      "pars",
      "partners",
      "parts",
      "party",
      "passagens",
      "pay",
      "pccw",
      "pet",
      "pfizer",
      "pharmacy",
      "phd",
      "philips",
      "phone",
      "photo",
      "photography",
      "photos",
      "physio",
      "pics",
      "pictet",
      "pictures",
      "pid",
      "pin",
      "ping",
      "pink",
      "pioneer",
      "pizza",
      "place",
      "play",
      "playstation",
      "plumbing",
      "plus",
      "pnc",
      "pohl",
      "poker",
      "politie",
      "porn",
      "pramerica",
      "praxi",
      "press",
      "prime",
      "prod",
      "productions",
      "prof",
      "progressive",
      "promo",
      "properties",
      "property",
      "protection",
      "pru",
      "prudential",
      "pub",
      "pwc",
      "qpon",
      "quebec",
      "quest",
      "racing",
      "radio",
      "read",
      "realestate",
      "realtor",
      "realty",
      "recipes",
      "red",
      "redstone",
      "redumbrella",
      "rehab",
      "reise",
      "reisen",
      "reit",
      "reliance",
      "ren",
      "rent",
      "rentals",
      "repair",
      "report",
      "republican",
      "rest",
      "restaurant",
      "review",
      "reviews",
      "rexroth",
      "rich",
      "richardli",
      "ricoh",
      "ril",
      "rio",
      "rip",
      "rocher",
      "rocks",
      "rodeo",
      "rogers",
      "room",
      "rsvp",
      "rugby",
      "ruhr",
      "run",
      "rwe",
      "ryukyu",
      "saarland",
      "safe",
      "safety",
      "sakura",
      "sale",
      "salon",
      "samsclub",
      "samsung",
      "sandvik",
      "sandvikcoromant",
      "sanofi",
      "sap",
      "sarl",
      "sas",
      "save",
      "saxo",
      "sbi",
      "sbs",
      "sca",
      "scb",
      "schaeffler",
      "schmidt",
      "scholarships",
      "school",
      "schule",
      "schwarz",
      "science",
      "scot",
      "search",
      "seat",
      "secure",
      "security",
      "seek",
      "select",
      "sener",
      "services",
      "ses",
      "seven",
      "sew",
      "sex",
      "sexy",
      "sfr",
      "shangrila",
      "sharp",
      "shaw",
      "shell",
      "shia",
      "shiksha",
      "shoes",
      "shop",
      "shopping",
      "shouji",
      "show",
      "showtime",
      "silk",
      "sina",
      "singles",
      "site",
      "ski",
      "skin",
      "sky",
      "skype",
      "sling",
      "smart",
      "smile",
      "sncf",
      "soccer",
      "social",
      "softbank",
      "software",
      "sohu",
      "solar",
      "solutions",
      "song",
      "sony",
      "soy",
      "spa",
      "space",
      "sport",
      "spot",
      "srl",
      "stada",
      "staples",
      "star",
      "statebank",
      "statefarm",
      "stc",
      "stcgroup",
      "stockholm",
      "storage",
      "store",
      "stream",
      "studio",
      "study",
      "style",
      "sucks",
      "supplies",
      "supply",
      "support",
      "surf",
      "surgery",
      "suzuki",
      "swatch",
      "swiss",
      "sydney",
      "systems",
      "tab",
      "taipei",
      "talk",
      "taobao",
      "target",
      "tatamotors",
      "tatar",
      "tattoo",
      "tax",
      "taxi",
      "tci",
      "tdk",
      "team",
      "tech",
      "technology",
      "temasek",
      "tennis",
      "teva",
      "thd",
      "theater",
      "theatre",
      "tiaa",
      "tickets",
      "tienda",
      "tiffany",
      "tips",
      "tires",
      "tirol",
      "tjmaxx",
      "tjx",
      "tkmaxx",
      "tmall",
      "today",
      "tokyo",
      "tools",
      "top",
      "toray",
      "toshiba",
      "total",
      "tours",
      "town",
      "toyota",
      "toys",
      "trade",
      "trading",
      "training",
      "travel",
      "travelchannel",
      "travelers",
      "travelersinsurance",
      "trust",
      "trv",
      "tube",
      "tui",
      "tunes",
      "tushu",
      "tvs",
      "ubank",
      "ubs",
      "unicom",
      "university",
      "uno",
      "uol",
      "ups",
      "vacations",
      "vana",
      "vanguard",
      "vegas",
      "ventures",
      "verisign",
      "versicherung",
      "vet",
      "viajes",
      "video",
      "vig",
      "viking",
      "villas",
      "vin",
      "vip",
      "virgin",
      "visa",
      "vision",
      "viva",
      "vivo",
      "vlaanderen",
      "vodka",
      "volkswagen",
      "volvo",
      "vote",
      "voting",
      "voto",
      "voyage",
      "vuelos",
      "wales",
      "walmart",
      "walter",
      "wang",
      "wanggou",
      "watch",
      "watches",
      "weather",
      "weatherchannel",
      "webcam",
      "weber",
      "website",
      "wedding",
      "weibo",
      "weir",
      "whoswho",
      "wien",
      "wiki",
      "williamhill",
      "win",
      "windows",
      "wine",
      "winners",
      "wme",
      "wolterskluwer",
      "woodside",
      "work",
      "works",
      "world",
      "wow",
      "wtc",
      "wtf",
      "xbox",
      "xerox",
      "xfinity",
      "xihuan",
      "xin",
      "\u0915\u0949\u092E",
      "\u30BB\u30FC\u30EB",
      "\u4F5B\u5C71",
      "\u6148\u5584",
      "\u96C6\u56E2",
      "\u5728\u7EBF",
      "\u70B9\u770B",
      "\u0E04\u0E2D\u0E21",
      "\u516B\u5366",
      "\u0645\u0648\u0642\u0639",
      "\u516C\u76CA",
      "\u516C\u53F8",
      "\u9999\u683C\u91CC\u62C9",
      "\u7F51\u7AD9",
      "\u79FB\u52A8",
      "\u6211\u7231\u4F60",
      "\u043C\u043E\u0441\u043A\u0432\u0430",
      "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
      "\u043E\u043D\u043B\u0430\u0439\u043D",
      "\u0441\u0430\u0439\u0442",
      "\u8054\u901A",
      "\u05E7\u05D5\u05DD",
      "\u65F6\u5C1A",
      "\u5FAE\u535A",
      "\u6DE1\u9A6C\u9521",
      "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
      "\u043E\u0440\u0433",
      "\u0928\u0947\u091F",
      "\u30B9\u30C8\u30A2",
      "\u30A2\u30DE\u30BE\u30F3",
      "\uC0BC\uC131",
      "\u5546\u6807",
      "\u5546\u5E97",
      "\u5546\u57CE",
      "\u0434\u0435\u0442\u0438",
      "\u30DD\u30A4\u30F3\u30C8",
      "\u65B0\u95FB",
      "\u5BB6\u96FB",
      "\u0643\u0648\u0645",
      "\u4E2D\u6587\u7F51",
      "\u4E2D\u4FE1",
      "\u5A31\u4E50",
      "\u8C37\u6B4C",
      "\u96FB\u8A0A\u76C8\u79D1",
      "\u8D2D\u7269",
      "\u30AF\u30E9\u30A6\u30C9",
      "\u901A\u8CA9",
      "\u7F51\u5E97",
      "\u0938\u0902\u0917\u0920\u0928",
      "\u9910\u5385",
      "\u7F51\u7EDC",
      "\u043A\u043E\u043C",
      "\u4E9A\u9A6C\u900A",
      "\u8BFA\u57FA\u4E9A",
      "\u98DF\u54C1",
      "\u98DE\u5229\u6D66",
      "\u624B\u673A",
      "\u0627\u0631\u0627\u0645\u0643\u0648",
      "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
      "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
      "\u0628\u0627\u0632\u0627\u0631",
      "\u0627\u0628\u0648\u0638\u0628\u064A",
      "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
      "\u0647\u0645\u0631\u0627\u0647",
      "\uB2F7\uCEF4",
      "\u653F\u5E9C",
      "\u0634\u0628\u0643\u0629",
      "\u0628\u064A\u062A\u0643",
      "\u0639\u0631\u0628",
      "\u673A\u6784",
      "\u7EC4\u7EC7\u673A\u6784",
      "\u5065\u5EB7",
      "\u62DB\u8058",
      "\u0440\u0443\u0441",
      "\u5927\u62FF",
      "\u307F\u3093\u306A",
      "\u30B0\u30FC\u30B0\u30EB",
      "\u4E16\u754C",
      "\u66F8\u7C4D",
      "\u7F51\u5740",
      "\uB2F7\uB137",
      "\u30B3\u30E0",
      "\u5929\u4E3B\u6559",
      "\u6E38\u620F",
      "verm\xF6gensberater",
      "verm\xF6gensberatung",
      "\u4F01\u4E1A",
      "\u4FE1\u606F",
      "\u5609\u91CC\u5927\u9152\u5E97",
      "\u5609\u91CC",
      "\u5E7F\u4E1C",
      "\u653F\u52A1",
      "xyz",
      "yachts",
      "yahoo",
      "yamaxun",
      "yandex",
      "yodobashi",
      "yoga",
      "yokohama",
      "you",
      "youtube",
      "yun",
      "zappos",
      "zara",
      "zero",
      "zip",
      "zone",
      "zuerich",
      "cc.ua",
      "inf.ua",
      "ltd.ua",
      "611.to",
      "graphox.us",
      "*.devcdnaccesso.com",
      "adobeaemcloud.com",
      "*.dev.adobeaemcloud.com",
      "hlx.live",
      "adobeaemcloud.net",
      "hlx.page",
      "hlx3.page",
      "beep.pl",
      "airkitapps.com",
      "airkitapps-au.com",
      "airkitapps.eu",
      "aivencloud.com",
      "barsy.ca",
      "*.compute.estate",
      "*.alces.network",
      "kasserver.com",
      "altervista.org",
      "alwaysdata.net",
      "cloudfront.net",
      "*.compute.amazonaws.com",
      "*.compute-1.amazonaws.com",
      "*.compute.amazonaws.com.cn",
      "us-east-1.amazonaws.com",
      "cn-north-1.eb.amazonaws.com.cn",
      "cn-northwest-1.eb.amazonaws.com.cn",
      "elasticbeanstalk.com",
      "ap-northeast-1.elasticbeanstalk.com",
      "ap-northeast-2.elasticbeanstalk.com",
      "ap-northeast-3.elasticbeanstalk.com",
      "ap-south-1.elasticbeanstalk.com",
      "ap-southeast-1.elasticbeanstalk.com",
      "ap-southeast-2.elasticbeanstalk.com",
      "ca-central-1.elasticbeanstalk.com",
      "eu-central-1.elasticbeanstalk.com",
      "eu-west-1.elasticbeanstalk.com",
      "eu-west-2.elasticbeanstalk.com",
      "eu-west-3.elasticbeanstalk.com",
      "sa-east-1.elasticbeanstalk.com",
      "us-east-1.elasticbeanstalk.com",
      "us-east-2.elasticbeanstalk.com",
      "us-gov-west-1.elasticbeanstalk.com",
      "us-west-1.elasticbeanstalk.com",
      "us-west-2.elasticbeanstalk.com",
      "*.elb.amazonaws.com",
      "*.elb.amazonaws.com.cn",
      "awsglobalaccelerator.com",
      "s3.amazonaws.com",
      "s3-ap-northeast-1.amazonaws.com",
      "s3-ap-northeast-2.amazonaws.com",
      "s3-ap-south-1.amazonaws.com",
      "s3-ap-southeast-1.amazonaws.com",
      "s3-ap-southeast-2.amazonaws.com",
      "s3-ca-central-1.amazonaws.com",
      "s3-eu-central-1.amazonaws.com",
      "s3-eu-west-1.amazonaws.com",
      "s3-eu-west-2.amazonaws.com",
      "s3-eu-west-3.amazonaws.com",
      "s3-external-1.amazonaws.com",
      "s3-fips-us-gov-west-1.amazonaws.com",
      "s3-sa-east-1.amazonaws.com",
      "s3-us-gov-west-1.amazonaws.com",
      "s3-us-east-2.amazonaws.com",
      "s3-us-west-1.amazonaws.com",
      "s3-us-west-2.amazonaws.com",
      "s3.ap-northeast-2.amazonaws.com",
      "s3.ap-south-1.amazonaws.com",
      "s3.cn-north-1.amazonaws.com.cn",
      "s3.ca-central-1.amazonaws.com",
      "s3.eu-central-1.amazonaws.com",
      "s3.eu-west-2.amazonaws.com",
      "s3.eu-west-3.amazonaws.com",
      "s3.us-east-2.amazonaws.com",
      "s3.dualstack.ap-northeast-1.amazonaws.com",
      "s3.dualstack.ap-northeast-2.amazonaws.com",
      "s3.dualstack.ap-south-1.amazonaws.com",
      "s3.dualstack.ap-southeast-1.amazonaws.com",
      "s3.dualstack.ap-southeast-2.amazonaws.com",
      "s3.dualstack.ca-central-1.amazonaws.com",
      "s3.dualstack.eu-central-1.amazonaws.com",
      "s3.dualstack.eu-west-1.amazonaws.com",
      "s3.dualstack.eu-west-2.amazonaws.com",
      "s3.dualstack.eu-west-3.amazonaws.com",
      "s3.dualstack.sa-east-1.amazonaws.com",
      "s3.dualstack.us-east-1.amazonaws.com",
      "s3.dualstack.us-east-2.amazonaws.com",
      "s3-website-us-east-1.amazonaws.com",
      "s3-website-us-west-1.amazonaws.com",
      "s3-website-us-west-2.amazonaws.com",
      "s3-website-ap-northeast-1.amazonaws.com",
      "s3-website-ap-southeast-1.amazonaws.com",
      "s3-website-ap-southeast-2.amazonaws.com",
      "s3-website-eu-west-1.amazonaws.com",
      "s3-website-sa-east-1.amazonaws.com",
      "s3-website.ap-northeast-2.amazonaws.com",
      "s3-website.ap-south-1.amazonaws.com",
      "s3-website.ca-central-1.amazonaws.com",
      "s3-website.eu-central-1.amazonaws.com",
      "s3-website.eu-west-2.amazonaws.com",
      "s3-website.eu-west-3.amazonaws.com",
      "s3-website.us-east-2.amazonaws.com",
      "t3l3p0rt.net",
      "tele.amune.org",
      "apigee.io",
      "siiites.com",
      "appspacehosted.com",
      "appspaceusercontent.com",
      "appudo.net",
      "on-aptible.com",
      "user.aseinet.ne.jp",
      "gv.vc",
      "d.gv.vc",
      "user.party.eus",
      "pimienta.org",
      "poivron.org",
      "potager.org",
      "sweetpepper.org",
      "myasustor.com",
      "cdn.prod.atlassian-dev.net",
      "translated.page",
      "myfritz.net",
      "onavstack.net",
      "*.awdev.ca",
      "*.advisor.ws",
      "ecommerce-shop.pl",
      "b-data.io",
      "backplaneapp.io",
      "balena-devices.com",
      "rs.ba",
      "*.banzai.cloud",
      "app.banzaicloud.io",
      "*.backyards.banzaicloud.io",
      "base.ec",
      "official.ec",
      "buyshop.jp",
      "fashionstore.jp",
      "handcrafted.jp",
      "kawaiishop.jp",
      "supersale.jp",
      "theshop.jp",
      "shopselect.net",
      "base.shop",
      "*.beget.app",
      "betainabox.com",
      "bnr.la",
      "bitbucket.io",
      "blackbaudcdn.net",
      "of.je",
      "bluebite.io",
      "boomla.net",
      "boutir.com",
      "boxfuse.io",
      "square7.ch",
      "bplaced.com",
      "bplaced.de",
      "square7.de",
      "bplaced.net",
      "square7.net",
      "shop.brendly.rs",
      "browsersafetymark.io",
      "uk0.bigv.io",
      "dh.bytemark.co.uk",
      "vm.bytemark.co.uk",
      "cafjs.com",
      "mycd.eu",
      "drr.ac",
      "uwu.ai",
      "carrd.co",
      "crd.co",
      "ju.mp",
      "ae.org",
      "br.com",
      "cn.com",
      "com.de",
      "com.se",
      "de.com",
      "eu.com",
      "gb.net",
      "hu.net",
      "jp.net",
      "jpn.com",
      "mex.com",
      "ru.com",
      "sa.com",
      "se.net",
      "uk.com",
      "uk.net",
      "us.com",
      "za.bz",
      "za.com",
      "ar.com",
      "hu.com",
      "kr.com",
      "no.com",
      "qc.com",
      "uy.com",
      "africa.com",
      "gr.com",
      "in.net",
      "web.in",
      "us.org",
      "co.com",
      "aus.basketball",
      "nz.basketball",
      "radio.am",
      "radio.fm",
      "c.la",
      "certmgr.org",
      "cx.ua",
      "discourse.group",
      "discourse.team",
      "cleverapps.io",
      "clerk.app",
      "clerkstage.app",
      "*.lcl.dev",
      "*.lclstage.dev",
      "*.stg.dev",
      "*.stgstage.dev",
      "clickrising.net",
      "c66.me",
      "cloud66.ws",
      "cloud66.zone",
      "jdevcloud.com",
      "wpdevcloud.com",
      "cloudaccess.host",
      "freesite.host",
      "cloudaccess.net",
      "cloudcontrolled.com",
      "cloudcontrolapp.com",
      "*.cloudera.site",
      "pages.dev",
      "trycloudflare.com",
      "workers.dev",
      "wnext.app",
      "co.ca",
      "*.otap.co",
      "co.cz",
      "c.cdn77.org",
      "cdn77-ssl.net",
      "r.cdn77.net",
      "rsc.cdn77.org",
      "ssl.origin.cdn77-secure.org",
      "cloudns.asia",
      "cloudns.biz",
      "cloudns.club",
      "cloudns.cc",
      "cloudns.eu",
      "cloudns.in",
      "cloudns.info",
      "cloudns.org",
      "cloudns.pro",
      "cloudns.pw",
      "cloudns.us",
      "cnpy.gdn",
      "codeberg.page",
      "co.nl",
      "co.no",
      "webhosting.be",
      "hosting-cluster.nl",
      "ac.ru",
      "edu.ru",
      "gov.ru",
      "int.ru",
      "mil.ru",
      "test.ru",
      "dyn.cosidns.de",
      "dynamisches-dns.de",
      "dnsupdater.de",
      "internet-dns.de",
      "l-o-g-i-n.de",
      "dynamic-dns.info",
      "feste-ip.net",
      "knx-server.net",
      "static-access.net",
      "realm.cz",
      "*.cryptonomic.net",
      "cupcake.is",
      "curv.dev",
      "*.customer-oci.com",
      "*.oci.customer-oci.com",
      "*.ocp.customer-oci.com",
      "*.ocs.customer-oci.com",
      "cyon.link",
      "cyon.site",
      "fnwk.site",
      "folionetwork.site",
      "platform0.app",
      "daplie.me",
      "localhost.daplie.me",
      "dattolocal.com",
      "dattorelay.com",
      "dattoweb.com",
      "mydatto.com",
      "dattolocal.net",
      "mydatto.net",
      "biz.dk",
      "co.dk",
      "firm.dk",
      "reg.dk",
      "store.dk",
      "dyndns.dappnode.io",
      "*.dapps.earth",
      "*.bzz.dapps.earth",
      "builtwithdark.com",
      "demo.datadetect.com",
      "instance.datadetect.com",
      "edgestack.me",
      "ddns5.com",
      "debian.net",
      "deno.dev",
      "deno-staging.dev",
      "dedyn.io",
      "deta.app",
      "deta.dev",
      "*.rss.my.id",
      "*.diher.solutions",
      "discordsays.com",
      "discordsez.com",
      "jozi.biz",
      "dnshome.de",
      "online.th",
      "shop.th",
      "drayddns.com",
      "shoparena.pl",
      "dreamhosters.com",
      "mydrobo.com",
      "drud.io",
      "drud.us",
      "duckdns.org",
      "bip.sh",
      "bitbridge.net",
      "dy.fi",
      "tunk.org",
      "dyndns-at-home.com",
      "dyndns-at-work.com",
      "dyndns-blog.com",
      "dyndns-free.com",
      "dyndns-home.com",
      "dyndns-ip.com",
      "dyndns-mail.com",
      "dyndns-office.com",
      "dyndns-pics.com",
      "dyndns-remote.com",
      "dyndns-server.com",
      "dyndns-web.com",
      "dyndns-wiki.com",
      "dyndns-work.com",
      "dyndns.biz",
      "dyndns.info",
      "dyndns.org",
      "dyndns.tv",
      "at-band-camp.net",
      "ath.cx",
      "barrel-of-knowledge.info",
      "barrell-of-knowledge.info",
      "better-than.tv",
      "blogdns.com",
      "blogdns.net",
      "blogdns.org",
      "blogsite.org",
      "boldlygoingnowhere.org",
      "broke-it.net",
      "buyshouses.net",
      "cechire.com",
      "dnsalias.com",
      "dnsalias.net",
      "dnsalias.org",
      "dnsdojo.com",
      "dnsdojo.net",
      "dnsdojo.org",
      "does-it.net",
      "doesntexist.com",
      "doesntexist.org",
      "dontexist.com",
      "dontexist.net",
      "dontexist.org",
      "doomdns.com",
      "doomdns.org",
      "dvrdns.org",
      "dyn-o-saur.com",
      "dynalias.com",
      "dynalias.net",
      "dynalias.org",
      "dynathome.net",
      "dyndns.ws",
      "endofinternet.net",
      "endofinternet.org",
      "endoftheinternet.org",
      "est-a-la-maison.com",
      "est-a-la-masion.com",
      "est-le-patron.com",
      "est-mon-blogueur.com",
      "for-better.biz",
      "for-more.biz",
      "for-our.info",
      "for-some.biz",
      "for-the.biz",
      "forgot.her.name",
      "forgot.his.name",
      "from-ak.com",
      "from-al.com",
      "from-ar.com",
      "from-az.net",
      "from-ca.com",
      "from-co.net",
      "from-ct.com",
      "from-dc.com",
      "from-de.com",
      "from-fl.com",
      "from-ga.com",
      "from-hi.com",
      "from-ia.com",
      "from-id.com",
      "from-il.com",
      "from-in.com",
      "from-ks.com",
      "from-ky.com",
      "from-la.net",
      "from-ma.com",
      "from-md.com",
      "from-me.org",
      "from-mi.com",
      "from-mn.com",
      "from-mo.com",
      "from-ms.com",
      "from-mt.com",
      "from-nc.com",
      "from-nd.com",
      "from-ne.com",
      "from-nh.com",
      "from-nj.com",
      "from-nm.com",
      "from-nv.com",
      "from-ny.net",
      "from-oh.com",
      "from-ok.com",
      "from-or.com",
      "from-pa.com",
      "from-pr.com",
      "from-ri.com",
      "from-sc.com",
      "from-sd.com",
      "from-tn.com",
      "from-tx.com",
      "from-ut.com",
      "from-va.com",
      "from-vt.com",
      "from-wa.com",
      "from-wi.com",
      "from-wv.com",
      "from-wy.com",
      "ftpaccess.cc",
      "fuettertdasnetz.de",
      "game-host.org",
      "game-server.cc",
      "getmyip.com",
      "gets-it.net",
      "go.dyndns.org",
      "gotdns.com",
      "gotdns.org",
      "groks-the.info",
      "groks-this.info",
      "ham-radio-op.net",
      "here-for-more.info",
      "hobby-site.com",
      "hobby-site.org",
      "home.dyndns.org",
      "homedns.org",
      "homeftp.net",
      "homeftp.org",
      "homeip.net",
      "homelinux.com",
      "homelinux.net",
      "homelinux.org",
      "homeunix.com",
      "homeunix.net",
      "homeunix.org",
      "iamallama.com",
      "in-the-band.net",
      "is-a-anarchist.com",
      "is-a-blogger.com",
      "is-a-bookkeeper.com",
      "is-a-bruinsfan.org",
      "is-a-bulls-fan.com",
      "is-a-candidate.org",
      "is-a-caterer.com",
      "is-a-celticsfan.org",
      "is-a-chef.com",
      "is-a-chef.net",
      "is-a-chef.org",
      "is-a-conservative.com",
      "is-a-cpa.com",
      "is-a-cubicle-slave.com",
      "is-a-democrat.com",
      "is-a-designer.com",
      "is-a-doctor.com",
      "is-a-financialadvisor.com",
      "is-a-geek.com",
      "is-a-geek.net",
      "is-a-geek.org",
      "is-a-green.com",
      "is-a-guru.com",
      "is-a-hard-worker.com",
      "is-a-hunter.com",
      "is-a-knight.org",
      "is-a-landscaper.com",
      "is-a-lawyer.com",
      "is-a-liberal.com",
      "is-a-libertarian.com",
      "is-a-linux-user.org",
      "is-a-llama.com",
      "is-a-musician.com",
      "is-a-nascarfan.com",
      "is-a-nurse.com",
      "is-a-painter.com",
      "is-a-patsfan.org",
      "is-a-personaltrainer.com",
      "is-a-photographer.com",
      "is-a-player.com",
      "is-a-republican.com",
      "is-a-rockstar.com",
      "is-a-socialist.com",
      "is-a-soxfan.org",
      "is-a-student.com",
      "is-a-teacher.com",
      "is-a-techie.com",
      "is-a-therapist.com",
      "is-an-accountant.com",
      "is-an-actor.com",
      "is-an-actress.com",
      "is-an-anarchist.com",
      "is-an-artist.com",
      "is-an-engineer.com",
      "is-an-entertainer.com",
      "is-by.us",
      "is-certified.com",
      "is-found.org",
      "is-gone.com",
      "is-into-anime.com",
      "is-into-cars.com",
      "is-into-cartoons.com",
      "is-into-games.com",
      "is-leet.com",
      "is-lost.org",
      "is-not-certified.com",
      "is-saved.org",
      "is-slick.com",
      "is-uberleet.com",
      "is-very-bad.org",
      "is-very-evil.org",
      "is-very-good.org",
      "is-very-nice.org",
      "is-very-sweet.org",
      "is-with-theband.com",
      "isa-geek.com",
      "isa-geek.net",
      "isa-geek.org",
      "isa-hockeynut.com",
      "issmarterthanyou.com",
      "isteingeek.de",
      "istmein.de",
      "kicks-ass.net",
      "kicks-ass.org",
      "knowsitall.info",
      "land-4-sale.us",
      "lebtimnetz.de",
      "leitungsen.de",
      "likes-pie.com",
      "likescandy.com",
      "merseine.nu",
      "mine.nu",
      "misconfused.org",
      "mypets.ws",
      "myphotos.cc",
      "neat-url.com",
      "office-on-the.net",
      "on-the-web.tv",
      "podzone.net",
      "podzone.org",
      "readmyblog.org",
      "saves-the-whales.com",
      "scrapper-site.net",
      "scrapping.cc",
      "selfip.biz",
      "selfip.com",
      "selfip.info",
      "selfip.net",
      "selfip.org",
      "sells-for-less.com",
      "sells-for-u.com",
      "sells-it.net",
      "sellsyourhome.org",
      "servebbs.com",
      "servebbs.net",
      "servebbs.org",
      "serveftp.net",
      "serveftp.org",
      "servegame.org",
      "shacknet.nu",
      "simple-url.com",
      "space-to-rent.com",
      "stuff-4-sale.org",
      "stuff-4-sale.us",
      "teaches-yoga.com",
      "thruhere.net",
      "traeumtgerade.de",
      "webhop.biz",
      "webhop.info",
      "webhop.net",
      "webhop.org",
      "worse-than.tv",
      "writesthisblog.com",
      "ddnss.de",
      "dyn.ddnss.de",
      "dyndns.ddnss.de",
      "dyndns1.de",
      "dyn-ip24.de",
      "home-webserver.de",
      "dyn.home-webserver.de",
      "myhome-server.de",
      "ddnss.org",
      "definima.net",
      "definima.io",
      "ondigitalocean.app",
      "*.digitaloceanspaces.com",
      "bci.dnstrace.pro",
      "ddnsfree.com",
      "ddnsgeek.com",
      "giize.com",
      "gleeze.com",
      "kozow.com",
      "loseyourip.com",
      "ooguy.com",
      "theworkpc.com",
      "casacam.net",
      "dynu.net",
      "accesscam.org",
      "camdvr.org",
      "freeddns.org",
      "mywire.org",
      "webredirect.org",
      "myddns.rocks",
      "blogsite.xyz",
      "dynv6.net",
      "e4.cz",
      "eero.online",
      "eero-stage.online",
      "elementor.cloud",
      "elementor.cool",
      "en-root.fr",
      "mytuleap.com",
      "tuleap-partners.com",
      "encr.app",
      "encoreapi.com",
      "onred.one",
      "staging.onred.one",
      "eu.encoway.cloud",
      "eu.org",
      "al.eu.org",
      "asso.eu.org",
      "at.eu.org",
      "au.eu.org",
      "be.eu.org",
      "bg.eu.org",
      "ca.eu.org",
      "cd.eu.org",
      "ch.eu.org",
      "cn.eu.org",
      "cy.eu.org",
      "cz.eu.org",
      "de.eu.org",
      "dk.eu.org",
      "edu.eu.org",
      "ee.eu.org",
      "es.eu.org",
      "fi.eu.org",
      "fr.eu.org",
      "gr.eu.org",
      "hr.eu.org",
      "hu.eu.org",
      "ie.eu.org",
      "il.eu.org",
      "in.eu.org",
      "int.eu.org",
      "is.eu.org",
      "it.eu.org",
      "jp.eu.org",
      "kr.eu.org",
      "lt.eu.org",
      "lu.eu.org",
      "lv.eu.org",
      "mc.eu.org",
      "me.eu.org",
      "mk.eu.org",
      "mt.eu.org",
      "my.eu.org",
      "net.eu.org",
      "ng.eu.org",
      "nl.eu.org",
      "no.eu.org",
      "nz.eu.org",
      "paris.eu.org",
      "pl.eu.org",
      "pt.eu.org",
      "q-a.eu.org",
      "ro.eu.org",
      "ru.eu.org",
      "se.eu.org",
      "si.eu.org",
      "sk.eu.org",
      "tr.eu.org",
      "uk.eu.org",
      "us.eu.org",
      "eurodir.ru",
      "eu-1.evennode.com",
      "eu-2.evennode.com",
      "eu-3.evennode.com",
      "eu-4.evennode.com",
      "us-1.evennode.com",
      "us-2.evennode.com",
      "us-3.evennode.com",
      "us-4.evennode.com",
      "twmail.cc",
      "twmail.net",
      "twmail.org",
      "mymailer.com.tw",
      "url.tw",
      "onfabrica.com",
      "apps.fbsbx.com",
      "ru.net",
      "adygeya.ru",
      "bashkiria.ru",
      "bir.ru",
      "cbg.ru",
      "com.ru",
      "dagestan.ru",
      "grozny.ru",
      "kalmykia.ru",
      "kustanai.ru",
      "marine.ru",
      "mordovia.ru",
      "msk.ru",
      "mytis.ru",
      "nalchik.ru",
      "nov.ru",
      "pyatigorsk.ru",
      "spb.ru",
      "vladikavkaz.ru",
      "vladimir.ru",
      "abkhazia.su",
      "adygeya.su",
      "aktyubinsk.su",
      "arkhangelsk.su",
      "armenia.su",
      "ashgabad.su",
      "azerbaijan.su",
      "balashov.su",
      "bashkiria.su",
      "bryansk.su",
      "bukhara.su",
      "chimkent.su",
      "dagestan.su",
      "east-kazakhstan.su",
      "exnet.su",
      "georgia.su",
      "grozny.su",
      "ivanovo.su",
      "jambyl.su",
      "kalmykia.su",
      "kaluga.su",
      "karacol.su",
      "karaganda.su",
      "karelia.su",
      "khakassia.su",
      "krasnodar.su",
      "kurgan.su",
      "kustanai.su",
      "lenug.su",
      "mangyshlak.su",
      "mordovia.su",
      "msk.su",
      "murmansk.su",
      "nalchik.su",
      "navoi.su",
      "north-kazakhstan.su",
      "nov.su",
      "obninsk.su",
      "penza.su",
      "pokrovsk.su",
      "sochi.su",
      "spb.su",
      "tashkent.su",
      "termez.su",
      "togliatti.su",
      "troitsk.su",
      "tselinograd.su",
      "tula.su",
      "tuva.su",
      "vladikavkaz.su",
      "vladimir.su",
      "vologda.su",
      "channelsdvr.net",
      "u.channelsdvr.net",
      "edgecompute.app",
      "fastly-terrarium.com",
      "fastlylb.net",
      "map.fastlylb.net",
      "freetls.fastly.net",
      "map.fastly.net",
      "a.prod.fastly.net",
      "global.prod.fastly.net",
      "a.ssl.fastly.net",
      "b.ssl.fastly.net",
      "global.ssl.fastly.net",
      "fastvps-server.com",
      "fastvps.host",
      "myfast.host",
      "fastvps.site",
      "myfast.space",
      "fedorainfracloud.org",
      "fedorapeople.org",
      "cloud.fedoraproject.org",
      "app.os.fedoraproject.org",
      "app.os.stg.fedoraproject.org",
      "conn.uk",
      "copro.uk",
      "hosp.uk",
      "mydobiss.com",
      "fh-muenster.io",
      "filegear.me",
      "filegear-au.me",
      "filegear-de.me",
      "filegear-gb.me",
      "filegear-ie.me",
      "filegear-jp.me",
      "filegear-sg.me",
      "firebaseapp.com",
      "fireweb.app",
      "flap.id",
      "onflashdrive.app",
      "fldrv.com",
      "fly.dev",
      "edgeapp.net",
      "shw.io",
      "flynnhosting.net",
      "forgeblocks.com",
      "id.forgerock.io",
      "framer.app",
      "framercanvas.com",
      "*.frusky.de",
      "ravpage.co.il",
      "0e.vc",
      "freebox-os.com",
      "freeboxos.com",
      "fbx-os.fr",
      "fbxos.fr",
      "freebox-os.fr",
      "freeboxos.fr",
      "freedesktop.org",
      "freemyip.com",
      "wien.funkfeuer.at",
      "*.futurecms.at",
      "*.ex.futurecms.at",
      "*.in.futurecms.at",
      "futurehosting.at",
      "futuremailing.at",
      "*.ex.ortsinfo.at",
      "*.kunden.ortsinfo.at",
      "*.statics.cloud",
      "independent-commission.uk",
      "independent-inquest.uk",
      "independent-inquiry.uk",
      "independent-panel.uk",
      "independent-review.uk",
      "public-inquiry.uk",
      "royal-commission.uk",
      "campaign.gov.uk",
      "service.gov.uk",
      "api.gov.uk",
      "gehirn.ne.jp",
      "usercontent.jp",
      "gentapps.com",
      "gentlentapis.com",
      "lab.ms",
      "cdn-edges.net",
      "ghost.io",
      "gsj.bz",
      "githubusercontent.com",
      "githubpreview.dev",
      "github.io",
      "gitlab.io",
      "gitapp.si",
      "gitpage.si",
      "glitch.me",
      "nog.community",
      "co.ro",
      "shop.ro",
      "lolipop.io",
      "angry.jp",
      "babyblue.jp",
      "babymilk.jp",
      "backdrop.jp",
      "bambina.jp",
      "bitter.jp",
      "blush.jp",
      "boo.jp",
      "boy.jp",
      "boyfriend.jp",
      "but.jp",
      "candypop.jp",
      "capoo.jp",
      "catfood.jp",
      "cheap.jp",
      "chicappa.jp",
      "chillout.jp",
      "chips.jp",
      "chowder.jp",
      "chu.jp",
      "ciao.jp",
      "cocotte.jp",
      "coolblog.jp",
      "cranky.jp",
      "cutegirl.jp",
      "daa.jp",
      "deca.jp",
      "deci.jp",
      "digick.jp",
      "egoism.jp",
      "fakefur.jp",
      "fem.jp",
      "flier.jp",
      "floppy.jp",
      "fool.jp",
      "frenchkiss.jp",
      "girlfriend.jp",
      "girly.jp",
      "gloomy.jp",
      "gonna.jp",
      "greater.jp",
      "hacca.jp",
      "heavy.jp",
      "her.jp",
      "hiho.jp",
      "hippy.jp",
      "holy.jp",
      "hungry.jp",
      "icurus.jp",
      "itigo.jp",
      "jellybean.jp",
      "kikirara.jp",
      "kill.jp",
      "kilo.jp",
      "kuron.jp",
      "littlestar.jp",
      "lolipopmc.jp",
      "lolitapunk.jp",
      "lomo.jp",
      "lovepop.jp",
      "lovesick.jp",
      "main.jp",
      "mods.jp",
      "mond.jp",
      "mongolian.jp",
      "moo.jp",
      "namaste.jp",
      "nikita.jp",
      "nobushi.jp",
      "noor.jp",
      "oops.jp",
      "parallel.jp",
      "parasite.jp",
      "pecori.jp",
      "peewee.jp",
      "penne.jp",
      "pepper.jp",
      "perma.jp",
      "pigboat.jp",
      "pinoko.jp",
      "punyu.jp",
      "pupu.jp",
      "pussycat.jp",
      "pya.jp",
      "raindrop.jp",
      "readymade.jp",
      "sadist.jp",
      "schoolbus.jp",
      "secret.jp",
      "staba.jp",
      "stripper.jp",
      "sub.jp",
      "sunnyday.jp",
      "thick.jp",
      "tonkotsu.jp",
      "under.jp",
      "upper.jp",
      "velvet.jp",
      "verse.jp",
      "versus.jp",
      "vivian.jp",
      "watson.jp",
      "weblike.jp",
      "whitesnow.jp",
      "zombie.jp",
      "heteml.net",
      "cloudapps.digital",
      "london.cloudapps.digital",
      "pymnt.uk",
      "homeoffice.gov.uk",
      "ro.im",
      "goip.de",
      "run.app",
      "a.run.app",
      "web.app",
      "*.0emm.com",
      "appspot.com",
      "*.r.appspot.com",
      "codespot.com",
      "googleapis.com",
      "googlecode.com",
      "pagespeedmobilizer.com",
      "publishproxy.com",
      "withgoogle.com",
      "withyoutube.com",
      "*.gateway.dev",
      "cloud.goog",
      "translate.goog",
      "*.usercontent.goog",
      "cloudfunctions.net",
      "blogspot.ae",
      "blogspot.al",
      "blogspot.am",
      "blogspot.ba",
      "blogspot.be",
      "blogspot.bg",
      "blogspot.bj",
      "blogspot.ca",
      "blogspot.cf",
      "blogspot.ch",
      "blogspot.cl",
      "blogspot.co.at",
      "blogspot.co.id",
      "blogspot.co.il",
      "blogspot.co.ke",
      "blogspot.co.nz",
      "blogspot.co.uk",
      "blogspot.co.za",
      "blogspot.com",
      "blogspot.com.ar",
      "blogspot.com.au",
      "blogspot.com.br",
      "blogspot.com.by",
      "blogspot.com.co",
      "blogspot.com.cy",
      "blogspot.com.ee",
      "blogspot.com.eg",
      "blogspot.com.es",
      "blogspot.com.mt",
      "blogspot.com.ng",
      "blogspot.com.tr",
      "blogspot.com.uy",
      "blogspot.cv",
      "blogspot.cz",
      "blogspot.de",
      "blogspot.dk",
      "blogspot.fi",
      "blogspot.fr",
      "blogspot.gr",
      "blogspot.hk",
      "blogspot.hr",
      "blogspot.hu",
      "blogspot.ie",
      "blogspot.in",
      "blogspot.is",
      "blogspot.it",
      "blogspot.jp",
      "blogspot.kr",
      "blogspot.li",
      "blogspot.lt",
      "blogspot.lu",
      "blogspot.md",
      "blogspot.mk",
      "blogspot.mr",
      "blogspot.mx",
      "blogspot.my",
      "blogspot.nl",
      "blogspot.no",
      "blogspot.pe",
      "blogspot.pt",
      "blogspot.qa",
      "blogspot.re",
      "blogspot.ro",
      "blogspot.rs",
      "blogspot.ru",
      "blogspot.se",
      "blogspot.sg",
      "blogspot.si",
      "blogspot.sk",
      "blogspot.sn",
      "blogspot.td",
      "blogspot.tw",
      "blogspot.ug",
      "blogspot.vn",
      "goupile.fr",
      "gov.nl",
      "awsmppl.com",
      "g\xFCnstigbestellen.de",
      "g\xFCnstigliefern.de",
      "fin.ci",
      "free.hr",
      "caa.li",
      "ua.rs",
      "conf.se",
      "hs.zone",
      "hs.run",
      "hashbang.sh",
      "hasura.app",
      "hasura-app.io",
      "pages.it.hs-heilbronn.de",
      "hepforge.org",
      "herokuapp.com",
      "herokussl.com",
      "ravendb.cloud",
      "myravendb.com",
      "ravendb.community",
      "ravendb.me",
      "development.run",
      "ravendb.run",
      "homesklep.pl",
      "secaas.hk",
      "hoplix.shop",
      "orx.biz",
      "biz.gl",
      "col.ng",
      "firm.ng",
      "gen.ng",
      "ltd.ng",
      "ngo.ng",
      "edu.scot",
      "sch.so",
      "hostyhosting.io",
      "h\xE4kkinen.fi",
      "*.moonscale.io",
      "moonscale.net",
      "iki.fi",
      "ibxos.it",
      "iliadboxos.it",
      "impertrixcdn.com",
      "impertrix.com",
      "smushcdn.com",
      "wphostedmail.com",
      "wpmucdn.com",
      "tempurl.host",
      "wpmudev.host",
      "dyn-berlin.de",
      "in-berlin.de",
      "in-brb.de",
      "in-butter.de",
      "in-dsl.de",
      "in-dsl.net",
      "in-dsl.org",
      "in-vpn.de",
      "in-vpn.net",
      "in-vpn.org",
      "biz.at",
      "info.at",
      "info.cx",
      "ac.leg.br",
      "al.leg.br",
      "am.leg.br",
      "ap.leg.br",
      "ba.leg.br",
      "ce.leg.br",
      "df.leg.br",
      "es.leg.br",
      "go.leg.br",
      "ma.leg.br",
      "mg.leg.br",
      "ms.leg.br",
      "mt.leg.br",
      "pa.leg.br",
      "pb.leg.br",
      "pe.leg.br",
      "pi.leg.br",
      "pr.leg.br",
      "rj.leg.br",
      "rn.leg.br",
      "ro.leg.br",
      "rr.leg.br",
      "rs.leg.br",
      "sc.leg.br",
      "se.leg.br",
      "sp.leg.br",
      "to.leg.br",
      "pixolino.com",
      "na4u.ru",
      "iopsys.se",
      "ipifony.net",
      "iservschule.de",
      "mein-iserv.de",
      "schulplattform.de",
      "schulserver.de",
      "test-iserv.de",
      "iserv.dev",
      "iobb.net",
      "mel.cloudlets.com.au",
      "cloud.interhostsolutions.be",
      "users.scale.virtualcloud.com.br",
      "mycloud.by",
      "alp1.ae.flow.ch",
      "appengine.flow.ch",
      "es-1.axarnet.cloud",
      "diadem.cloud",
      "vip.jelastic.cloud",
      "jele.cloud",
      "it1.eur.aruba.jenv-aruba.cloud",
      "it1.jenv-aruba.cloud",
      "keliweb.cloud",
      "cs.keliweb.cloud",
      "oxa.cloud",
      "tn.oxa.cloud",
      "uk.oxa.cloud",
      "primetel.cloud",
      "uk.primetel.cloud",
      "ca.reclaim.cloud",
      "uk.reclaim.cloud",
      "us.reclaim.cloud",
      "ch.trendhosting.cloud",
      "de.trendhosting.cloud",
      "jele.club",
      "amscompute.com",
      "clicketcloud.com",
      "dopaas.com",
      "hidora.com",
      "paas.hosted-by-previder.com",
      "rag-cloud.hosteur.com",
      "rag-cloud-ch.hosteur.com",
      "jcloud.ik-server.com",
      "jcloud-ver-jpc.ik-server.com",
      "demo.jelastic.com",
      "kilatiron.com",
      "paas.massivegrid.com",
      "jed.wafaicloud.com",
      "lon.wafaicloud.com",
      "ryd.wafaicloud.com",
      "j.scaleforce.com.cy",
      "jelastic.dogado.eu",
      "fi.cloudplatform.fi",
      "demo.datacenter.fi",
      "paas.datacenter.fi",
      "jele.host",
      "mircloud.host",
      "paas.beebyte.io",
      "sekd1.beebyteapp.io",
      "jele.io",
      "cloud-fr1.unispace.io",
      "jc.neen.it",
      "cloud.jelastic.open.tim.it",
      "jcloud.kz",
      "upaas.kazteleport.kz",
      "cloudjiffy.net",
      "fra1-de.cloudjiffy.net",
      "west1-us.cloudjiffy.net",
      "jls-sto1.elastx.net",
      "jls-sto2.elastx.net",
      "jls-sto3.elastx.net",
      "faststacks.net",
      "fr-1.paas.massivegrid.net",
      "lon-1.paas.massivegrid.net",
      "lon-2.paas.massivegrid.net",
      "ny-1.paas.massivegrid.net",
      "ny-2.paas.massivegrid.net",
      "sg-1.paas.massivegrid.net",
      "jelastic.saveincloud.net",
      "nordeste-idc.saveincloud.net",
      "j.scaleforce.net",
      "jelastic.tsukaeru.net",
      "sdscloud.pl",
      "unicloud.pl",
      "mircloud.ru",
      "jelastic.regruhosting.ru",
      "enscaled.sg",
      "jele.site",
      "jelastic.team",
      "orangecloud.tn",
      "j.layershift.co.uk",
      "phx.enscaled.us",
      "mircloud.us",
      "myjino.ru",
      "*.hosting.myjino.ru",
      "*.landing.myjino.ru",
      "*.spectrum.myjino.ru",
      "*.vps.myjino.ru",
      "jotelulu.cloud",
      "*.triton.zone",
      "*.cns.joyent.com",
      "js.org",
      "kaas.gg",
      "khplay.nl",
      "ktistory.com",
      "kapsi.fi",
      "keymachine.de",
      "kinghost.net",
      "uni5.net",
      "knightpoint.systems",
      "koobin.events",
      "oya.to",
      "kuleuven.cloud",
      "ezproxy.kuleuven.be",
      "co.krd",
      "edu.krd",
      "krellian.net",
      "webthings.io",
      "git-repos.de",
      "lcube-server.de",
      "svn-repos.de",
      "leadpages.co",
      "lpages.co",
      "lpusercontent.com",
      "lelux.site",
      "co.business",
      "co.education",
      "co.events",
      "co.financial",
      "co.network",
      "co.place",
      "co.technology",
      "app.lmpm.com",
      "linkyard.cloud",
      "linkyard-cloud.ch",
      "members.linode.com",
      "*.nodebalancer.linode.com",
      "*.linodeobjects.com",
      "ip.linodeusercontent.com",
      "we.bs",
      "*.user.localcert.dev",
      "localzone.xyz",
      "loginline.app",
      "loginline.dev",
      "loginline.io",
      "loginline.services",
      "loginline.site",
      "servers.run",
      "lohmus.me",
      "krasnik.pl",
      "leczna.pl",
      "lubartow.pl",
      "lublin.pl",
      "poniatowa.pl",
      "swidnik.pl",
      "glug.org.uk",
      "lug.org.uk",
      "lugs.org.uk",
      "barsy.bg",
      "barsy.co.uk",
      "barsyonline.co.uk",
      "barsycenter.com",
      "barsyonline.com",
      "barsy.club",
      "barsy.de",
      "barsy.eu",
      "barsy.in",
      "barsy.info",
      "barsy.io",
      "barsy.me",
      "barsy.menu",
      "barsy.mobi",
      "barsy.net",
      "barsy.online",
      "barsy.org",
      "barsy.pro",
      "barsy.pub",
      "barsy.ro",
      "barsy.shop",
      "barsy.site",
      "barsy.support",
      "barsy.uk",
      "*.magentosite.cloud",
      "mayfirst.info",
      "mayfirst.org",
      "hb.cldmail.ru",
      "cn.vu",
      "mazeplay.com",
      "mcpe.me",
      "mcdir.me",
      "mcdir.ru",
      "mcpre.ru",
      "vps.mcdir.ru",
      "mediatech.by",
      "mediatech.dev",
      "hra.health",
      "miniserver.com",
      "memset.net",
      "messerli.app",
      "*.cloud.metacentrum.cz",
      "custom.metacentrum.cz",
      "flt.cloud.muni.cz",
      "usr.cloud.muni.cz",
      "meteorapp.com",
      "eu.meteorapp.com",
      "co.pl",
      "*.azurecontainer.io",
      "azurewebsites.net",
      "azure-mobile.net",
      "cloudapp.net",
      "azurestaticapps.net",
      "1.azurestaticapps.net",
      "centralus.azurestaticapps.net",
      "eastasia.azurestaticapps.net",
      "eastus2.azurestaticapps.net",
      "westeurope.azurestaticapps.net",
      "westus2.azurestaticapps.net",
      "csx.cc",
      "mintere.site",
      "forte.id",
      "mozilla-iot.org",
      "bmoattachments.org",
      "net.ru",
      "org.ru",
      "pp.ru",
      "hostedpi.com",
      "customer.mythic-beasts.com",
      "caracal.mythic-beasts.com",
      "fentiger.mythic-beasts.com",
      "lynx.mythic-beasts.com",
      "ocelot.mythic-beasts.com",
      "oncilla.mythic-beasts.com",
      "onza.mythic-beasts.com",
      "sphinx.mythic-beasts.com",
      "vs.mythic-beasts.com",
      "x.mythic-beasts.com",
      "yali.mythic-beasts.com",
      "cust.retrosnub.co.uk",
      "ui.nabu.casa",
      "pony.club",
      "of.fashion",
      "in.london",
      "of.london",
      "from.marketing",
      "with.marketing",
      "for.men",
      "repair.men",
      "and.mom",
      "for.mom",
      "for.one",
      "under.one",
      "for.sale",
      "that.win",
      "from.work",
      "to.work",
      "cloud.nospamproxy.com",
      "netlify.app",
      "4u.com",
      "ngrok.io",
      "nh-serv.co.uk",
      "nfshost.com",
      "*.developer.app",
      "noop.app",
      "*.northflank.app",
      "*.build.run",
      "*.code.run",
      "*.database.run",
      "*.migration.run",
      "noticeable.news",
      "dnsking.ch",
      "mypi.co",
      "n4t.co",
      "001www.com",
      "ddnslive.com",
      "myiphost.com",
      "forumz.info",
      "16-b.it",
      "32-b.it",
      "64-b.it",
      "soundcast.me",
      "tcp4.me",
      "dnsup.net",
      "hicam.net",
      "now-dns.net",
      "ownip.net",
      "vpndns.net",
      "dynserv.org",
      "now-dns.org",
      "x443.pw",
      "now-dns.top",
      "ntdll.top",
      "freeddns.us",
      "crafting.xyz",
      "zapto.xyz",
      "nsupdate.info",
      "nerdpol.ovh",
      "blogsyte.com",
      "brasilia.me",
      "cable-modem.org",
      "ciscofreak.com",
      "collegefan.org",
      "couchpotatofries.org",
      "damnserver.com",
      "ddns.me",
      "ditchyourip.com",
      "dnsfor.me",
      "dnsiskinky.com",
      "dvrcam.info",
      "dynns.com",
      "eating-organic.net",
      "fantasyleague.cc",
      "geekgalaxy.com",
      "golffan.us",
      "health-carereform.com",
      "homesecuritymac.com",
      "homesecuritypc.com",
      "hopto.me",
      "ilovecollege.info",
      "loginto.me",
      "mlbfan.org",
      "mmafan.biz",
      "myactivedirectory.com",
      "mydissent.net",
      "myeffect.net",
      "mymediapc.net",
      "mypsx.net",
      "mysecuritycamera.com",
      "mysecuritycamera.net",
      "mysecuritycamera.org",
      "net-freaks.com",
      "nflfan.org",
      "nhlfan.net",
      "no-ip.ca",
      "no-ip.co.uk",
      "no-ip.net",
      "noip.us",
      "onthewifi.com",
      "pgafan.net",
      "point2this.com",
      "pointto.us",
      "privatizehealthinsurance.net",
      "quicksytes.com",
      "read-books.org",
      "securitytactics.com",
      "serveexchange.com",
      "servehumour.com",
      "servep2p.com",
      "servesarcasm.com",
      "stufftoread.com",
      "ufcfan.org",
      "unusualperson.com",
      "workisboring.com",
      "3utilities.com",
      "bounceme.net",
      "ddns.net",
      "ddnsking.com",
      "gotdns.ch",
      "hopto.org",
      "myftp.biz",
      "myftp.org",
      "myvnc.com",
      "no-ip.biz",
      "no-ip.info",
      "no-ip.org",
      "noip.me",
      "redirectme.net",
      "servebeer.com",
      "serveblog.net",
      "servecounterstrike.com",
      "serveftp.com",
      "servegame.com",
      "servehalflife.com",
      "servehttp.com",
      "serveirc.com",
      "serveminecraft.net",
      "servemp3.com",
      "servepics.com",
      "servequake.com",
      "sytes.net",
      "webhop.me",
      "zapto.org",
      "stage.nodeart.io",
      "pcloud.host",
      "nyc.mn",
      "static.observableusercontent.com",
      "cya.gg",
      "omg.lol",
      "cloudycluster.net",
      "omniwe.site",
      "service.one",
      "nid.io",
      "opensocial.site",
      "opencraft.hosting",
      "orsites.com",
      "operaunite.com",
      "tech.orange",
      "authgear-staging.com",
      "authgearapps.com",
      "skygearapp.com",
      "outsystemscloud.com",
      "*.webpaas.ovh.net",
      "*.hosting.ovh.net",
      "ownprovider.com",
      "own.pm",
      "*.owo.codes",
      "ox.rs",
      "oy.lc",
      "pgfog.com",
      "pagefrontapp.com",
      "pagexl.com",
      "*.paywhirl.com",
      "bar0.net",
      "bar1.net",
      "bar2.net",
      "rdv.to",
      "art.pl",
      "gliwice.pl",
      "krakow.pl",
      "poznan.pl",
      "wroc.pl",
      "zakopane.pl",
      "pantheonsite.io",
      "gotpantheon.com",
      "mypep.link",
      "perspecta.cloud",
      "lk3.ru",
      "on-web.fr",
      "bc.platform.sh",
      "ent.platform.sh",
      "eu.platform.sh",
      "us.platform.sh",
      "*.platformsh.site",
      "*.tst.site",
      "platter-app.com",
      "platter-app.dev",
      "platterp.us",
      "pdns.page",
      "plesk.page",
      "pleskns.com",
      "dyn53.io",
      "onporter.run",
      "co.bn",
      "postman-echo.com",
      "pstmn.io",
      "mock.pstmn.io",
      "httpbin.org",
      "prequalifyme.today",
      "xen.prgmr.com",
      "priv.at",
      "prvcy.page",
      "*.dweb.link",
      "protonet.io",
      "chirurgiens-dentistes-en-france.fr",
      "byen.site",
      "pubtls.org",
      "pythonanywhere.com",
      "eu.pythonanywhere.com",
      "qoto.io",
      "qualifioapp.com",
      "qbuser.com",
      "cloudsite.builders",
      "instances.spawn.cc",
      "instantcloud.cn",
      "ras.ru",
      "qa2.com",
      "qcx.io",
      "*.sys.qcx.io",
      "dev-myqnapcloud.com",
      "alpha-myqnapcloud.com",
      "myqnapcloud.com",
      "*.quipelements.com",
      "vapor.cloud",
      "vaporcloud.io",
      "rackmaze.com",
      "rackmaze.net",
      "g.vbrplsbx.io",
      "*.on-k3s.io",
      "*.on-rancher.cloud",
      "*.on-rio.io",
      "readthedocs.io",
      "rhcloud.com",
      "app.render.com",
      "onrender.com",
      "repl.co",
      "id.repl.co",
      "repl.run",
      "resindevice.io",
      "devices.resinstaging.io",
      "hzc.io",
      "wellbeingzone.eu",
      "wellbeingzone.co.uk",
      "adimo.co.uk",
      "itcouldbewor.se",
      "git-pages.rit.edu",
      "rocky.page",
      "\u0431\u0438\u0437.\u0440\u0443\u0441",
      "\u043A\u043E\u043C.\u0440\u0443\u0441",
      "\u043A\u0440\u044B\u043C.\u0440\u0443\u0441",
      "\u043C\u0438\u0440.\u0440\u0443\u0441",
      "\u043C\u0441\u043A.\u0440\u0443\u0441",
      "\u043E\u0440\u0433.\u0440\u0443\u0441",
      "\u0441\u0430\u043C\u0430\u0440\u0430.\u0440\u0443\u0441",
      "\u0441\u043E\u0447\u0438.\u0440\u0443\u0441",
      "\u0441\u043F\u0431.\u0440\u0443\u0441",
      "\u044F.\u0440\u0443\u0441",
      "*.builder.code.com",
      "*.dev-builder.code.com",
      "*.stg-builder.code.com",
      "sandcats.io",
      "logoip.de",
      "logoip.com",
      "fr-par-1.baremetal.scw.cloud",
      "fr-par-2.baremetal.scw.cloud",
      "nl-ams-1.baremetal.scw.cloud",
      "fnc.fr-par.scw.cloud",
      "functions.fnc.fr-par.scw.cloud",
      "k8s.fr-par.scw.cloud",
      "nodes.k8s.fr-par.scw.cloud",
      "s3.fr-par.scw.cloud",
      "s3-website.fr-par.scw.cloud",
      "whm.fr-par.scw.cloud",
      "priv.instances.scw.cloud",
      "pub.instances.scw.cloud",
      "k8s.scw.cloud",
      "k8s.nl-ams.scw.cloud",
      "nodes.k8s.nl-ams.scw.cloud",
      "s3.nl-ams.scw.cloud",
      "s3-website.nl-ams.scw.cloud",
      "whm.nl-ams.scw.cloud",
      "k8s.pl-waw.scw.cloud",
      "nodes.k8s.pl-waw.scw.cloud",
      "s3.pl-waw.scw.cloud",
      "s3-website.pl-waw.scw.cloud",
      "scalebook.scw.cloud",
      "smartlabeling.scw.cloud",
      "dedibox.fr",
      "schokokeks.net",
      "gov.scot",
      "service.gov.scot",
      "scrysec.com",
      "firewall-gateway.com",
      "firewall-gateway.de",
      "my-gateway.de",
      "my-router.de",
      "spdns.de",
      "spdns.eu",
      "firewall-gateway.net",
      "my-firewall.org",
      "myfirewall.org",
      "spdns.org",
      "seidat.net",
      "sellfy.store",
      "senseering.net",
      "minisite.ms",
      "magnet.page",
      "biz.ua",
      "co.ua",
      "pp.ua",
      "shiftcrypto.dev",
      "shiftcrypto.io",
      "shiftedit.io",
      "myshopblocks.com",
      "myshopify.com",
      "shopitsite.com",
      "shopware.store",
      "mo-siemens.io",
      "1kapp.com",
      "appchizi.com",
      "applinzi.com",
      "sinaapp.com",
      "vipsinaapp.com",
      "siteleaf.net",
      "bounty-full.com",
      "alpha.bounty-full.com",
      "beta.bounty-full.com",
      "small-web.org",
      "vp4.me",
      "try-snowplow.com",
      "srht.site",
      "stackhero-network.com",
      "musician.io",
      "novecore.site",
      "static.land",
      "dev.static.land",
      "sites.static.land",
      "storebase.store",
      "vps-host.net",
      "atl.jelastic.vps-host.net",
      "njs.jelastic.vps-host.net",
      "ric.jelastic.vps-host.net",
      "playstation-cloud.com",
      "apps.lair.io",
      "*.stolos.io",
      "spacekit.io",
      "customer.speedpartner.de",
      "myspreadshop.at",
      "myspreadshop.com.au",
      "myspreadshop.be",
      "myspreadshop.ca",
      "myspreadshop.ch",
      "myspreadshop.com",
      "myspreadshop.de",
      "myspreadshop.dk",
      "myspreadshop.es",
      "myspreadshop.fi",
      "myspreadshop.fr",
      "myspreadshop.ie",
      "myspreadshop.it",
      "myspreadshop.net",
      "myspreadshop.nl",
      "myspreadshop.no",
      "myspreadshop.pl",
      "myspreadshop.se",
      "myspreadshop.co.uk",
      "api.stdlib.com",
      "storj.farm",
      "utwente.io",
      "soc.srcf.net",
      "user.srcf.net",
      "temp-dns.com",
      "supabase.co",
      "supabase.in",
      "supabase.net",
      "su.paba.se",
      "*.s5y.io",
      "*.sensiosite.cloud",
      "syncloud.it",
      "dscloud.biz",
      "direct.quickconnect.cn",
      "dsmynas.com",
      "familyds.com",
      "diskstation.me",
      "dscloud.me",
      "i234.me",
      "myds.me",
      "synology.me",
      "dscloud.mobi",
      "dsmynas.net",
      "familyds.net",
      "dsmynas.org",
      "familyds.org",
      "vpnplus.to",
      "direct.quickconnect.to",
      "tabitorder.co.il",
      "taifun-dns.de",
      "beta.tailscale.net",
      "ts.net",
      "gda.pl",
      "gdansk.pl",
      "gdynia.pl",
      "med.pl",
      "sopot.pl",
      "site.tb-hosting.com",
      "edugit.io",
      "s3.teckids.org",
      "telebit.app",
      "telebit.io",
      "*.telebit.xyz",
      "gwiddle.co.uk",
      "*.firenet.ch",
      "*.svc.firenet.ch",
      "reservd.com",
      "thingdustdata.com",
      "cust.dev.thingdust.io",
      "cust.disrec.thingdust.io",
      "cust.prod.thingdust.io",
      "cust.testing.thingdust.io",
      "reservd.dev.thingdust.io",
      "reservd.disrec.thingdust.io",
      "reservd.testing.thingdust.io",
      "tickets.io",
      "arvo.network",
      "azimuth.network",
      "tlon.network",
      "torproject.net",
      "pages.torproject.net",
      "bloxcms.com",
      "townnews-staging.com",
      "tbits.me",
      "12hp.at",
      "2ix.at",
      "4lima.at",
      "lima-city.at",
      "12hp.ch",
      "2ix.ch",
      "4lima.ch",
      "lima-city.ch",
      "trafficplex.cloud",
      "de.cool",
      "12hp.de",
      "2ix.de",
      "4lima.de",
      "lima-city.de",
      "1337.pictures",
      "clan.rip",
      "lima-city.rocks",
      "webspace.rocks",
      "lima.zone",
      "*.transurl.be",
      "*.transurl.eu",
      "*.transurl.nl",
      "site.transip.me",
      "tuxfamily.org",
      "dd-dns.de",
      "diskstation.eu",
      "diskstation.org",
      "dray-dns.de",
      "draydns.de",
      "dyn-vpn.de",
      "dynvpn.de",
      "mein-vigor.de",
      "my-vigor.de",
      "my-wan.de",
      "syno-ds.de",
      "synology-diskstation.de",
      "synology-ds.de",
      "typedream.app",
      "pro.typeform.com",
      "uber.space",
      "*.uberspace.de",
      "hk.com",
      "hk.org",
      "ltd.hk",
      "inc.hk",
      "name.pm",
      "sch.tf",
      "biz.wf",
      "sch.wf",
      "org.yt",
      "virtualuser.de",
      "virtual-user.de",
      "upli.io",
      "urown.cloud",
      "dnsupdate.info",
      "lib.de.us",
      "2038.io",
      "vercel.app",
      "vercel.dev",
      "now.sh",
      "router.management",
      "v-info.info",
      "voorloper.cloud",
      "neko.am",
      "nyaa.am",
      "be.ax",
      "cat.ax",
      "es.ax",
      "eu.ax",
      "gg.ax",
      "mc.ax",
      "us.ax",
      "xy.ax",
      "nl.ci",
      "xx.gl",
      "app.gp",
      "blog.gt",
      "de.gt",
      "to.gt",
      "be.gy",
      "cc.hn",
      "blog.kg",
      "io.kg",
      "jp.kg",
      "tv.kg",
      "uk.kg",
      "us.kg",
      "de.ls",
      "at.md",
      "de.md",
      "jp.md",
      "to.md",
      "indie.porn",
      "vxl.sh",
      "ch.tc",
      "me.tc",
      "we.tc",
      "nyan.to",
      "at.vg",
      "blog.vu",
      "dev.vu",
      "me.vu",
      "v.ua",
      "*.vultrobjects.com",
      "wafflecell.com",
      "*.webhare.dev",
      "reserve-online.net",
      "reserve-online.com",
      "bookonline.app",
      "hotelwithflight.com",
      "wedeploy.io",
      "wedeploy.me",
      "wedeploy.sh",
      "remotewd.com",
      "pages.wiardweb.com",
      "wmflabs.org",
      "toolforge.org",
      "wmcloud.org",
      "panel.gg",
      "daemon.panel.gg",
      "messwithdns.com",
      "woltlab-demo.com",
      "myforum.community",
      "community-pro.de",
      "diskussionsbereich.de",
      "community-pro.net",
      "meinforum.net",
      "affinitylottery.org.uk",
      "raffleentry.org.uk",
      "weeklylottery.org.uk",
      "wpenginepowered.com",
      "js.wpenginepowered.com",
      "wixsite.com",
      "editorx.io",
      "half.host",
      "xnbay.com",
      "u2.xnbay.com",
      "u2-local.xnbay.com",
      "cistron.nl",
      "demon.nl",
      "xs4all.space",
      "yandexcloud.net",
      "storage.yandexcloud.net",
      "website.yandexcloud.net",
      "official.academy",
      "yolasite.com",
      "ybo.faith",
      "yombo.me",
      "homelink.one",
      "ybo.party",
      "ybo.review",
      "ybo.science",
      "ybo.trade",
      "ynh.fr",
      "nohost.me",
      "noho.st",
      "za.net",
      "za.org",
      "bss.design",
      "basicserver.io",
      "virtualserver.io",
      "enterprisecloud.nu"
    ];
  }
});

// node_modules/psl/index.js
var require_psl = __commonJS({
  "node_modules/psl/index.js"(exports) {
    "use strict";
    var Punycode = __require("punycode");
    var internals = {};
    internals.rules = require_rules().map(function(rule) {
      return {
        rule,
        suffix: rule.replace(/^(\*\.|\!)/, ""),
        punySuffix: -1,
        wildcard: rule.charAt(0) === "*",
        exception: rule.charAt(0) === "!"
      };
    });
    internals.endsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    internals.findRule = function(domain) {
      var punyDomain = Punycode.toASCII(domain);
      return internals.rules.reduce(function(memo, rule) {
        if (rule.punySuffix === -1) {
          rule.punySuffix = Punycode.toASCII(rule.suffix);
        }
        if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
          return memo;
        }
        return rule;
      }, null);
    };
    exports.errorCodes = {
      DOMAIN_TOO_SHORT: "Domain name too short.",
      DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
      LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
      LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
      LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
      LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
      LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
    };
    internals.validate = function(input) {
      var ascii = Punycode.toASCII(input);
      if (ascii.length < 1) {
        return "DOMAIN_TOO_SHORT";
      }
      if (ascii.length > 255) {
        return "DOMAIN_TOO_LONG";
      }
      var labels = ascii.split(".");
      var label;
      for (var i = 0; i < labels.length; ++i) {
        label = labels[i];
        if (!label.length) {
          return "LABEL_TOO_SHORT";
        }
        if (label.length > 63) {
          return "LABEL_TOO_LONG";
        }
        if (label.charAt(0) === "-") {
          return "LABEL_STARTS_WITH_DASH";
        }
        if (label.charAt(label.length - 1) === "-") {
          return "LABEL_ENDS_WITH_DASH";
        }
        if (!/^[a-z0-9\-]+$/.test(label)) {
          return "LABEL_INVALID_CHARS";
        }
      }
    };
    exports.parse = function(input) {
      if (typeof input !== "string") {
        throw new TypeError("Domain name must be a string.");
      }
      var domain = input.slice(0).toLowerCase();
      if (domain.charAt(domain.length - 1) === ".") {
        domain = domain.slice(0, domain.length - 1);
      }
      var error = internals.validate(domain);
      if (error) {
        return {
          input,
          error: {
            message: exports.errorCodes[error],
            code: error
          }
        };
      }
      var parsed = {
        input,
        tld: null,
        sld: null,
        domain: null,
        subdomain: null,
        listed: false
      };
      var domainParts = domain.split(".");
      if (domainParts[domainParts.length - 1] === "local") {
        return parsed;
      }
      var handlePunycode = function() {
        if (!/xn--/.test(domain)) {
          return parsed;
        }
        if (parsed.domain) {
          parsed.domain = Punycode.toASCII(parsed.domain);
        }
        if (parsed.subdomain) {
          parsed.subdomain = Punycode.toASCII(parsed.subdomain);
        }
        return parsed;
      };
      var rule = internals.findRule(domain);
      if (!rule) {
        if (domainParts.length < 2) {
          return parsed;
        }
        parsed.tld = domainParts.pop();
        parsed.sld = domainParts.pop();
        parsed.domain = [parsed.sld, parsed.tld].join(".");
        if (domainParts.length) {
          parsed.subdomain = domainParts.pop();
        }
        return handlePunycode();
      }
      parsed.listed = true;
      var tldParts = rule.suffix.split(".");
      var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
      if (rule.exception) {
        privateParts.push(tldParts.shift());
      }
      parsed.tld = tldParts.join(".");
      if (!privateParts.length) {
        return handlePunycode();
      }
      if (rule.wildcard) {
        tldParts.unshift(privateParts.pop());
        parsed.tld = tldParts.join(".");
      }
      if (!privateParts.length) {
        return handlePunycode();
      }
      parsed.sld = privateParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (privateParts.length) {
        parsed.subdomain = privateParts.join(".");
      }
      return handlePunycode();
    };
    exports.get = function(domain) {
      if (!domain) {
        return null;
      }
      return exports.parse(domain).domain || null;
    };
    exports.isValid = function(domain) {
      var parsed = exports.parse(domain);
      return Boolean(parsed.domain && parsed.listed);
    };
  }
});

// node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS({
  "node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports) {
    "use strict";
    var psl = require_psl();
    function getPublicSuffix(domain) {
      return psl.get(domain);
    }
    exports.getPublicSuffix = getPublicSuffix;
  }
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "node_modules/tough-cookie/lib/store.js"(exports) {
    "use strict";
    function Store() {
    }
    exports.Store = Store;
    Store.prototype.synchronous = false;
    Store.prototype.findCookie = function(domain, path3, key, cb) {
      throw new Error("findCookie is not implemented");
    };
    Store.prototype.findCookies = function(domain, path3, cb) {
      throw new Error("findCookies is not implemented");
    };
    Store.prototype.putCookie = function(cookie, cb) {
      throw new Error("putCookie is not implemented");
    };
    Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      throw new Error("updateCookie is not implemented");
    };
    Store.prototype.removeCookie = function(domain, path3, key, cb) {
      throw new Error("removeCookie is not implemented");
    };
    Store.prototype.removeCookies = function(domain, path3, cb) {
      throw new Error("removeCookies is not implemented");
    };
    Store.prototype.removeAllCookies = function(cb) {
      throw new Error("removeAllCookies is not implemented");
    };
    Store.prototype.getAllCookies = function(cb) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    };
  }
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "node_modules/tough-cookie/lib/permuteDomain.js"(exports) {
    "use strict";
    var pubsuffix = require_pubsuffix_psl();
    function permuteDomain(domain) {
      var pubSuf = pubsuffix.getPublicSuffix(domain);
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      var prefix = domain.slice(0, -(pubSuf.length + 1));
      var parts = prefix.split(".").reverse();
      var cur = pubSuf;
      var permutations = [cur];
      while (parts.length) {
        cur = parts.shift() + "." + cur;
        permutations.push(cur);
      }
      return permutations;
    }
    exports.permuteDomain = permuteDomain;
  }
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "node_modules/tough-cookie/lib/pathMatch.js"(exports) {
    "use strict";
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      var idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports.pathMatch = pathMatch;
  }
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "node_modules/tough-cookie/lib/memstore.js"(exports) {
    "use strict";
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var util = __require("util");
    function MemoryCookieStore() {
      Store.call(this);
      this.idx = {};
    }
    util.inherits(MemoryCookieStore, Store);
    exports.MemoryCookieStore = MemoryCookieStore;
    MemoryCookieStore.prototype.idx = null;
    MemoryCookieStore.prototype.synchronous = true;
    MemoryCookieStore.prototype.inspect = function() {
      return "{ idx: " + util.inspect(this.idx, false, 2) + " }";
    };
    if (util.inspect.custom) {
      MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;
    }
    MemoryCookieStore.prototype.findCookie = function(domain, path3, key, cb) {
      if (!this.idx[domain]) {
        return cb(null, void 0);
      }
      if (!this.idx[domain][path3]) {
        return cb(null, void 0);
      }
      return cb(null, this.idx[domain][path3][key] || null);
    };
    MemoryCookieStore.prototype.findCookies = function(domain, path3, cb) {
      var results = [];
      if (!domain) {
        return cb(null, []);
      }
      var pathMatcher;
      if (!path3) {
        pathMatcher = function matchAll(domainIndex) {
          for (var curPath in domainIndex) {
            var pathIndex = domainIndex[curPath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
      } else {
        pathMatcher = function matchRFC(domainIndex) {
          Object.keys(domainIndex).forEach(function(cookiePath) {
            if (pathMatch(path3, cookiePath)) {
              var pathIndex = domainIndex[cookiePath];
              for (var key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          });
        };
      }
      var domains = permuteDomain(domain) || [domain];
      var idx = this.idx;
      domains.forEach(function(curDomain) {
        var domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
      cb(null, results);
    };
    MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = {};
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = {};
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    };
    MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
    MemoryCookieStore.prototype.removeCookie = function(domain, path3, key, cb) {
      if (this.idx[domain] && this.idx[domain][path3] && this.idx[domain][path3][key]) {
        delete this.idx[domain][path3][key];
      }
      cb(null);
    };
    MemoryCookieStore.prototype.removeCookies = function(domain, path3, cb) {
      if (this.idx[domain]) {
        if (path3) {
          delete this.idx[domain][path3];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    };
    MemoryCookieStore.prototype.removeAllCookies = function(cb) {
      this.idx = {};
      return cb(null);
    };
    MemoryCookieStore.prototype.getAllCookies = function(cb) {
      var cookies = [];
      var idx = this.idx;
      var domains = Object.keys(idx);
      domains.forEach(function(domain) {
        var paths3 = Object.keys(idx[domain]);
        paths3.forEach(function(path3) {
          var keys4 = Object.keys(idx[domain][path3]);
          keys4.forEach(function(key) {
            if (key !== null) {
              cookies.push(idx[domain][path3][key]);
            }
          });
        });
      });
      cookies.sort(function(a, b) {
        return (a.creationIndex || 0) - (b.creationIndex || 0);
      });
      cb(null, cookies);
    };
  }
});

// node_modules/tough-cookie/lib/version.js
var require_version = __commonJS({
  "node_modules/tough-cookie/lib/version.js"(exports, module) {
    module.exports = "2.5.0";
  }
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "node_modules/tough-cookie/lib/cookie.js"(exports) {
    "use strict";
    var net = __require("net");
    var urlParse = __require("url").parse;
    var util = __require("util");
    var pubsuffix = require_pubsuffix_psl();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var VERSION = require_version();
    var punycode;
    try {
      punycode = __require("punycode");
    } catch (e) {
      console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
    }
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var NUM_TO_MONTH = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var NUM_TO_DAY = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      var count = 0;
      while (count < token.length) {
        var c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
          break;
        }
        count++;
      }
      if (count < minDigits || count > maxDigits) {
        return null;
      }
      if (!trailingOK && count != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count), 10);
    }
    function parseTime(token) {
      var parts = token.split(":");
      var result = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (var i = 0; i < 3; i++) {
        var trailingOK = i == 2;
        var num = parseDigits(parts[i], 1, 2, trailingOK);
        if (num === null) {
          return null;
        }
        result[i] = num;
      }
      return result;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      var num = MONTH_TO_NUM[token];
      return num >= 0 ? num : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      var tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      var hour = null;
      var minute = null;
      var second = null;
      var dayOfMonth = null;
      var month = null;
      var year = null;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
        var result;
        if (second === null) {
          result = parseTime(token);
          if (result) {
            hour = result[0];
            minute = result[1];
            second = result[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result = parseDigits(token, 1, 2, true);
          if (result !== null) {
            dayOfMonth = result;
            continue;
          }
        }
        if (month === null) {
          result = parseMonth(token);
          if (result !== null) {
            month = result;
            continue;
          }
        }
        if (year === null) {
          result = parseDigits(token, 2, 4, true);
          if (result !== null) {
            year = result;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      var d = date.getUTCDate();
      d = d >= 10 ? d : "0" + d;
      var h = date.getUTCHours();
      h = h >= 10 ? h : "0" + h;
      var m = date.getUTCMinutes();
      m = m >= 10 ? m : "0" + m;
      var s = date.getUTCSeconds();
      s = s >= 10 ? s : "0" + s;
      return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      if (net.isIP(str)) {
        return false;
      }
      var idx = str.indexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      return true;
    }
    function defaultPath(path3) {
      if (!path3 || path3.substr(0, 1) !== "/") {
        return "/";
      }
      if (path3 === "/") {
        return path3;
      }
      var rightSlash = path3.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path3.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      for (var t = 0; t < TERMINATORS.length; t++) {
        var terminatorIdx = str.indexOf(TERMINATORS[t]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      var firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      var cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      var c = new Cookie();
      c.key = cookieName;
      c.value = cookieValue;
      return c;
    }
    function parse9(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      str = str.trim();
      var firstSemi = str.indexOf(";");
      var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      var c = parseCookiePair(cookiePair, !!options.loose);
      if (!c) {
        return;
      }
      if (firstSemi === -1) {
        return c;
      }
      var unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c;
      }
      var cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        var av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        var av_sep = av.indexOf("=");
        var av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              var exp = parseDate(av_value);
              if (exp) {
                c.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                var delta = parseInt(av_value, 10);
                c.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              var domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c.secure = true;
            break;
          case "httponly":
            c.httpOnly = true;
            break;
          default:
            c.extensions = c.extensions || [];
            c.extensions.push(av);
            break;
        }
      }
      return c;
    }
    function jsonParse(str) {
      var obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str) {
        return null;
      }
      var obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      var c = new Cookie();
      for (var i = 0; i < Cookie.serializableProperties.length; i++) {
        var prop2 = Cookie.serializableProperties[i];
        if (obj[prop2] === void 0 || obj[prop2] === Cookie.prototype[prop2]) {
          continue;
        }
        if (prop2 === "expires" || prop2 === "creation" || prop2 === "lastAccessed") {
          if (obj[prop2] === null) {
            c[prop2] = null;
          } else {
            c[prop2] = obj[prop2] == "Infinity" ? "Infinity" : new Date(obj[prop2]);
          }
        } else {
          c[prop2] = obj[prop2];
        }
      }
      return c;
    }
    function cookieCompare(a, b) {
      var cmp = 0;
      var aPathLen = a.path ? a.path.length : 0;
      var bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a.creationIndex - b.creationIndex;
      return cmp;
    }
    function permutePath(path3) {
      if (path3 === "/") {
        return ["/"];
      }
      if (path3.lastIndexOf("/") === path3.length - 1) {
        path3 = path3.substr(0, path3.length - 1);
      }
      var permutations = [path3];
      while (path3.length > 1) {
        var lindex = path3.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path3 = path3.substr(0, lindex);
        permutations.push(path3);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url6) {
      if (url6 instanceof Object) {
        return url6;
      }
      try {
        url6 = decodeURI(url6);
      } catch (err) {
      }
      return urlParse(url6);
    }
    function Cookie(options) {
      options = options || {};
      Object.keys(options).forEach(function(prop2) {
        if (Cookie.prototype.hasOwnProperty(prop2) && Cookie.prototype[prop2] !== options[prop2] && prop2.substr(0, 1) !== "_") {
          this[prop2] = options[prop2];
        }
      }, this);
      this.creation = this.creation || /* @__PURE__ */ new Date();
      Object.defineProperty(this, "creationIndex", {
        configurable: false,
        enumerable: false,
        // important for assert.deepEqual checks
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    Cookie.cookiesCreated = 0;
    Cookie.parse = parse9;
    Cookie.fromJSON = fromJSON;
    Cookie.prototype.key = "";
    Cookie.prototype.value = "";
    Cookie.prototype.expires = "Infinity";
    Cookie.prototype.maxAge = null;
    Cookie.prototype.domain = null;
    Cookie.prototype.path = null;
    Cookie.prototype.secure = false;
    Cookie.prototype.httpOnly = false;
    Cookie.prototype.extensions = null;
    Cookie.prototype.hostOnly = null;
    Cookie.prototype.pathIsDefault = null;
    Cookie.prototype.creation = null;
    Cookie.prototype.lastAccessed = null;
    Object.defineProperty(Cookie.prototype, "creationIndex", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: 0
    });
    Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop2) {
      return !(Cookie.prototype[prop2] instanceof Function || prop2 === "creationIndex" || prop2.substr(0, 1) === "_");
    });
    Cookie.prototype.inspect = function inspect() {
      var now = Date.now();
      return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
    };
    if (util.inspect.custom) {
      Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
    }
    Cookie.prototype.toJSON = function() {
      var obj = {};
      var props = Cookie.serializableProperties;
      for (var i = 0; i < props.length; i++) {
        var prop2 = props[i];
        if (this[prop2] === Cookie.prototype[prop2]) {
          continue;
        }
        if (prop2 === "expires" || prop2 === "creation" || prop2 === "lastAccessed") {
          if (this[prop2] === null) {
            obj[prop2] = null;
          } else {
            obj[prop2] = this[prop2] == "Infinity" ? (
              // intentionally not ===
              "Infinity"
            ) : this[prop2].toISOString();
          }
        } else if (prop2 === "maxAge") {
          if (this[prop2] !== null) {
            obj[prop2] = this[prop2] == Infinity || this[prop2] == -Infinity ? this[prop2].toString() : this[prop2];
          }
        } else {
          if (this[prop2] !== Cookie.prototype[prop2]) {
            obj[prop2] = this[prop2];
          }
        }
      }
      return obj;
    };
    Cookie.prototype.clone = function() {
      return fromJSON(this.toJSON());
    };
    Cookie.prototype.validate = function validate3() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false;
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
      var cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false;
        }
        var suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) {
          return false;
        }
      }
      return true;
    };
    Cookie.prototype.setExpires = function setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    };
    Cookie.prototype.setMaxAge = function setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString();
      } else {
        this.maxAge = age;
      }
    };
    Cookie.prototype.cookieString = function cookieString() {
      var val2 = this.value;
      if (val2 == null) {
        val2 = "";
      }
      if (this.key === "") {
        return val2;
      }
      return this.key + "=" + val2;
    };
    Cookie.prototype.toString = function toString3() {
      var str = this.cookieString();
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str += "; Expires=" + formatDate(this.expires);
        } else {
          str += "; Expires=" + this.expires;
        }
      }
      if (this.maxAge != null && this.maxAge != Infinity) {
        str += "; Max-Age=" + this.maxAge;
      }
      if (this.domain && !this.hostOnly) {
        str += "; Domain=" + this.domain;
      }
      if (this.path) {
        str += "; Path=" + this.path;
      }
      if (this.secure) {
        str += "; Secure";
      }
      if (this.httpOnly) {
        str += "; HttpOnly";
      }
      if (this.extensions) {
        this.extensions.forEach(function(ext) {
          str += "; " + ext;
        });
      }
      return str;
    };
    Cookie.prototype.TTL = function TTL(now) {
      if (this.maxAge != null) {
        return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
      }
      var expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
        if (expires == Infinity) {
          return Infinity;
        }
        return expires.getTime() - (now || Date.now());
      }
      return Infinity;
    };
    Cookie.prototype.expiryTime = function expiryTime(now) {
      if (this.maxAge != null) {
        var relativeTo = now || this.creation || /* @__PURE__ */ new Date();
        var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
        return relativeTo.getTime() + age;
      }
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    };
    Cookie.prototype.expiryDate = function expiryDate(now) {
      var millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    };
    Cookie.prototype.isPersistent = function isPersistent() {
      return this.maxAge != null || this.expires != Infinity;
    };
    Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    };
    function CookieJar(store2, options) {
      if (typeof options === "boolean") {
        options = { rejectPublicSuffixes: options };
      } else if (options == null) {
        options = {};
      }
      if (options.rejectPublicSuffixes != null) {
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
      }
      if (options.looseMode != null) {
        this.enableLooseMode = options.looseMode;
      }
      if (!store2) {
        store2 = new MemoryCookieStore();
      }
      this.store = store2;
    }
    CookieJar.prototype.store = null;
    CookieJar.prototype.rejectPublicSuffixes = true;
    CookieJar.prototype.enableLooseMode = false;
    var CAN_BE_SYNC = [];
    CAN_BE_SYNC.push("setCookie");
    CookieJar.prototype.setCookie = function(cookie, url6, options, cb) {
      var err;
      var context = getCookieContext(url6);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var loose = this.enableLooseMode;
      if (options.loose != null) {
        loose = options.loose;
      }
      if (!(cookie instanceof Cookie)) {
        cookie = Cookie.parse(cookie, { loose });
      }
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
      var now = options.now || /* @__PURE__ */ new Date();
      if (this.rejectPublicSuffixes && cookie.domain) {
        var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
        if (suffix == null) {
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.hostOnly == null) {
          cookie.hostOnly = false;
        }
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
      if (!cookie.path || cookie.path[0] !== "/") {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      var store2 = this.store;
      if (!store2.updateCookie) {
        store2.updateCookie = function(oldCookie, newCookie, cb2) {
          this.putCookie(newCookie, cb2);
        };
      }
      function withCookie(err2, oldCookie) {
        if (err2) {
          return cb(err2);
        }
        var next2 = function(err3) {
          if (err3) {
            return cb(err3);
          } else {
            cb(null, cookie);
          }
        };
        if (oldCookie) {
          if (options.http === false && oldCookie.httpOnly) {
            err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err2);
          }
          cookie.creation = oldCookie.creation;
          cookie.creationIndex = oldCookie.creationIndex;
          cookie.lastAccessed = now;
          store2.updateCookie(oldCookie, cookie, next2);
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store2.putCookie(cookie, next2);
        }
      }
      store2.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    };
    CAN_BE_SYNC.push("getCookies");
    CookieJar.prototype.getCookies = function(url6, options, cb) {
      var context = getCookieContext(url6);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var path3 = context.pathname || "/";
      var secure = options.secure;
      if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
        secure = true;
      }
      var http = options.http;
      if (http == null) {
        http = true;
      }
      var now = options.now || Date.now();
      var expireCheck = options.expire !== false;
      var allPaths = !!options.allPaths;
      var store2 = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
        if (!allPaths && !pathMatch(path3, c.path)) {
          return false;
        }
        if (c.secure && !secure) {
          return false;
        }
        if (c.httpOnly && !http) {
          return false;
        }
        if (expireCheck && c.expiryTime() <= now) {
          store2.removeCookie(c.domain, c.path, c.key, function() {
          });
          return false;
        }
        return true;
      }
      store2.findCookies(host, allPaths ? null : path3, function(err, cookies) {
        if (err) {
          return cb(err);
        }
        cookies = cookies.filter(matchingCookie);
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
        var now2 = /* @__PURE__ */ new Date();
        cookies.forEach(function(c) {
          c.lastAccessed = now2;
        });
        cb(null, cookies);
      });
    };
    CAN_BE_SYNC.push("getCookieString");
    CookieJar.prototype.getCookieString = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next2 = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.sort(cookieCompare).map(function(c) {
            return c.cookieString();
          }).join("; "));
        }
      };
      args.push(next2);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("getSetCookieStrings");
    CookieJar.prototype.getSetCookieStrings = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next2 = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map(function(c) {
            return c.toString();
          }));
        }
      };
      args.push(next2);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("serialize");
    CookieJar.prototype.serialize = function(cb) {
      var type3 = this.store.constructor.name;
      if (type3 === "Object") {
        type3 = null;
      }
      var serialized = {
        // The version of tough-cookie that serialized this jar. Generally a good
        // practice since future versions can make data import decisions based on
        // known past behavior. When/if this matters, use `semver`.
        version: "tough-cookie@" + VERSION,
        // add the store type, to make humans happy:
        storeType: type3,
        // CookieJar configuration:
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
        // this gets filled from getAllCookies:
        cookies: []
      };
      if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
        return cb(new Error("store does not support getAllCookies and cannot be serialized"));
      }
      this.store.getAllCookies(function(err, cookies) {
        if (err) {
          return cb(err);
        }
        serialized.cookies = cookies.map(function(cookie) {
          cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
          delete cookie.creationIndex;
          return cookie;
        });
        return cb(null, serialized);
      });
    };
    CookieJar.prototype.toJSON = function() {
      return this.serializeSync();
    };
    CAN_BE_SYNC.push("_importCookies");
    CookieJar.prototype._importCookies = function(serialized, cb) {
      var jar = this;
      var cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error("serialized jar has no cookies array"));
      }
      cookies = cookies.slice();
      function putNext(err) {
        if (err) {
          return cb(err);
        }
        if (!cookies.length) {
          return cb(err, jar);
        }
        var cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
        if (cookie === null) {
          return putNext(null);
        }
        jar.store.putCookie(cookie, putNext);
      }
      putNext();
    };
    CookieJar.deserialize = function(strOrObj, store2, cb) {
      if (arguments.length !== 3) {
        cb = store2;
        store2 = null;
      }
      var serialized;
      if (typeof strOrObj === "string") {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
      var jar = new CookieJar(store2, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    };
    CookieJar.deserializeSync = function(strOrObj, store2) {
      var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
      var jar = new CookieJar(store2, serialized.rejectPublicSuffixes);
      if (!jar.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      jar._importCookiesSync(serialized);
      return jar;
    };
    CookieJar.fromJSON = CookieJar.deserializeSync;
    CookieJar.prototype.clone = function(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
      this.serialize(function(err, serialized) {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(serialized, newStore, cb);
      });
    };
    CAN_BE_SYNC.push("removeAllCookies");
    CookieJar.prototype.removeAllCookies = function(cb) {
      var store2 = this.store;
      if (store2.removeAllCookies instanceof Function && store2.removeAllCookies !== Store.prototype.removeAllCookies) {
        return store2.removeAllCookies(cb);
      }
      store2.getAllCookies(function(err, cookies) {
        if (err) {
          return cb(err);
        }
        if (cookies.length === 0) {
          return cb(null);
        }
        var completedCount = 0;
        var removeErrors = [];
        function removeCookieCb(removeErr) {
          if (removeErr) {
            removeErrors.push(removeErr);
          }
          completedCount++;
          if (completedCount === cookies.length) {
            return cb(removeErrors.length ? removeErrors[0] : null);
          }
        }
        cookies.forEach(function(cookie) {
          store2.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
        });
      });
    };
    CookieJar.prototype._cloneSync = syncWrap("clone");
    CookieJar.prototype.cloneSync = function(newStore) {
      if (!newStore.synchronous) {
        throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
      }
      return this._cloneSync(newStore);
    };
    function syncWrap(method) {
      return function() {
        if (!this.store.synchronous) {
          throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        var args = Array.prototype.slice.call(arguments);
        var syncErr, syncResult;
        args.push(function syncCb(err, result) {
          syncErr = err;
          syncResult = result;
        });
        this[method].apply(this, args);
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    CAN_BE_SYNC.forEach(function(method) {
      CookieJar.prototype[method + "Sync"] = syncWrap(method);
    });
    exports.version = VERSION;
    exports.CookieJar = CookieJar;
    exports.Cookie = Cookie;
    exports.Store = Store;
    exports.MemoryCookieStore = MemoryCookieStore;
    exports.parseDate = parseDate;
    exports.formatDate = formatDate;
    exports.parse = parse9;
    exports.fromJSON = fromJSON;
    exports.domainMatch = domainMatch;
    exports.defaultPath = defaultPath;
    exports.pathMatch = pathMatch;
    exports.getPublicSuffix = pubsuffix.getPublicSuffix;
    exports.cookieCompare = cookieCompare;
    exports.permuteDomain = require_permuteDomain().permuteDomain;
    exports.permutePath = permutePath;
    exports.canonicalDomain = canonicalDomain;
  }
});

// node_modules/request/lib/cookies.js
var require_cookies = __commonJS({
  "node_modules/request/lib/cookies.js"(exports) {
    "use strict";
    var tough = require_cookie();
    var Cookie = tough.Cookie;
    var CookieJar = tough.CookieJar;
    exports.parse = function(str) {
      if (str && str.uri) {
        str = str.uri;
      }
      if (typeof str !== "string") {
        throw new Error("The cookie function only accepts STRING as param");
      }
      return Cookie.parse(str, { loose: true });
    };
    function RequestJar(store2) {
      var self2 = this;
      self2._jar = new CookieJar(store2, { looseMode: true });
    }
    RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
      var self2 = this;
      return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
    };
    RequestJar.prototype.getCookieString = function(uri) {
      var self2 = this;
      return self2._jar.getCookieStringSync(uri);
    };
    RequestJar.prototype.getCookies = function(uri) {
      var self2 = this;
      return self2._jar.getCookiesSync(uri);
    };
    exports.jar = function(store2) {
      return new RequestJar(store2);
    };
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json-stringify-safe/stringify.js"(exports, module) {
    exports = module.exports = stringify2;
    exports.getSerialize = serializer;
    function stringify2(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys4 = [];
      if (cycleReplacer == null)
        cycleReplacer = function(key, value2) {
          if (stack[0] === value2)
            return "[Circular ~]";
          return "[Circular ~." + keys4.slice(0, stack.indexOf(value2)).join(".") + "]";
        };
      return function(key, value2) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys4.splice(thisPos, Infinity, key) : keys4.push(key);
          if (~stack.indexOf(value2))
            value2 = cycleReplacer.call(this, key, value2);
        } else
          stack.push(value2);
        return replacer == null ? value2 : replacer.call(this, key, value2);
      };
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/request/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/request/lib/helpers.js"(exports) {
    "use strict";
    var jsonSafeStringify = require_stringify2();
    var crypto = __require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
    function paramsHaveRequestBody(params) {
      return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
    }
    function safeStringify(obj, replacer) {
      var ret;
      try {
        ret = JSON.stringify(obj, replacer);
      } catch (e) {
        ret = jsonSafeStringify(obj, replacer);
      }
      return ret;
    }
    function md5(str) {
      return crypto.createHash("md5").update(str).digest("hex");
    }
    function isReadStream(rs) {
      return rs.readable && rs.path && rs.mode;
    }
    function toBase64(str) {
      return Buffer2.from(str || "", "utf8").toString("base64");
    }
    function copy(obj) {
      var o = {};
      Object.keys(obj).forEach(function(i) {
        o[i] = obj[i];
      });
      return o;
    }
    function version() {
      var numbers = process.version.replace("v", "").split(".");
      return {
        major: parseInt(numbers[0], 10),
        minor: parseInt(numbers[1], 10),
        patch: parseInt(numbers[2], 10)
      };
    }
    exports.paramsHaveRequestBody = paramsHaveRequestBody;
    exports.safeStringify = safeStringify;
    exports.md5 = md5;
    exports.isReadStream = isReadStream;
    exports.toBase64 = toBase64;
    exports.copy = copy;
    exports.version = version;
    exports.defer = defer;
  }
});

// node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS({
  "node_modules/aws-sign2/index.js"(exports, module) {
    var crypto = __require("crypto");
    var parse9 = __require("url").parse;
    var keys4 = [
      "acl",
      "location",
      "logging",
      "notification",
      "partNumber",
      "policy",
      "requestPayment",
      "torrent",
      "uploadId",
      "uploads",
      "versionId",
      "versioning",
      "versions",
      "website"
    ];
    function authorization(options) {
      return "AWS " + options.key + ":" + sign(options);
    }
    module.exports = authorization;
    module.exports.authorization = authorization;
    function hmacSha1(options) {
      return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
    }
    module.exports.hmacSha1 = hmacSha1;
    function sign(options) {
      options.message = stringToSign(options);
      return hmacSha1(options);
    }
    module.exports.sign = sign;
    function signQuery(options) {
      options.message = queryStringToSign(options);
      return hmacSha1(options);
    }
    module.exports.signQuery = signQuery;
    function stringToSign(options) {
      var headers = options.amazonHeaders || "";
      if (headers)
        headers += "\n";
      var r = [
        options.verb,
        options.md5,
        options.contentType,
        options.date ? options.date.toUTCString() : "",
        headers + options.resource
      ];
      return r.join("\n");
    }
    module.exports.stringToSign = stringToSign;
    function queryStringToSign(options) {
      return "GET\n\n\n" + options.date + "\n" + options.resource;
    }
    module.exports.queryStringToSign = queryStringToSign;
    function canonicalizeHeaders(headers) {
      var buf = [], fields = Object.keys(headers);
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i], val2 = headers[field], field = field.toLowerCase();
        if (0 !== field.indexOf("x-amz"))
          continue;
        buf.push(field + ":" + val2);
      }
      return buf.sort().join("\n");
    }
    module.exports.canonicalizeHeaders = canonicalizeHeaders;
    function canonicalizeResource(resource) {
      var url6 = parse9(resource, true), path3 = url6.pathname, buf = [];
      Object.keys(url6.query).forEach(function(key) {
        if (!~keys4.indexOf(key))
          return;
        var val2 = "" == url6.query[key] ? "" : "=" + encodeURIComponent(url6.query[key]);
        buf.push(key + val2);
      });
      return path3 + (buf.length ? "?" + buf.sort().join("&") : "");
    }
    module.exports.canonicalizeResource = canonicalizeResource;
  }
});

// node_modules/aws4/lru.js
var require_lru = __commonJS({
  "node_modules/aws4/lru.js"(exports, module) {
    module.exports = function(size) {
      return new LruCache(size);
    };
    function LruCache(size) {
      this.capacity = size | 0;
      this.map = /* @__PURE__ */ Object.create(null);
      this.list = new DoublyLinkedList();
    }
    LruCache.prototype.get = function(key) {
      var node = this.map[key];
      if (node == null)
        return void 0;
      this.used(node);
      return node.val;
    };
    LruCache.prototype.set = function(key, val2) {
      var node = this.map[key];
      if (node != null) {
        node.val = val2;
      } else {
        if (!this.capacity)
          this.prune();
        if (!this.capacity)
          return false;
        node = new DoublyLinkedNode(key, val2);
        this.map[key] = node;
        this.capacity--;
      }
      this.used(node);
      return true;
    };
    LruCache.prototype.used = function(node) {
      this.list.moveToFront(node);
    };
    LruCache.prototype.prune = function() {
      var node = this.list.pop();
      if (node != null) {
        delete this.map[node.key];
        this.capacity++;
      }
    };
    function DoublyLinkedList() {
      this.firstNode = null;
      this.lastNode = null;
    }
    DoublyLinkedList.prototype.moveToFront = function(node) {
      if (this.firstNode == node)
        return;
      this.remove(node);
      if (this.firstNode == null) {
        this.firstNode = node;
        this.lastNode = node;
        node.prev = null;
        node.next = null;
      } else {
        node.prev = null;
        node.next = this.firstNode;
        node.next.prev = node;
        this.firstNode = node;
      }
    };
    DoublyLinkedList.prototype.pop = function() {
      var lastNode = this.lastNode;
      if (lastNode != null) {
        this.remove(lastNode);
      }
      return lastNode;
    };
    DoublyLinkedList.prototype.remove = function(node) {
      if (this.firstNode == node) {
        this.firstNode = node.next;
      } else if (node.prev != null) {
        node.prev.next = node.next;
      }
      if (this.lastNode == node) {
        this.lastNode = node.prev;
      } else if (node.next != null) {
        node.next.prev = node.prev;
      }
    };
    function DoublyLinkedNode(key, val2) {
      this.key = key;
      this.val = val2;
      this.prev = null;
      this.next = null;
    }
  }
});

// node_modules/aws4/aws4.js
var require_aws4 = __commonJS({
  "node_modules/aws4/aws4.js"(exports) {
    var aws4 = exports;
    var url6 = __require("url");
    var querystring = __require("querystring");
    var crypto = __require("crypto");
    var lru = require_lru();
    var credentialsCache = lru(1e3);
    function hmac(key, string, encoding) {
      return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
      return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    var HEADERS_TO_IGNORE = {
      "authorization": true,
      "connection": true,
      "x-amzn-trace-id": true,
      "user-agent": true,
      "expect": true,
      "presigned-expires": true,
      "range": true
    };
    function RequestSigner(request2, credentials) {
      if (typeof request2 === "string")
        request2 = url6.parse(request2);
      var headers = request2.headers = request2.headers || {}, hostParts = (!this.service || !this.region) && this.matchHost(request2.hostname || request2.host || headers.Host || headers.host);
      this.request = request2;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request2.service || hostParts[0] || "";
      this.region = request2.region || hostParts[1] || "us-east-1";
      if (this.service === "email")
        this.service = "ses";
      if (!request2.method && request2.body)
        request2.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request2.hostname || request2.host || this.createHost();
        if (request2.port)
          headers.Host += ":" + request2.port;
      }
      if (!request2.hostname && !request2.host)
        request2.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request2.method === "GIT";
      this.extraHeadersToIgnore = request2.extraHeadersToIgnore || /* @__PURE__ */ Object.create(null);
      this.extraHeadersToInclude = request2.extraHeadersToInclude || /* @__PURE__ */ Object.create(null);
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es" || hostParts[1] === "aoss")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i = 0; i < 2; i++) {
          if (/^s3-/.test(hostParts[i])) {
            hostParts[1] = hostParts[i].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
        return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request2 = this.request, headers = request2.headers, query;
      if (request2.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request2.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request2.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request2.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request2.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || /* @__PURE__ */ new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit)
          this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key) {
          if (!key)
            return obj;
          obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
          } else {
            reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val2) {
              encodedQueryPieces.push(key + "=" + val2);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath)
          pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path3, piece) {
          if (normalizePath && piece === "..") {
            path3.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath)
              piece = decodeURIComponent(piece.replace(/\+/g, " "));
            path3.push(encodeRfc3986Full(piece));
          }
          return path3;
        }, []).join("/");
        if (pathStr[0] !== "/")
          pathStr = "/" + pathStr;
        if (decodeSlashesInPath)
          pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      var headers = this.request.headers;
      function trimAll(header) {
        return header.toString().trim().replace(/\s+/g, " ");
      }
      return Object.keys(headers).filter(function(key) {
        return HEADERS_TO_IGNORE[key.toLowerCase()] == null;
      }).sort(function(a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
      }).map(function(key) {
        return key.toLowerCase() + ":" + trimAll(headers[key]);
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      var extraHeadersToInclude = this.extraHeadersToInclude, extraHeadersToIgnore = this.extraHeadersToIgnore;
      return Object.keys(this.request.headers).map(function(key) {
        return key.toLowerCase();
      }).filter(function(key) {
        return extraHeadersToInclude[key] || HEADERS_TO_IGNORE[key] == null && !extraHeadersToIgnore[key];
      }).sort().join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env;
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path3 = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path3)) {
        path3 = encodeURI(decodeURI(path3));
      }
      var queryIx = path3.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring.parse(path3.slice(queryIx + 1));
        path3 = path3.slice(0, queryIx);
      }
      this.parsedPath = {
        path: path3,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path3 = this.parsedPath.path, query = this.parsedPath.query;
      if (!query)
        return path3;
      if (query[""] != null)
        delete query[""];
      return path3 + "?" + encodeRfc3986(querystring.stringify(query));
    };
    aws4.RequestSigner = RequestSigner;
    aws4.sign = function(request2, credentials) {
      return new RequestSigner(request2, credentials).sign();
    };
  }
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS({
  "node_modules/assert-plus/assert.js"(exports, module) {
    var assert = __require("assert");
    var Stream = __require("stream").Stream;
    var util = __require("util");
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys4 = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys4.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type3 = types[k];
        out[k] = function(arg, msg) {
          if (!type3.check(arg)) {
            _toss(msg, k, type3.operator, arg, type3.actual);
          }
        };
      });
      keys4.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type3 = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type3.check(arg)) {
            _toss(msg, k, type3.operator, arg, type3.actual);
          }
        };
      });
      keys4.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type3 = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type3.operator, arg, type3.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type3.check(arg[i])) {
              _toss(msg, expected, type3.operator, arg, type3.actual);
            }
          }
        };
      });
      keys4.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type3 = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type3.operator, arg, type3.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type3.check(arg[i])) {
              _toss(msg, expected, type3.operator, arg, type3.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value2, encodingOrOffset, length) {
        if (typeof value2 === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value2);
        }
        if (value2 && typeof value2.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
        }
        return Buffer2(value2, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/sshpk/lib/algs.js
var require_algs = __commonJS({
  "node_modules/sshpk/lib/algs.js"(exports, module) {
    var Buffer2 = require_safer().Buffer;
    var algInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y"],
        sizePart: "p"
      },
      "rsa": {
        parts: ["e", "n"],
        sizePart: "n"
      },
      "ecdsa": {
        parts: ["curve", "Q"],
        sizePart: "Q"
      },
      "ed25519": {
        parts: ["A"],
        sizePart: "A"
      }
    };
    algInfo["curve25519"] = algInfo["ed25519"];
    var algPrivInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y", "x"]
      },
      "rsa": {
        parts: ["n", "e", "d", "iqmp", "p", "q"]
      },
      "ecdsa": {
        parts: ["curve", "Q", "d"]
      },
      "ed25519": {
        parts: ["A", "k"]
      }
    };
    algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
    var hashAlgs = {
      "md5": true,
      "sha1": true,
      "sha256": true,
      "sha384": true,
      "sha512": true
    };
    var curves = {
      "nistp256": {
        size: 256,
        pkcs8oid: "1.2.840.10045.3.1.7",
        p: Buffer2.from("00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00c49d3608 86e70493 6a6678e1 139d26b7819f7e90".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551".replace(/ /g, ""), "hex"),
        G: Buffer2.from("046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5".replace(/ /g, ""), "hex")
      },
      "nistp384": {
        size: 384,
        pkcs8oid: "1.3.132.0.34",
        p: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00a335926a a319a27a 1d00896a 6773a4827acdac73".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973".replace(/ /g, ""), "hex"),
        G: Buffer2.from("04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f".replace(/ /g, ""), "hex")
      },
      "nistp521": {
        size: 521,
        pkcs8oid: "1.3.132.0.35",
        p: Buffer2.from("01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00d09e8800 291cb853 96cc6717 393284aaa0da64ba".replace(/ /g, ""), "hex"),
        n: Buffer2.from("01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409".replace(/ /g, ""), "hex"),
        G: Buffer2.from("0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650".replace(/ /g, ""), "hex")
      }
    };
    module.exports = {
      info: algInfo,
      privInfo: algPrivInfo,
      hashAlgs,
      curves
    };
  }
});

// node_modules/sshpk/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/sshpk/lib/errors.js"(exports, module) {
    var assert = require_assert();
    var util = __require("util");
    function FingerprintFormatError(fp, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, FingerprintFormatError);
      this.name = "FingerprintFormatError";
      this.fingerprint = fp;
      this.format = format;
      this.message = "Fingerprint format is not supported, or is invalid: ";
      if (fp !== void 0)
        this.message += " fingerprint = " + fp;
      if (format !== void 0)
        this.message += " format = " + format;
    }
    util.inherits(FingerprintFormatError, Error);
    function InvalidAlgorithmError(alg) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, InvalidAlgorithmError);
      this.name = "InvalidAlgorithmError";
      this.algorithm = alg;
      this.message = 'Algorithm "' + alg + '" is not supported';
    }
    util.inherits(InvalidAlgorithmError, Error);
    function KeyParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyParseError);
      this.name = "KeyParseError";
      this.format = format;
      this.keyName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
    }
    util.inherits(KeyParseError, Error);
    function SignatureParseError(type3, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, SignatureParseError);
      this.name = "SignatureParseError";
      this.type = type3;
      this.format = format;
      this.innerErr = innerErr;
      this.message = "Failed to parse the given data as a " + type3 + " signature in " + format + " format: " + innerErr.message;
    }
    util.inherits(SignatureParseError, Error);
    function CertificateParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CertificateParseError);
      this.name = "CertificateParseError";
      this.format = format;
      this.certName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
    }
    util.inherits(CertificateParseError, Error);
    function KeyEncryptedError(name, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyEncryptedError);
      this.name = "KeyEncryptedError";
      this.format = format;
      this.keyName = name;
      this.message = "The " + format + " format key " + name + " is encrypted (password-protected), and no passphrase was provided in `options`";
    }
    util.inherits(KeyEncryptedError, Error);
    module.exports = {
      FingerprintFormatError,
      InvalidAlgorithmError,
      KeyParseError,
      SignatureParseError,
      KeyEncryptedError,
      CertificateParseError
    };
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors3 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module) {
    module.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types4 = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module) {
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module) {
    var assert = __require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types4();
    var errors = require_errors3();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data3) {
      if (!data3 || !Buffer2.isBuffer(data3))
        throw new TypeError("data must be a node Buffer");
      this._buf = data3;
      this._size = data3.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values3 = [];
      var value2 = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value2 <<= 7;
        value2 += byte & 127;
        if ((byte & 128) === 0) {
          values3.push(value2);
          value2 = 0;
        }
      }
      value2 = values3.shift();
      values3.unshift(value2 % 40);
      values3.unshift(value2 / 40 >> 0);
      return values3.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value2 = 0;
      for (var i = 0; i < this.length; i++) {
        value2 <<= 8;
        value2 |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value2 -= 1 << i * 8;
      return value2 >> 0;
    };
    module.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module) {
    var assert = __require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types4();
    var errors = require_errors3();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge3(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys4 = Object.getOwnPropertyNames(from);
      keys4.forEach(function(key) {
        if (to[key])
          return;
        var value2 = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value2);
      });
      return to;
    }
    function Writer(options) {
      options = merge3(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module) {
    var errors = require_errors3();
    var types = require_types4();
    var Reader = require_reader();
    var Writer = require_writer();
    module.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module) {
    var Ber = require_ber();
    module.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/jsbn/index.js"(exports, module) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a)
            this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a)
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q2, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q2 != null)
            q2.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q2 != null) {
          r.drShiftTo(ys, q2);
          if (ts != ms)
            BigInteger.ZERO.subTo(q2, q2);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q2 = nbi(), r = nbi();
        this.divRemTo(a, q2, r);
        return new Array(q2, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom2() {
      }
      SecureRandom2.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      BigInteger.SecureRandom = SecureRandom2;
      BigInteger.BigInteger = BigInteger;
      if (typeof exports !== "undefined") {
        exports = module.exports = BigInteger;
      } else {
        this.BigInteger = BigInteger;
        this.SecureRandom = SecureRandom2;
      }
    }).call(exports);
  }
});

// node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS({
  "node_modules/ecc-jsbn/lib/ec.js"(exports, module) {
    var BigInteger = require_jsbn().BigInteger;
    var Barrett = BigInteger.prototype.Barrett;
    function ECFieldElementFp(q2, x) {
      this.x = x;
      this.q = q2;
    }
    function feFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.x.equals(other.x);
    }
    function feFpToBigInteger() {
      return this.x;
    }
    function feFpNegate() {
      return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
    }
    function feFpAdd(b) {
      return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
    }
    function feFpSubtract(b) {
      return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
    }
    function feFpMultiply(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
    }
    function feFpSquare() {
      return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
    }
    function feFpDivide(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
    }
    ECFieldElementFp.prototype.equals = feFpEquals;
    ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
    ECFieldElementFp.prototype.negate = feFpNegate;
    ECFieldElementFp.prototype.add = feFpAdd;
    ECFieldElementFp.prototype.subtract = feFpSubtract;
    ECFieldElementFp.prototype.multiply = feFpMultiply;
    ECFieldElementFp.prototype.square = feFpSquare;
    ECFieldElementFp.prototype.divide = feFpDivide;
    function ECPointFp(curve, x, y, z) {
      this.curve = curve;
      this.x = x;
      this.y = y;
      if (z == null) {
        this.z = BigInteger.ONE;
      } else {
        this.z = z;
      }
      this.zinv = null;
    }
    function pointFpGetX() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.x.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpGetY() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.y.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpEquals(other) {
      if (other == this)
        return true;
      if (this.isInfinity())
        return other.isInfinity();
      if (other.isInfinity())
        return this.isInfinity();
      var u, v;
      u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
      if (!u.equals(BigInteger.ZERO))
        return false;
      v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
      return v.equals(BigInteger.ZERO);
    }
    function pointFpIsInfinity() {
      if (this.x == null && this.y == null)
        return true;
      return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
    }
    function pointFpNegate() {
      return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
    }
    function pointFpAdd(b) {
      if (this.isInfinity())
        return b;
      if (b.isInfinity())
        return this;
      var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
      var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
      if (BigInteger.ZERO.equals(v)) {
        if (BigInteger.ZERO.equals(u)) {
          return this.twice();
        }
        return this.curve.getInfinity();
      }
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var x2 = b.x.toBigInteger();
      var y2 = b.y.toBigInteger();
      var v2 = v.square();
      var v3 = v2.multiply(v);
      var x1v2 = x1.multiply(v2);
      var zu2 = u.square().multiply(this.z);
      var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
      var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
      var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpTwice() {
      if (this.isInfinity())
        return this;
      if (this.y.toBigInteger().signum() == 0)
        return this.curve.getInfinity();
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var y1z1 = y1.multiply(this.z);
      var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
      var a = this.curve.a.toBigInteger();
      var w = x1.square().multiply(THREE);
      if (!BigInteger.ZERO.equals(a)) {
        w = w.add(this.z.square().multiply(a));
      }
      w = w.mod(this.curve.q);
      var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
      var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
      var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpMultiply(k) {
      if (this.isInfinity())
        return this;
      if (k.signum() == 0)
        return this.curve.getInfinity();
      var e = k;
      var h = e.multiply(new BigInteger("3"));
      var neg = this.negate();
      var R = this;
      var i;
      for (i = h.bitLength() - 2; i > 0; --i) {
        R = R.twice();
        var hBit = h.testBit(i);
        var eBit = e.testBit(i);
        if (hBit != eBit) {
          R = R.add(hBit ? this : neg);
        }
      }
      return R;
    }
    function pointFpMultiplyTwo(j, x, k) {
      var i;
      if (j.bitLength() > k.bitLength())
        i = j.bitLength() - 1;
      else
        i = k.bitLength() - 1;
      var R = this.curve.getInfinity();
      var both = this.add(x);
      while (i >= 0) {
        R = R.twice();
        if (j.testBit(i)) {
          if (k.testBit(i)) {
            R = R.add(both);
          } else {
            R = R.add(this);
          }
        } else {
          if (k.testBit(i)) {
            R = R.add(x);
          }
        }
        --i;
      }
      return R;
    }
    ECPointFp.prototype.getX = pointFpGetX;
    ECPointFp.prototype.getY = pointFpGetY;
    ECPointFp.prototype.equals = pointFpEquals;
    ECPointFp.prototype.isInfinity = pointFpIsInfinity;
    ECPointFp.prototype.negate = pointFpNegate;
    ECPointFp.prototype.add = pointFpAdd;
    ECPointFp.prototype.twice = pointFpTwice;
    ECPointFp.prototype.multiply = pointFpMultiply;
    ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
    function ECCurveFp(q2, a, b) {
      this.q = q2;
      this.a = this.fromBigInteger(a);
      this.b = this.fromBigInteger(b);
      this.infinity = new ECPointFp(this, null, null);
      this.reducer = new Barrett(this.q);
    }
    function curveFpGetQ() {
      return this.q;
    }
    function curveFpGetA() {
      return this.a;
    }
    function curveFpGetB() {
      return this.b;
    }
    function curveFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
    }
    function curveFpGetInfinity() {
      return this.infinity;
    }
    function curveFpFromBigInteger(x) {
      return new ECFieldElementFp(this.q, x);
    }
    function curveReduce(x) {
      this.reducer.reduce(x);
    }
    function curveFpEncodePointHex(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var yHex = p.getY().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen) {
        xHex = "0" + xHex;
      }
      while (yHex.length < oLen) {
        yHex = "0" + yHex;
      }
      return "04" + xHex + yHex;
    }
    ECCurveFp.prototype.getQ = curveFpGetQ;
    ECCurveFp.prototype.getA = curveFpGetA;
    ECCurveFp.prototype.getB = curveFpGetB;
    ECCurveFp.prototype.equals = curveFpEquals;
    ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
    ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
    ECCurveFp.prototype.reduce = curveReduce;
    ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
    ECCurveFp.prototype.decodePointHex = function(s) {
      var yIsEven;
      switch (parseInt(s.substr(0, 2), 16)) {
        case 0:
          return this.infinity;
        case 2:
          yIsEven = false;
        case 3:
          if (yIsEven == void 0)
            yIsEven = true;
          var len = s.length - 2;
          var xHex = s.substr(2, len);
          var x = this.fromBigInteger(new BigInteger(xHex, 16));
          var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
          var beta = alpha.sqrt();
          if (beta == null)
            throw "Invalid point compression";
          var betaValue = beta.toBigInteger();
          if (betaValue.testBit(0) != yIsEven) {
            beta = this.fromBigInteger(this.getQ().subtract(betaValue));
          }
          return new ECPointFp(this, x, beta);
        case 4:
        case 6:
        case 7:
          var len = (s.length - 2) / 2;
          var xHex = s.substr(2, len);
          var yHex = s.substr(len + 2, len);
          return new ECPointFp(
            this,
            this.fromBigInteger(new BigInteger(xHex, 16)),
            this.fromBigInteger(new BigInteger(yHex, 16))
          );
        default:
          return null;
      }
    };
    ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen)
        xHex = "0" + xHex;
      var yPrefix;
      if (p.getY().toBigInteger().isEven())
        yPrefix = "02";
      else
        yPrefix = "03";
      return yPrefix + xHex;
    };
    ECFieldElementFp.prototype.getR = function() {
      if (this.r != void 0)
        return this.r;
      this.r = null;
      var bitLength = this.q.bitLength();
      if (bitLength > 128) {
        var firstWord = this.q.shiftRight(bitLength - 64);
        if (firstWord.intValue() == -1) {
          this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
        }
      }
      return this.r;
    };
    ECFieldElementFp.prototype.modMult = function(x1, x2) {
      return this.modReduce(x1.multiply(x2));
    };
    ECFieldElementFp.prototype.modReduce = function(x) {
      if (this.getR() != null) {
        var qLen = q.bitLength();
        while (x.bitLength() > qLen + 1) {
          var u = x.shiftRight(qLen);
          var v = x.subtract(u.shiftLeft(qLen));
          if (!this.getR().equals(BigInteger.ONE)) {
            u = u.multiply(this.getR());
          }
          x = u.add(v);
        }
        while (x.compareTo(q) >= 0) {
          x = x.subtract(q);
        }
      } else {
        x = x.mod(q);
      }
      return x;
    };
    ECFieldElementFp.prototype.sqrt = function() {
      if (!this.q.testBit(0))
        throw "unsupported";
      if (this.q.testBit(1)) {
        var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
        return z.square().equals(this) ? z : null;
      }
      var qMinusOne = this.q.subtract(BigInteger.ONE);
      var legendreExponent = qMinusOne.shiftRight(1);
      if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
        return null;
      }
      var u = qMinusOne.shiftRight(2);
      var k = u.shiftLeft(1).add(BigInteger.ONE);
      var Q = this.x;
      var fourQ = modDouble(modDouble(Q));
      var U, V;
      do {
        var P;
        do {
          P = new BigInteger(this.q.bitLength(), new SecureRandom());
        } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
        var result = this.lucasSequence(P, Q, k);
        U = result[0];
        V = result[1];
        if (this.modMult(V, V).equals(fourQ)) {
          if (V.testBit(0)) {
            V = V.add(q);
          }
          V = V.shiftRight(1);
          return new ECFieldElementFp(q, V);
        }
      } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
      return null;
    };
    ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
      var n = k.bitLength();
      var s = k.getLowestSetBit();
      var Uh = BigInteger.ONE;
      var Vl = BigInteger.TWO;
      var Vh = P;
      var Ql = BigInteger.ONE;
      var Qh = BigInteger.ONE;
      for (var j = n - 1; j >= s + 1; --j) {
        Ql = this.modMult(Ql, Qh);
        if (k.testBit(j)) {
          Qh = this.modMult(Ql, Q);
          Uh = this.modMult(Uh, Vh);
          Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
        } else {
          Qh = Ql;
          Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
          Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        }
      }
      Ql = this.modMult(Ql, Qh);
      Qh = this.modMult(Ql, Q);
      Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
      Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
      Ql = this.modMult(Ql, Qh);
      for (var j = 1; j <= s; ++j) {
        Uh = this.modMult(Uh, Vl);
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        Ql = this.modMult(Ql, Ql);
      }
      return [Uh, Vl];
    };
    var exports = {
      ECCurveFp,
      ECPointFp,
      ECFieldElementFp
    };
    module.exports = exports;
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q2, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q2[i]);
          p[i] ^= t;
          q2[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q2, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n) {
        return crypto_scalarmult(q2, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add2(p, q2) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q2[1], q2[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q2[0], q2[1]);
        M(b, b, t);
        M(c, p[3], q2[3]);
        M(c, c, D2);
        M(d, p[2], q2[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q2, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q2[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q2, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q2, b);
          add2(q2, p);
          add2(p, p);
          cswap(p, q2, b);
        }
      }
      function scalarbase(p, s) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X);
        set25519(q2[1], Y);
        set25519(q2[2], gf1);
        M(q2[3], X, Y);
        scalarmult(p, q2, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q2, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q2, h);
        scalarbase(q2, sm.subarray(32));
        add2(p, q2);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n, p);
        return q2;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n);
        return q2;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto = __require("crypto");
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/sshpk/lib/utils.js
var require_utils = __commonJS({
  "node_modules/sshpk/lib/utils.js"(exports, module) {
    module.exports = {
      bufferSplit,
      addRSAMissing,
      calculateDSAPublic,
      calculateED25519Public,
      calculateX25519Public,
      mpNormalize,
      mpDenormalize,
      ecNormalize,
      countZeros,
      assertCompatible,
      isCompatible,
      opensslKeyDeriv,
      opensshCipherInfo,
      publicFromPrivateECDSA,
      zeroPadToLength,
      writeBitString,
      readBitString,
      pbkdf2
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var PrivateKey = require_private_key();
    var Key = require_key();
    var crypto = __require("crypto");
    var algs = require_algs();
    var asn1 = require_lib();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    var nacl = require_nacl_fast();
    var MAX_CLASS_DEPTH = 3;
    function isCompatible(obj, klass, needVer) {
      if (obj === null || typeof obj !== "object")
        return false;
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return true;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        if (!proto || ++depth > MAX_CLASS_DEPTH)
          return false;
      }
      if (proto.constructor.name !== klass.name)
        return false;
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      if (ver[0] != needVer[0] || ver[1] < needVer[1])
        return false;
      return true;
    }
    function assertCompatible(obj, klass, needVer, name) {
      if (name === void 0)
        name = "object";
      assert.ok(obj, name + " must not be null");
      assert.object(obj, name + " must be an object");
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        assert.ok(
          proto && ++depth <= MAX_CLASS_DEPTH,
          name + " must be a " + klass.name + " instance"
        );
      }
      assert.strictEqual(
        proto.constructor.name,
        klass.name,
        name + " must be a " + klass.name + " instance"
      );
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      assert.ok(
        ver[0] == needVer[0] && ver[1] >= needVer[1],
        name + " must be compatible with " + klass.name + " klass version " + needVer[0] + "." + needVer[1]
      );
    }
    var CIPHER_LEN = {
      "des-ede3-cbc": { key: 24, iv: 8 },
      "aes-128-cbc": { key: 16, iv: 16 },
      "aes-256-cbc": { key: 32, iv: 16 }
    };
    var PKCS5_SALT_LEN = 8;
    function opensslKeyDeriv(cipher, salt, passphrase, count) {
      assert.buffer(salt, "salt");
      assert.buffer(passphrase, "passphrase");
      assert.number(count, "iteration count");
      var clen = CIPHER_LEN[cipher];
      assert.object(clen, "supported cipher");
      salt = salt.slice(0, PKCS5_SALT_LEN);
      var D, D_prev, bufs;
      var material = Buffer2.alloc(0);
      while (material.length < clen.key + clen.iv) {
        bufs = [];
        if (D_prev)
          bufs.push(D_prev);
        bufs.push(passphrase);
        bufs.push(salt);
        D = Buffer2.concat(bufs);
        for (var j = 0; j < count; ++j)
          D = crypto.createHash("md5").update(D).digest();
        material = Buffer2.concat([material, D]);
        D_prev = D;
      }
      return {
        key: material.slice(0, clen.key),
        iv: material.slice(clen.key, clen.key + clen.iv)
      };
    }
    function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
      var hkey = Buffer2.alloc(salt.length + 4);
      salt.copy(hkey);
      var gen = 0, ts = [];
      var i = 1;
      while (gen < size) {
        var t = T(i++);
        gen += t.length;
        ts.push(t);
      }
      return Buffer2.concat(ts).slice(0, size);
      function T(I) {
        hkey.writeUInt32BE(I, hkey.length - 4);
        var hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(hkey);
        var Ti = hmac.digest();
        var Uc = Ti;
        var c = 1;
        while (c++ < iterations) {
          hmac = crypto.createHmac(hashAlg, passphrase);
          hmac.update(Uc);
          Uc = hmac.digest();
          for (var x = 0; x < Ti.length; ++x)
            Ti[x] ^= Uc[x];
        }
        return Ti;
      }
    }
    function countZeros(buf) {
      var o = 0, obit = 8;
      while (o < buf.length) {
        var mask = 1 << obit;
        if ((buf[o] & mask) === mask)
          break;
        obit--;
        if (obit < 0) {
          o++;
          obit = 8;
        }
      }
      return o * 8 + (8 - obit) - 1;
    }
    function bufferSplit(buf, chr) {
      assert.buffer(buf);
      assert.string(chr);
      var parts = [];
      var lastPart = 0;
      var matches2 = 0;
      for (var i = 0; i < buf.length; ++i) {
        if (buf[i] === chr.charCodeAt(matches2))
          ++matches2;
        else if (buf[i] === chr.charCodeAt(0))
          matches2 = 1;
        else
          matches2 = 0;
        if (matches2 >= chr.length) {
          var newPart = i + 1;
          parts.push(buf.slice(lastPart, newPart - matches2));
          lastPart = newPart;
          matches2 = 0;
        }
      }
      if (lastPart <= buf.length)
        parts.push(buf.slice(lastPart, buf.length));
      return parts;
    }
    function ecNormalize(buf, addZero) {
      assert.buffer(buf);
      if (buf[0] === 0 && buf[1] === 4) {
        if (addZero)
          return buf;
        return buf.slice(1);
      } else if (buf[0] === 4) {
        if (!addZero)
          return buf;
      } else {
        while (buf[0] === 0)
          buf = buf.slice(1);
        if (buf[0] === 2 || buf[0] === 3)
          throw new Error("Compressed elliptic curve points are not supported");
        if (buf[0] !== 4)
          throw new Error("Not a valid elliptic curve point");
        if (!addZero)
          return buf;
      }
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      return b;
    }
    function readBitString(der, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var buf = der.readString(tag, true);
      assert.strictEqual(buf[0], 0, "bit strings with unused bits are not supported (0x" + buf[0].toString(16) + ")");
      return buf.slice(1);
    }
    function writeBitString(der, buf, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      der.writeBuffer(b, tag);
    }
    function mpNormalize(buf) {
      assert.buffer(buf);
      while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
        buf = buf.slice(1);
      if ((buf[0] & 128) === 128) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function mpDenormalize(buf) {
      assert.buffer(buf);
      while (buf.length > 1 && buf[0] === 0)
        buf = buf.slice(1);
      return buf;
    }
    function zeroPadToLength(buf, len) {
      assert.buffer(buf);
      assert.number(len);
      while (buf.length > len) {
        assert.equal(buf[0], 0);
        buf = buf.slice(1);
      }
      while (buf.length < len) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function bigintToMpBuf(bigint) {
      var buf = Buffer2.from(bigint.toByteArray());
      buf = mpNormalize(buf);
      return buf;
    }
    function calculateDSAPublic(g, p, x) {
      assert.buffer(g);
      assert.buffer(p);
      assert.buffer(x);
      g = new jsbn(g);
      p = new jsbn(p);
      x = new jsbn(x);
      var y = g.modPow(x, p);
      var ybuf = bigintToMpBuf(y);
      return ybuf;
    }
    function calculateED25519Public(k) {
      assert.buffer(k);
      var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function calculateX25519Public(k) {
      assert.buffer(k);
      var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function addRSAMissing(key) {
      assert.object(key);
      assertCompatible(key, PrivateKey, [1, 1]);
      var d = new jsbn(key.part.d.data);
      var buf;
      if (!key.part.dmodp) {
        var p = new jsbn(key.part.p.data);
        var dmodp = d.mod(p.subtract(1));
        buf = bigintToMpBuf(dmodp);
        key.part.dmodp = { name: "dmodp", data: buf };
        key.parts.push(key.part.dmodp);
      }
      if (!key.part.dmodq) {
        var q2 = new jsbn(key.part.q.data);
        var dmodq = d.mod(q2.subtract(1));
        buf = bigintToMpBuf(dmodq);
        key.part.dmodq = { name: "dmodq", data: buf };
        key.parts.push(key.part.dmodq);
      }
    }
    function publicFromPrivateECDSA(curveName, priv) {
      assert.string(curveName, "curveName");
      assert.buffer(priv);
      var params = algs.curves[curveName];
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      var d = new jsbn(mpNormalize(priv));
      var pub = G.multiply(d);
      pub = Buffer2.from(curve.encodePointHex(pub), "hex");
      var parts = [];
      parts.push({ name: "curve", data: Buffer2.from(curveName) });
      parts.push({ name: "Q", data: pub });
      var key = new Key({ type: "ecdsa", curve, parts });
      return key;
    }
    function opensshCipherInfo(cipher) {
      var inf = {};
      switch (cipher) {
        case "3des-cbc":
          inf.keySize = 24;
          inf.blockSize = 8;
          inf.opensslName = "des-ede3-cbc";
          break;
        case "blowfish-cbc":
          inf.keySize = 16;
          inf.blockSize = 8;
          inf.opensslName = "bf-cbc";
          break;
        case "aes128-cbc":
        case "aes128-ctr":
        case "aes128-gcm@openssh.com":
          inf.keySize = 16;
          inf.blockSize = 16;
          inf.opensslName = "aes-128-" + cipher.slice(7, 10);
          break;
        case "aes192-cbc":
        case "aes192-ctr":
        case "aes192-gcm@openssh.com":
          inf.keySize = 24;
          inf.blockSize = 16;
          inf.opensslName = "aes-192-" + cipher.slice(7, 10);
          break;
        case "aes256-cbc":
        case "aes256-ctr":
        case "aes256-gcm@openssh.com":
          inf.keySize = 32;
          inf.blockSize = 16;
          inf.opensslName = "aes-256-" + cipher.slice(7, 10);
          break;
        default:
          throw new Error(
            'Unsupported openssl cipher "' + cipher + '"'
          );
      }
      return inf;
    }
  }
});

// node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS({
  "node_modules/sshpk/lib/ssh-buffer.js"(exports, module) {
    module.exports = SSHBuffer;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    function SSHBuffer(opts) {
      assert.object(opts, "options");
      if (opts.buffer !== void 0)
        assert.buffer(opts.buffer, "options.buffer");
      this._size = opts.buffer ? opts.buffer.length : 1024;
      this._buffer = opts.buffer || Buffer2.alloc(this._size);
      this._offset = 0;
    }
    SSHBuffer.prototype.toBuffer = function() {
      return this._buffer.slice(0, this._offset);
    };
    SSHBuffer.prototype.atEnd = function() {
      return this._offset >= this._buffer.length;
    };
    SSHBuffer.prototype.remainder = function() {
      return this._buffer.slice(this._offset);
    };
    SSHBuffer.prototype.skip = function(n) {
      this._offset += n;
    };
    SSHBuffer.prototype.expand = function() {
      this._size *= 2;
      var buf = Buffer2.alloc(this._size);
      this._buffer.copy(buf, 0);
      this._buffer = buf;
    };
    SSHBuffer.prototype.readPart = function() {
      return { data: this.readBuffer() };
    };
    SSHBuffer.prototype.readBuffer = function() {
      var len = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      assert.ok(
        this._offset + len <= this._buffer.length,
        "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)"
      );
      var buf = this._buffer.slice(this._offset, this._offset + len);
      this._offset += len;
      return buf;
    };
    SSHBuffer.prototype.readString = function() {
      return this.readBuffer().toString();
    };
    SSHBuffer.prototype.readCString = function() {
      var offset = this._offset;
      while (offset < this._buffer.length && this._buffer[offset] !== 0)
        offset++;
      assert.ok(offset < this._buffer.length, "c string does not terminate");
      var str = this._buffer.slice(this._offset, offset).toString();
      this._offset = offset + 1;
      return str;
    };
    SSHBuffer.prototype.readInt = function() {
      var v = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      return v;
    };
    SSHBuffer.prototype.readInt64 = function() {
      assert.ok(
        this._offset + 8 < this._buffer.length,
        "buffer not long enough to read Int64"
      );
      var v = this._buffer.slice(this._offset, this._offset + 8);
      this._offset += 8;
      return v;
    };
    SSHBuffer.prototype.readChar = function() {
      var v = this._buffer[this._offset++];
      return v;
    };
    SSHBuffer.prototype.writeBuffer = function(buf) {
      while (this._offset + 4 + buf.length > this._size)
        this.expand();
      this._buffer.writeUInt32BE(buf.length, this._offset);
      this._offset += 4;
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
    SSHBuffer.prototype.writeString = function(str) {
      this.writeBuffer(Buffer2.from(str, "utf8"));
    };
    SSHBuffer.prototype.writeCString = function(str) {
      while (this._offset + 1 + str.length > this._size)
        this.expand();
      this._buffer.write(str, this._offset);
      this._offset += str.length;
      this._buffer[this._offset++] = 0;
    };
    SSHBuffer.prototype.writeInt = function(v) {
      while (this._offset + 4 > this._size)
        this.expand();
      this._buffer.writeUInt32BE(v, this._offset);
      this._offset += 4;
    };
    SSHBuffer.prototype.writeInt64 = function(v) {
      assert.buffer(v, "value");
      if (v.length > 8) {
        var lead = v.slice(0, v.length - 8);
        for (var i = 0; i < lead.length; ++i) {
          assert.strictEqual(
            lead[i],
            0,
            "must fit in 64 bits of precision"
          );
        }
        v = v.slice(v.length - 8, v.length);
      }
      while (this._offset + 8 > this._size)
        this.expand();
      v.copy(this._buffer, this._offset);
      this._offset += 8;
    };
    SSHBuffer.prototype.writeChar = function(v) {
      while (this._offset + 1 > this._size)
        this.expand();
      this._buffer[this._offset++] = v;
    };
    SSHBuffer.prototype.writePart = function(p) {
      this.writeBuffer(p.data);
    };
    SSHBuffer.prototype.write = function(buf) {
      while (this._offset + buf.length > this._size)
        this.expand();
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
  }
});

// node_modules/sshpk/lib/signature.js
var require_signature = __commonJS({
  "node_modules/sshpk/lib/signature.js"(exports, module) {
    module.exports = Signature;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = __require("crypto");
    var errs = require_errors2();
    var utils = require_utils();
    var asn1 = require_lib();
    var SSHBuffer = require_ssh_buffer();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var SignatureParseError = errs.SignatureParseError;
    function Signature(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.parts, "options.parts");
      assert.string(opts.type, "options.type");
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.hashAlgorithm = opts.hashAlgo;
      this.curve = opts.curve;
      this.parts = opts.parts;
      this.part = partLookup;
    }
    Signature.prototype.toBuffer = function(format) {
      if (format === void 0)
        format = "asn1";
      assert.string(format, "format");
      var buf;
      var stype = "ssh-" + this.type;
      switch (this.type) {
        case "rsa":
          switch (this.hashAlgorithm) {
            case "sha256":
              stype = "rsa-sha2-256";
              break;
            case "sha512":
              stype = "rsa-sha2-512";
              break;
            case "sha1":
            case void 0:
              break;
            default:
              throw new Error("SSH signature format does not support hash algorithm " + this.hashAlgorithm);
          }
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "ed25519":
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "dsa":
        case "ecdsa":
          var r, s;
          if (format === "asn1") {
            var der = new asn1.BerWriter();
            der.startSequence();
            r = utils.mpNormalize(this.part.r.data);
            s = utils.mpNormalize(this.part.s.data);
            der.writeBuffer(r, asn1.Ber.Integer);
            der.writeBuffer(s, asn1.Ber.Integer);
            der.endSequence();
            return der.buffer;
          } else if (format === "ssh" && this.type === "dsa") {
            buf = new SSHBuffer({});
            buf.writeString("ssh-dss");
            r = this.part.r.data;
            if (r.length > 20 && r[0] === 0)
              r = r.slice(1);
            s = this.part.s.data;
            if (s.length > 20 && s[0] === 0)
              s = s.slice(1);
            if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
              throw new Error("OpenSSH only supports DSA signatures with SHA1 hash");
            }
            buf.writeBuffer(Buffer2.concat([r, s]));
            return buf.toBuffer();
          } else if (format === "ssh" && this.type === "ecdsa") {
            var inner = new SSHBuffer({});
            r = this.part.r.data;
            inner.writeBuffer(r);
            inner.writePart(this.part.s);
            buf = new SSHBuffer({});
            var curve;
            if (r[0] === 0)
              r = r.slice(1);
            var sz = r.length * 8;
            if (sz === 256)
              curve = "nistp256";
            else if (sz === 384)
              curve = "nistp384";
            else if (sz === 528)
              curve = "nistp521";
            buf.writeString("ecdsa-sha2-" + curve);
            buf.writeBuffer(inner.toBuffer());
            return buf.toBuffer();
          }
          throw new Error("Invalid signature format");
        default:
          throw new Error("Invalid signature data");
      }
    };
    Signature.prototype.toString = function(format) {
      assert.optionalString(format, "format");
      return this.toBuffer(format).toString("base64");
    };
    Signature.parse = function(data3, type3, format) {
      if (typeof data3 === "string")
        data3 = Buffer2.from(data3, "base64");
      assert.buffer(data3, "data");
      assert.string(format, "format");
      assert.string(type3, "type");
      var opts = {};
      opts.type = type3.toLowerCase();
      opts.parts = [];
      try {
        assert.ok(data3.length > 0, "signature must not be empty");
        switch (opts.type) {
          case "rsa":
            return parseOneNum(data3, type3, format, opts);
          case "ed25519":
            return parseOneNum(data3, type3, format, opts);
          case "dsa":
          case "ecdsa":
            if (format === "asn1")
              return parseDSAasn1(data3, type3, format, opts);
            else if (opts.type === "dsa")
              return parseDSA(data3, type3, format, opts);
            else
              return parseECDSA(data3, type3, format, opts);
          default:
            throw new InvalidAlgorithmError(type3);
        }
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw e;
        throw new SignatureParseError(type3, format, e);
      }
    };
    function parseOneNum(data3, type3, format, opts) {
      if (format === "ssh") {
        try {
          var buf = new SSHBuffer({ buffer: data3 });
          var head = buf.readString();
        } catch (e) {
        }
        if (buf !== void 0) {
          var msg = "SSH signature does not match expected type (expected " + type3 + ", got " + head + ")";
          switch (head) {
            case "ssh-rsa":
              assert.strictEqual(type3, "rsa", msg);
              opts.hashAlgo = "sha1";
              break;
            case "rsa-sha2-256":
              assert.strictEqual(type3, "rsa", msg);
              opts.hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              assert.strictEqual(type3, "rsa", msg);
              opts.hashAlgo = "sha512";
              break;
            case "ssh-ed25519":
              assert.strictEqual(type3, "ed25519", msg);
              opts.hashAlgo = "sha512";
              break;
            default:
              throw new Error("Unknown SSH signature type: " + head);
          }
          var sig = buf.readPart();
          assert.ok(buf.atEnd(), "extra trailing bytes");
          sig.name = "sig";
          opts.parts.push(sig);
          return new Signature(opts);
        }
      }
      opts.parts.push({ name: "sig", data: data3 });
      return new Signature(opts);
    }
    function parseDSAasn1(data3, type3, format, opts) {
      var der = new asn1.BerReader(data3);
      der.readSequence();
      var r = der.readString(asn1.Ber.Integer, true);
      var s = der.readString(asn1.Ber.Integer, true);
      opts.parts.push({ name: "r", data: utils.mpNormalize(r) });
      opts.parts.push({ name: "s", data: utils.mpNormalize(s) });
      return new Signature(opts);
    }
    function parseDSA(data3, type3, format, opts) {
      if (data3.length != 40) {
        var buf = new SSHBuffer({ buffer: data3 });
        var d = buf.readBuffer();
        if (d.toString("ascii") === "ssh-dss")
          d = buf.readBuffer();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        assert.strictEqual(d.length, 40, "invalid inner length");
        data3 = d;
      }
      opts.parts.push({ name: "r", data: data3.slice(0, 20) });
      opts.parts.push({ name: "s", data: data3.slice(20, 40) });
      return new Signature(opts);
    }
    function parseECDSA(data3, type3, format, opts) {
      var buf = new SSHBuffer({ buffer: data3 });
      var r, s;
      var inner = buf.readBuffer();
      var stype = inner.toString("ascii");
      if (stype.slice(0, 6) === "ecdsa-") {
        var parts = stype.split("-");
        assert.strictEqual(parts[0], "ecdsa");
        assert.strictEqual(parts[1], "sha2");
        opts.curve = parts[2];
        switch (opts.curve) {
          case "nistp256":
            opts.hashAlgo = "sha256";
            break;
          case "nistp384":
            opts.hashAlgo = "sha384";
            break;
          case "nistp521":
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unsupported ECDSA curve: " + opts.curve);
        }
        inner = buf.readBuffer();
        assert.ok(buf.atEnd(), "extra trailing bytes on outer");
        buf = new SSHBuffer({ buffer: inner });
        r = buf.readPart();
      } else {
        r = { data: inner };
      }
      s = buf.readPart();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      r.name = "r";
      s.name = "s";
      opts.parts.push(r);
      opts.parts.push(s);
      return new Signature(opts);
    }
    Signature.isSignature = function(obj, ver) {
      return utils.isCompatible(obj, Signature, ver);
    };
    Signature.prototype._sshpkApiVersion = [2, 1];
    Signature._oldVersionDetect = function(obj) {
      assert.func(obj.toBuffer);
      if (obj.hasOwnProperty("hashAlgorithm"))
        return [2, 0];
      return [1, 0];
    };
  }
});

// node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS({
  "node_modules/ecc-jsbn/lib/sec.js"(exports, module) {
    var BigInteger = require_jsbn().BigInteger;
    var ECCurveFp = require_ec().ECCurveFp;
    function X9ECParameters(curve, g, n, h) {
      this.curve = curve;
      this.g = g;
      this.n = n;
      this.h = h;
    }
    function x9getCurve() {
      return this.curve;
    }
    function x9getG() {
      return this.g;
    }
    function x9getN() {
      return this.n;
    }
    function x9getH() {
      return this.h;
    }
    X9ECParameters.prototype.getCurve = x9getCurve;
    X9ECParameters.prototype.getG = x9getG;
    X9ECParameters.prototype.getN = x9getN;
    X9ECParameters.prototype.getH = x9getH;
    function fromHex(s) {
      return new BigInteger(s, 16);
    }
    function secp128r1() {
      var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
      var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
      var a = BigInteger.ZERO;
      var b = fromHex("7");
      var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
      var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
      var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
      var a = BigInteger.ZERO;
      var b = fromHex("3");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
      var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp224r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
      var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp256r1() {
      var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
      var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
      return new X9ECParameters(curve, G, n, h);
    }
    module.exports = {
      "secp128r1": secp128r1,
      "secp160k1": secp160k1,
      "secp160r1": secp160r1,
      "secp192k1": secp192k1,
      "secp192r1": secp192r1,
      "secp224r1": secp224r1,
      "secp256r1": secp256r1
    };
  }
});

// node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS({
  "node_modules/ecc-jsbn/index.js"(exports) {
    var crypto = __require("crypto");
    var BigInteger = require_jsbn().BigInteger;
    var ECPointFp = require_ec().ECPointFp;
    var Buffer2 = require_safer().Buffer;
    exports.ECCurves = require_sec();
    function unstupid(hex, len) {
      return hex.length >= len ? hex : unstupid("0" + hex, len);
    }
    exports.ECKey = function(curve, key, isPublic) {
      var priv;
      var c = curve();
      var n = c.getN();
      var bytes = Math.floor(n.bitLength() / 8);
      if (key) {
        if (isPublic) {
          var curve = c.getCurve();
          this.P = curve.decodePointHex(key.toString("hex"));
        } else {
          if (key.length != bytes)
            return false;
          priv = new BigInteger(key.toString("hex"), 16);
        }
      } else {
        var n1 = n.subtract(BigInteger.ONE);
        var r = new BigInteger(crypto.randomBytes(n.bitLength()));
        priv = r.mod(n1).add(BigInteger.ONE);
        this.P = c.getG().multiply(priv);
      }
      if (this.P) {
        this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
      }
      if (priv) {
        this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
        this.deriveSharedSecret = function(key2) {
          if (!key2 || !key2.P)
            return false;
          var S = key2.P.multiply(priv);
          return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
        };
      }
    };
  }
});

// node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS({
  "node_modules/sshpk/lib/dhe.js"(exports, module) {
    module.exports = {
      DiffieHellman,
      generateECDSA,
      generateED25519
    };
    var assert = require_assert();
    var crypto = __require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
    var ecdh = require_ecc_jsbn();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    function DiffieHellman(key) {
      utils.assertCompatible(key, Key, [1, 4], "key");
      this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
      this._algo = key.type;
      this._curve = key.curve;
      this._key = key;
      if (key.type === "dsa") {
        if (!CRYPTO_HAVE_ECDH) {
          throw new Error("Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH");
        }
        this._dh = crypto.createDiffieHellman(
          key.part.p.data,
          void 0,
          key.part.g.data,
          void 0
        );
        this._p = key.part.p;
        this._g = key.part.g;
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.x.data);
        this._dh.setPublicKey(key.part.y.data);
      } else if (key.type === "ecdsa") {
        if (!CRYPTO_HAVE_ECDH) {
          this._ecParams = new X9ECParameters(this._curve);
          if (this._isPriv) {
            this._priv = new ECPrivate(
              this._ecParams,
              key.part.d.data
            );
          }
          return;
        }
        var curve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[key.curve];
        this._dh = crypto.createECDH(curve);
        if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
          CRYPTO_HAVE_ECDH = false;
          DiffieHellman.call(this, key);
          return;
        }
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.d.data);
        this._dh.setPublicKey(key.part.Q.data);
      } else if (key.type === "curve25519") {
        if (this._isPriv) {
          utils.assertCompatible(key, PrivateKey, [1, 5], "key");
          this._priv = key.part.k.data;
        }
      } else {
        throw new Error("DH not supported for " + key.type + " keys");
      }
    }
    DiffieHellman.prototype.getPublicKey = function() {
      if (this._isPriv)
        return this._key.toPublic();
      return this._key;
    };
    DiffieHellman.prototype.getPrivateKey = function() {
      if (this._isPriv)
        return this._key;
      else
        return void 0;
    };
    DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
    DiffieHellman.prototype._keyCheck = function(pk, isPub) {
      assert.object(pk, "key");
      if (!isPub)
        utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
      utils.assertCompatible(pk, Key, [1, 4], "key");
      if (pk.type !== this._algo) {
        throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
      }
      if (pk.curve !== this._curve) {
        throw new Error("A key from the " + pk.curve + " curve cannot be used with a " + this._curve + " Diffie-Hellman");
      }
      if (pk.type === "dsa") {
        assert.deepEqual(
          pk.part.p,
          this._p,
          "DSA key prime does not match"
        );
        assert.deepEqual(
          pk.part.g,
          this._g,
          "DSA key generator does not match"
        );
      }
    };
    DiffieHellman.prototype.setKey = function(pk) {
      this._keyCheck(pk);
      if (pk.type === "dsa") {
        this._dh.setPrivateKey(pk.part.x.data);
        this._dh.setPublicKey(pk.part.y.data);
      } else if (pk.type === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.setPrivateKey(pk.part.d.data);
          this._dh.setPublicKey(pk.part.Q.data);
        } else {
          this._priv = new ECPrivate(
            this._ecParams,
            pk.part.d.data
          );
        }
      } else if (pk.type === "curve25519") {
        var k = pk.part.k;
        if (!pk.part.k)
          k = pk.part.r;
        this._priv = k.data;
        if (this._priv[0] === 0)
          this._priv = this._priv.slice(1);
        this._priv = this._priv.slice(0, 32);
      }
      this._key = pk;
      this._isPriv = true;
    };
    DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
    DiffieHellman.prototype.computeSecret = function(otherpk) {
      this._keyCheck(otherpk, true);
      if (!this._isPriv)
        throw new Error("DH exchange has not been initialized with a private key yet");
      var pub;
      if (this._algo === "dsa") {
        return this._dh.computeSecret(
          otherpk.part.y.data
        );
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          return this._dh.computeSecret(
            otherpk.part.Q.data
          );
        } else {
          pub = new ECPublic(
            this._ecParams,
            otherpk.part.Q.data
          );
          return this._priv.deriveSharedSecret(pub);
        }
      } else if (this._algo === "curve25519") {
        pub = otherpk.part.A.data;
        while (pub[0] === 0 && pub.length > 32)
          pub = pub.slice(1);
        var priv = this._priv;
        assert.strictEqual(pub.length, 32);
        assert.strictEqual(priv.length, 32);
        var secret = nacl.box.before(
          new Uint8Array(pub),
          new Uint8Array(priv)
        );
        return Buffer2.from(secret);
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKey = function() {
      var parts = [];
      var priv, pub;
      if (this._algo === "dsa") {
        this._dh.generateKeys();
        parts.push({ name: "p", data: this._p.data });
        parts.push({ name: "q", data: this._key.part.q.data });
        parts.push({ name: "g", data: this._g.data });
        parts.push({ name: "y", data: this._dh.getPublicKey() });
        parts.push({ name: "x", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "dsa",
          parts
        });
        this._isPriv = true;
        return this._key;
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.generateKeys();
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: this._dh.getPublicKey() });
          parts.push({ name: "d", data: this._dh.getPrivateKey() });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        } else {
          var n = this._ecParams.getN();
          var r = new jsbn(crypto.randomBytes(n.bitLength()));
          var n1 = n.subtract(jsbn.ONE);
          priv = r.mod(n1).add(jsbn.ONE);
          pub = this._ecParams.getG().multiply(priv);
          priv = Buffer2.from(priv.toByteArray());
          pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
          this._priv = new ECPrivate(this._ecParams, priv);
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: pub });
          parts.push({ name: "d", data: priv });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        }
      } else if (this._algo === "curve25519") {
        var pair = nacl.box.keyPair();
        priv = Buffer2.from(pair.secretKey);
        pub = Buffer2.from(pair.publicKey);
        priv = Buffer2.concat([priv, pub]);
        assert.strictEqual(priv.length, 64);
        assert.strictEqual(pub.length, 32);
        parts.push({ name: "A", data: pub });
        parts.push({ name: "k", data: priv });
        this._key = new PrivateKey({
          type: "curve25519",
          parts
        });
        this._isPriv = true;
        return this._key;
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
    function X9ECParameters(name) {
      var params = algs.curves[name];
      assert.object(params);
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var n = new jsbn(params.n);
      var h = jsbn.ONE;
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      this.curve = curve;
      this.g = G;
      this.n = n;
      this.h = h;
    }
    X9ECParameters.prototype.getCurve = function() {
      return this.curve;
    };
    X9ECParameters.prototype.getG = function() {
      return this.g;
    };
    X9ECParameters.prototype.getN = function() {
      return this.n;
    };
    X9ECParameters.prototype.getH = function() {
      return this.h;
    };
    function ECPublic(params, buffer) {
      this._params = params;
      if (buffer[0] === 0)
        buffer = buffer.slice(1);
      this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
    }
    function ECPrivate(params, buffer) {
      this._params = params;
      this._priv = new jsbn(utils.mpNormalize(buffer));
    }
    ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
      assert.ok(pubKey instanceof ECPublic);
      var S = pubKey._pub.multiply(this._priv);
      return Buffer2.from(S.getX().toBigInteger().toByteArray());
    };
    function generateED25519() {
      var pair = nacl.sign.keyPair();
      var priv = Buffer2.from(pair.secretKey);
      var pub = Buffer2.from(pair.publicKey);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      var parts = [];
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv.slice(0, 32) });
      var key = new PrivateKey({
        type: "ed25519",
        parts
      });
      return key;
    }
    function generateECDSA(curve) {
      var parts = [];
      var key;
      if (CRYPTO_HAVE_ECDH) {
        var osCurve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[curve];
        var dh = crypto.createECDH(osCurve);
        dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(curve)
        });
        parts.push({ name: "Q", data: dh.getPublicKey() });
        parts.push({ name: "d", data: dh.getPrivateKey() });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      } else {
        var ecParams = new X9ECParameters(curve);
        var n = ecParams.getN();
        var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
        var c = new jsbn(crypto.randomBytes(cByteLen));
        var n1 = n.subtract(jsbn.ONE);
        var priv = c.mod(n1).add(jsbn.ONE);
        var pub = ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
        parts.push({ name: "curve", data: Buffer2.from(curve) });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      }
    }
  }
});

// node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS({
  "node_modules/sshpk/lib/ed-compat.js"(exports, module) {
    module.exports = {
      Verifier,
      Signer
    };
    var nacl = require_nacl_fast();
    var stream = __require("stream");
    var util = __require("util");
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Signature = require_signature();
    function Verifier(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util.inherits(Verifier, stream.Writable);
    Verifier.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Verifier.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Verifier.prototype.verify = function(signature, fmt) {
      var sig;
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== "ed25519")
          return false;
        sig = signature.toBuffer("raw");
      } else if (typeof signature === "string") {
        sig = Buffer2.from(signature, "base64");
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old a version of sshpk and cannot be verified");
      }
      assert.buffer(sig);
      return nacl.sign.detached.verify(
        new Uint8Array(Buffer2.concat(this.chunks)),
        new Uint8Array(sig),
        new Uint8Array(this.key.part.A.data)
      );
    };
    function Signer(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util.inherits(Signer, stream.Writable);
    Signer.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Signer.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Signer.prototype.sign = function() {
      var sig = nacl.sign.detached(
        new Uint8Array(Buffer2.concat(this.chunks)),
        new Uint8Array(Buffer2.concat([
          this.key.part.k.data,
          this.key.part.A.data
        ]))
      );
      var sigBuf = Buffer2.from(sig);
      var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
      sigObj.hashAlgorithm = "sha512";
      return sigObj;
    };
  }
});

// node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS({
  "node_modules/sshpk/lib/formats/pkcs8.js"(exports, module) {
    module.exports = {
      read,
      readPkcs8,
      write,
      writePkcs8,
      pkcs8ToBuffer,
      readECDSACurve,
      writeECDSACurve
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    function read(buf, options) {
      return pem.read(buf, options, "pkcs8");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs8");
    }
    function readMPInt(der, nm) {
      assert.strictEqual(
        der.peek(),
        asn1.Ber.Integer,
        nm + " is not an Integer"
      );
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs8(alg, type3, der) {
      if (der.peek() === asn1.Ber.Integer) {
        assert.strictEqual(
          type3,
          "private",
          "unexpected Integer at start of public key"
        );
        der.readString(asn1.Ber.Integer, true);
      }
      der.readSequence();
      var next2 = der.offset + der.length;
      var oid = der.readOID();
      switch (oid) {
        case "1.2.840.113549.1.1.1":
          der._offset = next2;
          if (type3 === "public")
            return readPkcs8RSAPublic(der);
          else
            return readPkcs8RSAPrivate(der);
        case "1.2.840.10040.4.1":
          if (type3 === "public")
            return readPkcs8DSAPublic(der);
          else
            return readPkcs8DSAPrivate(der);
        case "1.2.840.10045.2.1":
          if (type3 === "public")
            return readPkcs8ECDSAPublic(der);
          else
            return readPkcs8ECDSAPrivate(der);
        case "1.3.101.112":
          if (type3 === "public") {
            return readPkcs8EdDSAPublic(der);
          } else {
            return readPkcs8EdDSAPrivate(der);
          }
        case "1.3.101.110":
          if (type3 === "public") {
            return readPkcs8X25519Public(der);
          } else {
            return readPkcs8X25519Private(der);
          }
        default:
          throw new Error("Unknown key type OID " + oid);
      }
    }
    function readPkcs8RSAPublic(der) {
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      der.readSequence();
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        source: der.originalInput,
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs8RSAPrivate(der) {
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var ver = readMPInt(der, "version");
      assert.equal(ver[0], 0, "unknown RSA private key version");
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8DSAPublic(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      var y = readMPInt(der, "y");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y }
        ]
      };
      return new Key(key);
    }
    function readPkcs8DSAPrivate(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.OctetString);
      var x = readMPInt(der, "x");
      var y = utils.calculateDSAPublic(g, p, x);
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readECDSACurve(der) {
      var curveName, curveNames;
      var j, c, cd;
      if (der.peek() === asn1.Ber.OID) {
        var oid = der.readOID();
        curveNames = Object.keys(algs.curves);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          if (cd.pkcs8oid === oid) {
            curveName = c;
            break;
          }
        }
      } else {
        der.readSequence();
        var version = der.readString(asn1.Ber.Integer, true);
        assert.strictEqual(version[0], 1, "ECDSA key not version 1");
        var curve = {};
        der.readSequence();
        var fieldTypeOid = der.readOID();
        assert.strictEqual(
          fieldTypeOid,
          "1.2.840.10045.1.1",
          "ECDSA key is not from a prime-field"
        );
        var p = curve.p = utils.mpNormalize(
          der.readString(asn1.Ber.Integer, true)
        );
        curve.size = p.length * 8 - utils.countZeros(p);
        der.readSequence();
        curve.a = utils.mpNormalize(
          der.readString(asn1.Ber.OctetString, true)
        );
        curve.b = utils.mpNormalize(
          der.readString(asn1.Ber.OctetString, true)
        );
        if (der.peek() === asn1.Ber.BitString)
          curve.s = der.readString(asn1.Ber.BitString, true);
        curve.G = der.readString(asn1.Ber.OctetString, true);
        assert.strictEqual(
          curve.G[0],
          4,
          "uncompressed G is required"
        );
        curve.n = utils.mpNormalize(
          der.readString(asn1.Ber.Integer, true)
        );
        curve.h = utils.mpNormalize(
          der.readString(asn1.Ber.Integer, true)
        );
        assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is required");
        curveNames = Object.keys(algs.curves);
        var ks = Object.keys(curve);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          var equal = true;
          for (var i = 0; i < ks.length; ++i) {
            var k = ks[i];
            if (cd[k] === void 0)
              continue;
            if (typeof cd[k] === "object" && cd[k].equals !== void 0) {
              if (!cd[k].equals(curve[k])) {
                equal = false;
                break;
              }
            } else if (Buffer2.isBuffer(cd[k])) {
              if (cd[k].toString("binary") !== curve[k].toString("binary")) {
                equal = false;
                break;
              }
            } else {
              if (cd[k] !== curve[k]) {
                equal = false;
                break;
              }
            }
          }
          if (equal) {
            curveName = c;
            break;
          }
        }
      }
      return curveName;
    }
    function readPkcs8ECDSAPrivate(der) {
      var curveName = readECDSACurve(der);
      assert.string(curveName, "a known elliptic curve");
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var version = readMPInt(der, "version");
      assert.equal(version[0], 1, "unknown version of ECDSA key");
      var d = der.readString(asn1.Ber.OctetString, true);
      var Q;
      if (der.peek() == 160) {
        der.readSequence(160);
        der._offset += der.length;
      }
      if (der.peek() == 161) {
        der.readSequence(161);
        Q = der.readString(asn1.Ber.BitString, true);
        Q = utils.ecNormalize(Q);
      }
      if (Q === void 0) {
        var pub = utils.publicFromPrivateECDSA(curveName, d);
        Q = pub.part.Q.data;
      }
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8ECDSAPublic(der) {
      var curveName = readECDSACurve(der);
      assert.string(curveName, "a known elliptic curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPublic(der) {
      if (der.peek() === 0)
        der.readByte();
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8X25519Public(der) {
      var A = utils.readBitString(der);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPrivate(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A;
      if (der.peek() === asn1.Ber.BitString) {
        A = utils.readBitString(der);
        A = utils.zeroPadToLength(A, 32);
      } else {
        A = utils.calculateED25519Public(k);
      }
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8X25519Private(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A = utils.calculateX25519Public(k);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function pkcs8ToBuffer(key) {
      var der = new asn1.BerWriter();
      writePkcs8(der, key);
      return der.buffer;
    }
    function writePkcs8(der, key) {
      der.startSequence();
      if (PrivateKey.isPrivateKey(key)) {
        var sillyInt = Buffer2.from([0]);
        der.writeBuffer(sillyInt, asn1.Ber.Integer);
      }
      der.startSequence();
      switch (key.type) {
        case "rsa":
          der.writeOID("1.2.840.113549.1.1.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8RSAPrivate(key, der);
          else
            writePkcs8RSAPublic(key, der);
          break;
        case "dsa":
          der.writeOID("1.2.840.10040.4.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8DSAPrivate(key, der);
          else
            writePkcs8DSAPublic(key, der);
          break;
        case "ecdsa":
          der.writeOID("1.2.840.10045.2.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8ECDSAPrivate(key, der);
          else
            writePkcs8ECDSAPublic(key, der);
          break;
        case "ed25519":
          der.writeOID("1.3.101.112");
          if (PrivateKey.isPrivateKey(key))
            throw new Error("Ed25519 private keys in pkcs8 format are not supported");
          writePkcs8EdDSAPublic(key, der);
          break;
        default:
          throw new Error("Unsupported key type: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs8RSAPrivate(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([0]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8RSAPublic(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.startSequence();
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8DSAPrivate(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writePkcs8DSAPublic(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writeECDSACurve(key, der) {
      var curve = algs.curves[key.curve];
      if (curve.pkcs8oid) {
        der.writeOID(curve.pkcs8oid);
      } else {
        der.startSequence();
        var version = Buffer2.from([1]);
        der.writeBuffer(version, asn1.Ber.Integer);
        der.startSequence();
        der.writeOID("1.2.840.10045.1.1");
        der.writeBuffer(curve.p, asn1.Ber.Integer);
        der.endSequence();
        der.startSequence();
        var a = curve.p;
        if (a[0] === 0)
          a = a.slice(1);
        der.writeBuffer(a, asn1.Ber.OctetString);
        der.writeBuffer(curve.b, asn1.Ber.OctetString);
        der.writeBuffer(curve.s, asn1.Ber.BitString);
        der.endSequence();
        der.writeBuffer(curve.G, asn1.Ber.OctetString);
        der.writeBuffer(curve.n, asn1.Ber.Integer);
        var h = curve.h;
        if (!h) {
          h = Buffer2.from([1]);
        }
        der.writeBuffer(h, asn1.Ber.Integer);
        der.endSequence();
      }
    }
    function writePkcs8ECDSAPublic(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs8ECDSAPrivate(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8EdDSAPublic(key, der) {
      der.endSequence();
      utils.writeBitString(der, key.part.A.data);
    }
  }
});

// node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/sshpk/lib/formats/pkcs1.js"(exports, module) {
    module.exports = {
      read,
      readPkcs1,
      write,
      writePkcs1
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var pkcs8 = require_pkcs8();
    var readECDSACurve = pkcs8.readECDSACurve;
    function read(buf, options) {
      return pem.read(buf, options, "pkcs1");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs1");
    }
    function readMPInt(der, nm) {
      assert.strictEqual(
        der.peek(),
        asn1.Ber.Integer,
        nm + " is not an Integer"
      );
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs1(alg, type3, der) {
      switch (alg) {
        case "RSA":
          if (type3 === "public")
            return readPkcs1RSAPublic(der);
          else if (type3 === "private")
            return readPkcs1RSAPrivate(der);
          throw new Error("Unknown key type: " + type3);
        case "DSA":
          if (type3 === "public")
            return readPkcs1DSAPublic(der);
          else if (type3 === "private")
            return readPkcs1DSAPrivate(der);
          throw new Error("Unknown key type: " + type3);
        case "EC":
        case "ECDSA":
          if (type3 === "private")
            return readPkcs1ECDSAPrivate(der);
          else if (type3 === "public")
            return readPkcs1ECDSAPublic(der);
          throw new Error("Unknown key type: " + type3);
        case "EDDSA":
        case "EdDSA":
          if (type3 === "private")
            return readPkcs1EdDSAPrivate(der);
          throw new Error(type3 + " keys not supported with EdDSA");
        default:
          throw new Error("Unknown key algo: " + alg);
      }
    }
    function readPkcs1RSAPublic(der) {
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs1RSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version[0], 0);
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 0);
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var y = readMPInt(der, "y");
      var x = readMPInt(der, "x");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1EdDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 1);
      var k = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var oid = der.readOID();
      assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
      der.readSequence(161);
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: k }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPublic(der) {
      var y = readMPInt(der, "y");
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var key = {
        type: "dsa",
        parts: [
          { name: "y", data: y },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPublic(der) {
      der.readSequence();
      var oid = der.readOID();
      assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
      var curveOid = der.readOID();
      var curve;
      var curves = Object.keys(algs.curves);
      for (var j = 0; j < curves.length; ++j) {
        var c = curves[j];
        var cd = algs.curves[c];
        if (cd.pkcs8oid === curveOid) {
          curve = c;
          break;
        }
      }
      assert.string(curve, "a known ECDSA named curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 1);
      var d = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var curve = readECDSACurve(der);
      assert.string(curve, "a known elliptic curve");
      der.readSequence(161);
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function writePkcs1(der, key) {
      der.startSequence();
      switch (key.type) {
        case "rsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1RSAPrivate(der, key);
          else
            writePkcs1RSAPublic(der, key);
          break;
        case "dsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1DSAPrivate(der, key);
          else
            writePkcs1DSAPublic(der, key);
          break;
        case "ecdsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1ECDSAPrivate(der, key);
          else
            writePkcs1ECDSAPublic(der, key);
          break;
        case "ed25519":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1EdDSAPrivate(der, key);
          else
            writePkcs1EdDSAPublic(der, key);
          break;
        default:
          throw new Error("Unknown key algo: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs1RSAPublic(der, key) {
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    }
    function writePkcs1RSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPublic(der, key) {
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    }
    function writePkcs1ECDSAPublic(der, key) {
      der.startSequence();
      der.writeOID("1.2.840.10045.2.1");
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs1ECDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(160);
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
    }
    function writePkcs1EdDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
      der.startSequence(160);
      der.writeOID("1.3.101.112");
      der.endSequence();
      der.startSequence(161);
      utils.writeBitString(der, key.part.A.data);
      der.endSequence();
    }
    function writePkcs1EdDSAPublic(der, key) {
      throw new Error("Public keys are not supported for EdDSA PKCS#1");
    }
  }
});

// node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS({
  "node_modules/sshpk/lib/formats/rfc4253.js"(exports, module) {
    module.exports = {
      read: read.bind(void 0, false, void 0),
      readType: read.bind(void 0, false),
      write,
      /* semi-private api, used by sshpk-agent */
      readPartial: read.bind(void 0, true),
      /* shared with ssh format */
      readInternal: read,
      keyTypeToAlg,
      algToKeyType
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var SSHBuffer = require_ssh_buffer();
    function algToKeyType(alg) {
      assert.string(alg);
      if (alg === "ssh-dss")
        return "dsa";
      else if (alg === "ssh-rsa")
        return "rsa";
      else if (alg === "ssh-ed25519")
        return "ed25519";
      else if (alg === "ssh-curve25519")
        return "curve25519";
      else if (alg.match(/^ecdsa-sha2-/))
        return "ecdsa";
      else
        throw new Error("Unknown algorithm " + alg);
    }
    function keyTypeToAlg(key) {
      assert.object(key);
      if (key.type === "dsa")
        return "ssh-dss";
      else if (key.type === "rsa")
        return "ssh-rsa";
      else if (key.type === "ed25519")
        return "ssh-ed25519";
      else if (key.type === "curve25519")
        return "ssh-curve25519";
      else if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.part.curve.data.toString();
      else
        throw new Error("Unknown key type " + key.type);
    }
    function read(partial2, type3, buf, options) {
      if (typeof buf === "string")
        buf = Buffer2.from(buf);
      assert.buffer(buf, "buf");
      var key = {};
      var parts = key.parts = [];
      var sshbuf = new SSHBuffer({ buffer: buf });
      var alg = sshbuf.readString();
      assert.ok(!sshbuf.atEnd(), "key must have at least one part");
      key.type = algToKeyType(alg);
      var partCount = algs.info[key.type].parts.length;
      if (type3 && type3 === "private")
        partCount = algs.privInfo[key.type].parts.length;
      while (!sshbuf.atEnd() && parts.length < partCount)
        parts.push(sshbuf.readPart());
      while (!partial2 && !sshbuf.atEnd())
        parts.push(sshbuf.readPart());
      assert.ok(
        parts.length >= 1,
        "key must have at least one part"
      );
      assert.ok(
        partial2 || sshbuf.atEnd(),
        "leftover bytes at end of key"
      );
      var Constructor = Key;
      var algInfo = algs.info[key.type];
      if (type3 === "private" || algInfo.parts.length !== parts.length) {
        algInfo = algs.privInfo[key.type];
        Constructor = PrivateKey;
      }
      assert.strictEqual(algInfo.parts.length, parts.length);
      if (key.type === "ecdsa") {
        var res = /^ecdsa-sha2-(.+)$/.exec(alg);
        assert.ok(res !== null);
        assert.strictEqual(res[1], parts[0].data.toString());
      }
      var normalized = true;
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = parts[i];
        p.name = algInfo.parts[i];
        if (key.type === "ed25519" && p.name === "k")
          p.data = p.data.slice(0, 32);
        if (p.name !== "curve" && algInfo.normalize !== false) {
          var nd;
          if (key.type === "ed25519") {
            nd = utils.zeroPadToLength(p.data, 32);
          } else {
            nd = utils.mpNormalize(p.data);
          }
          if (nd.toString("binary") !== p.data.toString("binary")) {
            p.data = nd;
            normalized = false;
          }
        }
      }
      if (normalized)
        key._rfc4253Cache = sshbuf.toBuffer();
      if (partial2 && typeof partial2 === "object") {
        partial2.remainder = sshbuf.remainder();
        partial2.consumed = sshbuf._offset;
      }
      return new Constructor(key);
    }
    function write(key, options) {
      assert.object(key);
      var alg = keyTypeToAlg(key);
      var i;
      var algInfo = algs.info[key.type];
      if (PrivateKey.isPrivateKey(key))
        algInfo = algs.privInfo[key.type];
      var parts = algInfo.parts;
      var buf = new SSHBuffer({});
      buf.writeString(alg);
      for (i = 0; i < parts.length; ++i) {
        var data3 = key.part[parts[i]].data;
        if (algInfo.normalize !== false) {
          if (key.type === "ed25519")
            data3 = utils.zeroPadToLength(data3, 32);
          else
            data3 = utils.mpNormalize(data3);
        }
        if (key.type === "ed25519" && parts[i] === "k")
          data3 = Buffer2.concat([data3, key.part.A.data]);
        buf.writeBuffer(data3);
      }
      return buf.toBuffer();
    }
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports, module) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data3, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data3[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data3, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data3, databytes);
        d[1] ^= stream2word(data3, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data3, databytes);
          d[1] ^= stream2word(data3, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data3, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data3.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data3, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data3.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state.expand0state(sha2salt, 64);
        state.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS({
  "node_modules/sshpk/lib/formats/ssh-private.js"(exports, module) {
    module.exports = {
      read,
      readSSHPrivate,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var crypto = __require("crypto");
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var rfc4253 = require_rfc4253();
    var SSHBuffer = require_ssh_buffer();
    var errors = require_errors2();
    var bcrypt;
    function read(buf, options) {
      return pem.read(buf, options);
    }
    var MAGIC = "openssh-key-v1";
    function readSSHPrivate(type3, buf, options) {
      buf = new SSHBuffer({ buffer: buf });
      var magic = buf.readCString();
      assert.strictEqual(magic, MAGIC, "bad magic string");
      var cipher = buf.readString();
      var kdf = buf.readString();
      var kdfOpts = buf.readBuffer();
      var nkeys = buf.readInt();
      if (nkeys !== 1) {
        throw new Error("OpenSSH-format key file contains multiple keys: this is unsupported.");
      }
      var pubKey = buf.readBuffer();
      if (type3 === "public") {
        assert.ok(buf.atEnd(), "excess bytes left after key");
        return rfc4253.read(pubKey);
      }
      var privKeyBlob = buf.readBuffer();
      assert.ok(buf.atEnd(), "excess bytes left after key");
      var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
      switch (kdf) {
        case "none":
          if (cipher !== "none") {
            throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');
          }
          break;
        case "bcrypt":
          var salt = kdfOptsBuf.readBuffer();
          var rounds = kdfOptsBuf.readInt();
          var cinf = utils.opensshCipherInfo(cipher);
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(
              options.passphrase,
              "utf-8"
            );
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(
              options.filename,
              "OpenSSH"
            );
          }
          var pass = new Uint8Array(options.passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(
            pass,
            pass.length,
            salti,
            salti.length,
            out,
            out.length,
            rounds
          );
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createDecipheriv(
            cinf.opensslName,
            ckey,
            iv
          );
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            if (e.toString().indexOf("bad decrypt") !== -1) {
              throw new Error("Incorrect passphrase supplied, could not decrypt key");
            }
            throw e;
          });
          cipherStream.write(privKeyBlob);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privKeyBlob = Buffer2.concat(chunks);
          break;
        default:
          throw new Error(
            'OpenSSH-format key uses unknown KDF "' + kdf + '"'
          );
      }
      buf = new SSHBuffer({ buffer: privKeyBlob });
      var checkInt1 = buf.readInt();
      var checkInt2 = buf.readInt();
      if (checkInt1 !== checkInt2) {
        throw new Error("Incorrect passphrase supplied, could not decrypt key");
      }
      var ret = {};
      var key = rfc4253.readInternal(ret, "private", buf.remainder());
      buf.skip(ret.consumed);
      var comment = buf.readString();
      key.comment = comment;
      return key;
    }
    function write(key, options) {
      var pubKey;
      if (PrivateKey.isPrivateKey(key))
        pubKey = key.toPublic();
      else
        pubKey = key;
      var cipher = "none";
      var kdf = "none";
      var kdfopts = Buffer2.alloc(0);
      var cinf = { blockSize: 8 };
      var passphrase;
      if (options !== void 0) {
        passphrase = options.passphrase;
        if (typeof passphrase === "string")
          passphrase = Buffer2.from(passphrase, "utf-8");
        if (passphrase !== void 0) {
          assert.buffer(passphrase, "options.passphrase");
          assert.optionalString(options.cipher, "options.cipher");
          cipher = options.cipher;
          if (cipher === void 0)
            cipher = "aes128-ctr";
          cinf = utils.opensshCipherInfo(cipher);
          kdf = "bcrypt";
        }
      }
      var privBuf;
      if (PrivateKey.isPrivateKey(key)) {
        privBuf = new SSHBuffer({});
        var checkInt = crypto.randomBytes(4).readUInt32BE(0);
        privBuf.writeInt(checkInt);
        privBuf.writeInt(checkInt);
        privBuf.write(key.toBuffer("rfc4253"));
        privBuf.writeString(key.comment || "");
        var n = 1;
        while (privBuf._offset % cinf.blockSize !== 0)
          privBuf.writeChar(n++);
        privBuf = privBuf.toBuffer();
      }
      switch (kdf) {
        case "none":
          break;
        case "bcrypt":
          var salt = crypto.randomBytes(16);
          var rounds = 16;
          var kdfssh = new SSHBuffer({});
          kdfssh.writeBuffer(salt);
          kdfssh.writeInt(rounds);
          kdfopts = kdfssh.toBuffer();
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          var pass = new Uint8Array(passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(
            pass,
            pass.length,
            salti,
            salti.length,
            out,
            out.length,
            rounds
          );
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createCipheriv(
            cinf.opensslName,
            ckey,
            iv
          );
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            throw e;
          });
          cipherStream.write(privBuf);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privBuf = Buffer2.concat(chunks);
          break;
        default:
          throw new Error("Unsupported kdf " + kdf);
      }
      var buf = new SSHBuffer({});
      buf.writeCString(MAGIC);
      buf.writeString(cipher);
      buf.writeString(kdf);
      buf.writeBuffer(kdfopts);
      buf.writeInt(1);
      buf.writeBuffer(pubKey.toBuffer("rfc4253"));
      if (privBuf)
        buf.writeBuffer(privBuf);
      buf = buf.toBuffer();
      var header;
      if (PrivateKey.isPrivateKey(key))
        header = "OPENSSH PRIVATE KEY";
      else
        header = "OPENSSH PUBLIC KEY";
      var tmp = buf.toString("base64");
      var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
      buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 70;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS({
  "node_modules/sshpk/lib/formats/pem.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var crypto = __require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pkcs1 = require_pkcs1();
    var pkcs8 = require_pkcs8();
    var sshpriv = require_ssh_private();
    var rfc4253 = require_rfc4253();
    var errors = require_errors2();
    var OID_PBES2 = "1.2.840.113549.1.5.13";
    var OID_PBKDF2 = "1.2.840.113549.1.5.12";
    var OID_TO_CIPHER = {
      "1.2.840.113549.3.7": "3des-cbc",
      "2.16.840.1.101.3.4.1.2": "aes128-cbc",
      "2.16.840.1.101.3.4.1.42": "aes256-cbc"
    };
    var CIPHER_TO_OID = {};
    Object.keys(OID_TO_CIPHER).forEach(function(k) {
      CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
    });
    var OID_TO_HASH = {
      "1.2.840.113549.2.7": "sha1",
      "1.2.840.113549.2.9": "sha256",
      "1.2.840.113549.2.11": "sha512"
    };
    var HASH_TO_OID = {};
    Object.keys(OID_TO_HASH).forEach(function(k) {
      HASH_TO_OID[OID_TO_HASH[k]] = k;
    });
    function read(buf, options, forceType) {
      var input = buf;
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(
          /*JSSTYLED*/
          /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/
        );
      }
      assert.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(
          /*JSSTYLED*/
          /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/
        );
      }
      assert.ok(m2, "invalid PEM footer");
      assert.equal(m[2], m2[2]);
      var type3 = m[2].toLowerCase();
      var alg;
      if (m[1]) {
        assert.equal(m[1], m2[1], "PEM header and footer mismatch");
        alg = m[1].trim();
      }
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(
          /*JSSTYLED*/
          /^([A-Za-z0-9-]+): (.+)$/
        );
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      var cipher, key, iv;
      if (headers["proc-type"]) {
        var parts = headers["proc-type"].split(",");
        if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(
              options.passphrase,
              "utf-8"
            );
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(
              options.filename,
              "PEM"
            );
          } else {
            parts = headers["dek-info"].split(",");
            assert.ok(parts.length === 2);
            cipher = parts[0].toLowerCase();
            iv = Buffer2.from(parts[1], "hex");
            key = utils.opensslKeyDeriv(
              cipher,
              iv,
              options.passphrase,
              1
            ).key;
          }
        }
      }
      if (alg && alg.toLowerCase() === "encrypted") {
        var eder = new asn1.BerReader(buf);
        var pbesEnd;
        eder.readSequence();
        eder.readSequence();
        pbesEnd = eder.offset + eder.length;
        var method = eder.readOID();
        if (method !== OID_PBES2) {
          throw new Error("Unsupported PEM/PKCS8 encryption scheme: " + method);
        }
        eder.readSequence();
        eder.readSequence();
        var kdfEnd = eder.offset + eder.length;
        var kdfOid = eder.readOID();
        if (kdfOid !== OID_PBKDF2)
          throw new Error("Unsupported PBES2 KDF: " + kdfOid);
        eder.readSequence();
        var salt = eder.readString(asn1.Ber.OctetString, true);
        var iterations = eder.readInt();
        var hashAlg = "sha1";
        if (eder.offset < kdfEnd) {
          eder.readSequence();
          var hashAlgOid = eder.readOID();
          hashAlg = OID_TO_HASH[hashAlgOid];
          if (hashAlg === void 0) {
            throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
          }
        }
        eder._offset = kdfEnd;
        eder.readSequence();
        var cipherOid = eder.readOID();
        cipher = OID_TO_CIPHER[cipherOid];
        if (cipher === void 0) {
          throw new Error("Unsupported PBES2 cipher: " + cipherOid);
        }
        iv = eder.readString(asn1.Ber.OctetString, true);
        eder._offset = pbesEnd;
        buf = eder.readString(asn1.Ber.OctetString, true);
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(
            options.passphrase,
            "utf-8"
          );
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(
            options.filename,
            "PEM"
          );
        }
        var cinfo = utils.opensshCipherInfo(cipher);
        cipher = cinfo.opensslName;
        key = utils.pbkdf2(
          hashAlg,
          salt,
          iterations,
          cinfo.keySize,
          options.passphrase
        );
        alg = void 0;
      }
      if (cipher && key && iv) {
        var cipherStream = crypto.createDecipheriv(cipher, key, iv);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(buf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        buf = Buffer2.concat(chunks);
      }
      if (alg && alg.toLowerCase() === "openssh")
        return sshpriv.readSSHPrivate(type3, buf, options);
      if (alg && alg.toLowerCase() === "ssh2")
        return rfc4253.readType(type3, buf, options);
      var der = new asn1.BerReader(buf);
      der.originalInput = input;
      der.readSequence();
      if (alg) {
        if (forceType)
          assert.strictEqual(forceType, "pkcs1");
        return pkcs1.readPkcs1(alg, type3, der);
      } else {
        if (forceType)
          assert.strictEqual(forceType, "pkcs8");
        return pkcs8.readPkcs8(alg, type3, der);
      }
    }
    function write(key, options, type3) {
      assert.object(key);
      var alg = {
        "ecdsa": "EC",
        "rsa": "RSA",
        "dsa": "DSA",
        "ed25519": "EdDSA"
      }[key.type];
      var header;
      var der = new asn1.BerWriter();
      if (PrivateKey.isPrivateKey(key)) {
        if (type3 && type3 === "pkcs8") {
          header = "PRIVATE KEY";
          pkcs8.writePkcs8(der, key);
        } else {
          if (type3)
            assert.strictEqual(type3, "pkcs1");
          header = alg + " PRIVATE KEY";
          pkcs1.writePkcs1(der, key);
        }
      } else if (Key.isKey(key)) {
        if (type3 && type3 === "pkcs1") {
          header = alg + " PUBLIC KEY";
          pkcs1.writePkcs1(der, key);
        } else {
          if (type3)
            assert.strictEqual(type3, "pkcs8");
          header = "PUBLIC KEY";
          pkcs8.writePkcs8(der, key);
        }
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
      var tmp = der.buffer.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS({
  "node_modules/sshpk/lib/formats/ssh.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var sshpriv = require_ssh_private();
    var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
    var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var trimmed = buf.trim().replace(/[\\\r]/g, "");
      var m = trimmed.match(SSHKEY_RE);
      if (!m)
        m = trimmed.match(SSHKEY_RE2);
      assert.ok(m, "key must match regex");
      var type3 = rfc4253.algToKeyType(m[1]);
      var kbuf = Buffer2.from(m[2], "base64");
      var key;
      var ret = {};
      if (m[4]) {
        try {
          key = rfc4253.read(kbuf);
        } catch (e) {
          m = trimmed.match(SSHKEY_RE2);
          assert.ok(m, "key must match regex");
          kbuf = Buffer2.from(m[2], "base64");
          key = rfc4253.readInternal(ret, "public", kbuf);
        }
      } else {
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
      assert.strictEqual(type3, key.type);
      if (m[4] && m[4].length > 0) {
        key.comment = m[4];
      } else if (ret.consumed) {
        var data3 = m[2] + (m[3] ? m[3] : "");
        var realOffset = Math.ceil(ret.consumed / 3) * 4;
        data3 = data3.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data3.slice(realOffset - 2);
        var padding = ret.consumed % 3;
        if (padding > 0 && data3.slice(realOffset - 1, realOffset) !== "=")
          realOffset--;
        while (data3.slice(realOffset, realOffset + 1) === "=")
          realOffset++;
        var trailer = data3.slice(realOffset);
        trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
        if (trailer.match(/^[a-zA-Z0-9]/))
          key.comment = trailer;
      }
      return key;
    }
    function write(key, options) {
      assert.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var parts = [];
      var alg = rfc4253.keyTypeToAlg(key);
      parts.push(alg);
      var buf = rfc4253.write(key);
      parts.push(buf.toString("base64"));
      if (key.comment)
        parts.push(key.comment);
      return Buffer2.from(parts.join(" "));
    }
  }
});

// node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS({
  "node_modules/sshpk/lib/formats/dnssec.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Key = require_key();
    var PrivateKey = require_private_key();
    var utils = require_utils();
    var SSHBuffer = require_ssh_buffer();
    var Dhe = require_dhe();
    var supportedAlgos = {
      "rsa-sha1": 5,
      "rsa-sha256": 8,
      "rsa-sha512": 10,
      "ecdsa-p256-sha256": 13,
      "ecdsa-p384-sha384": 14
      /*
       * ed25519 is hypothetically supported with id 15
       * but the common tools available don't appear to be
       * capable of generating/using ed25519 keys
       */
    };
    var supportedAlgosById = {};
    Object.keys(supportedAlgos).forEach(function(k) {
      supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
    });
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      if (lines[0].match(/^Private-key-format\: v1/)) {
        var algElems = lines[1].split(" ");
        var algoNum = parseInt(algElems[1], 10);
        var algoName = algElems[2];
        if (!supportedAlgosById[algoNum])
          throw new Error("Unsupported algorithm: " + algoName);
        return readDNSSECPrivateKey(algoNum, lines.slice(2));
      }
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
        return readRFC3110(lines[line]);
      }
      throw new Error("Cannot parse dnssec key");
    }
    function readRFC3110(keyString) {
      var elems = keyString.split(" ");
      var algorithm = parseInt(elems[5], 10);
      if (!supportedAlgosById[algorithm])
        throw new Error("Unsupported algorithm: " + algorithm);
      var base64key = elems.slice(6, elems.length).join();
      var keyBuffer = Buffer2.from(base64key, "base64");
      if (supportedAlgosById[algorithm].match(/^RSA-/)) {
        var publicExponentLen = keyBuffer.readUInt8(0);
        if (publicExponentLen != 3 && publicExponentLen != 1)
          throw new Error("Cannot parse dnssec key: unsupported exponent length");
        var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
        publicExponent = utils.mpNormalize(publicExponent);
        var modulus = keyBuffer.slice(1 + publicExponentLen);
        modulus = utils.mpNormalize(modulus);
        var rsaKey = {
          type: "rsa",
          parts: []
        };
        rsaKey.parts.push({ name: "e", data: publicExponent });
        rsaKey.parts.push({ name: "n", data: modulus });
        return new Key(rsaKey);
      }
      if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
          curve = "nistp256";
          size = 256;
        }
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "Q", data: utils.ecNormalize(keyBuffer) }
          ]
        };
        return new Key(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
    }
    function elementToBuf(e) {
      return Buffer2.from(e.split(" ")[1], "base64");
    }
    function readDNSSECRSAPrivateKey(elements) {
      var rsaParams = {};
      elements.forEach(function(element) {
        if (element.split(" ")[0] === "Modulus:")
          rsaParams["n"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PublicExponent:")
          rsaParams["e"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PrivateExponent:")
          rsaParams["d"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime1:")
          rsaParams["p"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime2:")
          rsaParams["q"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent1:")
          rsaParams["dmodp"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent2:")
          rsaParams["dmodq"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Coefficient:")
          rsaParams["iqmp"] = elementToBuf(element);
      });
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: utils.mpNormalize(rsaParams["e"]) },
          { name: "n", data: utils.mpNormalize(rsaParams["n"]) },
          { name: "d", data: utils.mpNormalize(rsaParams["d"]) },
          { name: "p", data: utils.mpNormalize(rsaParams["p"]) },
          { name: "q", data: utils.mpNormalize(rsaParams["q"]) },
          {
            name: "dmodp",
            data: utils.mpNormalize(rsaParams["dmodp"])
          },
          {
            name: "dmodq",
            data: utils.mpNormalize(rsaParams["dmodq"])
          },
          {
            name: "iqmp",
            data: utils.mpNormalize(rsaParams["iqmp"])
          }
        ]
      };
      return new PrivateKey(key);
    }
    function readDNSSECPrivateKey(alg, elements) {
      if (supportedAlgosById[alg].match(/^RSA-/)) {
        return readDNSSECRSAPrivateKey(elements);
      }
      if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        var d = Buffer2.from(elements[0].split(" ")[1], "base64");
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
          curve = "nistp256";
          size = 256;
        }
        var publicKey = utils.publicFromPrivateECDSA(curve, d);
        var Q = publicKey.part["Q"].data;
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "d", data: d },
            { name: "Q", data: Q }
          ]
        };
        return new PrivateKey(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
    }
    function dnssecTimestamp(date) {
      var year = date.getFullYear() + "";
      var month = date.getMonth() + 1;
      var timestampStr = year + month + date.getUTCDate();
      timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
      timestampStr += date.getUTCSeconds();
      return timestampStr;
    }
    function rsaAlgFromOptions(opts) {
      if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
        return "5 (RSASHA1)";
      else if (opts.hashAlgo === "sha256")
        return "8 (RSASHA256)";
      else if (opts.hashAlgo === "sha512")
        return "10 (RSASHA512)";
      else
        throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
    }
    function writeRSA(key, options) {
      if (!key.part.dmodp || !key.part.dmodq) {
        utils.addRSAMissing(key);
      }
      var out = "";
      out += "Private-key-format: v1.3\n";
      out += "Algorithm: " + rsaAlgFromOptions(options) + "\n";
      var n = utils.mpDenormalize(key.part["n"].data);
      out += "Modulus: " + n.toString("base64") + "\n";
      var e = utils.mpDenormalize(key.part["e"].data);
      out += "PublicExponent: " + e.toString("base64") + "\n";
      var d = utils.mpDenormalize(key.part["d"].data);
      out += "PrivateExponent: " + d.toString("base64") + "\n";
      var p = utils.mpDenormalize(key.part["p"].data);
      out += "Prime1: " + p.toString("base64") + "\n";
      var q2 = utils.mpDenormalize(key.part["q"].data);
      out += "Prime2: " + q2.toString("base64") + "\n";
      var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
      out += "Exponent1: " + dmodp.toString("base64") + "\n";
      var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
      out += "Exponent2: " + dmodq.toString("base64") + "\n";
      var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
      out += "Coefficient: " + iqmp.toString("base64") + "\n";
      var timestamp = /* @__PURE__ */ new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function writeECDSA(key, options) {
      var out = "";
      out += "Private-key-format: v1.3\n";
      if (key.curve === "nistp256") {
        out += "Algorithm: 13 (ECDSAP256SHA256)\n";
      } else if (key.curve === "nistp384") {
        out += "Algorithm: 14 (ECDSAP384SHA384)\n";
      } else {
        throw new Error("Unsupported curve");
      }
      var base64Key = key.part["d"].data.toString("base64");
      out += "PrivateKey: " + base64Key + "\n";
      var timestamp = /* @__PURE__ */ new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function write(key, options) {
      if (PrivateKey.isPrivateKey(key)) {
        if (key.type === "rsa") {
          return writeRSA(key, options);
        } else if (key.type === "ecdsa") {
          return writeECDSA(key, options);
        } else {
          throw new Error("Unsupported algorithm: " + key.type);
        }
      } else if (Key.isKey(key)) {
        throw new Error('Format "dnssec" only supports writing private keys');
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
    }
  }
});

// node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS({
  "node_modules/sshpk/lib/formats/putty.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var Key = require_key();
    var SSHBuffer = require_ssh_buffer();
    var crypto = __require("crypto");
    var PrivateKey = require_private_key();
    var errors = require_errors2();
    function read(buf, options) {
      var lines = buf.toString("ascii").split(/[\r\n]+/);
      var found = false;
      var parts;
      var si = 0;
      var formatVersion;
      while (si < lines.length) {
        parts = splitHeader(lines[si++]);
        if (parts) {
          formatVersion = {
            "putty-user-key-file-2": 2,
            "putty-user-key-file-3": 3
          }[parts[0].toLowerCase()];
          if (formatVersion) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        throw new Error("No PuTTY format first line found");
      }
      var alg = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "encryption");
      var encryption = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "comment");
      var comment = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "public-lines");
      var publicLines = parseInt(parts[1], 10);
      if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
        throw new Error("Invalid public-lines count");
      }
      var publicBuf = Buffer2.from(
        lines.slice(si, si + publicLines).join(""),
        "base64"
      );
      var keyType = rfc4253.algToKeyType(alg);
      var key = rfc4253.read(publicBuf);
      if (key.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      si += publicLines;
      if (lines[si]) {
        parts = splitHeader(lines[si++]);
        assert.equal(parts[0].toLowerCase(), "private-lines");
        var privateLines = parseInt(parts[1], 10);
        if (!isFinite(privateLines) || privateLines < 0 || privateLines > lines.length) {
          throw new Error("Invalid private-lines count");
        }
        var privateBuf = Buffer2.from(
          lines.slice(si, si + privateLines).join(""),
          "base64"
        );
        if (encryption !== "none" && formatVersion === 3) {
          throw new Error("Encrypted keys arenot supported for PuTTY format version 3");
        }
        if (encryption === "aes256-cbc") {
          if (!options.passphrase) {
            throw new errors.KeyEncryptedError(
              options.filename,
              "PEM"
            );
          }
          var iv = Buffer2.alloc(16, 0);
          var decipher = crypto.createDecipheriv(
            "aes-256-cbc",
            derivePPK2EncryptionKey(options.passphrase),
            iv
          );
          decipher.setAutoPadding(false);
          privateBuf = Buffer2.concat([
            decipher.update(privateBuf),
            decipher.final()
          ]);
        }
        key = new PrivateKey(key);
        if (key.type !== keyType) {
          throw new Error("Outer key algorithm mismatch");
        }
        var sshbuf = new SSHBuffer({ buffer: privateBuf });
        var privateKeyParts;
        if (alg === "ssh-dss") {
          privateKeyParts = [{
            name: "x",
            data: sshbuf.readBuffer()
          }];
        } else if (alg === "ssh-rsa") {
          privateKeyParts = [
            { name: "d", data: sshbuf.readBuffer() },
            { name: "p", data: sshbuf.readBuffer() },
            { name: "q", data: sshbuf.readBuffer() },
            { name: "iqmp", data: sshbuf.readBuffer() }
          ];
        } else if (alg.match(/^ecdsa-sha2-nistp/)) {
          privateKeyParts = [{
            name: "d",
            data: sshbuf.readBuffer()
          }];
        } else if (alg === "ssh-ed25519") {
          privateKeyParts = [{
            name: "k",
            data: sshbuf.readBuffer()
          }];
        } else {
          throw new Error("Unsupported PPK key type: " + alg);
        }
        key = new PrivateKey({
          type: key.type,
          parts: key.parts.concat(privateKeyParts)
        });
      }
      key.comment = comment;
      return key;
    }
    function derivePPK2EncryptionKey(passphrase) {
      var hash1 = crypto.createHash("sha1").update(Buffer2.concat([
        Buffer2.from([0, 0, 0, 0]),
        Buffer2.from(passphrase)
      ])).digest();
      var hash2 = crypto.createHash("sha1").update(Buffer2.concat([
        Buffer2.from([0, 0, 0, 1]),
        Buffer2.from(passphrase)
      ])).digest();
      return Buffer2.concat([hash1, hash2]).slice(0, 32);
    }
    function splitHeader(line) {
      var idx = line.indexOf(":");
      if (idx === -1)
        return null;
      var header = line.slice(0, idx);
      ++idx;
      while (line[idx] === " ")
        ++idx;
      var rest = line.slice(idx);
      return [header, rest];
    }
    function write(key, options) {
      assert.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var alg = rfc4253.keyTypeToAlg(key);
      var buf = rfc4253.write(key);
      var comment = key.comment || "";
      var b64 = buf.toString("base64");
      var lines = wrap2(b64, 64);
      lines.unshift("Public-Lines: " + lines.length);
      lines.unshift("Comment: " + comment);
      lines.unshift("Encryption: none");
      lines.unshift("PuTTY-User-Key-File-2: " + alg);
      return Buffer2.from(lines.join("\n") + "\n");
    }
    function wrap2(txt, len) {
      var lines = [];
      var pos = 0;
      while (pos < txt.length) {
        lines.push(txt.slice(pos, pos + 64));
        pos += 64;
      }
      return lines;
    }
  }
});

// node_modules/sshpk/lib/formats/auto.js
var require_auto2 = __commonJS({
  "node_modules/sshpk/lib/formats/auto.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var ssh = require_ssh();
    var rfc4253 = require_rfc4253();
    var dnssec = require_dnssec();
    var putty = require_putty();
    var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
    function read(buf, options) {
      if (typeof buf === "string") {
        if (buf.trim().match(/^[-]+[ ]*BEGIN/))
          return pem.read(buf, options);
        if (buf.match(/^\s*ssh-[a-z]/))
          return ssh.read(buf, options);
        if (buf.match(/^\s*ecdsa-/))
          return ssh.read(buf, options);
        if (buf.match(/^putty-user-key-file-2:/i))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
        buf = Buffer2.from(buf, "binary");
      } else {
        assert.buffer(buf);
        if (findPEMHeader(buf))
          return pem.read(buf, options);
        if (findSSHHeader(buf))
          return ssh.read(buf, options);
        if (findPuTTYHeader(buf))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
      }
      if (buf.readUInt32BE(0) < buf.length)
        return rfc4253.read(buf, options);
      throw new Error("Failed to auto-detect format of key");
    }
    function findPuTTYHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
        return true;
      return false;
    }
    function findSSHHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
        return true;
      if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
        return true;
      return false;
    }
    function findPEMHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
        ++offset;
      if (buf[offset] !== 45)
        return false;
      while (offset < buf.length && buf[offset] === 45)
        ++offset;
      while (offset < buf.length && buf[offset] === 32)
        ++offset;
      if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
        return false;
      return true;
    }
    function findDNSSECHeader(buf) {
      if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
        return false;
      var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
      if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
        return true;
      if (typeof buf !== "string") {
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if (lines[line].toString("ascii").match(/\. IN KEY /))
        return true;
      if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
        return true;
      return false;
    }
    function write(key, options) {
      throw new Error('"auto" format cannot be used for writing');
    }
  }
});

// node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS({
  "node_modules/sshpk/lib/private-key.js"(exports, module) {
    module.exports = PrivateKey;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = __require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors2();
    var util = __require("util");
    var utils = require_utils();
    var dhe = require_dhe();
    var generateECDSA = dhe.generateECDSA;
    var generateED25519 = dhe.generateED25519;
    var edCompat = require_ed_compat();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var KeyEncryptedError = errs.KeyEncryptedError;
    var formats = {};
    formats["auto"] = require_auto2();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["ssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    formats["putty"] = require_putty();
    function PrivateKey(opts) {
      assert.object(opts, "options");
      Key.call(this, opts);
      this._pubCache = void 0;
    }
    util.inherits(PrivateKey, Key);
    PrivateKey.formats = formats;
    PrivateKey.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "pkcs1";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    PrivateKey.prototype.hash = function(algo, type3) {
      return this.toPublic().hash(algo, type3);
    };
    PrivateKey.prototype.fingerprint = function(algo, type3) {
      return this.toPublic().fingerprint(algo, type3);
    };
    PrivateKey.prototype.toPublic = function() {
      if (this._pubCache)
        return this._pubCache;
      var algInfo = algs.info[this.type];
      var pubParts = [];
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = algInfo.parts[i];
        pubParts.push(this.part[p]);
      }
      this._pubCache = new Key({
        type: this.type,
        source: this,
        parts: pubParts
      });
      if (this.comment)
        this._pubCache.comment = this.comment;
      return this._pubCache;
    };
    PrivateKey.prototype.derive = function(newType) {
      assert.string(newType, "type");
      var priv, pub, pair;
      if (this.type === "ed25519" && newType === "curve25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "curve25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      } else if (this.type === "curve25519" && newType === "ed25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "ed25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      }
      throw new Error("Key derivation not supported from " + this.type + " to " + newType);
    };
    PrivateKey.prototype.createVerify = function(hashAlgo) {
      return this.toPublic().createVerify(hashAlgo);
    };
    PrivateKey.prototype.createSign = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Signer(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      }
      assert.ok(v, "failed to create verifier");
      var oldSign = v.sign.bind(v);
      var key = this.toBuffer("pkcs1");
      var type3 = this.type;
      var curve = this.curve;
      v.sign = function() {
        var sig = oldSign(key);
        if (typeof sig === "string")
          sig = Buffer2.from(sig, "binary");
        sig = Signature.parse(sig, type3, "asn1");
        sig.hashAlgorithm = hashAlgo;
        sig.curve = curve;
        return sig;
      };
      return v;
    };
    PrivateKey.parse = function(data3, format, options) {
      if (typeof data3 !== "string")
        assert.buffer(data3, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data3, options);
        assert.ok(k instanceof PrivateKey, "key is not a private key");
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    PrivateKey.isPrivateKey = function(obj, ver) {
      return utils.isCompatible(obj, PrivateKey, ver);
    };
    PrivateKey.generate = function(type3, options) {
      if (options === void 0)
        options = {};
      assert.object(options, "options");
      switch (type3) {
        case "ecdsa":
          if (options.curve === void 0)
            options.curve = "nistp256";
          assert.string(options.curve, "options.curve");
          return generateECDSA(options.curve);
        case "ed25519":
          return generateED25519();
        default:
          throw new Error('Key generation not supported with key type "' + type3 + '"');
      }
    };
    PrivateKey.prototype._sshpkApiVersion = [1, 6];
    PrivateKey._oldVersionDetect = function(obj) {
      assert.func(obj.toPublic);
      assert.func(obj.createSign);
      if (obj.derive)
        return [1, 3];
      if (obj.defaultHashAlgorithm)
        return [1, 2];
      if (obj.formats["auto"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/identity.js
var require_identity = __commonJS({
  "node_modules/sshpk/lib/identity.js"(exports, module) {
    module.exports = Identity;
    var assert = require_assert();
    var algs = require_algs();
    var crypto = __require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors2();
    var util = __require("util");
    var utils = require_utils();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
    var oids = {};
    oids.cn = "2.5.4.3";
    oids.o = "2.5.4.10";
    oids.ou = "2.5.4.11";
    oids.l = "2.5.4.7";
    oids.s = "2.5.4.8";
    oids.c = "2.5.4.6";
    oids.sn = "2.5.4.4";
    oids.postalCode = "2.5.4.17";
    oids.serialNumber = "2.5.4.5";
    oids.street = "2.5.4.9";
    oids.x500UniqueIdentifier = "2.5.4.45";
    oids.role = "2.5.4.72";
    oids.telephoneNumber = "2.5.4.20";
    oids.description = "2.5.4.13";
    oids.dc = "0.9.2342.19200300.100.1.25";
    oids.uid = "0.9.2342.19200300.100.1.1";
    oids.mail = "0.9.2342.19200300.100.1.3";
    oids.title = "2.5.4.12";
    oids.gn = "2.5.4.42";
    oids.initials = "2.5.4.43";
    oids.pseudonym = "2.5.4.65";
    oids.emailAddress = "1.2.840.113549.1.9.1";
    var unoids = {};
    Object.keys(oids).forEach(function(k) {
      unoids[oids[k]] = k;
    });
    function Identity(opts) {
      var self2 = this;
      assert.object(opts, "options");
      assert.arrayOfObject(opts.components, "options.components");
      this.components = opts.components;
      this.componentLookup = {};
      this.components.forEach(function(c) {
        if (c.name && !c.oid)
          c.oid = oids[c.name];
        if (c.oid && !c.name)
          c.name = unoids[c.oid];
        if (self2.componentLookup[c.name] === void 0)
          self2.componentLookup[c.name] = [];
        self2.componentLookup[c.name].push(c);
      });
      if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
        this.cn = this.componentLookup.cn[0].value;
      }
      assert.optionalString(opts.type, "options.type");
      if (opts.type === void 0) {
        if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
          this.type = "host";
          this.hostname = this.componentLookup.dc.map(
            function(c) {
              return c.value;
            }
          ).join(".");
        } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
          this.type = "email";
          this.email = this.componentLookup.mail[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.cn[0].value;
        } else {
          this.type = "unknown";
        }
      } else {
        this.type = opts.type;
        if (this.type === "host")
          this.hostname = opts.hostname;
        else if (this.type === "user")
          this.uid = opts.uid;
        else if (this.type === "email")
          this.email = opts.email;
        else
          throw new Error("Unknown type " + this.type);
      }
    }
    Identity.prototype.toString = function() {
      return this.components.map(function(c) {
        var n = c.name.toUpperCase();
        n = n.replace(/=/g, "\\=");
        var v = c.value;
        v = v.replace(/,/g, "\\,");
        return n + "=" + v;
      }).join(", ");
    };
    Identity.prototype.get = function(name, asArray) {
      assert.string(name, "name");
      var arr = this.componentLookup[name];
      if (arr === void 0 || arr.length === 0)
        return void 0;
      if (!asArray && arr.length > 1)
        throw new Error("Multiple values for attribute " + name);
      if (!asArray)
        return arr[0].value;
      return arr.map(function(c) {
        return c.value;
      });
    };
    Identity.prototype.toArray = function(idx) {
      return this.components.map(function(c) {
        return {
          name: c.name,
          value: c.value
        };
      });
    };
    var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
    var NOT_IA5 = /[^\x00-\x7f]/;
    Identity.prototype.toAsn1 = function(der, tag) {
      der.startSequence(tag);
      this.components.forEach(function(c) {
        der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        der.startSequence();
        der.writeOID(c.oid);
        if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
          var v = Buffer2.from(c.value, "utf8");
          der.writeBuffer(v, asn1.Ber.Utf8String);
        } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
          der.writeString(c.value, asn1.Ber.IA5String);
        } else {
          var type3 = asn1.Ber.PrintableString;
          if (c.asn1type !== void 0)
            type3 = c.asn1type;
          der.writeString(c.value, type3);
        }
        der.endSequence();
        der.endSequence();
      });
      der.endSequence();
    };
    function globMatch(a, b) {
      if (a === "**" || b === "**")
        return true;
      var aParts = a.split(".");
      var bParts = b.split(".");
      if (aParts.length !== bParts.length)
        return false;
      for (var i = 0; i < aParts.length; ++i) {
        if (aParts[i] === "*" || bParts[i] === "*")
          continue;
        if (aParts[i] !== bParts[i])
          return false;
      }
      return true;
    }
    Identity.prototype.equals = function(other) {
      if (!Identity.isIdentity(other, [1, 0]))
        return false;
      if (other.components.length !== this.components.length)
        return false;
      for (var i = 0; i < this.components.length; ++i) {
        if (this.components[i].oid !== other.components[i].oid)
          return false;
        if (!globMatch(
          this.components[i].value,
          other.components[i].value
        )) {
          return false;
        }
      }
      return true;
    };
    Identity.forHost = function(hostname) {
      assert.string(hostname, "hostname");
      return new Identity({
        type: "host",
        hostname,
        components: [{ name: "cn", value: hostname }]
      });
    };
    Identity.forUser = function(uid) {
      assert.string(uid, "uid");
      return new Identity({
        type: "user",
        uid,
        components: [{ name: "uid", value: uid }]
      });
    };
    Identity.forEmail = function(email) {
      assert.string(email, "email");
      return new Identity({
        type: "email",
        email,
        components: [{ name: "mail", value: email }]
      });
    };
    Identity.parseDN = function(dn) {
      assert.string(dn, "dn");
      var parts = [""];
      var idx = 0;
      var rem = dn;
      while (rem.length > 0) {
        var m;
        if ((m = /^,/.exec(rem)) !== null) {
          parts[++idx] = "";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\,/.exec(rem)) !== null) {
          parts[idx] += ",";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\./.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else {
          throw new Error("Failed to parse DN");
        }
      }
      var cmps = parts.map(function(c) {
        c = c.trim();
        var eqPos = c.indexOf("=");
        while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
          eqPos = c.indexOf("=", eqPos + 1);
        if (eqPos === -1) {
          throw new Error("Failed to parse DN");
        }
        var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
        var value2 = c.slice(eqPos + 1);
        return { name, value: value2 };
      });
      return new Identity({ components: cmps });
    };
    Identity.fromArray = function(components) {
      assert.arrayOfObject(components, "components");
      components.forEach(function(cmp) {
        assert.object(cmp, "component");
        assert.string(cmp.name, "component.name");
        if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
          throw new Error("Invalid component value");
        }
      });
      return new Identity({ components });
    };
    Identity.parseAsn1 = function(der, top) {
      var components = [];
      der.readSequence(top);
      var end2 = der.offset + der.length;
      while (der.offset < end2) {
        der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        var after2 = der.offset + der.length;
        der.readSequence();
        var oid = der.readOID();
        var type3 = der.peek();
        var value2;
        switch (type3) {
          case asn1.Ber.PrintableString:
          case asn1.Ber.IA5String:
          case asn1.Ber.OctetString:
          case asn1.Ber.T61String:
            value2 = der.readString(type3);
            break;
          case asn1.Ber.Utf8String:
            value2 = der.readString(type3, true);
            value2 = value2.toString("utf8");
            break;
          case asn1.Ber.CharacterString:
          case asn1.Ber.BMPString:
            value2 = der.readString(type3, true);
            value2 = value2.toString("utf16le");
            break;
          default:
            throw new Error("Unknown asn1 type " + type3);
        }
        components.push({ oid, asn1type: type3, value: value2 });
        der._offset = after2;
      }
      der._offset = end2;
      return new Identity({
        components
      });
    };
    Identity.isIdentity = function(obj, ver) {
      return utils.isCompatible(obj, Identity, ver);
    };
    Identity.prototype._sshpkApiVersion = [1, 0];
    Identity._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS({
  "node_modules/sshpk/lib/formats/openssh-cert.js"(exports, module) {
    module.exports = {
      read,
      verify,
      sign,
      signAsync,
      write,
      /* Internal private API */
      fromBuffer,
      toBuffer
    };
    var assert = require_assert();
    var SSHBuffer = require_ssh_buffer();
    var crypto = __require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var rfc4253 = require_rfc4253();
    var Signature = require_signature();
    var utils = require_utils();
    var Certificate = require_certificate();
    function verify(cert, key) {
      return false;
    }
    var TYPES = {
      "user": 1,
      "host": 2
    };
    Object.keys(TYPES).forEach(function(k) {
      TYPES[TYPES[k]] = k;
    });
    var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
    function read(buf, options) {
      if (Buffer2.isBuffer(buf))
        buf = buf.toString("ascii");
      var parts = buf.trim().split(/[ \t\n]+/g);
      if (parts.length < 2 || parts.length > 3)
        throw new Error("Not a valid SSH certificate line");
      var algo = parts[0];
      var data3 = parts[1];
      data3 = Buffer2.from(data3, "base64");
      return fromBuffer(data3, algo);
    }
    function fromBuffer(data3, algo, partial2) {
      var sshbuf = new SSHBuffer({ buffer: data3 });
      var innerAlgo = sshbuf.readString();
      if (algo !== void 0 && innerAlgo !== algo)
        throw new Error("SSH certificate algorithm mismatch");
      if (algo === void 0)
        algo = innerAlgo;
      var cert = {};
      cert.signatures = {};
      cert.signatures.openssh = {};
      cert.signatures.openssh.nonce = sshbuf.readBuffer();
      var key = {};
      var parts = key.parts = [];
      key.type = getAlg(algo);
      var partCount = algs.info[key.type].parts.length;
      while (parts.length < partCount)
        parts.push(sshbuf.readPart());
      assert.ok(parts.length >= 1, "key must have at least one part");
      var algInfo = algs.info[key.type];
      if (key.type === "ecdsa") {
        var res = ECDSA_ALGO.exec(algo);
        assert.ok(res !== null);
        assert.strictEqual(res[1], parts[0].data.toString());
      }
      for (var i = 0; i < algInfo.parts.length; ++i) {
        parts[i].name = algInfo.parts[i];
        if (parts[i].name !== "curve" && algInfo.normalize !== false) {
          var p = parts[i];
          p.data = utils.mpNormalize(p.data);
        }
      }
      cert.subjectKey = new Key(key);
      cert.serial = sshbuf.readInt64();
      var type3 = TYPES[sshbuf.readInt()];
      assert.string(type3, "valid cert type");
      cert.signatures.openssh.keyId = sshbuf.readString();
      var principals = [];
      var pbuf = sshbuf.readBuffer();
      var psshbuf = new SSHBuffer({ buffer: pbuf });
      while (!psshbuf.atEnd())
        principals.push(psshbuf.readString());
      if (principals.length === 0)
        principals = ["*"];
      cert.subjects = principals.map(function(pr) {
        if (type3 === "user")
          return Identity.forUser(pr);
        else if (type3 === "host")
          return Identity.forHost(pr);
        throw new Error("Unknown identity type " + type3);
      });
      cert.validFrom = int64ToDate(sshbuf.readInt64());
      cert.validUntil = int64ToDate(sshbuf.readInt64());
      var exts = [];
      var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      var ext;
      while (!extbuf.atEnd()) {
        ext = { critical: true };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      while (!extbuf.atEnd()) {
        ext = { critical: false };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      cert.signatures.openssh.exts = exts;
      sshbuf.readBuffer();
      var signingKeyBuf = sshbuf.readBuffer();
      cert.issuerKey = rfc4253.read(signingKeyBuf);
      cert.issuer = Identity.forHost("**");
      var sigBuf = sshbuf.readBuffer();
      cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
      if (partial2 !== void 0) {
        partial2.remainder = sshbuf.remainder();
        partial2.consumed = sshbuf._offset;
      }
      return new Certificate(cert);
    }
    function int64ToDate(buf) {
      var i = buf.readUInt32BE(0) * 4294967296;
      i += buf.readUInt32BE(4);
      var d = /* @__PURE__ */ new Date();
      d.setTime(i * 1e3);
      d.sourceInt64 = buf;
      return d;
    }
    function dateToInt64(date) {
      if (date.sourceInt64 !== void 0)
        return date.sourceInt64;
      var i = Math.round(date.getTime() / 1e3);
      var upper = Math.floor(i / 4294967296);
      var lower = Math.floor(i % 4294967296);
      var buf = Buffer2.alloc(8);
      buf.writeUInt32BE(upper, 0);
      buf.writeUInt32BE(lower, 4);
      return buf;
    }
    function sign(cert, key) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        return false;
      }
      var sig = cert.signatures.openssh;
      var hashAlgo = void 0;
      if (key.type === "rsa" || key.type === "dsa")
        hashAlgo = "sha1";
      var signer = key.createSign(hashAlgo);
      signer.write(blob);
      sig.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        done(e);
        return;
      }
      var sig = cert.signatures.openssh;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        try {
          signature.toBuffer("ssh");
        } catch (e) {
          done(e);
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      if (options === void 0)
        options = {};
      var blob = toBuffer(cert);
      var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
      if (options.comment)
        out = out + " " + options.comment;
      return out;
    }
    function toBuffer(cert, noSig) {
      assert.object(cert.signatures.openssh, "signature for openssh format");
      var sig = cert.signatures.openssh;
      if (sig.nonce === void 0)
        sig.nonce = crypto.randomBytes(16);
      var buf = new SSHBuffer({});
      buf.writeString(getCertType(cert.subjectKey));
      buf.writeBuffer(sig.nonce);
      var key = cert.subjectKey;
      var algInfo = algs.info[key.type];
      algInfo.parts.forEach(function(part) {
        buf.writePart(key.part[part]);
      });
      buf.writeInt64(cert.serial);
      var type3 = cert.subjects[0].type;
      assert.notStrictEqual(type3, "unknown");
      cert.subjects.forEach(function(id) {
        assert.strictEqual(id.type, type3);
      });
      type3 = TYPES[type3];
      buf.writeInt(type3);
      if (sig.keyId === void 0) {
        sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
      }
      buf.writeString(sig.keyId);
      var sub = new SSHBuffer({});
      cert.subjects.forEach(function(id) {
        if (type3 === TYPES.host)
          sub.writeString(id.hostname);
        else if (type3 === TYPES.user)
          sub.writeString(id.uid);
      });
      buf.writeBuffer(sub.toBuffer());
      buf.writeInt64(dateToInt64(cert.validFrom));
      buf.writeInt64(dateToInt64(cert.validUntil));
      var exts = sig.exts;
      if (exts === void 0)
        exts = [];
      var extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical !== true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical === true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      buf.writeBuffer(Buffer2.alloc(0));
      sub = rfc4253.write(cert.issuerKey);
      buf.writeBuffer(sub);
      if (!noSig)
        buf.writeBuffer(sig.signature.toBuffer("ssh"));
      return buf.toBuffer();
    }
    function getAlg(certType) {
      if (certType === "ssh-rsa-cert-v01@openssh.com")
        return "rsa";
      if (certType === "ssh-dss-cert-v01@openssh.com")
        return "dsa";
      if (certType.match(ECDSA_ALGO))
        return "ecdsa";
      if (certType === "ssh-ed25519-cert-v01@openssh.com")
        return "ed25519";
      throw new Error("Unsupported cert type " + certType);
    }
    function getCertType(key) {
      if (key.type === "rsa")
        return "ssh-rsa-cert-v01@openssh.com";
      if (key.type === "dsa")
        return "ssh-dss-cert-v01@openssh.com";
      if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
      if (key.type === "ed25519")
        return "ssh-ed25519-cert-v01@openssh.com";
      throw new Error("Unsupported key type " + key.type);
    }
  }
});

// node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS({
  "node_modules/sshpk/lib/formats/x509.js"(exports, module) {
    module.exports = {
      read,
      verify,
      sign,
      signAsync,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    var pkcs8 = require_pkcs8();
    function readMPInt(der, nm) {
      assert.strictEqual(
        der.peek(),
        asn1.Ber.Integer,
        nm + " is not an Integer"
      );
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function verify(cert, key) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      var algParts = sig.algo.split("-");
      if (algParts[0] !== key.type)
        return false;
      var blob = sig.cache;
      if (blob === void 0) {
        var der = new asn1.BerWriter();
        writeTBSCert(cert, der);
        blob = der.buffer;
      }
      var verifier = key.createVerify(algParts[1]);
      verifier.write(blob);
      return verifier.verify(sig.signature);
    }
    function Local(i) {
      return asn1.Ber.Context | asn1.Ber.Constructor | i;
    }
    function Context(i) {
      return asn1.Ber.Context | i;
    }
    var SIGN_ALGS = {
      "rsa-md5": "1.2.840.113549.1.1.4",
      "rsa-sha1": "1.2.840.113549.1.1.5",
      "rsa-sha256": "1.2.840.113549.1.1.11",
      "rsa-sha384": "1.2.840.113549.1.1.12",
      "rsa-sha512": "1.2.840.113549.1.1.13",
      "dsa-sha1": "1.2.840.10040.4.3",
      "dsa-sha256": "2.16.840.1.101.3.4.3.2",
      "ecdsa-sha1": "1.2.840.10045.4.1",
      "ecdsa-sha256": "1.2.840.10045.4.3.2",
      "ecdsa-sha384": "1.2.840.10045.4.3.3",
      "ecdsa-sha512": "1.2.840.10045.4.3.4",
      "ed25519-sha512": "1.3.101.112"
    };
    Object.keys(SIGN_ALGS).forEach(function(k) {
      SIGN_ALGS[SIGN_ALGS[k]] = k;
    });
    SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
    SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
    var EXTS = {
      "issuerKeyId": "2.5.29.35",
      "altName": "2.5.29.17",
      "basicConstraints": "2.5.29.19",
      "keyUsage": "2.5.29.15",
      "extKeyUsage": "2.5.29.37"
    };
    function read(buf, options) {
      if (typeof buf === "string") {
        buf = Buffer2.from(buf, "binary");
      }
      assert.buffer(buf, "buf");
      var der = new asn1.BerReader(buf);
      der.readSequence();
      if (Math.abs(der.length - der.remain) > 1) {
        throw new Error("DER sequence does not contain whole byte stream");
      }
      var tbsStart = der.offset;
      der.readSequence();
      var sigOffset = der.offset + der.length;
      var tbsEnd = sigOffset;
      if (der.peek() === Local(0)) {
        der.readSequence(Local(0));
        var version = der.readInt();
        assert.ok(
          version <= 3,
          "only x.509 versions up to v3 supported"
        );
      }
      var cert = {};
      cert.signatures = {};
      var sig = cert.signatures.x509 = {};
      sig.extras = {};
      cert.serial = readMPInt(der, "serial");
      der.readSequence();
      var after2 = der.offset + der.length;
      var certAlgOid = der.readOID();
      var certAlg = SIGN_ALGS[certAlgOid];
      if (certAlg === void 0)
        throw new Error("unknown signature algorithm " + certAlgOid);
      der._offset = after2;
      cert.issuer = Identity.parseAsn1(der);
      der.readSequence();
      cert.validFrom = readDate(der);
      cert.validUntil = readDate(der);
      cert.subjects = [Identity.parseAsn1(der)];
      der.readSequence();
      after2 = der.offset + der.length;
      cert.subjectKey = pkcs8.readPkcs8(void 0, "public", der);
      der._offset = after2;
      if (der.peek() === Local(1)) {
        der.readSequence(Local(1));
        sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(2)) {
        der.readSequence(Local(2));
        sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(3)) {
        der.readSequence(Local(3));
        var extEnd = der.offset + der.length;
        der.readSequence();
        while (der.offset < extEnd)
          readExtension(cert, buf, der);
        assert.strictEqual(der.offset, extEnd);
      }
      assert.strictEqual(der.offset, sigOffset);
      der.readSequence();
      after2 = der.offset + der.length;
      var sigAlgOid = der.readOID();
      var sigAlg = SIGN_ALGS[sigAlgOid];
      if (sigAlg === void 0)
        throw new Error("unknown signature algorithm " + sigAlgOid);
      der._offset = after2;
      var sigData = der.readString(asn1.Ber.BitString, true);
      if (sigData[0] === 0)
        sigData = sigData.slice(1);
      var algParts = sigAlg.split("-");
      sig.signature = Signature.parse(sigData, algParts[0], "asn1");
      sig.signature.hashAlgorithm = algParts[1];
      sig.algo = sigAlg;
      sig.cache = buf.slice(tbsStart, tbsEnd);
      return new Certificate(cert);
    }
    function readDate(der) {
      if (der.peek() === asn1.Ber.UTCTime) {
        return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
      } else if (der.peek() === asn1.Ber.GeneralizedTime) {
        return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
      } else {
        throw new Error("Unsupported date format");
      }
    }
    function writeDate(der, date) {
      if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
        der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
      } else {
        der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
      }
    }
    var ALTNAME = {
      OtherName: Local(0),
      RFC822Name: Context(1),
      DNSName: Context(2),
      X400Address: Local(3),
      DirectoryName: Local(4),
      EDIPartyName: Local(5),
      URI: Context(6),
      IPAddress: Context(7),
      OID: Context(8)
    };
    var EXTPURPOSE = {
      "serverAuth": "1.3.6.1.5.5.7.3.1",
      "clientAuth": "1.3.6.1.5.5.7.3.2",
      "codeSigning": "1.3.6.1.5.5.7.3.3",
      /* See https://github.com/joyent/oid-docs/blob/master/root.md */
      "joyentDocker": "1.3.6.1.4.1.38678.1.4.1",
      "joyentCmon": "1.3.6.1.4.1.38678.1.4.2"
    };
    var EXTPURPOSE_REV = {};
    Object.keys(EXTPURPOSE).forEach(function(k) {
      EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
    });
    var KEYUSEBITS = [
      "signature",
      "identity",
      "keyEncryption",
      "encryption",
      "keyAgreement",
      "ca",
      "crl"
    ];
    function readExtension(cert, buf, der) {
      der.readSequence();
      var after2 = der.offset + der.length;
      var extId = der.readOID();
      var id;
      var sig = cert.signatures.x509;
      if (!sig.extras.exts)
        sig.extras.exts = [];
      var critical;
      if (der.peek() === asn1.Ber.Boolean)
        critical = der.readBoolean();
      switch (extId) {
        case EXTS.basicConstraints:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var bcEnd = der.offset + der.length;
          var ca = false;
          if (der.peek() === asn1.Ber.Boolean)
            ca = der.readBoolean();
          if (cert.purposes === void 0)
            cert.purposes = [];
          if (ca === true)
            cert.purposes.push("ca");
          var bc = { oid: extId, critical };
          if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
            bc.pathLen = der.readInt();
          sig.extras.exts.push(bc);
          break;
        case EXTS.extKeyUsage:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          if (cert.purposes === void 0)
            cert.purposes = [];
          var ekEnd = der.offset + der.length;
          while (der.offset < ekEnd) {
            var oid = der.readOID();
            cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
          }
          if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "host") {
                ide.type = "host";
                ide.hostname = ide.uid || ide.email || ide.components[0].value;
              }
            });
          } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "user") {
                ide.type = "user";
                ide.uid = ide.hostname || ide.email || ide.components[0].value;
              }
            });
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        case EXTS.keyUsage:
          der.readSequence(asn1.Ber.OctetString);
          var bits = der.readString(asn1.Ber.BitString, true);
          var setBits = readBitField(bits, KEYUSEBITS);
          setBits.forEach(function(bit) {
            if (cert.purposes === void 0)
              cert.purposes = [];
            if (cert.purposes.indexOf(bit) === -1)
              cert.purposes.push(bit);
          });
          sig.extras.exts.push({
            oid: extId,
            critical,
            bits
          });
          break;
        case EXTS.altName:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var aeEnd = der.offset + der.length;
          while (der.offset < aeEnd) {
            switch (der.peek()) {
              case ALTNAME.OtherName:
              case ALTNAME.EDIPartyName:
                der.readSequence();
                der._offset += der.length;
                break;
              case ALTNAME.OID:
                der.readOID(ALTNAME.OID);
                break;
              case ALTNAME.RFC822Name:
                var email = der.readString(ALTNAME.RFC822Name);
                id = Identity.forEmail(email);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DirectoryName:
                der.readSequence(ALTNAME.DirectoryName);
                id = Identity.parseAsn1(der);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DNSName:
                var host = der.readString(
                  ALTNAME.DNSName
                );
                id = Identity.forHost(host);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              default:
                der.readString(der.peek());
                break;
            }
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        default:
          sig.extras.exts.push({
            oid: extId,
            critical,
            data: der.readString(asn1.Ber.OctetString, true)
          });
          break;
      }
      der._offset = after2;
    }
    var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function utcTimeToDate(t) {
      var m = t.match(UTCTIME_RE);
      assert.ok(m, "timestamps must be in UTC");
      var d = /* @__PURE__ */ new Date();
      var thisYear = d.getUTCFullYear();
      var century = Math.floor(thisYear / 100) * 100;
      var year = parseInt(m[1], 10);
      if (thisYear % 100 < 50 && year >= 60)
        year += century - 1;
      else
        year += century;
      d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function gTimeToDate(t) {
      var m = t.match(GTIME_RE);
      assert.ok(m);
      var d = /* @__PURE__ */ new Date();
      d.setUTCFullYear(
        parseInt(m[1], 10),
        parseInt(m[2], 10) - 1,
        parseInt(m[3], 10)
      );
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    function zeroPad(n, m) {
      if (m === void 0)
        m = 2;
      var s = "" + n;
      while (s.length < m)
        s = "0" + s;
      return s;
    }
    function dateToUTCTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear() % 100);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function dateToGTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear(), 4);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function sign(cert, key) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      sig.algo = key.type + "-" + key.defaultHashAlgorithm();
      if (SIGN_ALGS[sig.algo] === void 0)
        return false;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      var signer = key.createSign();
      signer.write(blob);
      cert.signatures.x509.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        sig.algo = signature.type + "-" + signature.hashAlgorithm;
        if (SIGN_ALGS[sig.algo] === void 0) {
          done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      var der = new asn1.BerWriter();
      der.startSequence();
      if (sig.cache) {
        der._ensure(sig.cache.length);
        sig.cache.copy(der._buf, der._offset);
        der._offset += sig.cache.length;
      } else {
        writeTBSCert(cert, der);
      }
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      var sigData = sig.signature.toBuffer("asn1");
      var data3 = Buffer2.alloc(sigData.length + 1);
      data3[0] = 0;
      sigData.copy(data3, 1);
      der.writeBuffer(data3, asn1.Ber.BitString);
      der.endSequence();
      return der.buffer;
    }
    function writeTBSCert(cert, der) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      der.startSequence();
      der.startSequence(Local(0));
      der.writeInt(2);
      der.endSequence();
      der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      cert.issuer.toAsn1(der);
      der.startSequence();
      writeDate(der, cert.validFrom);
      writeDate(der, cert.validUntil);
      der.endSequence();
      var subject = cert.subjects[0];
      var altNames = cert.subjects.slice(1);
      subject.toAsn1(der);
      pkcs8.writePkcs8(der, cert.subjectKey);
      if (sig.extras && sig.extras.issuerUniqueID) {
        der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
      }
      if (sig.extras && sig.extras.subjectUniqueID) {
        der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
      }
      if (altNames.length > 0 || subject.type === "host" || cert.purposes !== void 0 && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
        der.startSequence(Local(3));
        der.startSequence();
        var exts = [];
        if (cert.purposes !== void 0 && cert.purposes.length > 0) {
          exts.push({
            oid: EXTS.basicConstraints,
            critical: true
          });
          exts.push({
            oid: EXTS.keyUsage,
            critical: true
          });
          exts.push({
            oid: EXTS.extKeyUsage,
            critical: true
          });
        }
        exts.push({ oid: EXTS.altName });
        if (sig.extras && sig.extras.exts)
          exts = sig.extras.exts;
        for (var i = 0; i < exts.length; ++i) {
          der.startSequence();
          der.writeOID(exts[i].oid);
          if (exts[i].critical !== void 0)
            der.writeBoolean(exts[i].critical);
          if (exts[i].oid === EXTS.altName) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            if (subject.type === "host") {
              der.writeString(
                subject.hostname,
                Context(2)
              );
            }
            for (var j = 0; j < altNames.length; ++j) {
              if (altNames[j].type === "host") {
                der.writeString(
                  altNames[j].hostname,
                  ALTNAME.DNSName
                );
              } else if (altNames[j].type === "email") {
                der.writeString(
                  altNames[j].email,
                  ALTNAME.RFC822Name
                );
              } else {
                der.startSequence(
                  ALTNAME.DirectoryName
                );
                altNames[j].toAsn1(der);
                der.endSequence();
              }
            }
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.basicConstraints) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            var ca = cert.purposes.indexOf("ca") !== -1;
            var pathLen = exts[i].pathLen;
            der.writeBoolean(ca);
            if (pathLen !== void 0)
              der.writeInt(pathLen);
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.extKeyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            cert.purposes.forEach(function(purpose) {
              if (purpose === "ca")
                return;
              if (KEYUSEBITS.indexOf(purpose) !== -1)
                return;
              var oid = purpose;
              if (EXTPURPOSE[purpose] !== void 0)
                oid = EXTPURPOSE[purpose];
              der.writeOID(oid);
            });
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.keyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            if (exts[i].bits !== void 0) {
              der.writeBuffer(
                exts[i].bits,
                asn1.Ber.BitString
              );
            } else {
              var bits = writeBitField(
                cert.purposes,
                KEYUSEBITS
              );
              der.writeBuffer(
                bits,
                asn1.Ber.BitString
              );
            }
            der.endSequence();
          } else {
            der.writeBuffer(
              exts[i].data,
              asn1.Ber.OctetString
            );
          }
          der.endSequence();
        }
        der.endSequence();
        der.endSequence();
      }
      der.endSequence();
    }
    function readBitField(bits, bitIndex) {
      var bitLen = 8 * (bits.length - 1) - bits[0];
      var setBits = {};
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var bitVal = (bits[byteN] & mask) !== 0;
        var name = bitIndex[i];
        if (bitVal && typeof name === "string") {
          setBits[name] = true;
        }
      }
      return Object.keys(setBits);
    }
    function writeBitField(setBits, bitIndex) {
      var bitLen = bitIndex.length;
      var blen = Math.ceil(bitLen / 8);
      var unused = blen * 8 - bitLen;
      var bits = Buffer2.alloc(1 + blen);
      bits[0] = unused;
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var name = bitIndex[i];
        if (name === void 0)
          continue;
        var bitVal = setBits.indexOf(name) !== -1;
        if (bitVal) {
          bits[byteN] |= mask;
        }
      }
      return bits;
    }
  }
});

// node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS({
  "node_modules/sshpk/lib/formats/x509-pem.js"(exports, module) {
    var x509 = require_x509();
    module.exports = {
      read,
      verify: x509.verify,
      sign: x509.sign,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(
          /*JSSTYLED*/
          /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/
        );
      }
      assert.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(
          /*JSSTYLED*/
          /[-]+[ ]*END CERTIFICATE[ ]*[-]+/
        );
      }
      assert.ok(m2, "invalid PEM footer");
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(
          /*JSSTYLED*/
          /^([A-Za-z0-9-]+): (.+)$/
        );
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      return x509.read(buf, options);
    }
    function write(cert, options) {
      var dbuf = x509.write(cert, options);
      var header = "CERTIFICATE";
      var tmp = dbuf.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS({
  "node_modules/sshpk/lib/certificate.js"(exports, module) {
    module.exports = Certificate;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = __require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors2();
    var util = __require("util");
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var formats = {};
    formats["openssh"] = require_openssh_cert();
    formats["x509"] = require_x509();
    formats["pem"] = require_x509_pem();
    var CertificateParseError = errs.CertificateParseError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Certificate(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.subjects, "options.subjects");
      utils.assertCompatible(
        opts.subjects[0],
        Identity,
        [1, 0],
        "options.subjects"
      );
      utils.assertCompatible(
        opts.subjectKey,
        Key,
        [1, 0],
        "options.subjectKey"
      );
      utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
      if (opts.issuerKey !== void 0) {
        utils.assertCompatible(
          opts.issuerKey,
          Key,
          [1, 0],
          "options.issuerKey"
        );
      }
      assert.object(opts.signatures, "options.signatures");
      assert.buffer(opts.serial, "options.serial");
      assert.date(opts.validFrom, "options.validFrom");
      assert.date(opts.validUntil, "optons.validUntil");
      assert.optionalArrayOfString(opts.purposes, "options.purposes");
      this._hashCache = {};
      this.subjects = opts.subjects;
      this.issuer = opts.issuer;
      this.subjectKey = opts.subjectKey;
      this.issuerKey = opts.issuerKey;
      this.signatures = opts.signatures;
      this.serial = opts.serial;
      this.validFrom = opts.validFrom;
      this.validUntil = opts.validUntil;
      this.purposes = opts.purposes;
    }
    Certificate.formats = formats;
    Certificate.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "x509";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    Certificate.prototype.toString = function(format, options) {
      if (format === void 0)
        format = "pem";
      return this.toBuffer(format, options).toString();
    };
    Certificate.prototype.fingerprint = function(algo) {
      if (algo === void 0)
        algo = "sha256";
      assert.string(algo, "algorithm");
      var opts = {
        type: "certificate",
        hash: this.hash(algo),
        algorithm: algo
      };
      return new Fingerprint(opts);
    };
    Certificate.prototype.hash = function(algo) {
      assert.string(algo, "algorithm");
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      if (this._hashCache[algo])
        return this._hashCache[algo];
      var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
      this._hashCache[algo] = hash;
      return hash;
    };
    Certificate.prototype.isExpired = function(when) {
      if (when === void 0)
        when = /* @__PURE__ */ new Date();
      return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
    };
    Certificate.prototype.isSignedBy = function(issuerCert) {
      utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
      if (!this.issuer.equals(issuerCert.subjects[0]))
        return false;
      if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
        return false;
      }
      return this.isSignedByKey(issuerCert.subjectKey);
    };
    Certificate.prototype.getExtension = function(keyOrOid) {
      assert.string(keyOrOid, "keyOrOid");
      var ext = this.getExtensions().filter(function(maybeExt) {
        if (maybeExt.format === "x509")
          return maybeExt.oid === keyOrOid;
        if (maybeExt.format === "openssh")
          return maybeExt.name === keyOrOid;
        return false;
      })[0];
      return ext;
    };
    Certificate.prototype.getExtensions = function() {
      var exts = [];
      var x509 = this.signatures.x509;
      if (x509 && x509.extras && x509.extras.exts) {
        x509.extras.exts.forEach(function(ext) {
          ext.format = "x509";
          exts.push(ext);
        });
      }
      var openssh = this.signatures.openssh;
      if (openssh && openssh.exts) {
        openssh.exts.forEach(function(ext) {
          ext.format = "openssh";
          exts.push(ext);
        });
      }
      return exts;
    };
    Certificate.prototype.isSignedByKey = function(issuerKey) {
      utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
      if (this.issuerKey !== void 0) {
        return this.issuerKey.fingerprint("sha512").matches(issuerKey);
      }
      var fmt = Object.keys(this.signatures)[0];
      var valid = formats[fmt].verify(this, issuerKey);
      if (valid)
        this.issuerKey = issuerKey;
      return valid;
    };
    Certificate.prototype.signWith = function(key) {
      utils.assertCompatible(key, PrivateKey, [1, 2], "key");
      var fmts = Object.keys(formats);
      var didOne = false;
      for (var i = 0; i < fmts.length; ++i) {
        if (fmts[i] !== "pem") {
          var ret = formats[fmts[i]].sign(this, key);
          if (ret === true)
            didOne = true;
        }
      }
      if (!didOne) {
        throw new Error("Failed to sign the certificate for any available certificate formats");
      }
    };
    Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalObject(options.validFrom, "options.validFrom");
      assert.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = /* @__PURE__ */ new Date();
      if (validUntil === void 0) {
        assert.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = /* @__PURE__ */ new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
      if (purposes.length <= 3) {
        var hostSubjects = subjects.filter(function(subject) {
          return subject.type === "host";
        });
        var userSubjects = subjects.filter(function(subject) {
          return subject.type === "user";
        });
        if (hostSubjects.length > 0) {
          if (purposes.indexOf("serverAuth") === -1)
            purposes.push("serverAuth");
        }
        if (userSubjects.length > 0) {
          if (purposes.indexOf("clientAuth") === -1)
            purposes.push("clientAuth");
        }
        if (userSubjects.length > 0 || hostSubjects.length > 0) {
          if (purposes.indexOf("keyAgreement") === -1)
            purposes.push("keyAgreement");
          if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
            purposes.push("encryption");
        }
      }
      var cert = new Certificate({
        subjects,
        issuer: subjects[0],
        subjectKey: key.toPublic(),
        issuerKey: key.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(key);
      return cert;
    };
    Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, Key, [1, 0], "key");
      if (PrivateKey.isPrivateKey(key))
        key = key.toPublic();
      utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
      utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalObject(options.validFrom, "options.validFrom");
      assert.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = /* @__PURE__ */ new Date();
      if (validUntil === void 0) {
        assert.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = /* @__PURE__ */ new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (options.ca === true) {
        if (purposes.indexOf("ca") === -1)
          purposes.push("ca");
        if (purposes.indexOf("crl") === -1)
          purposes.push("crl");
      }
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
      var cert = new Certificate({
        subjects,
        issuer,
        subjectKey: key,
        issuerKey: issuerKey.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(issuerKey);
      return cert;
    };
    Certificate.parse = function(data3, format, options) {
      if (typeof data3 !== "string")
        assert.buffer(data3, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data3, options);
        return k;
      } catch (e) {
        throw new CertificateParseError(options.filename, format, e);
      }
    };
    Certificate.isCertificate = function(obj, ver) {
      return utils.isCompatible(obj, Certificate, ver);
    };
    Certificate.prototype._sshpkApiVersion = [1, 1];
    Certificate._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS({
  "node_modules/sshpk/lib/fingerprint.js"(exports, module) {
    module.exports = Fingerprint;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = __require("crypto");
    var errs = require_errors2();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var utils = require_utils();
    var FingerprintFormatError = errs.FingerprintFormatError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Fingerprint(opts) {
      assert.object(opts, "options");
      assert.string(opts.type, "options.type");
      assert.buffer(opts.hash, "options.hash");
      assert.string(opts.algorithm, "options.algorithm");
      this.algorithm = opts.algorithm.toLowerCase();
      if (algs.hashAlgs[this.algorithm] !== true)
        throw new InvalidAlgorithmError(this.algorithm);
      this.hash = opts.hash;
      this.type = opts.type;
      this.hashType = opts.hashType;
    }
    Fingerprint.prototype.toString = function(format) {
      if (format === void 0) {
        if (this.algorithm === "md5" || this.hashType === "spki")
          format = "hex";
        else
          format = "base64";
      }
      assert.string(format);
      switch (format) {
        case "hex":
          if (this.hashType === "spki")
            return this.hash.toString("hex");
          return addColons(this.hash.toString("hex"));
        case "base64":
          if (this.hashType === "spki")
            return this.hash.toString("base64");
          return sshBase64Format(
            this.algorithm,
            this.hash.toString("base64")
          );
        default:
          throw new FingerprintFormatError(void 0, format);
      }
    };
    Fingerprint.prototype.matches = function(other) {
      assert.object(other, "key or certificate");
      if (this.type === "key" && this.hashType !== "ssh") {
        utils.assertCompatible(other, Key, [1, 7], "key with spki");
        if (PrivateKey.isPrivateKey(other)) {
          utils.assertCompatible(
            other,
            PrivateKey,
            [1, 6],
            "privatekey with spki support"
          );
        }
      } else if (this.type === "key") {
        utils.assertCompatible(other, Key, [1, 0], "key");
      } else {
        utils.assertCompatible(
          other,
          Certificate,
          [1, 0],
          "certificate"
        );
      }
      var theirHash = other.hash(this.algorithm, this.hashType);
      var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
      if (this.hash2 === void 0)
        this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
      return this.hash2 === theirHash2;
    };
    var base64RE = /^[A-Za-z0-9+\/=]+$/;
    var hexRE = /^[a-fA-F0-9]+$/;
    Fingerprint.parse = function(fp, options) {
      assert.string(fp, "fingerprint");
      var alg, hash, enAlgs;
      if (Array.isArray(options)) {
        enAlgs = options;
        options = {};
      }
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      if (options.enAlgs !== void 0)
        enAlgs = options.enAlgs;
      if (options.algorithms !== void 0)
        enAlgs = options.algorithms;
      assert.optionalArrayOfString(enAlgs, "algorithms");
      var hashType = "ssh";
      if (options.hashType !== void 0)
        hashType = options.hashType;
      assert.string(hashType, "options.hashType");
      var parts = fp.split(":");
      if (parts.length == 2) {
        alg = parts[0].toLowerCase();
        if (!base64RE.test(parts[1]))
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts[1], "base64");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else if (parts.length > 2) {
        alg = "md5";
        if (parts[0].toLowerCase() === "md5")
          parts = parts.slice(1);
        parts = parts.map(function(p) {
          while (p.length < 2)
            p = "0" + p;
          if (p.length > 2)
            throw new FingerprintFormatError(fp);
          return p;
        });
        parts = parts.join("");
        if (!hexRE.test(parts) || parts.length % 2 !== 0)
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts, "hex");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else {
        if (hexRE.test(fp)) {
          hash = Buffer2.from(fp, "hex");
        } else if (base64RE.test(fp)) {
          hash = Buffer2.from(fp, "base64");
        } else {
          throw new FingerprintFormatError(fp);
        }
        switch (hash.length) {
          case 32:
            alg = "sha256";
            break;
          case 16:
            alg = "md5";
            break;
          case 20:
            alg = "sha1";
            break;
          case 64:
            alg = "sha512";
            break;
          default:
            throw new FingerprintFormatError(fp);
        }
        if (options.hashType === void 0)
          hashType = "spki";
      }
      if (alg === void 0)
        throw new FingerprintFormatError(fp);
      if (algs.hashAlgs[alg] === void 0)
        throw new InvalidAlgorithmError(alg);
      if (enAlgs !== void 0) {
        enAlgs = enAlgs.map(function(a) {
          return a.toLowerCase();
        });
        if (enAlgs.indexOf(alg) === -1)
          throw new InvalidAlgorithmError(alg);
      }
      return new Fingerprint({
        algorithm: alg,
        hash,
        type: options.type || "key",
        hashType
      });
    };
    function addColons(s) {
      return s.replace(/(.{2})(?=.)/g, "$1:");
    }
    function base64Strip(s) {
      return s.replace(/=*$/, "");
    }
    function sshBase64Format(alg, h) {
      return alg.toUpperCase() + ":" + base64Strip(h);
    }
    Fingerprint.isFingerprint = function(obj, ver) {
      return utils.isCompatible(obj, Fingerprint, ver);
    };
    Fingerprint.prototype._sshpkApiVersion = [1, 2];
    Fingerprint._oldVersionDetect = function(obj) {
      assert.func(obj.toString);
      assert.func(obj.matches);
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/key.js
var require_key = __commonJS({
  "node_modules/sshpk/lib/key.js"(exports, module) {
    module.exports = Key;
    var assert = require_assert();
    var algs = require_algs();
    var crypto = __require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var DiffieHellman = require_dhe().DiffieHellman;
    var errs = require_errors2();
    var utils = require_utils();
    var PrivateKey = require_private_key();
    var edCompat;
    try {
      edCompat = require_ed_compat();
    } catch (e) {
    }
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var formats = {};
    formats["auto"] = require_auto2();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh"] = require_ssh();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    formats["putty"] = require_putty();
    formats["ppk"] = formats["putty"];
    function Key(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.parts, "options.parts");
      assert.string(opts.type, "options.type");
      assert.optionalString(opts.comment, "options.comment");
      var algInfo = algs.info[opts.type];
      if (typeof algInfo !== "object")
        throw new InvalidAlgorithmError(opts.type);
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.parts = opts.parts;
      this.part = partLookup;
      this.comment = void 0;
      this.source = opts.source;
      this._rfc4253Cache = opts._rfc4253Cache;
      this._hashCache = {};
      var sz;
      this.curve = void 0;
      if (this.type === "ecdsa") {
        var curve = this.part.curve.data.toString();
        this.curve = curve;
        sz = algs.curves[curve].size;
      } else if (this.type === "ed25519" || this.type === "curve25519") {
        sz = 256;
        this.curve = "curve25519";
      } else {
        var szPart = this.part[algInfo.sizePart];
        sz = szPart.data.length;
        sz = sz * 8 - utils.countZeros(szPart.data);
      }
      this.size = sz;
    }
    Key.formats = formats;
    Key.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "ssh";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      if (format === "rfc4253") {
        if (this._rfc4253Cache === void 0)
          this._rfc4253Cache = formats["rfc4253"].write(this);
        return this._rfc4253Cache;
      }
      return formats[format].write(this, options);
    };
    Key.prototype.toString = function(format, options) {
      return this.toBuffer(format, options).toString();
    };
    Key.prototype.hash = function(algo, type3) {
      assert.string(algo, "algorithm");
      assert.optionalString(type3, "type");
      if (type3 === void 0)
        type3 = "ssh";
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      var cacheKey = algo + "||" + type3;
      if (this._hashCache[cacheKey])
        return this._hashCache[cacheKey];
      var buf;
      if (type3 === "ssh") {
        buf = this.toBuffer("rfc4253");
      } else if (type3 === "spki") {
        buf = formats.pkcs8.pkcs8ToBuffer(this);
      } else {
        throw new Error("Hash type " + type3 + " not supported");
      }
      var hash = crypto.createHash(algo).update(buf).digest();
      this._hashCache[cacheKey] = hash;
      return hash;
    };
    Key.prototype.fingerprint = function(algo, type3) {
      if (algo === void 0)
        algo = "sha256";
      if (type3 === void 0)
        type3 = "ssh";
      assert.string(algo, "algorithm");
      assert.string(type3, "type");
      var opts = {
        type: "key",
        hash: this.hash(algo, type3),
        algorithm: algo,
        hashType: type3
      };
      return new Fingerprint(opts);
    };
    Key.prototype.defaultHashAlgorithm = function() {
      var hashAlgo = "sha1";
      if (this.type === "rsa")
        hashAlgo = "sha256";
      if (this.type === "dsa" && this.size > 1024)
        hashAlgo = "sha256";
      if (this.type === "ed25519")
        hashAlgo = "sha512";
      if (this.type === "ecdsa") {
        if (this.size <= 256)
          hashAlgo = "sha256";
        else if (this.size <= 384)
          hashAlgo = "sha384";
        else
          hashAlgo = "sha512";
      }
      return hashAlgo;
    };
    Key.prototype.createVerify = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Verifier(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      }
      assert.ok(v, "failed to create verifier");
      var oldVerify = v.verify.bind(v);
      var key = this.toBuffer("pkcs8");
      var curve = this.curve;
      var self2 = this;
      v.verify = function(signature, fmt) {
        if (Signature.isSignature(signature, [2, 0])) {
          if (signature.type !== self2.type)
            return false;
          if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
            return false;
          if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
            return false;
          return oldVerify(key, signature.toBuffer("asn1"));
        } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
          return oldVerify(key, signature, fmt);
        } else if (Signature.isSignature(signature, [1, 0])) {
          throw new Error("signature was created by too old a version of sshpk and cannot be verified");
        } else {
          throw new TypeError("signature must be a string, Buffer, or Signature object");
        }
      };
      return v;
    };
    Key.prototype.createDiffieHellman = function() {
      if (this.type === "rsa")
        throw new Error("RSA keys do not support Diffie-Hellman");
      return new DiffieHellman(this);
    };
    Key.prototype.createDH = Key.prototype.createDiffieHellman;
    Key.parse = function(data3, format, options) {
      if (typeof data3 !== "string")
        assert.buffer(data3, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data3, options);
        if (k instanceof PrivateKey)
          k = k.toPublic();
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    Key.isKey = function(obj, ver) {
      return utils.isCompatible(obj, Key, ver);
    };
    Key.prototype._sshpkApiVersion = [1, 7];
    Key._oldVersionDetect = function(obj) {
      assert.func(obj.toBuffer);
      assert.func(obj.fingerprint);
      if (obj.createDH)
        return [1, 4];
      if (obj.defaultHashAlgorithm)
        return [1, 3];
      if (obj.formats["auto"])
        return [1, 2];
      if (obj.formats["pkcs1"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/sshpk/lib/index.js"(exports, module) {
    var Key = require_key();
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var Identity = require_identity();
    var errs = require_errors2();
    module.exports = {
      /* top-level classes */
      Key,
      parseKey: Key.parse,
      Fingerprint,
      parseFingerprint: Fingerprint.parse,
      Signature,
      parseSignature: Signature.parse,
      PrivateKey,
      parsePrivateKey: PrivateKey.parse,
      generatePrivateKey: PrivateKey.generate,
      Certificate,
      parseCertificate: Certificate.parse,
      createSelfSignedCertificate: Certificate.createSelfSigned,
      createCertificate: Certificate.create,
      Identity,
      identityFromDN: Identity.parseDN,
      identityForHost: Identity.forHost,
      identityForUser: Identity.forUser,
      identityForEmail: Identity.forEmail,
      identityFromArray: Identity.fromArray,
      /* errors */
      FingerprintFormatError: errs.FingerprintFormatError,
      InvalidAlgorithmError: errs.InvalidAlgorithmError,
      KeyParseError: errs.KeyParseError,
      SignatureParseError: errs.SignatureParseError,
      KeyEncryptedError: errs.KeyEncryptedError,
      CertificateParseError: errs.CertificateParseError
    };
  }
});

// node_modules/http-signature/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/http-signature/lib/utils.js"(exports, module) {
    var assert = require_assert();
    var sshpk = require_lib2();
    var util = __require("util");
    var HASH_ALGOS = {
      "sha1": true,
      "sha256": true,
      "sha512": true
    };
    var PK_ALGOS = {
      "rsa": true,
      "dsa": true,
      "ecdsa": true
    };
    function HttpSignatureError(message, caller) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, caller || HttpSignatureError);
      this.message = message;
      this.name = caller.name;
    }
    util.inherits(HttpSignatureError, Error);
    function InvalidAlgorithmError(message) {
      HttpSignatureError.call(this, message, InvalidAlgorithmError);
    }
    util.inherits(InvalidAlgorithmError, HttpSignatureError);
    function validateAlgorithm(algorithm) {
      var alg = algorithm.toLowerCase().split("-");
      if (alg.length !== 2) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a valid algorithm");
      }
      if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys are not supported");
      }
      if (!HASH_ALGOS[alg[1]]) {
        throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a supported hash algorithm");
      }
      return alg;
    }
    module.exports = {
      HASH_ALGOS,
      PK_ALGOS,
      HttpSignatureError,
      InvalidAlgorithmError,
      validateAlgorithm,
      /**
       * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
       *
       * The intent of this module is to interoperate with OpenSSL only,
       * specifically the node crypto module's `verify` method.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} PEM encoded form of the RSA public key.
       * @throws {TypeError} on bad input.
       * @throws {Error} on invalid ssh key formatted data.
       */
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.toString("pem");
      },
      /**
       * Generates an OpenSSH fingerprint from an ssh public key.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} key fingerprint.
       * @throws {TypeError} on bad input.
       * @throws {Error} if what you passed doesn't look like an ssh public key.
       */
      fingerprint: function fingerprint(key) {
        assert.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.fingerprint("md5").toString("hex");
      },
      /**
       * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
       *
       * The reverse of the above function.
       */
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert.equal("string", typeof pem, "typeof pem");
        var k = sshpk.parseKey(pem, "pem");
        k.comment = comment;
        return k.toString("ssh");
      }
    };
  }
});

// node_modules/http-signature/lib/parser.js
var require_parser = __commonJS({
  "node_modules/http-signature/lib/parser.js"(exports, module) {
    var assert = require_assert();
    var util = __require("util");
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var HttpSignatureError = utils.HttpSignatureError;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var validateAlgorithm = utils.validateAlgorithm;
    var State3 = {
      New: 0,
      Params: 1
    };
    var ParamsState = {
      Name: 0,
      Quote: 1,
      Value: 2,
      Comma: 3
    };
    function ExpiredRequestError(message) {
      HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    util.inherits(ExpiredRequestError, HttpSignatureError);
    function InvalidHeaderError(message) {
      HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    util.inherits(InvalidHeaderError, HttpSignatureError);
    function InvalidParamsError(message) {
      HttpSignatureError.call(this, message, InvalidParamsError);
    }
    util.inherits(InvalidParamsError, HttpSignatureError);
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util.inherits(StrictParsingError, HttpSignatureError);
    module.exports = {
      /**
       * Parses the 'Authorization' header out of an http.ServerRequest object.
       *
       * Note that this API will fully validate the Authorization header, and throw
       * on any error.  It will not however check the signature, or the keyId format
       * as those are specific to your environment.  You can use the options object
       * to pass in extra constraints.
       *
       * As a response object you can expect this:
       *
       *     {
       *       "scheme": "Signature",
       *       "params": {
       *         "keyId": "foo",
       *         "algorithm": "rsa-sha256",
       *         "headers": [
       *           "date" or "x-date",
       *           "digest"
       *         ],
       *         "signature": "base64"
       *       },
       *       "signingString": "ready to be passed to crypto.verify()"
       *     }
       *
       * @param {Object} request an http.ServerRequest.
       * @param {Object} options an optional options object with:
       *                   - clockSkew: allowed clock skew in seconds (default 300).
       *                   - headers: required header names (def: date or x-date)
       *                   - algorithms: algorithms to support (default: all).
       *                   - strict: should enforce latest spec parsing
       *                             (default: false).
       * @return {Object} parsed out object (see above).
       * @throws {TypeError} on invalid input.
       * @throws {InvalidHeaderError} on an invalid Authorization header error.
       * @throws {InvalidParamsError} if the params in the scheme are invalid.
       * @throws {MissingHeaderError} if the params indicate a header not present,
       *                              either in the request headers from the params,
       *                              or not in the params from a required header
       *                              in options.
       * @throws {StrictParsingError} if old attributes are used in strict parsing
       *                              mode.
       * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
       */
      parseRequest: function parseRequest(request2, options) {
        assert.object(request2, "request");
        assert.object(request2.headers, "request.headers");
        if (options === void 0) {
          options = {};
        }
        if (options.headers === void 0) {
          options.headers = [request2.headers["x-date"] ? "x-date" : "date"];
        }
        assert.object(options, "options");
        assert.arrayOfString(options.headers, "options.headers");
        assert.optionalFinite(options.clockSkew, "options.clockSkew");
        var authzHeaderName = options.authorizationHeaderName || "authorization";
        if (!request2.headers[authzHeaderName]) {
          throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
        }
        options.clockSkew = options.clockSkew || 300;
        var i = 0;
        var state = State3.New;
        var substate = ParamsState.Name;
        var tmpName = "";
        var tmpValue = "";
        var parsed = {
          scheme: "",
          params: {},
          signingString: ""
        };
        var authz = request2.headers[authzHeaderName];
        for (i = 0; i < authz.length; i++) {
          var c = authz.charAt(i);
          switch (Number(state)) {
            case State3.New:
              if (c !== " ")
                parsed.scheme += c;
              else
                state = State3.Params;
              break;
            case State3.Params:
              switch (Number(substate)) {
                case ParamsState.Name:
                  var code = c.charCodeAt(0);
                  if (code >= 65 && code <= 90 || // A-Z
                  code >= 97 && code <= 122) {
                    tmpName += c;
                  } else if (c === "=") {
                    if (tmpName.length === 0)
                      throw new InvalidHeaderError("bad param format");
                    substate = ParamsState.Quote;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Quote:
                  if (c === '"') {
                    tmpValue = "";
                    substate = ParamsState.Value;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Value:
                  if (c === '"') {
                    parsed.params[tmpName] = tmpValue;
                    substate = ParamsState.Comma;
                  } else {
                    tmpValue += c;
                  }
                  break;
                case ParamsState.Comma:
                  if (c === ",") {
                    tmpName = "";
                    substate = ParamsState.Name;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                default:
                  throw new Error("Invalid substate");
              }
              break;
            default:
              throw new Error("Invalid substate");
          }
        }
        if (!parsed.params.headers || parsed.params.headers === "") {
          if (request2.headers["x-date"]) {
            parsed.params.headers = ["x-date"];
          } else {
            parsed.params.headers = ["date"];
          }
        } else {
          parsed.params.headers = parsed.params.headers.split(" ");
        }
        if (!parsed.scheme || parsed.scheme !== "Signature")
          throw new InvalidHeaderError('scheme was not "Signature"');
        if (!parsed.params.keyId)
          throw new InvalidHeaderError("keyId was not specified");
        if (!parsed.params.algorithm)
          throw new InvalidHeaderError("algorithm was not specified");
        if (!parsed.params.signature)
          throw new InvalidHeaderError("signature was not specified");
        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
        try {
          validateAlgorithm(parsed.params.algorithm);
        } catch (e) {
          if (e instanceof InvalidAlgorithmError)
            throw new InvalidParamsError(parsed.params.algorithm + " is not supported");
          else
            throw e;
        }
        for (i = 0; i < parsed.params.headers.length; i++) {
          var h = parsed.params.headers[i].toLowerCase();
          parsed.params.headers[i] = h;
          if (h === "request-line") {
            if (!options.strict) {
              parsed.signingString += request2.method + " " + request2.url + " HTTP/" + request2.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            parsed.signingString += "(request-target): " + request2.method.toLowerCase() + " " + request2.url;
          } else {
            var value2 = request2.headers[h];
            if (value2 === void 0)
              throw new MissingHeaderError(h + " was not in the request");
            parsed.signingString += h + ": " + value2;
          }
          if (i + 1 < parsed.params.headers.length)
            parsed.signingString += "\n";
        }
        var date;
        if (request2.headers.date || request2.headers["x-date"]) {
          if (request2.headers["x-date"]) {
            date = new Date(request2.headers["x-date"]);
          } else {
            date = new Date(request2.headers.date);
          }
          var now = /* @__PURE__ */ new Date();
          var skew = Math.abs(now.getTime() - date.getTime());
          if (skew > options.clockSkew * 1e3) {
            throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
          }
        }
        options.headers.forEach(function(hdr) {
          if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
            throw new MissingHeaderError(hdr + " was not a signed header");
        });
        if (options.algorithms) {
          if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
            throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
        }
        parsed.algorithm = parsed.params.algorithm.toUpperCase();
        parsed.keyId = parsed.params.keyId;
        return parsed;
      }
    };
  }
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "node_modules/extsprintf/lib/extsprintf.js"(exports) {
    var mod_assert = __require("assert");
    var mod_util = __require("util");
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    exports.fprintf = jsFprintf;
    function jsSprintf(fmt) {
      var regex = [
        "([^%]*)",
        /* normal text */
        "%",
        /* start of format */
        "(['\\-+ #0]*?)",
        /* flags (optional) */
        "([1-9]\\d*)?",
        /* width (optional) */
        "(\\.([1-9]\\d*))?",
        /* precision (optional) */
        "[lhjztL]*?",
        /* length mods (ignored) */
        "([diouxXfFeEgGaAcCsSp%jr])"
        /* conversion */
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var flags, width, precision, conversion;
      var left, pad3, sign, arg, match;
      var ret = "";
      var argn = 1;
      mod_assert.equal("string", typeof fmt);
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad3 = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0)
          throw new Error("too few args to sprintf");
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/))
          throw new Error(
            "unsupported flags: " + flags
          );
        if (precision.length > 0)
          throw new Error(
            "non-zero precision not supported"
          );
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad3 = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null)
              throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
            ret += doPad(pad3, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(
              pad3,
              width,
              left,
              arg.toString()
            );
            break;
          case "x":
            ret += doPad(pad3, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw new Error("unsupported conversion: " + conversion);
        }
      }
      ret += fmt;
      return ret;
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf2 = __commonJS({
  "node_modules/verror/node_modules/extsprintf/lib/extsprintf.js"(exports) {
    var mod_assert = __require("assert");
    var mod_util = __require("util");
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    exports.fprintf = jsFprintf;
    function jsSprintf(ofmt) {
      var regex = [
        "([^%]*)",
        /* normal text */
        "%",
        /* start of format */
        "(['\\-+ #0]*?)",
        /* flags (optional) */
        "([1-9]\\d*)?",
        /* width (optional) */
        "(\\.([1-9]\\d*))?",
        /* precision (optional) */
        "[lhjztL]*?",
        /* length mods (ignored) */
        "([diouxXfFeEgGaAcCsSp%jr])"
        /* conversion */
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var fmt = ofmt;
      var flags, width, precision, conversion;
      var left, pad3, sign, arg, match;
      var ret = "";
      var argn = 1;
      var posn = 0;
      var convposn;
      var curconv;
      mod_assert.equal(
        "string",
        typeof fmt,
        "first argument must be a format string"
      );
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        curconv = match[0].substring(match[1].length);
        convposn = posn + match[1].length + 1;
        posn += match[0].length;
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad3 = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "has no matching argument (too few arguments passed)"
          );
        }
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/)) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses unsupported flags"
          );
        }
        if (precision.length > 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses non-zero precision (not supported)"
          );
        }
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad3 = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null) {
              throw jsError(
                ofmt,
                convposn,
                curconv,
                "attempted to print undefined or null as a string (argument " + argn + " to sprintf)"
              );
            }
            ret += doPad(pad3, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(
              pad3,
              width,
              left,
              arg.toString()
            );
            break;
          case "x":
            ret += doPad(pad3, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw jsError(
              ofmt,
              convposn,
              curconv,
              "is not supported"
            );
        }
      }
      ret += fmt;
      return ret;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
      mod_assert.equal(typeof fmtstr, "string");
      mod_assert.equal(typeof curconv, "string");
      mod_assert.equal(typeof convposn, "number");
      mod_assert.equal(typeof reason, "string");
      return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber3(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber3;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "node_modules/verror/lib/verror.js"(exports, module) {
    var mod_assertplus = require_assert();
    var mod_util = __require("util");
    var mod_extsprintf = require_extsprintf2();
    var mod_isError = require_util().isError;
    var sprintf = mod_extsprintf.sprintf;
    module.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(
          argv[0],
          "first argument to VError, SError, or WError constructor must be a string, object, or Error"
        );
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(
          parsed.options.name,
          `error's "name" must be a string`
        );
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// node_modules/json-schema/lib/validate.js
var require_validate = __commonJS({
  "node_modules/json-schema/lib/validate.js"(exports, module) {
    (function(root3, factory) {
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return factory();
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root3.jsonSchema = factory();
      }
    })(exports, function() {
      var exports2 = validate3;
      exports2.Integer = { type: "integer" };
      var primitiveConstructors = {
        String,
        Boolean,
        Number,
        Object,
        Array,
        Date
      };
      exports2.validate = validate3;
      function validate3(instance, schema) {
        return validate3(instance, schema, { changing: false });
      }
      ;
      exports2.checkPropertyChange = function(value2, schema, property) {
        return validate3(value2, schema, { changing: property || "property" });
      };
      var validate3 = exports2._validate = function(instance, schema, options) {
        if (!options)
          options = {};
        var _changing = options.changing;
        function getType(schema2) {
          return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
        }
        var errors = [];
        function checkProp(value2, schema2, path3, i) {
          var l;
          path3 += path3 ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
          function addError(message) {
            errors.push({ property: path3, message });
          }
          if ((typeof schema2 != "object" || schema2 instanceof Array) && (path3 || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
            if (typeof schema2 == "function") {
              if (!(value2 instanceof schema2)) {
                addError("is not an instance of the class/constructor " + schema2.name);
              }
            } else if (schema2) {
              addError("Invalid schema/property definition " + schema2);
            }
            return null;
          }
          if (_changing && schema2.readonly) {
            addError("is a readonly field, it can not be changed");
          }
          if (schema2["extends"]) {
            checkProp(value2, schema2["extends"], path3, i);
          }
          function checkType(type3, value3) {
            if (type3) {
              if (typeof type3 == "string" && type3 != "any" && (type3 == "null" ? value3 !== null : typeof value3 != type3) && !(value3 instanceof Array && type3 == "array") && !(value3 instanceof Date && type3 == "date") && !(type3 == "integer" && value3 % 1 === 0)) {
                return [{ property: path3, message: value3 + " - " + typeof value3 + " value found, but a " + type3 + " is required" }];
              }
              if (type3 instanceof Array) {
                var unionErrors = [];
                for (var j2 = 0; j2 < type3.length; j2++) {
                  if (!(unionErrors = checkType(type3[j2], value3)).length) {
                    break;
                  }
                }
                if (unionErrors.length) {
                  return unionErrors;
                }
              } else if (typeof type3 == "object") {
                var priorErrors = errors;
                errors = [];
                checkProp(value3, type3, path3);
                var theseErrors = errors;
                errors = priorErrors;
                return theseErrors;
              }
            }
            return [];
          }
          if (value2 === void 0) {
            if (schema2.required) {
              addError("is missing and it is required");
            }
          } else {
            errors = errors.concat(checkType(getType(schema2), value2));
            if (schema2.disallow && !checkType(schema2.disallow, value2).length) {
              addError(" disallowed value was matched");
            }
            if (value2 !== null) {
              if (value2 instanceof Array) {
                if (schema2.items) {
                  var itemsIsArray = schema2.items instanceof Array;
                  var propDef = schema2.items;
                  for (i = 0, l = value2.length; i < l; i += 1) {
                    if (itemsIsArray)
                      propDef = schema2.items[i];
                    if (options.coerce)
                      value2[i] = options.coerce(value2[i], propDef);
                    errors.concat(checkProp(value2[i], propDef, path3, i));
                  }
                }
                if (schema2.minItems && value2.length < schema2.minItems) {
                  addError("There must be a minimum of " + schema2.minItems + " in the array");
                }
                if (schema2.maxItems && value2.length > schema2.maxItems) {
                  addError("There must be a maximum of " + schema2.maxItems + " in the array");
                }
              } else if (schema2.properties || schema2.additionalProperties) {
                errors.concat(checkObj(value2, schema2.properties, path3, schema2.additionalProperties));
              }
              if (schema2.pattern && typeof value2 == "string" && !value2.match(schema2.pattern)) {
                addError("does not match the regex pattern " + schema2.pattern);
              }
              if (schema2.maxLength && typeof value2 == "string" && value2.length > schema2.maxLength) {
                addError("may only be " + schema2.maxLength + " characters long");
              }
              if (schema2.minLength && typeof value2 == "string" && value2.length < schema2.minLength) {
                addError("must be at least " + schema2.minLength + " characters long");
              }
              if (typeof schema2.minimum !== "undefined" && typeof value2 == typeof schema2.minimum && schema2.minimum > value2) {
                addError("must have a minimum value of " + schema2.minimum);
              }
              if (typeof schema2.maximum !== "undefined" && typeof value2 == typeof schema2.maximum && schema2.maximum < value2) {
                addError("must have a maximum value of " + schema2.maximum);
              }
              if (schema2["enum"]) {
                var enumer = schema2["enum"];
                l = enumer.length;
                var found;
                for (var j = 0; j < l; j++) {
                  if (enumer[j] === value2) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  addError("does not have a value in the enumeration " + enumer.join(", "));
                }
              }
              if (typeof schema2.maxDecimal == "number" && value2.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
                addError("may only have " + schema2.maxDecimal + " digits of decimal places");
              }
            }
          }
          return null;
        }
        function checkObj(instance2, objTypeDef, path3, additionalProp) {
          if (typeof objTypeDef == "object") {
            if (typeof instance2 != "object" || instance2 instanceof Array) {
              errors.push({ property: path3, message: "an object is required" });
            }
            for (var i in objTypeDef) {
              if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
                var value2 = instance2.hasOwnProperty(i) ? instance2[i] : void 0;
                if (value2 === void 0 && options.existingOnly)
                  continue;
                var propDef = objTypeDef[i];
                if (value2 === void 0 && propDef["default"]) {
                  value2 = instance2[i] = propDef["default"];
                }
                if (options.coerce && i in instance2) {
                  value2 = instance2[i] = options.coerce(value2, propDef);
                }
                checkProp(value2, propDef, path3, i);
              }
            }
          }
          for (i in instance2) {
            if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
              if (options.filter) {
                delete instance2[i];
                continue;
              } else {
                errors.push({ property: path3, message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
              }
            }
            var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
            if (requires && !(requires in instance2)) {
              errors.push({ property: path3, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
            }
            value2 = instance2[i];
            if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
              if (options.coerce) {
                value2 = instance2[i] = options.coerce(value2, additionalProp);
              }
              checkProp(value2, additionalProp, path3, i);
            }
            if (!_changing && value2 && value2.$schema) {
              errors = errors.concat(checkProp(value2, value2.$schema, path3, i));
            }
          }
          return errors;
        }
        if (schema) {
          checkProp(instance, schema, "", _changing || "");
        }
        if (!_changing && instance && instance.$schema) {
          checkProp(instance, instance.$schema, "", "");
        }
        return { valid: !errors.length, errors };
      };
      exports2.mustBeValid = function(result) {
        if (!result.valid) {
          throw new TypeError(result.errors.map(function(error) {
            return "for property " + error.property + ": " + error.message;
          }).join(", \n"));
        }
      };
      return exports2;
    });
  }
});

// node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS({
  "node_modules/jsprim/lib/jsprim.js"(exports) {
    var mod_assert = require_assert();
    var mod_util = __require("util");
    var mod_extsprintf = require_extsprintf();
    var mod_verror = require_verror();
    var mod_jsonschema = require_validate();
    exports.deepCopy = deepCopy;
    exports.deepEqual = deepEqual;
    exports.isEmpty = isEmpty;
    exports.hasKey = hasKey;
    exports.forEachKey = forEachKey;
    exports.pluck = pluck;
    exports.flattenObject = flattenObject;
    exports.flattenIter = flattenIter;
    exports.validateJsonObject = validateJsonObjectJS;
    exports.validateJsonObjectJS = validateJsonObjectJS;
    exports.randElt = randElt;
    exports.extraProperties = extraProperties;
    exports.mergeObjects = mergeObjects;
    exports.startsWith = startsWith;
    exports.endsWith = endsWith;
    exports.parseInteger = parseInteger;
    exports.iso8601 = iso8601;
    exports.rfc1123 = rfc1123;
    exports.parseDateTime = parseDateTime;
    exports.hrtimediff = hrtimeDiff;
    exports.hrtimeDiff = hrtimeDiff;
    exports.hrtimeAccum = hrtimeAccum;
    exports.hrtimeAdd = hrtimeAdd;
    exports.hrtimeNanosec = hrtimeNanosec;
    exports.hrtimeMicrosec = hrtimeMicrosec;
    exports.hrtimeMillisec = hrtimeMillisec;
    function deepCopy(obj) {
      var ret, key;
      var marker = "__deepCopy";
      if (obj && obj[marker])
        throw new Error("attempted deep copy of cyclic object");
      if (obj && obj.constructor == Object) {
        ret = {};
        obj[marker] = true;
        for (key in obj) {
          if (key == marker)
            continue;
          ret[key] = deepCopy(obj[key]);
        }
        delete obj[marker];
        return ret;
      }
      if (obj && obj.constructor == Array) {
        ret = [];
        obj[marker] = true;
        for (key = 0; key < obj.length; key++)
          ret.push(deepCopy(obj[key]));
        delete obj[marker];
        return ret;
      }
      return obj;
    }
    function deepEqual(obj1, obj2) {
      if (typeof obj1 != typeof obj2)
        return false;
      if (obj1 === null || obj2 === null || typeof obj1 != "object")
        return obj1 === obj2;
      if (obj1.constructor != obj2.constructor)
        return false;
      var k;
      for (k in obj1) {
        if (!obj2.hasOwnProperty(k))
          return false;
        if (!deepEqual(obj1[k], obj2[k]))
          return false;
      }
      for (k in obj2) {
        if (!obj1.hasOwnProperty(k))
          return false;
      }
      return true;
    }
    function isEmpty(obj) {
      var key;
      for (key in obj)
        return false;
      return true;
    }
    function hasKey(obj, key) {
      mod_assert.equal(typeof key, "string");
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function forEachKey(obj, callback) {
      for (var key in obj) {
        if (hasKey(obj, key)) {
          callback(key, obj[key]);
        }
      }
    }
    function pluck(obj, key) {
      mod_assert.equal(typeof key, "string");
      return pluckv(obj, key);
    }
    function pluckv(obj, key) {
      if (obj === null || typeof obj !== "object")
        return void 0;
      if (obj.hasOwnProperty(key))
        return obj[key];
      var i = key.indexOf(".");
      if (i == -1)
        return void 0;
      var key1 = key.substr(0, i);
      if (!obj.hasOwnProperty(key1))
        return void 0;
      return pluckv(obj[key1], key.substr(i + 1));
    }
    function flattenIter(data3, depth, callback) {
      doFlattenIter(data3, depth, [], callback);
    }
    function doFlattenIter(data3, depth, accum, callback) {
      var each2;
      var key;
      if (depth === 0) {
        each2 = accum.slice(0);
        each2.push(data3);
        callback(each2);
        return;
      }
      mod_assert.ok(data3 !== null);
      mod_assert.equal(typeof data3, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      for (key in data3) {
        each2 = accum.slice(0);
        each2.push(key);
        doFlattenIter(data3[key], depth - 1, each2, callback);
      }
    }
    function flattenObject(data3, depth) {
      if (depth === 0)
        return [data3];
      mod_assert.ok(data3 !== null);
      mod_assert.equal(typeof data3, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      var rv = [];
      var key;
      for (key in data3) {
        flattenObject(data3[key], depth - 1).forEach(function(p) {
          rv.push([key].concat(p));
        });
      }
      return rv;
    }
    function startsWith(str, prefix) {
      return str.substr(0, prefix.length) == prefix;
    }
    function endsWith(str, suffix) {
      return str.substr(
        str.length - suffix.length,
        suffix.length
      ) == suffix;
    }
    function iso8601(d) {
      if (typeof d == "number")
        d = new Date(d);
      mod_assert.ok(d.constructor === Date);
      return mod_extsprintf.sprintf(
        "%4d-%02d-%02dT%02d:%02d:%02d.%03dZ",
        d.getUTCFullYear(),
        d.getUTCMonth() + 1,
        d.getUTCDate(),
        d.getUTCHours(),
        d.getUTCMinutes(),
        d.getUTCSeconds(),
        d.getUTCMilliseconds()
      );
    }
    var RFC1123_MONTHS = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var RFC1123_DAYS = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    function rfc1123(date) {
      return mod_extsprintf.sprintf(
        "%s, %02d %s %04d %02d:%02d:%02d GMT",
        RFC1123_DAYS[date.getUTCDay()],
        date.getUTCDate(),
        RFC1123_MONTHS[date.getUTCMonth()],
        date.getUTCFullYear(),
        date.getUTCHours(),
        date.getUTCMinutes(),
        date.getUTCSeconds()
      );
    }
    function parseDateTime(str) {
      var numeric = +str;
      if (!isNaN(numeric)) {
        return new Date(numeric);
      } else {
        return new Date(str);
      }
    }
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var PI_DEFAULTS = {
      base: 10,
      allowSign: true,
      allowPrefix: false,
      allowTrailing: false,
      allowImprecise: false,
      trimWhitespace: false,
      leadingZeroIsOctal: false
    };
    var CP_0 = 48;
    var CP_9 = 57;
    var CP_A = 65;
    var CP_B = 66;
    var CP_O = 79;
    var CP_T = 84;
    var CP_X = 88;
    var CP_Z = 90;
    var CP_a = 97;
    var CP_b = 98;
    var CP_o = 111;
    var CP_t = 116;
    var CP_x = 120;
    var CP_z = 122;
    var PI_CONV_DEC = 48;
    var PI_CONV_UC = 55;
    var PI_CONV_LC = 87;
    function parseInteger(str, uopts) {
      mod_assert.string(str, "str");
      mod_assert.optionalObject(uopts, "options");
      var baseOverride = false;
      var options = PI_DEFAULTS;
      if (uopts) {
        baseOverride = hasKey(uopts, "base");
        options = mergeObjects(options, uopts);
        mod_assert.number(options.base, "options.base");
        mod_assert.ok(options.base >= 2, "options.base >= 2");
        mod_assert.ok(options.base <= 36, "options.base <= 36");
        mod_assert.bool(options.allowSign, "options.allowSign");
        mod_assert.bool(options.allowPrefix, "options.allowPrefix");
        mod_assert.bool(
          options.allowTrailing,
          "options.allowTrailing"
        );
        mod_assert.bool(
          options.allowImprecise,
          "options.allowImprecise"
        );
        mod_assert.bool(
          options.trimWhitespace,
          "options.trimWhitespace"
        );
        mod_assert.bool(
          options.leadingZeroIsOctal,
          "options.leadingZeroIsOctal"
        );
        if (options.leadingZeroIsOctal) {
          mod_assert.ok(
            !baseOverride,
            '"base" and "leadingZeroIsOctal" are mutually exclusive'
          );
        }
      }
      var c;
      var pbase = -1;
      var base = options.base;
      var start;
      var mult = 1;
      var value2 = 0;
      var idx = 0;
      var len = str.length;
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (options.allowSign) {
        if (str[idx] === "-") {
          idx += 1;
          mult = -1;
        } else if (str[idx] === "+") {
          idx += 1;
        }
      }
      if (str[idx] === "0") {
        if (options.allowPrefix) {
          pbase = prefixToBase(str.charCodeAt(idx + 1));
          if (pbase !== -1 && (!baseOverride || pbase === base)) {
            base = pbase;
            idx += 2;
          }
        }
        if (pbase === -1 && options.leadingZeroIsOctal) {
          base = 8;
        }
      }
      for (start = idx; idx < len; ++idx) {
        c = translateDigit(str.charCodeAt(idx));
        if (c !== -1 && c < base) {
          value2 *= base;
          value2 += c;
        } else {
          break;
        }
      }
      if (start === idx) {
        return new Error("invalid number: " + JSON.stringify(str));
      }
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (idx < len && !options.allowTrailing) {
        return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
      }
      if (value2 === 0) {
        return 0;
      }
      var result = value2 * mult;
      if (!options.allowImprecise && (value2 > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
        return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
      }
      return result;
    }
    function translateDigit(d) {
      if (d >= CP_0 && d <= CP_9) {
        return d - PI_CONV_DEC;
      } else if (d >= CP_A && d <= CP_Z) {
        return d - PI_CONV_UC;
      } else if (d >= CP_a && d <= CP_z) {
        return d - PI_CONV_LC;
      } else {
        return -1;
      }
    }
    function isSpace(c) {
      return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
    }
    function prefixToBase(c) {
      if (c === CP_b || c === CP_B) {
        return 2;
      } else if (c === CP_o || c === CP_O) {
        return 8;
      } else if (c === CP_t || c === CP_T) {
        return 10;
      } else if (c === CP_x || c === CP_X) {
        return 16;
      } else {
        return -1;
      }
    }
    function validateJsonObjectJS(schema, input) {
      var report = mod_jsonschema.validate(input, schema);
      if (report.errors.length === 0)
        return null;
      var error = report.errors[0];
      var propname = error["property"];
      var reason = error["message"].toLowerCase();
      var i, j;
      if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) != -1) {
        i += "the property ".length;
        if (propname === "")
          propname = reason.substr(i, j - i);
        else
          propname = propname + "." + reason.substr(i, j - i);
        reason = "unsupported property";
      }
      var rv = new mod_verror.VError('property "%s": %s', propname, reason);
      rv.jsv_details = error;
      return rv;
    }
    function randElt(arr) {
      mod_assert.ok(
        Array.isArray(arr) && arr.length > 0,
        "randElt argument must be a non-empty array"
      );
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function assertHrtime(a) {
      mod_assert.ok(
        a[0] >= 0 && a[1] >= 0,
        "negative numbers not allowed in hrtimes"
      );
      mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
    }
    function hrtimeDiff(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      mod_assert.ok(
        a[0] > b[0] || a[0] == b[0] && a[1] >= b[1],
        "negative differences not allowed"
      );
      var rv = [a[0] - b[0], 0];
      if (a[1] >= b[1]) {
        rv[1] = a[1] - b[1];
      } else {
        rv[0]--;
        rv[1] = 1e9 - (b[1] - a[1]);
      }
      return rv;
    }
    function hrtimeNanosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e9 + a[1]);
    }
    function hrtimeMicrosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e6 + a[1] / 1e3);
    }
    function hrtimeMillisec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e3 + a[1] / 1e6);
    }
    function hrtimeAccum(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      a[1] += b[1];
      if (a[1] >= 1e9) {
        a[0]++;
        a[1] -= 1e9;
      }
      a[0] += b[0];
      return a;
    }
    function hrtimeAdd(a, b) {
      assertHrtime(a);
      var rv = [a[0], a[1]];
      return hrtimeAccum(rv, b);
    }
    function extraProperties(obj, allowed) {
      mod_assert.ok(
        typeof obj === "object" && obj !== null,
        "obj argument must be a non-null object"
      );
      mod_assert.ok(
        Array.isArray(allowed),
        "allowed argument must be an array of strings"
      );
      for (var i = 0; i < allowed.length; i++) {
        mod_assert.ok(
          typeof allowed[i] === "string",
          "allowed argument must be an array of strings"
        );
      }
      return Object.keys(obj).filter(function(key) {
        return allowed.indexOf(key) === -1;
      });
    }
    function mergeObjects(provided, overrides, defaults) {
      var rv, k;
      rv = {};
      if (defaults) {
        for (k in defaults)
          rv[k] = defaults[k];
      }
      if (provided) {
        for (k in provided)
          rv[k] = provided[k];
      }
      if (overrides) {
        for (k in overrides)
          rv[k] = overrides[k];
      }
      return rv;
    }
  }
});

// node_modules/http-signature/lib/signer.js
var require_signer = __commonJS({
  "node_modules/http-signature/lib/signer.js"(exports, module) {
    var assert = require_assert();
    var crypto = __require("crypto");
    var http = __require("http");
    var util = __require("util");
    var sshpk = require_lib2();
    var jsprim = require_jsprim();
    var utils = require_utils2();
    var sprintf = __require("util").format;
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util.inherits(StrictParsingError, HttpSignatureError);
    function RequestSigner(options) {
      assert.object(options, "options");
      var alg = [];
      if (options.algorithm !== void 0) {
        assert.string(options.algorithm, "options.algorithm");
        alg = validateAlgorithm(options.algorithm);
      }
      this.rs_alg = alg;
      if (options.sign !== void 0) {
        assert.func(options.sign, "options.sign");
        this.rs_signFunc = options.sign;
      } else if (alg[0] === "hmac" && options.key !== void 0) {
        assert.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key for HMAC must be a string or Buffer");
        this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
        this.rs_signer.sign = function() {
          var digest = this.digest("base64");
          return {
            hashAlgorithm: alg[1],
            toString: function() {
              return digest;
            }
          };
        };
      } else if (options.key !== void 0) {
        var key = options.key;
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(key);
        assert.ok(
          sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
          "options.key must be a sshpk.PrivateKey"
        );
        this.rs_key = key;
        assert.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
        }
        if (alg[0] !== void 0 && key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        this.rs_signer = key.createSign(alg[1]);
      } else {
        throw new TypeError("options.sign (func) or options.key is required");
      }
      this.rs_headers = [];
      this.rs_lines = [];
    }
    RequestSigner.prototype.writeHeader = function(header, value2) {
      assert.string(header, "header");
      header = header.toLowerCase();
      assert.string(value2, "value");
      this.rs_headers.push(header);
      if (this.rs_signFunc) {
        this.rs_lines.push(header + ": " + value2);
      } else {
        var line = header + ": " + value2;
        if (this.rs_headers.length > 0)
          line = "\n" + line;
        this.rs_signer.update(line);
      }
      return value2;
    };
    RequestSigner.prototype.writeDateHeader = function() {
      return this.writeHeader("date", jsprim.rfc1123(/* @__PURE__ */ new Date()));
    };
    RequestSigner.prototype.writeTarget = function(method, path3) {
      assert.string(method, "method");
      assert.string(path3, "path");
      method = method.toLowerCase();
      this.writeHeader("(request-target)", method + " " + path3);
    };
    RequestSigner.prototype.sign = function(cb) {
      assert.func(cb, "callback");
      if (this.rs_headers.length < 1)
        throw new Error("At least one header must be signed");
      var alg, authz;
      if (this.rs_signFunc) {
        var data3 = this.rs_lines.join("\n");
        var self2 = this;
        this.rs_signFunc(data3, function(err, sig) {
          if (err) {
            cb(err);
            return;
          }
          try {
            assert.object(sig, "signature");
            assert.string(sig.keyId, "signature.keyId");
            assert.string(sig.algorithm, "signature.algorithm");
            assert.string(sig.signature, "signature.signature");
            alg = validateAlgorithm(sig.algorithm);
            authz = sprintf(
              AUTHZ_FMT,
              sig.keyId,
              sig.algorithm,
              self2.rs_headers.join(" "),
              sig.signature
            );
          } catch (e) {
            cb(e);
            return;
          }
          cb(null, authz);
        });
      } else {
        try {
          var sigObj = this.rs_signer.sign();
        } catch (e) {
          cb(e);
          return;
        }
        alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
        var signature = sigObj.toString();
        authz = sprintf(
          AUTHZ_FMT,
          this.rs_keyId,
          alg,
          this.rs_headers.join(" "),
          signature
        );
        cb(null, authz);
      }
    };
    module.exports = {
      /**
       * Identifies whether a given object is a request signer or not.
       *
       * @param {Object} object, the object to identify
       * @returns {Boolean}
       */
      isSigner: function(obj) {
        if (typeof obj === "object" && obj instanceof RequestSigner)
          return true;
        return false;
      },
      /**
       * Creates a request signer, used to asynchronously build a signature
       * for a request (does not have to be an http.ClientRequest).
       *
       * @param {Object} options, either:
       *                   - {String} keyId
       *                   - {String|Buffer} key
       *                   - {String} algorithm (optional, required for HMAC)
       *                 or:
       *                   - {Func} sign (data, cb)
       * @return {RequestSigner}
       */
      createSigner: function createSigner(options) {
        return new RequestSigner(options);
      },
      /**
       * Adds an 'Authorization' header to an http.ClientRequest object.
       *
       * Note that this API will add a Date header if it's not already set. Any
       * other headers in the options.headers array MUST be present, or this
       * will throw.
       *
       * You shouldn't need to check the return type; it's just there if you want
       * to be pedantic.
       *
       * The optional flag indicates whether parsing should use strict enforcement
       * of the version draft-cavage-http-signatures-04 of the spec or beyond.
       * The default is to be loose and support
       * older versions for compatibility.
       *
       * @param {Object} request an instance of http.ClientRequest.
       * @param {Object} options signing parameters object:
       *                   - {String} keyId required.
       *                   - {String} key required (either a PEM or HMAC key).
       *                   - {Array} headers optional; defaults to ['date'].
       *                   - {String} algorithm optional (unless key is HMAC);
       *                              default is the same as the sshpk default
       *                              signing algorithm for the type of key given
       *                   - {String} httpVersion optional; defaults to '1.1'.
       *                   - {Boolean} strict optional; defaults to 'false'.
       * @return {Boolean} true if Authorization (and optionally Date) were added.
       * @throws {TypeError} on bad parameter types (input).
       * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
       *                                 the given key.
       * @throws {sshpk.KeyParseError} if key was bad.
       * @throws {MissingHeaderError} if a header to be signed was specified but
       *                              was not present.
       */
      signRequest: function signRequest(request2, options) {
        assert.object(request2, "request");
        assert.object(options, "options");
        assert.optionalString(options.algorithm, "options.algorithm");
        assert.string(options.keyId, "options.keyId");
        assert.optionalArrayOfString(options.headers, "options.headers");
        assert.optionalString(options.httpVersion, "options.httpVersion");
        if (!request2.getHeader("Date"))
          request2.setHeader("Date", jsprim.rfc1123(/* @__PURE__ */ new Date()));
        if (!options.headers)
          options.headers = ["date"];
        if (!options.httpVersion)
          options.httpVersion = "1.1";
        var alg = [];
        if (options.algorithm) {
          options.algorithm = options.algorithm.toLowerCase();
          alg = validateAlgorithm(options.algorithm);
        }
        var i;
        var stringToSign = "";
        for (i = 0; i < options.headers.length; i++) {
          if (typeof options.headers[i] !== "string")
            throw new TypeError("options.headers must be an array of Strings");
          var h = options.headers[i].toLowerCase();
          if (h === "request-line") {
            if (!options.strict) {
              stringToSign += request2.method + " " + request2.path + " HTTP/" + options.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            stringToSign += "(request-target): " + request2.method.toLowerCase() + " " + request2.path;
          } else {
            var value2 = request2.getHeader(h);
            if (value2 === void 0 || value2 === "") {
              throw new MissingHeaderError(h + " was not in the request");
            }
            stringToSign += h + ": " + value2;
          }
          if (i + 1 < options.headers.length)
            stringToSign += "\n";
        }
        if (request2.hasOwnProperty("_stringToSign")) {
          request2._stringToSign = stringToSign;
        }
        var signature;
        if (alg[0] === "hmac") {
          if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
            throw new TypeError("options.key must be a string or Buffer");
          var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
          hmac.update(stringToSign);
          signature = hmac.digest("base64");
        } else {
          var key = options.key;
          if (typeof key === "string" || Buffer.isBuffer(key))
            key = sshpk.parsePrivateKey(options.key);
          assert.ok(
            sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
            "options.key must be a sshpk.PrivateKey"
          );
          if (!PK_ALGOS[key.type]) {
            throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
          }
          if (alg[0] !== void 0 && key.type !== alg[0]) {
            throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
          }
          var signer = key.createSign(alg[1]);
          signer.update(stringToSign);
          var sigObj = signer.sign();
          if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
            throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
          }
          options.algorithm = key.type + "-" + sigObj.hashAlgorithm;
          signature = sigObj.toString();
          assert.notStrictEqual(signature, "", "empty signature produced");
        }
        var authzHeaderName = options.authorizationHeaderName || "Authorization";
        request2.setHeader(authzHeaderName, sprintf(
          AUTHZ_FMT,
          options.keyId,
          options.algorithm,
          options.headers.join(" "),
          signature
        ));
        return true;
      }
    };
  }
});

// node_modules/http-signature/lib/verify.js
var require_verify = __commonJS({
  "node_modules/http-signature/lib/verify.js"(exports, module) {
    var assert = require_assert();
    var crypto = __require("crypto");
    var sshpk = require_lib2();
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    module.exports = {
      /**
       * Verify RSA/DSA signature against public key.  You are expected to pass in
       * an object that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} pubkey RSA/DSA private key PEM.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       * @throws {InvalidAlgorithmError}
       */
      verifySignature: function verifySignature(parsedSignature, pubkey) {
        assert.object(parsedSignature, "parsedSignature");
        if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
          pubkey = sshpk.parseKey(pubkey);
        assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] === "hmac" || alg[0] !== pubkey.type)
          return false;
        var v = pubkey.createVerify(alg[1]);
        v.update(parsedSignature.signingString);
        return v.verify(parsedSignature.params.signature, "base64");
      },
      /**
       * Verify HMAC against shared secret.  You are expected to pass in an object
       * that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} secret HMAC shared secret.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       * @throws {InvalidAlgorithmError}
       */
      verifyHMAC: function verifyHMAC(parsedSignature, secret) {
        assert.object(parsedSignature, "parsedHMAC");
        assert.string(secret, "secret");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] !== "hmac")
          return false;
        var hashAlg = alg[1].toUpperCase();
        var hmac = crypto.createHmac(hashAlg, secret);
        hmac.update(parsedSignature.signingString);
        var h1 = crypto.createHmac(hashAlg, secret);
        h1.update(hmac.digest());
        h1 = h1.digest();
        var h2 = crypto.createHmac(hashAlg, secret);
        h2.update(new Buffer(parsedSignature.params.signature, "base64"));
        h2 = h2.digest();
        if (typeof h1 === "string")
          return h1 === h2;
        if (Buffer.isBuffer(h1) && !h1.equals)
          return h1.toString("binary") === h2.toString("binary");
        return h1.equals(h2);
      }
    };
  }
});

// node_modules/http-signature/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/http-signature/lib/index.js"(exports, module) {
    var parser = require_parser();
    var signer = require_signer();
    var verify = require_verify();
    var utils = require_utils2();
    module.exports = {
      parse: parser.parseRequest,
      parseRequest: parser.parseRequest,
      sign: signer.signRequest,
      signRequest: signer.signRequest,
      createSigner: signer.createSigner,
      isSigner: signer.isSigner,
      sshKeyToPEM: utils.sshKeyToPEM,
      sshKeyFingerprint: utils.fingerprint,
      pemToRsaSSHKey: utils.pemToRsaSSHKey,
      verify: verify.verifySignature,
      verifySignature: verify.verifySignature,
      verifyHMAC: verify.verifyHMAC
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module) {
    module.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type3) {
      if (!type3 || typeof type3 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type3);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type3) {
      if (!type3 || typeof type3 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type3);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path3) {
      if (!path3 || typeof path3 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path3).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type3) {
        var mime = db[type3];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type3] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type3;
        }
      });
    }
  }
});

// node_modules/caseless/index.js
var require_caseless = __commonJS({
  "node_modules/caseless/index.js"(exports, module) {
    function Caseless(dict) {
      this.dict = dict || {};
    }
    Caseless.prototype.set = function(name, value2, clobber) {
      if (typeof name === "object") {
        for (var i in name) {
          this.set(i, name[i], value2);
        }
      } else {
        if (typeof clobber === "undefined")
          clobber = true;
        var has2 = this.has(name);
        if (!clobber && has2)
          this.dict[has2] = this.dict[has2] + "," + value2;
        else
          this.dict[has2 || name] = value2;
        return has2;
      }
    };
    Caseless.prototype.has = function(name) {
      var keys4 = Object.keys(this.dict), name = name.toLowerCase();
      for (var i = 0; i < keys4.length; i++) {
        if (keys4[i].toLowerCase() === name)
          return keys4[i];
      }
      return false;
    };
    Caseless.prototype.get = function(name) {
      name = name.toLowerCase();
      var result, _key;
      var headers = this.dict;
      Object.keys(headers).forEach(function(key) {
        _key = key.toLowerCase();
        if (name === _key)
          result = headers[key];
      });
      return result;
    };
    Caseless.prototype.swap = function(name) {
      var has2 = this.has(name);
      if (has2 === name)
        return;
      if (!has2)
        throw new Error('There is no header than matches "' + name + '"');
      this.dict[name] = this.dict[has2];
      delete this.dict[has2];
    };
    Caseless.prototype.del = function(name) {
      var has2 = this.has(name);
      return delete this.dict[has2 || name];
    };
    module.exports = function(dict) {
      return new Caseless(dict);
    };
    module.exports.httpify = function(resp, headers) {
      var c = new Caseless(headers);
      resp.setHeader = function(key, value2, clobber) {
        if (typeof value2 === "undefined")
          return;
        return c.set(key, value2, clobber);
      };
      resp.hasHeader = function(key) {
        return c.has(key);
      };
      resp.getHeader = function(key) {
        return c.get(key);
      };
      resp.removeHeader = function(key) {
        return c.del(key);
      };
      resp.headers = c.dict;
      return c;
    };
  }
});

// node_modules/forever-agent/index.js
var require_forever_agent = __commonJS({
  "node_modules/forever-agent/index.js"(exports, module) {
    module.exports = ForeverAgent;
    ForeverAgent.SSL = ForeverAgentSSL;
    var util = __require("util");
    var Agent = __require("http").Agent;
    var net = __require("net");
    var tls = __require("tls");
    var AgentSSL = __require("https").Agent;
    function getConnectionName(host, port) {
      var name = "";
      if (typeof host === "string") {
        name = host + ":" + port;
      } else {
        name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
      }
      return name;
    }
    function ForeverAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.requests = {};
      self2.sockets = {};
      self2.freeSockets = {};
      self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
      self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
      self2.on("free", function(socket, host, port) {
        var name = getConnectionName(host, port);
        if (self2.requests[name] && self2.requests[name].length) {
          self2.requests[name].shift().onSocket(socket);
        } else if (self2.sockets[name].length < self2.minSockets) {
          if (!self2.freeSockets[name])
            self2.freeSockets[name] = [];
          self2.freeSockets[name].push(socket);
          var onIdleError = function() {
            socket.destroy();
          };
          socket._onIdleError = onIdleError;
          socket.on("error", onIdleError);
        } else {
          socket.destroy();
        }
      });
    }
    util.inherits(ForeverAgent, Agent);
    ForeverAgent.defaultMinSockets = 5;
    ForeverAgent.prototype.createConnection = net.createConnection;
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port);
      if (typeof host !== "string") {
        var options = host;
        port = options.port;
        host = options.host;
      }
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop();
        idleSocket.removeListener("error", idleSocket._onIdleError);
        delete idleSocket._onIdleError;
        req._reusedSocket = true;
        req.onSocket(idleSocket);
      } else {
        this.addRequestNoreuse(req, host, port);
      }
    };
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index2 = this.sockets[name].indexOf(s);
        if (index2 !== -1) {
          this.sockets[name].splice(index2, 1);
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        delete this.sockets[name];
        delete this.requests[name];
      }
      if (this.freeSockets[name]) {
        var index2 = this.freeSockets[name].indexOf(s);
        if (index2 !== -1) {
          this.freeSockets[name].splice(index2, 1);
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name];
          }
        }
      }
      if (this.requests[name] && this.requests[name].length) {
        this.createSocket(name, host, port).emit("free");
      }
    };
    function ForeverAgentSSL(options) {
      ForeverAgent.call(this, options);
    }
    util.inherits(ForeverAgentSSL, ForeverAgent);
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
    function createConnectionSSL(port, host, options) {
      if (typeof port === "object") {
        options = port;
      } else if (typeof host === "object") {
        options = host;
      } else if (typeof options === "object") {
        options = options;
      } else {
        options = {};
      }
      if (typeof port === "number") {
        options.port = port;
      }
      if (typeof host === "string") {
        options.host = host;
      }
      return tls.connect(options);
    }
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    var Stream = __require("stream").Stream;
    var util = __require("util");
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    var util = __require("util");
    var Stream = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value2 = stream;
      this.write(value2);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data3) {
      this.emit("data", data3);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module) {
    module.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async3 = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module) {
    var defer = require_defer();
    module.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module) {
    module.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate2 = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module) {
    var async = require_async3();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list2, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list2[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module) {
    module.exports = state;
    function state(list2, sortMethod) {
      var isNamedList = !Array.isArray(list2), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list2).length : list2.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list2[a], list2[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module) {
    var abort = require_abort();
    var async = require_async3();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module) {
    var iterate = require_iterate2();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list2, iterator, callback) {
      var state = initState(list2);
      while (state.index < (state["keyedList"] || list2).length) {
        iterate(list2, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module) {
    var iterate = require_iterate2();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list2, iterator, sortMethod, callback) {
      var state = initState(list2, sortMethod);
      iterate(list2, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list2).length) {
          iterate(list2, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module) {
    var serialOrdered = require_serialOrdered();
    module.exports = serial;
    function serial(list2, iterator, callback) {
      return serialOrdered(list2, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module) {
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module) {
    module.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop2) {
        dst[prop2] = dst[prop2] || src[prop2];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module) {
    var CombinedStream = require_combined_stream();
    var util = __require("util");
    var path3 = __require("path");
    var http = __require("http");
    var https = __require("https");
    var parseUrl = __require("url").parse;
    var fs = __require("fs");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module.exports = FormData;
    util.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData();
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value2, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append3 = CombinedStream.prototype.append.bind(this);
      if (typeof value2 == "number") {
        value2 = "" + value2;
      }
      if (util.isArray(value2)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value2, options);
      var footer = this._multiPartFooter();
      append3(header);
      append3(value2);
      append3(footer);
      this._trackLength(header, value2, options);
    };
    FormData.prototype._trackLength = function(header, value2, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value2)) {
        valueLength = value2.length;
      } else if (typeof value2 === "string") {
        valueLength = Buffer.byteLength(value2);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value2 || !value2.path && !(value2.readable && value2.hasOwnProperty("httpVersion"))) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value2);
      }
    };
    FormData.prototype._lengthRetriever = function(value2, callback) {
      if (value2.hasOwnProperty("fd")) {
        if (value2.end != void 0 && value2.end != Infinity && value2.start != void 0) {
          callback(null, value2.end + 1 - (value2.start ? value2.start : 0));
        } else {
          fs.stat(value2.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value2.start ? value2.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value2.hasOwnProperty("httpVersion")) {
        callback(null, +value2.headers["content-length"]);
      } else if (value2.hasOwnProperty("httpModule")) {
        value2.on("response", function(response2) {
          value2.pause();
          callback(null, +response2.headers["content-length"]);
        });
        value2.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value2, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value2, options);
      var contentType = this._getContentType(value2, options);
      var contents2 = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop2 in headers) {
        if (!headers.hasOwnProperty(prop2))
          continue;
        header = headers[prop2];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents2 += prop2 + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents2 + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value2, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path3.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value2.name || value2.path) {
        filename = path3.basename(options.filename || value2.name || value2.path);
      } else if (value2.readable && value2.hasOwnProperty("httpVersion")) {
        filename = path3.basename(value2.client._httpMessage.path);
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value2, options) {
      var contentType = options.contentType;
      if (!contentType && value2.name) {
        contentType = mime.lookup(value2.name);
      }
      if (!contentType && value2.path) {
        contentType = mime.lookup(value2.path);
      }
      if (!contentType && value2.readable && value2.hasOwnProperty("httpVersion")) {
        contentType = value2.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value2 == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next2) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next2(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values3) {
        if (err) {
          cb(err);
          return;
        }
        values3.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request2, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request2 = https.request(options);
      } else {
        request2 = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err) {
          this._error(err);
          return;
        }
        request2.setHeader("Content-Length", length);
        this.pipe(request2);
        if (cb) {
          request2.on("error", cb);
          request2.on("response", cb.bind(this, null));
        }
      }.bind(this));
      return request2;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS({
  "node_modules/isstream/isstream.js"(exports, module) {
    var stream = __require("stream");
    function isStream(obj) {
      return obj instanceof stream.Stream;
    }
    function isReadable(obj) {
      return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
    }
    function isWritable(obj) {
      return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
    }
    function isDuplex(obj) {
      return isReadable(obj) && isWritable(obj);
    }
    module.exports = isStream;
    module.exports.isReadable = isReadable;
    module.exports.isWritable = isWritable;
    module.exports.isDuplex = isDuplex;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString3 = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString3.call(arr)];
    }
  }
});

// node_modules/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS({
  "node_modules/request/lib/getProxyFromURI.js"(exports, module) {
    "use strict";
    function formatHostname(hostname) {
      return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
      zone = zone.trim().toLowerCase();
      var zoneParts = zone.split(":", 2);
      var zoneHost = formatHostname(zoneParts[0]);
      var zonePort = zoneParts[1];
      var hasPort = zone.indexOf(":") > -1;
      return { hostname: zoneHost, port: zonePort, hasPort };
    }
    function uriInNoProxy(uri, noProxy) {
      var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
      var hostname = formatHostname(uri.hostname);
      var noProxyList = noProxy.split(",");
      return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
        var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
        var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
        if (noProxyZone.hasPort) {
          return port === noProxyZone.port && hostnameMatched;
        }
        return hostnameMatched;
      });
    }
    function getProxyFromURI(uri) {
      var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
      if (noProxy === "*") {
        return null;
      }
      if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
        return null;
      }
      if (uri.protocol === "http:") {
        return process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      if (uri.protocol === "https:") {
        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      return null;
    }
    module.exports = getProxyFromURI;
  }
});

// node_modules/qs/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      var obj;
      while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];
        if (Array.isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
      return obj;
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (Array.isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has2.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function(item, i) {
          if (has2.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value2 = source[key];
        if (has2.call(acc, key)) {
          acc[key] = merge4(acc[key], value2, options);
        } else {
          acc[key] = value2;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, " "));
      } catch (e) {
        return str;
      }
    };
    var encode = function encode2(str) {
      if (str.length === 0) {
        return str;
      }
      var string = typeof str === "string" ? str : String(str);
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value2) {
      var queue = [{ obj: { o: value2 }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys4 = Object.keys(obj);
        for (var j = 0; j < keys4.length; ++j) {
          var key = keys4[j];
          var val2 = obj[key];
          if (typeof val2 === "object" && val2 !== null && refs.indexOf(val2) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val2);
          }
        }
      }
      return compactQueue(queue);
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    module.exports = {
      arrayToObject,
      assign,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      merge: merge3
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    module.exports = {
      "default": "RFC3986",
      formatters: {
        RFC1738: function(value2) {
          return replace.call(value2, percentTwenties, "+");
        },
        RFC3986: function(value2) {
          return String(value2);
        }
      },
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var formats = require_formats();
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaults = {
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var stringify2 = function stringify3(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter4, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
      var obj = object;
      if (typeof filter4 === "function") {
        obj = filter4(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }
        obj = "";
      }
      if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values3 = [];
      if (typeof obj === "undefined") {
        return values3;
      }
      var objKeys;
      if (isArray(filter4)) {
        objKeys = filter4;
      } else {
        var keys4 = Object.keys(obj);
        objKeys = sort ? keys4.sort(sort) : keys4;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        if (isArray(obj)) {
          pushToArray(values3, stringify3(
            obj[key],
            generateArrayPrefix(prefix, key),
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter4,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
          ));
        } else {
          pushToArray(values3, stringify3(
            obj[key],
            prefix + (allowDots ? "." + key : "[" + key + "]"),
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter4,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
          ));
        }
      }
      return values3;
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = opts ? utils.assign({}, opts) : {};
      if (options.encoder !== null && typeof options.encoder !== "undefined" && typeof options.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
      var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
      var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
      var encoder = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
      var sort = typeof options.sort === "function" ? options.sort : null;
      var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
      var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
      var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
      if (typeof options.format === "undefined") {
        options.format = formats["default"];
      } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      var formatter = formats.formatters[options.format];
      var objKeys;
      var filter4;
      if (typeof options.filter === "function") {
        filter4 = options.filter;
        obj = filter4("", obj);
      } else if (isArray(options.filter)) {
        filter4 = options.filter;
        objKeys = filter4;
      }
      var keys4 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
      } else if ("indices" in options) {
        arrayFormat = options.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (sort) {
        objKeys.sort(sort);
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys4, stringify2(
          obj[key],
          key,
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encode ? encoder : null,
          filter4,
          sort,
          allowDots,
          serializeDate,
          formatter,
          encodeValuesOnly
        ));
      }
      var joined = keys4.join(delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var has2 = Object.prototype.hasOwnProperty;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      parameterLimit: 1e3,
      plainObjects: false,
      strictNullHandling: false
    };
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val2;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder);
          val2 = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder);
          val2 = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has2.call(obj, key)) {
          obj[key] = [].concat(obj[key]).concat(val2);
        } else {
          obj[key] = val2;
        }
      }
      return obj;
    };
    var parseObject = function(chain3, val2, options) {
      var leaf = val2;
      for (var i = chain3.length - 1; i >= 0; --i) {
        var obj;
        var root3 = chain3[i];
        if (root3 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root3.charAt(0) === "[" && root3.charAt(root3.length - 1) === "]" ? root3.slice(1, -1) : root3;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root3 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val2, options) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent2 = segment ? key.slice(0, segment.index) : key;
      var keys4 = [];
      if (parent2) {
        if (!options.plainObjects && has2.call(Object.prototype, parent2)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys4.push(parent2);
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has2.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys4.push(segment[1]);
      }
      if (segment) {
        keys4.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys4, val2, options);
    };
    module.exports = function(str, opts) {
      var options = opts ? utils.assign({}, opts) : {};
      if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
      options.delimiter = typeof options.delimiter === "string" || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
      options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
      options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
      options.parseArrays = options.parseArrays !== false;
      options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
      options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
      options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
      options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
      options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
      options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys4 = Object.keys(tempObj);
      for (var i = 0; i < keys4.length; ++i) {
        var key = keys4[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify3();
    var parse9 = require_parse2();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse9,
      stringify: stringify2
    };
  }
});

// node_modules/request/lib/querystring.js
var require_querystring = __commonJS({
  "node_modules/request/lib/querystring.js"(exports) {
    "use strict";
    var qs3 = require_lib4();
    var querystring = __require("querystring");
    function Querystring(request2) {
      this.request = request2;
      this.lib = null;
      this.useQuerystring = null;
      this.parseOptions = null;
      this.stringifyOptions = null;
    }
    Querystring.prototype.init = function(options) {
      if (this.lib) {
        return;
      }
      this.useQuerystring = options.useQuerystring;
      this.lib = this.useQuerystring ? querystring : qs3;
      this.parseOptions = options.qsParseOptions || {};
      this.stringifyOptions = options.qsStringifyOptions || {};
    };
    Querystring.prototype.stringify = function(obj) {
      return this.useQuerystring ? this.rfc3986(this.lib.stringify(
        obj,
        this.stringifyOptions.sep || null,
        this.stringifyOptions.eq || null,
        this.stringifyOptions
      )) : this.lib.stringify(obj, this.stringifyOptions);
    };
    Querystring.prototype.parse = function(str) {
      return this.useQuerystring ? this.lib.parse(
        str,
        this.parseOptions.sep || null,
        this.parseOptions.eq || null,
        this.parseOptions
      ) : this.lib.parse(str, this.parseOptions);
    };
    Querystring.prototype.rfc3986 = function(str) {
      return str.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    };
    Querystring.prototype.unescape = querystring.unescape;
    exports.Querystring = Querystring;
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge3() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray2(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge3(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge3(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge3(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge3(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge3(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge3(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge3(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge3(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge3(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge3("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge3("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge3("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge3("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge3("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge3("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge3("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge3("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge3("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge3("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type3) {
        throw new RangeError(errors[type3]);
      }
      function map4(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map4(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value2 = string.charCodeAt(counter++);
          if (value2 >= 55296 && value2 <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value2);
              counter--;
            }
          } else {
            output.push(value2);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index2 >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q2 = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t) {
                    break;
                  }
                  var qMinusT = q2 - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q2 = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches2 = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches2, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches2 = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches2, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last2 = _address$toLowerCase$2[0], first2 = _address$toLowerCase$2[1];
          var firstFields = first2 ? first2.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last2.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index2) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index2) {
                lastLongest.length++;
              } else {
                acc.push({ index: index2, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse9(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches2 = uriString.match(URI_PARSE);
        if (matches2) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches2[1];
            components.userinfo = matches2[3];
            components.host = matches2[4];
            components.port = parseInt(matches2[5], 10);
            components.path = matches2[6] || "";
            components.query = matches2[7];
            components.fragment = matches2[8];
            if (isNaN(components.port)) {
              components.port = matches2[5];
            }
          } else {
            components.scheme = matches2[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches2[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches2[4] : void 0;
            components.port = parseInt(matches2[5], 10);
            components.path = matches2[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches2[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches2[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches2[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize3(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse9(serialize3(base2, options), options);
          relative = parse9(serialize3(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize3(resolveComponents(parse9(baseURI, schemelessOptions), parse9(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize3(parse9(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse9(serialize3(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize3(parse9(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize3(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize3(parse9(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize3(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse10(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize4(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse10(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize4(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path3 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path3 && path3 !== "/" ? path3 : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge3(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge3("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge3("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray2(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches2 = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches2) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches2[1].toLowerCase();
            var nss = matches2[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse10(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize4(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse9;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize3;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys4;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys4 = Object.keys(a);
        length = keys4.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys4[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys4[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
    "use strict";
    module.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value2;
      while (pos < len) {
        length++;
        value2 = str.charCodeAt(pos++);
        if (value2 >= 55296 && value2 <= 56319 && pos < len) {
          value2 = str.charCodeAt(pos);
          if ((value2 & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// node_modules/ajv/lib/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv/lib/compile/util.js"(exports, module) {
    "use strict";
    module.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data3, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data3 + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data3 + ")";
        case "object":
          return "(" + OK + data3 + AND + "typeof " + data3 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data3 + "))";
        case "integer":
          return "(typeof " + data3 + EQUAL + '"number"' + AND + NOT + "(" + data3 + " % 1)" + AND + data3 + EQUAL + data3 + (strictNumbers ? AND + OK + "isFinite(" + data3 + ")" : "") + ")";
        case "number":
          return "(typeof " + data3 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data3 + ")" : "") + ")";
        default:
          return "typeof " + data3 + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data3, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data3, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data3 + " || ";
            code += "typeof " + data3 + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data3, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches2 = str.match(new RegExp(dataVar, "g"));
      return matches2 ? matches2.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber3) {
      var path3 = jsonPointers ? "'/' + " + expr + (isNumber3 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber3 ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path3);
    }
    function getPath(currentPath, prop2, jsonPointers) {
      var path3 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop2)) : toQuotedString(getProperty(prop2));
      return joinPaths(currentPath, path3);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths3) {
      var up, jsonPointer, data3, matches2;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data3 = "rootData";
      } else {
        matches2 = $data.match(RELATIVE_JSON_POINTER);
        if (!matches2)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches2[1];
        jsonPointer = matches2[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths3[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data3 = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data3;
      }
      var expr = data3;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data3 += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data3;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
    "use strict";
    var util = require_util2();
    module.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop2 in sch)
                _traverse(opts, pre, post, sch[prop2], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop2), rootSchema, jsonPtr, key, schema, prop2);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/lib/compile/resolve.js"(exports, module) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util2();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile4, root3, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile4, root3, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root3, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root3 = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile4.call(this, schema.schema, root3, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile4.call(this, schema, root3, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root3, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root3.schema));
      if (Object.keys(root3.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root3, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root3 = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root: root3, baseId };
            root3 = refVal;
          } else {
            return;
          }
        }
        if (!root3.schema)
          return;
        baseId = getFullPath(this._getId(root3.schema));
      }
      return getJsonPointer.call(this, p, baseId, root3.schema, root3);
    }
    function resolveRecursive(root3, ref, parsedRef) {
      var res = resolveSchema.call(this, root3, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root3 = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root3);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root3) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root3, $ref);
              if (res) {
                schema = res.schema;
                root3 = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root3.schema)
        return { schema, root: root3, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data3, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys4 = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys4.length; i++) {
          var key = keys4[i];
          var value2 = stringify2(node[key]);
          if (!value2)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value2;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data3);
    };
  }
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate2 = __commonJS({
  "node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
    "use strict";
    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/lib/compile/index.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    var util = require_util2();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate2();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module.exports = compile4;
    function compile4(schema, root3, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root3 = root3 || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root3, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root3, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root3, baseId);
      }
      function callValidate() {
        var validate3 = compilation.validate;
        var result = validate3.apply(this, arguments);
        callValidate.errors = validate3.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root3.schema)
          return compile4.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate3;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate3 = makeValidate(
            self2,
            RULES,
            formats,
            root3,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate3;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate3.schema = _schema;
        validate3.errors = null;
        validate3.refs = refs;
        validate3.refVal = refVal;
        validate3.root = isRoot ? validate3 : _root;
        if ($async)
          validate3.$async = true;
        if (opts.sourceCode === true) {
          validate3.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate3;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root3.refs) {
          var rootRefId = root3.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root3.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root3, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile4.call(self2, localSchema, root3, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index2 = patternsHash[regexStr];
        if (index2 === void 0) {
          index2 = patternsHash[regexStr] = patterns.length;
          patterns[index2] = regexStr;
        }
        return "pattern" + index2;
      }
      function useDefault(value2) {
        switch (typeof value2) {
          case "boolean":
          case "number":
            return "" + value2;
          case "string":
            return util.toQuotedString(value2);
          case "object":
            if (value2 === null)
              return "null";
            var valueStr = stableStringify(value2);
            var index2 = defaultsHash[valueStr];
            if (index2 === void 0) {
              index2 = defaultsHash[valueStr] = defaults.length;
              defaults[index2] = value2;
            }
            return "default" + index2;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log")
                self2.logger.error(message);
              else
                throw new Error(message);
            }
          }
        }
        var compile5 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate3;
        if (compile5) {
          validate3 = compile5.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate3 = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate3, true);
        } else if (inline) {
          validate3 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate3 = rule.definition.validate;
          if (!validate3)
            return;
        }
        if (validate3 === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index2 = customRules.length;
        customRules[index2] = validate3;
        return {
          code: "customRule" + index2,
          validate: validate3
        };
      }
    }
    function checkCompiling(schema, root3, baseId) {
      var index2 = compIndex.call(this, schema, root3, baseId);
      if (index2 >= 0)
        return { index: index2, compiling: true };
      index2 = this._compilations.length;
      this._compilations[index2] = {
        schema,
        root: root3,
        baseId
      };
      return { index: index2, compiling: false };
    }
    function endCompiling(schema, root3, baseId) {
      var i = compIndex.call(this, schema, root3, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root3, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root3 && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "node_modules/ajv/lib/cache.js"(exports, module) {
    "use strict";
    var Cache = module.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value2) {
      this._cache[key] = value2;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS({
  "node_modules/ajv/lib/compile/formats.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches2 = str.match(DATE);
      if (!matches2)
        return false;
      var year = +matches2[1];
      var month = +matches2[2];
      var day = +matches2[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches2 = str.match(TIME);
      if (!matches2)
        return false;
      var hour = matches2[1];
      var minute = matches2[2];
      var second = matches2[3];
      var timeZone = matches2[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
    "use strict";
    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
    "use strict";
    module.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "node_modules/ajv/lib/dotjs/const.js"(exports, module) {
    "use strict";
    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains2 = __commonJS({
  "node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
    "use strict";
    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
    "use strict";
    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
    "use strict";
    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "node_modules/ajv/lib/dotjs/format.js"(exports, module) {
    "use strict";
    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "node_modules/ajv/lib/dotjs/if.js"(exports, module) {
    "use strict";
    module.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "node_modules/ajv/lib/dotjs/items.js"(exports, module) {
    "use strict";
    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
    "use strict";
    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "node_modules/ajv/lib/dotjs/not.js"(exports, module) {
    "use strict";
    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
    "use strict";
    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
    "use strict";
    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
    "use strict";
    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "node_modules/ajv/lib/dotjs/required.js"(exports, module) {
    "use strict";
    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
    "use strict";
    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "node_modules/ajv/lib/dotjs/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains2(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate2()
    };
  }
});

// node_modules/ajv/lib/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/ajv/lib/compile/rules.js"(exports, module) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util2().toHash;
    module.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "node_modules/ajv/lib/data.js"(exports, module) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// node_modules/ajv/lib/compile/async.js
var require_async4 = __commonJS({
  "node_modules/ajv/lib/compile/async.js"(exports, module) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom2 = __commonJS({
  "node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
    "use strict";
    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "node_modules/ajv/lib/definition_schema.js"(exports, module) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/lib/keyword.js"(exports, module) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom2();
    var definitionSchema = require_definition_schema();
    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv/lib/refs/data.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/lib/ajv.js"(exports, module) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats2();
    var rules = require_rules2();
    var $dataMetaSchema = require_data();
    var util = require_util2();
    module.exports = Ajv;
    Ajv.prototype.validate = validate3;
    Ajv.prototype.compile = compile4;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async4();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate3(schemaKeyRef, data3) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data3);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile4(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root3 = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root3, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root: root3,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize3 = this._opts.serialize;
          var cacheKey = serialize3 ? serialize3(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize3 = this._opts.serialize;
      var cacheKey = serialize3 ? serialize3(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root3) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root3 ? root3 : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root3, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text3 = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text3 += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text3.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0)
          logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// node_modules/har-validator/lib/error.js
var require_error = __commonJS({
  "node_modules/har-validator/lib/error.js"(exports, module) {
    function HARError(errors) {
      var message = "validation failed";
      this.name = "HARError";
      this.message = message;
      this.errors = errors;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
    HARError.prototype = Error.prototype;
    module.exports = HARError;
  }
});

// node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS({
  "node_modules/har-schema/lib/afterRequest.json"(exports, module) {
    module.exports = {
      $id: "afterRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS({
  "node_modules/har-schema/lib/beforeRequest.json"(exports, module) {
    module.exports = {
      $id: "beforeRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/browser.json
var require_browser2 = __commonJS({
  "node_modules/har-schema/lib/browser.json"(exports, module) {
    module.exports = {
      $id: "browser.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS({
  "node_modules/har-schema/lib/cache.json"(exports, module) {
    module.exports = {
      $id: "cache.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      properties: {
        beforeRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "beforeRequest.json#" }
          ]
        },
        afterRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "afterRequest.json#" }
          ]
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/content.json
var require_content = __commonJS({
  "node_modules/har-schema/lib/content.json"(exports, module) {
    module.exports = {
      $id: "content.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "size",
        "mimeType"
      ],
      properties: {
        size: {
          type: "integer"
        },
        compression: {
          type: "integer"
        },
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        encoding: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS({
  "node_modules/har-schema/lib/cookie.json"(exports, module) {
    module.exports = {
      $id: "cookie.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        path: {
          type: "string"
        },
        domain: {
          type: "string"
        },
        expires: {
          type: ["string", "null"],
          format: "date-time"
        },
        httpOnly: {
          type: "boolean"
        },
        secure: {
          type: "boolean"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/creator.json
var require_creator = __commonJS({
  "node_modules/har-schema/lib/creator.json"(exports, module) {
    module.exports = {
      $id: "creator.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/entry.json
var require_entry = __commonJS({
  "node_modules/har-schema/lib/entry.json"(exports, module) {
    module.exports = {
      $id: "entry.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "time",
        "request",
        "response",
        "cache",
        "timings"
      ],
      properties: {
        pageref: {
          type: "string"
        },
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        time: {
          type: "number",
          min: 0
        },
        request: {
          $ref: "request.json#"
        },
        response: {
          $ref: "response.json#"
        },
        cache: {
          $ref: "cache.json#"
        },
        timings: {
          $ref: "timings.json#"
        },
        serverIPAddress: {
          type: "string",
          oneOf: [
            { format: "ipv4" },
            { format: "ipv6" }
          ]
        },
        connection: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/har.json
var require_har = __commonJS({
  "node_modules/har-schema/lib/har.json"(exports, module) {
    module.exports = {
      $id: "har.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "log"
      ],
      properties: {
        log: {
          $ref: "log.json#"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/header.json
var require_header = __commonJS({
  "node_modules/har-schema/lib/header.json"(exports, module) {
    module.exports = {
      $id: "header.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/log.json
var require_log = __commonJS({
  "node_modules/har-schema/lib/log.json"(exports, module) {
    module.exports = {
      $id: "log.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "version",
        "creator",
        "entries"
      ],
      properties: {
        version: {
          type: "string"
        },
        creator: {
          $ref: "creator.json#"
        },
        browser: {
          $ref: "browser.json#"
        },
        pages: {
          type: "array",
          items: {
            $ref: "page.json#"
          }
        },
        entries: {
          type: "array",
          items: {
            $ref: "entry.json#"
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/page.json
var require_page = __commonJS({
  "node_modules/har-schema/lib/page.json"(exports, module) {
    module.exports = {
      $id: "page.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "id",
        "title",
        "pageTimings"
      ],
      properties: {
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        id: {
          type: "string",
          unique: true
        },
        title: {
          type: "string"
        },
        pageTimings: {
          $ref: "pageTimings.json#"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS({
  "node_modules/har-schema/lib/pageTimings.json"(exports, module) {
    module.exports = {
      $id: "pageTimings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      properties: {
        onContentLoad: {
          type: "number",
          min: -1
        },
        onLoad: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/postData.json
var require_postData = __commonJS({
  "node_modules/har-schema/lib/postData.json"(exports, module) {
    module.exports = {
      $id: "postData.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "mimeType"
      ],
      properties: {
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        params: {
          type: "array",
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            value: {
              type: "string"
            },
            fileName: {
              type: "string"
            },
            contentType: {
              type: "string"
            },
            comment: {
              type: "string"
            }
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/query.json
var require_query = __commonJS({
  "node_modules/har-schema/lib/query.json"(exports, module) {
    module.exports = {
      $id: "query.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/request.json
var require_request = __commonJS({
  "node_modules/har-schema/lib/request.json"(exports, module) {
    module.exports = {
      $id: "request.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "method",
        "url",
        "httpVersion",
        "cookies",
        "headers",
        "queryString",
        "headersSize",
        "bodySize"
      ],
      properties: {
        method: {
          type: "string"
        },
        url: {
          type: "string",
          format: "uri"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        queryString: {
          type: "array",
          items: {
            $ref: "query.json#"
          }
        },
        postData: {
          $ref: "postData.json#"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/response.json
var require_response = __commonJS({
  "node_modules/har-schema/lib/response.json"(exports, module) {
    module.exports = {
      $id: "response.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "status",
        "statusText",
        "httpVersion",
        "cookies",
        "headers",
        "content",
        "redirectURL",
        "headersSize",
        "bodySize"
      ],
      properties: {
        status: {
          type: "integer"
        },
        statusText: {
          type: "string"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        content: {
          $ref: "content.json#"
        },
        redirectURL: {
          type: "string"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/timings.json
var require_timings = __commonJS({
  "node_modules/har-schema/lib/timings.json"(exports, module) {
    module.exports = {
      $id: "timings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      required: [
        "send",
        "wait",
        "receive"
      ],
      properties: {
        dns: {
          type: "number",
          min: -1
        },
        connect: {
          type: "number",
          min: -1
        },
        blocked: {
          type: "number",
          min: -1
        },
        send: {
          type: "number",
          min: -1
        },
        wait: {
          type: "number",
          min: -1
        },
        receive: {
          type: "number",
          min: -1
        },
        ssl: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/har-schema/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      afterRequest: require_afterRequest(),
      beforeRequest: require_beforeRequest(),
      browser: require_browser2(),
      cache: require_cache2(),
      content: require_content(),
      cookie: require_cookie2(),
      creator: require_creator(),
      entry: require_entry(),
      har: require_har(),
      header: require_header(),
      log: require_log(),
      page: require_page(),
      pageTimings: require_pageTimings(),
      postData: require_postData(),
      query: require_query(),
      request: require_request(),
      response: require_response(),
      timings: require_timings()
    };
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS({
  "node_modules/ajv/lib/refs/json-schema-draft-06.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-06/schema#",
      $id: "http://json-schema.org/draft-06/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        examples: {
          type: "array",
          items: {}
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: {}
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: {},
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: {}
    };
  }
});

// node_modules/har-validator/lib/promise.js
var require_promise2 = __commonJS({
  "node_modules/har-validator/lib/promise.js"(exports) {
    var Ajv = require_ajv();
    var HARError = require_error();
    var schemas = require_lib5();
    var ajv;
    function createAjvInstance() {
      var ajv2 = new Ajv({
        allErrors: true
      });
      ajv2.addMetaSchema(require_json_schema_draft_06());
      ajv2.addSchema(schemas);
      return ajv2;
    }
    function validate3(name, data3) {
      data3 = data3 || {};
      ajv = ajv || createAjvInstance();
      var validate4 = ajv.getSchema(name + ".json");
      return new Promise(function(resolve, reject) {
        var valid = validate4(data3);
        !valid ? reject(new HARError(validate4.errors)) : resolve(data3);
      });
    }
    exports.afterRequest = function(data3) {
      return validate3("afterRequest", data3);
    };
    exports.beforeRequest = function(data3) {
      return validate3("beforeRequest", data3);
    };
    exports.browser = function(data3) {
      return validate3("browser", data3);
    };
    exports.cache = function(data3) {
      return validate3("cache", data3);
    };
    exports.content = function(data3) {
      return validate3("content", data3);
    };
    exports.cookie = function(data3) {
      return validate3("cookie", data3);
    };
    exports.creator = function(data3) {
      return validate3("creator", data3);
    };
    exports.entry = function(data3) {
      return validate3("entry", data3);
    };
    exports.har = function(data3) {
      return validate3("har", data3);
    };
    exports.header = function(data3) {
      return validate3("header", data3);
    };
    exports.log = function(data3) {
      return validate3("log", data3);
    };
    exports.page = function(data3) {
      return validate3("page", data3);
    };
    exports.pageTimings = function(data3) {
      return validate3("pageTimings", data3);
    };
    exports.postData = function(data3) {
      return validate3("postData", data3);
    };
    exports.query = function(data3) {
      return validate3("query", data3);
    };
    exports.request = function(data3) {
      return validate3("request", data3);
    };
    exports.response = function(data3) {
      return validate3("response", data3);
    };
    exports.timings = function(data3) {
      return validate3("timings", data3);
    };
  }
});

// node_modules/request/lib/har.js
var require_har2 = __commonJS({
  "node_modules/request/lib/har.js"(exports) {
    "use strict";
    var fs = __require("fs");
    var qs3 = __require("querystring");
    var validate3 = require_promise2();
    var extend = require_extend();
    function Har(request2) {
      this.request = request2;
    }
    Har.prototype.reducer = function(obj, pair) {
      if (obj[pair.name] === void 0) {
        obj[pair.name] = pair.value;
        return obj;
      }
      var arr = [
        obj[pair.name],
        pair.value
      ];
      obj[pair.name] = arr;
      return obj;
    };
    Har.prototype.prep = function(data3) {
      data3.queryObj = {};
      data3.headersObj = {};
      data3.postData.jsonObj = false;
      data3.postData.paramsObj = false;
      if (data3.queryString && data3.queryString.length) {
        data3.queryObj = data3.queryString.reduce(this.reducer, {});
      }
      if (data3.headers && data3.headers.length) {
        data3.headersObj = data3.headers.reduceRight(function(headers, header) {
          headers[header.name] = header.value;
          return headers;
        }, {});
      }
      if (data3.cookies && data3.cookies.length) {
        var cookies = data3.cookies.map(function(cookie) {
          return cookie.name + "=" + cookie.value;
        });
        if (cookies.length) {
          data3.headersObj.cookie = cookies.join("; ");
        }
      }
      function some2(arr) {
        return arr.some(function(type3) {
          return data3.postData.mimeType.indexOf(type3) === 0;
        });
      }
      if (some2([
        "multipart/mixed",
        "multipart/related",
        "multipart/form-data",
        "multipart/alternative"
      ])) {
        data3.postData.mimeType = "multipart/form-data";
      } else if (some2([
        "application/x-www-form-urlencoded"
      ])) {
        if (!data3.postData.params) {
          data3.postData.text = "";
        } else {
          data3.postData.paramsObj = data3.postData.params.reduce(this.reducer, {});
          data3.postData.text = qs3.stringify(data3.postData.paramsObj);
        }
      } else if (some2([
        "text/json",
        "text/x-json",
        "application/json",
        "application/x-json"
      ])) {
        data3.postData.mimeType = "application/json";
        if (data3.postData.text) {
          try {
            data3.postData.jsonObj = JSON.parse(data3.postData.text);
          } catch (e) {
            this.request.debug(e);
            data3.postData.mimeType = "text/plain";
          }
        }
      }
      return data3;
    };
    Har.prototype.options = function(options) {
      if (!options.har) {
        return options;
      }
      var har = {};
      extend(har, options.har);
      if (har.log && har.log.entries) {
        har = har.log.entries[0];
      }
      har.url = har.url || options.url || options.uri || options.baseUrl || "/";
      har.httpVersion = har.httpVersion || "HTTP/1.1";
      har.queryString = har.queryString || [];
      har.headers = har.headers || [];
      har.cookies = har.cookies || [];
      har.postData = har.postData || {};
      har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
      har.bodySize = 0;
      har.headersSize = 0;
      har.postData.size = 0;
      if (!validate3.request(har)) {
        return options;
      }
      var req = this.prep(har);
      if (req.url) {
        options.url = req.url;
      }
      if (req.method) {
        options.method = req.method;
      }
      if (Object.keys(req.queryObj).length) {
        options.qs = req.queryObj;
      }
      if (Object.keys(req.headersObj).length) {
        options.headers = req.headersObj;
      }
      function test(type3) {
        return req.postData.mimeType.indexOf(type3) === 0;
      }
      if (test("application/x-www-form-urlencoded")) {
        options.form = req.postData.paramsObj;
      } else if (test("application/json")) {
        if (req.postData.jsonObj) {
          options.body = req.postData.jsonObj;
          options.json = true;
        }
      } else if (test("multipart/form-data")) {
        options.formData = {};
        req.postData.params.forEach(function(param) {
          var attachment = {};
          if (!param.fileName && !param.contentType) {
            options.formData[param.name] = param.value;
            return;
          }
          if (param.fileName && !param.value) {
            attachment.value = fs.createReadStream(param.fileName);
          } else if (param.value) {
            attachment.value = param.value;
          }
          if (param.fileName) {
            attachment.options = {
              filename: param.fileName,
              contentType: param.contentType ? param.contentType : null
            };
          }
          options.formData[param.name] = attachment;
        });
      } else {
        if (req.postData.text) {
          options.body = req.postData.text;
        }
      }
      return options;
    };
    exports.Har = Har;
  }
});

// node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/lib/rng.js"(exports, module) {
    var crypto = __require("crypto");
    module.exports = function nodeRNG() {
      return crypto.randomBytes(16);
    };
  }
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/request/lib/auth.js
var require_auth = __commonJS({
  "node_modules/request/lib/auth.js"(exports) {
    "use strict";
    var caseless = require_caseless();
    var uuid = require_v4();
    var helpers = require_helpers();
    var md5 = helpers.md5;
    var toBase64 = helpers.toBase64;
    function Auth(request2) {
      this.request = request2;
      this.hasAuth = false;
      this.sentAuth = false;
      this.bearerToken = null;
      this.user = null;
      this.pass = null;
    }
    Auth.prototype.basic = function(user, pass, sendImmediately) {
      var self2 = this;
      if (typeof user !== "string" || pass !== void 0 && typeof pass !== "string") {
        self2.request.emit("error", new Error("auth() received invalid user or password"));
      }
      self2.user = user;
      self2.pass = pass;
      self2.hasAuth = true;
      var header = user + ":" + (pass || "");
      if (sendImmediately || typeof sendImmediately === "undefined") {
        var authHeader = "Basic " + toBase64(header);
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.bearer = function(bearer, sendImmediately) {
      var self2 = this;
      self2.bearerToken = bearer;
      self2.hasAuth = true;
      if (sendImmediately || typeof sendImmediately === "undefined") {
        if (typeof bearer === "function") {
          bearer = bearer();
        }
        var authHeader = "Bearer " + (bearer || "");
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.digest = function(method, path3, authHeader) {
      var self2 = this;
      var challenge = {};
      var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
      while (true) {
        var match = re.exec(authHeader);
        if (!match) {
          break;
        }
        challenge[match[1]] = match[2] || match[3];
      }
      var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
        var ha12 = md5(user + ":" + realm + ":" + pass);
        if (algorithm && algorithm.toLowerCase() === "md5-sess") {
          return md5(ha12 + ":" + nonce + ":" + cnonce2);
        } else {
          return ha12;
        }
      };
      var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
      var nc = qop && "00000001";
      var cnonce = qop && uuid().replace(/-/g, "");
      var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
      var ha2 = md5(method + ":" + path3);
      var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
      var authValues = {
        username: self2.user,
        realm: challenge.realm,
        nonce: challenge.nonce,
        uri: path3,
        qop,
        response: digestResponse,
        nc,
        cnonce,
        algorithm: challenge.algorithm,
        opaque: challenge.opaque
      };
      authHeader = [];
      for (var k in authValues) {
        if (authValues[k]) {
          if (k === "qop" || k === "nc" || k === "algorithm") {
            authHeader.push(k + "=" + authValues[k]);
          } else {
            authHeader.push(k + '="' + authValues[k] + '"');
          }
        }
      }
      authHeader = "Digest " + authHeader.join(", ");
      self2.sentAuth = true;
      return authHeader;
    };
    Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      var request2 = self2.request;
      var authHeader;
      if (bearer === void 0 && user === void 0) {
        self2.request.emit("error", new Error("no auth mechanism defined"));
      } else if (bearer !== void 0) {
        authHeader = self2.bearer(bearer, sendImmediately);
      } else {
        authHeader = self2.basic(user, pass, sendImmediately);
      }
      if (authHeader) {
        request2.setHeader("authorization", authHeader);
      }
    };
    Auth.prototype.onResponse = function(response2) {
      var self2 = this;
      var request2 = self2.request;
      if (!self2.hasAuth || self2.sentAuth) {
        return null;
      }
      var c = caseless(response2.headers);
      var authHeader = c.get("www-authenticate");
      var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
      request2.debug("reauth", authVerb);
      switch (authVerb) {
        case "basic":
          return self2.basic(self2.user, self2.pass, true);
        case "bearer":
          return self2.bearer(self2.bearerToken, true);
        case "digest":
          return self2.digest(request2.method, request2.path, authHeader);
      }
    };
    exports.Auth = Auth;
  }
});

// node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS({
  "node_modules/oauth-sign/index.js"(exports) {
    var crypto = __require("crypto");
    function sha(key, body, algorithm) {
      return crypto.createHmac(algorithm, key).update(body).digest("base64");
    }
    function rsa(key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, "base64");
    }
    function rfc3986(str) {
      return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
    }
    function map4(obj) {
      var key, val2, arr = [];
      for (key in obj) {
        val2 = obj[key];
        if (Array.isArray(val2))
          for (var i = 0; i < val2.length; i++)
            arr.push([key, val2[i]]);
        else if (typeof val2 === "object")
          for (var prop2 in val2)
            arr.push([key + "[" + prop2 + "]", val2[prop2]]);
        else
          arr.push([key, val2]);
      }
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function generateBase(httpMethod, base_uri, params) {
      var normalized = map4(params).map(function(p) {
        return [rfc3986(p[0]), rfc3986(p[1] || "")];
      }).sort(function(a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1]);
      }).map(function(p) {
        return p.join("=");
      }).join("&");
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join("&");
      return base;
    }
    function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return sha(key, base, "sha1");
    }
    function hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return sha(key, base, "sha256");
    }
    function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = private_key || "";
      return rsa(key, base);
    }
    function plaintext(consumer_secret, token_secret) {
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return key;
    }
    function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method;
      var skipArgs = 1;
      switch (signMethod) {
        case "RSA-SHA1":
          method = rsasign;
          break;
        case "HMAC-SHA1":
          method = hmacsign;
          break;
        case "HMAC-SHA256":
          method = hmacsign256;
          break;
        case "PLAINTEXT":
          method = plaintext;
          skipArgs = 4;
          break;
        default:
          throw new Error("Signature method not supported: " + signMethod);
      }
      return method.apply(null, [].slice.call(arguments, skipArgs));
    }
    exports.hmacsign = hmacsign;
    exports.hmacsign256 = hmacsign256;
    exports.rsasign = rsasign;
    exports.plaintext = plaintext;
    exports.sign = sign;
    exports.rfc3986 = rfc3986;
    exports.generateBase = generateBase;
  }
});

// node_modules/request/lib/oauth.js
var require_oauth = __commonJS({
  "node_modules/request/lib/oauth.js"(exports) {
    "use strict";
    var url6 = __require("url");
    var qs3 = require_lib4();
    var caseless = require_caseless();
    var uuid = require_v4();
    var oauth = require_oauth_sign();
    var crypto = __require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    function OAuth(request2) {
      this.request = request2;
      this.params = null;
    }
    OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
      var oa = {};
      for (var i in _oauth) {
        oa["oauth_" + i] = _oauth[i];
      }
      if (!oa.oauth_version) {
        oa.oauth_version = "1.0";
      }
      if (!oa.oauth_timestamp) {
        oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
      }
      if (!oa.oauth_nonce) {
        oa.oauth_nonce = uuid().replace(/-/g, "");
      }
      if (!oa.oauth_signature_method) {
        oa.oauth_signature_method = "HMAC-SHA1";
      }
      var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
      delete oa.oauth_consumer_secret;
      delete oa.oauth_private_key;
      var token_secret = oa.oauth_token_secret;
      delete oa.oauth_token_secret;
      var realm = oa.oauth_realm;
      delete oa.oauth_realm;
      delete oa.oauth_transport_method;
      var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
      var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
      oa.oauth_signature = oauth.sign(
        oa.oauth_signature_method,
        method,
        baseurl,
        params,
        consumer_secret_or_private_key,
        // eslint-disable-line camelcase
        token_secret
        // eslint-disable-line camelcase
      );
      if (realm) {
        oa.realm = realm;
      }
      return oa;
    };
    OAuth.prototype.buildBodyHash = function(_oauth, body) {
      if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
        this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
      }
      var shasum = crypto.createHash("sha1");
      shasum.update(body || "");
      var sha1 = shasum.digest("hex");
      return Buffer2.from(sha1, "hex").toString("base64");
    };
    OAuth.prototype.concatParams = function(oa, sep, wrap2) {
      wrap2 = wrap2 || "";
      var params = Object.keys(oa).filter(function(i) {
        return i !== "realm" && i !== "oauth_signature";
      }).sort();
      if (oa.realm) {
        params.splice(0, 0, "realm");
      }
      params.push("oauth_signature");
      return params.map(function(i) {
        return i + "=" + wrap2 + oauth.rfc3986(oa[i]) + wrap2;
      }).join(sep);
    };
    OAuth.prototype.onRequest = function(_oauth) {
      var self2 = this;
      self2.params = _oauth;
      var uri = self2.request.uri || {};
      var method = self2.request.method || "";
      var headers = caseless(self2.request.headers);
      var body = self2.request.body || "";
      var qsLib = self2.request.qsLib || qs3;
      var form;
      var query;
      var contentType = headers.get("content-type") || "";
      var formContentType = "application/x-www-form-urlencoded";
      var transport = _oauth.transport_method || "header";
      if (contentType.slice(0, formContentType.length) === formContentType) {
        contentType = formContentType;
        form = body;
      }
      if (uri.query) {
        query = uri.query;
      }
      if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
        self2.request.emit("error", new Error("oauth: transport_method of body requires POST and content-type " + formContentType));
      }
      if (!form && typeof _oauth.body_hash === "boolean") {
        _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
      }
      var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
      switch (transport) {
        case "header":
          self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
          break;
        case "query":
          var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
          self2.request.uri = url6.parse(href);
          self2.request.path = self2.request.uri.path;
          break;
        case "body":
          self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
          break;
        default:
          self2.request.emit("error", new Error("oauth: transport_method invalid"));
      }
    };
    exports.OAuth = OAuth;
  }
});

// node_modules/request/lib/hawk.js
var require_hawk = __commonJS({
  "node_modules/request/lib/hawk.js"(exports) {
    "use strict";
    var crypto = __require("crypto");
    function randomString(size) {
      var bits = (size + 1) * 6;
      var buffer = crypto.randomBytes(Math.ceil(bits / 8));
      var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      return string.slice(0, size);
    }
    function calculatePayloadHash(payload, algorithm, contentType) {
      var hash = crypto.createHash(algorithm);
      hash.update("hawk.1.payload\n");
      hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + "\n");
      hash.update(payload || "");
      hash.update("\n");
      return hash.digest("base64");
    }
    exports.calculateMac = function(credentials, opts) {
      var normalized = "hawk.1.header\n" + opts.ts + "\n" + opts.nonce + "\n" + (opts.method || "").toUpperCase() + "\n" + opts.resource + "\n" + opts.host.toLowerCase() + "\n" + opts.port + "\n" + (opts.hash || "") + "\n";
      if (opts.ext) {
        normalized = normalized + opts.ext.replace("\\", "\\\\").replace("\n", "\\n");
      }
      normalized = normalized + "\n";
      if (opts.app) {
        normalized = normalized + opts.app + "\n" + (opts.dlg || "") + "\n";
      }
      var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
      var digest = hmac.digest("base64");
      return digest;
    };
    exports.header = function(uri, method, opts) {
      var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
      var credentials = opts.credentials;
      if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
        return "";
      }
      if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
        return "";
      }
      var artifacts = {
        ts: timestamp,
        nonce: opts.nonce || randomString(6),
        method,
        resource: uri.pathname + (uri.search || ""),
        host: uri.hostname,
        port: uri.port || (uri.protocol === "http:" ? 80 : 443),
        hash: opts.hash,
        ext: opts.ext,
        app: opts.app,
        dlg: opts.dlg
      };
      if (!artifacts.hash && (opts.payload || opts.payload === "")) {
        artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
      }
      var mac = exports.calculateMac(credentials, artifacts);
      var hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== "";
      var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, '\\"') : "") + '", mac="' + mac + '"';
      if (artifacts.app) {
        header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
      }
      return header;
    };
  }
});

// node_modules/request/lib/multipart.js
var require_multipart = __commonJS({
  "node_modules/request/lib/multipart.js"(exports) {
    "use strict";
    var uuid = require_v4();
    var CombinedStream = require_combined_stream();
    var isstream = require_isstream();
    var Buffer2 = require_safe_buffer().Buffer;
    function Multipart(request2) {
      this.request = request2;
      this.boundary = uuid();
      this.chunked = false;
      this.body = null;
    }
    Multipart.prototype.isChunked = function(options) {
      var self2 = this;
      var chunked = false;
      var parts = options.data || options;
      if (!parts.forEach) {
        self2.request.emit("error", new Error("Argument error, options.multipart."));
      }
      if (options.chunked !== void 0) {
        chunked = options.chunked;
      }
      if (self2.request.getHeader("transfer-encoding") === "chunked") {
        chunked = true;
      }
      if (!chunked) {
        parts.forEach(function(part) {
          if (typeof part.body === "undefined") {
            self2.request.emit("error", new Error("Body attribute missing in multipart."));
          }
          if (isstream(part.body)) {
            chunked = true;
          }
        });
      }
      return chunked;
    };
    Multipart.prototype.setHeaders = function(chunked) {
      var self2 = this;
      if (chunked && !self2.request.hasHeader("transfer-encoding")) {
        self2.request.setHeader("transfer-encoding", "chunked");
      }
      var header = self2.request.getHeader("content-type");
      if (!header || header.indexOf("multipart") === -1) {
        self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
      } else {
        if (header.indexOf("boundary") !== -1) {
          self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
        } else {
          self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
        }
      }
    };
    Multipart.prototype.build = function(parts, chunked) {
      var self2 = this;
      var body = chunked ? new CombinedStream() : [];
      function add2(part) {
        if (typeof part === "number") {
          part = part.toString();
        }
        return chunked ? body.append(part) : body.push(Buffer2.from(part));
      }
      if (self2.request.preambleCRLF) {
        add2("\r\n");
      }
      parts.forEach(function(part) {
        var preamble = "--" + self2.boundary + "\r\n";
        Object.keys(part).forEach(function(key) {
          if (key === "body") {
            return;
          }
          preamble += key + ": " + part[key] + "\r\n";
        });
        preamble += "\r\n";
        add2(preamble);
        add2(part.body);
        add2("\r\n");
      });
      add2("--" + self2.boundary + "--");
      if (self2.request.postambleCRLF) {
        add2("\r\n");
      }
      return body;
    };
    Multipart.prototype.onRequest = function(options) {
      var self2 = this;
      var chunked = self2.isChunked(options);
      var parts = options.data || options;
      self2.setHeaders(chunked);
      self2.chunked = chunked;
      self2.body = self2.build(parts, chunked);
    };
    exports.Multipart = Multipart;
  }
});

// node_modules/request/lib/redirect.js
var require_redirect = __commonJS({
  "node_modules/request/lib/redirect.js"(exports) {
    "use strict";
    var url6 = __require("url");
    var isUrl = /^https?:/;
    function Redirect(request2) {
      this.request = request2;
      this.followRedirect = true;
      this.followRedirects = true;
      this.followAllRedirects = false;
      this.followOriginalHttpMethod = false;
      this.allowRedirect = function() {
        return true;
      };
      this.maxRedirects = 10;
      this.redirects = [];
      this.redirectsFollowed = 0;
      this.removeRefererHeader = false;
    }
    Redirect.prototype.onRequest = function(options) {
      var self2 = this;
      if (options.maxRedirects !== void 0) {
        self2.maxRedirects = options.maxRedirects;
      }
      if (typeof options.followRedirect === "function") {
        self2.allowRedirect = options.followRedirect;
      }
      if (options.followRedirect !== void 0) {
        self2.followRedirects = !!options.followRedirect;
      }
      if (options.followAllRedirects !== void 0) {
        self2.followAllRedirects = options.followAllRedirects;
      }
      if (self2.followRedirects || self2.followAllRedirects) {
        self2.redirects = self2.redirects || [];
      }
      if (options.removeRefererHeader !== void 0) {
        self2.removeRefererHeader = options.removeRefererHeader;
      }
      if (options.followOriginalHttpMethod !== void 0) {
        self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
      }
    };
    Redirect.prototype.redirectTo = function(response2) {
      var self2 = this;
      var request2 = self2.request;
      var redirectTo = null;
      if (response2.statusCode >= 300 && response2.statusCode < 400 && response2.caseless.has("location")) {
        var location = response2.caseless.get("location");
        request2.debug("redirect", location);
        if (self2.followAllRedirects) {
          redirectTo = location;
        } else if (self2.followRedirects) {
          switch (request2.method) {
            case "PATCH":
            case "PUT":
            case "POST":
            case "DELETE":
              break;
            default:
              redirectTo = location;
              break;
          }
        }
      } else if (response2.statusCode === 401) {
        var authHeader = request2._auth.onResponse(response2);
        if (authHeader) {
          request2.setHeader("authorization", authHeader);
          redirectTo = request2.uri;
        }
      }
      return redirectTo;
    };
    Redirect.prototype.onResponse = function(response2) {
      var self2 = this;
      var request2 = self2.request;
      var redirectTo = self2.redirectTo(response2);
      if (!redirectTo || !self2.allowRedirect.call(request2, response2)) {
        return false;
      }
      request2.debug("redirect to", redirectTo);
      if (response2.resume) {
        response2.resume();
      }
      if (self2.redirectsFollowed >= self2.maxRedirects) {
        request2.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request2.uri.href));
        return false;
      }
      self2.redirectsFollowed += 1;
      if (!isUrl.test(redirectTo)) {
        redirectTo = url6.resolve(request2.uri.href, redirectTo);
      }
      var uriPrev = request2.uri;
      request2.uri = url6.parse(redirectTo);
      if (request2.uri.protocol !== uriPrev.protocol) {
        delete request2.agent;
      }
      self2.redirects.push({ statusCode: response2.statusCode, redirectUri: redirectTo });
      if (self2.followAllRedirects && request2.method !== "HEAD" && response2.statusCode !== 401 && response2.statusCode !== 307) {
        request2.method = self2.followOriginalHttpMethod ? request2.method : "GET";
      }
      delete request2.src;
      delete request2.req;
      delete request2._started;
      if (response2.statusCode !== 401 && response2.statusCode !== 307) {
        delete request2.body;
        delete request2._form;
        if (request2.headers) {
          request2.removeHeader("host");
          request2.removeHeader("content-type");
          request2.removeHeader("content-length");
          if (request2.uri.hostname !== request2.originalHost.split(":")[0]) {
            request2.removeHeader("authorization");
          }
        }
      }
      if (!self2.removeRefererHeader) {
        request2.setHeader("referer", uriPrev.href);
      }
      request2.emit("redirect");
      request2.init();
      return true;
    };
    exports.Redirect = Redirect;
  }
});

// node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS({
  "node_modules/tunnel-agent/index.js"(exports) {
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var http = __require("http");
    var https = __require("https");
    var events = __require("events");
    var assert = __require("assert");
    var util = __require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port) {
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === host && pending.port === port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self2 = this;
      if (typeof options === "string") {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push({ host: options.host, port: options.port, request: req });
        return;
      }
      self2.createConnection({ host: options.host, port: options.port, request: req });
    };
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self2 = this;
      self2.createSocket(pending, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        pending.request.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, pending.host, pending.port);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions(
        {},
        self2.proxyOptions,
        {
          method: "CONNECT",
          path: options.host + ":" + options.port,
          agent: false
        }
      );
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
      }
      debug9("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          assert.equal(head.length, 0);
          debug9("tunneling connection has established");
          self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
          cb(socket);
        } else {
          debug9("tunneling socket could not be established, statusCode=%d", res.statusCode);
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
        }
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug9("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1)
        return;
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createConnection(pending);
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var secureSocket = tls.connect(0, mergeOptions(
          {},
          self2.options,
          {
            servername: options.host,
            socket
          }
        ));
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys4 = Object.keys(overrides);
          for (var j = 0, keyLen = keys4.length; j < keyLen; ++j) {
            var k = keys4[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug9;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug9 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug9 = function() {
      };
    }
    exports.debug = debug9;
  }
});

// node_modules/request/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/request/lib/tunnel.js"(exports) {
    "use strict";
    var url6 = __require("url");
    var tunnel = require_tunnel_agent();
    var defaultProxyHeaderWhiteList = [
      "accept",
      "accept-charset",
      "accept-encoding",
      "accept-language",
      "accept-ranges",
      "cache-control",
      "content-encoding",
      "content-language",
      "content-location",
      "content-md5",
      "content-range",
      "content-type",
      "connection",
      "date",
      "expect",
      "max-forwards",
      "pragma",
      "referer",
      "te",
      "user-agent",
      "via"
    ];
    var defaultProxyHeaderExclusiveList = [
      "proxy-authorization"
    ];
    function constructProxyHost(uriObject) {
      var port = uriObject.port;
      var protocol = uriObject.protocol;
      var proxyHost = uriObject.hostname + ":";
      if (port) {
        proxyHost += port;
      } else if (protocol === "https:") {
        proxyHost += "443";
      } else {
        proxyHost += "80";
      }
      return proxyHost;
    }
    function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
      var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
        set[header.toLowerCase()] = true;
        return set;
      }, {});
      return Object.keys(headers).filter(function(header) {
        return whiteList[header.toLowerCase()];
      }).reduce(function(set, header) {
        set[header] = headers[header];
        return set;
      }, {});
    }
    function constructTunnelOptions(request2, proxyHeaders) {
      var proxy = request2.proxy;
      var tunnelOptions = {
        proxy: {
          host: proxy.hostname,
          port: +proxy.port,
          proxyAuth: proxy.auth,
          headers: proxyHeaders
        },
        headers: request2.headers,
        ca: request2.ca,
        cert: request2.cert,
        key: request2.key,
        passphrase: request2.passphrase,
        pfx: request2.pfx,
        ciphers: request2.ciphers,
        rejectUnauthorized: request2.rejectUnauthorized,
        secureOptions: request2.secureOptions,
        secureProtocol: request2.secureProtocol
      };
      return tunnelOptions;
    }
    function constructTunnelFnName(uri, proxy) {
      var uriProtocol = uri.protocol === "https:" ? "https" : "http";
      var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
      return [uriProtocol, proxyProtocol].join("Over");
    }
    function getTunnelFn(request2) {
      var uri = request2.uri;
      var proxy = request2.proxy;
      var tunnelFnName = constructTunnelFnName(uri, proxy);
      return tunnel[tunnelFnName];
    }
    function Tunnel(request2) {
      this.request = request2;
      this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
      this.proxyHeaderExclusiveList = [];
      if (typeof request2.tunnel !== "undefined") {
        this.tunnelOverride = request2.tunnel;
      }
    }
    Tunnel.prototype.isEnabled = function() {
      var self2 = this;
      var request2 = self2.request;
      if (typeof self2.tunnelOverride !== "undefined") {
        return self2.tunnelOverride;
      }
      if (request2.uri.protocol === "https:") {
        return true;
      }
      return false;
    };
    Tunnel.prototype.setup = function(options) {
      var self2 = this;
      var request2 = self2.request;
      options = options || {};
      if (typeof request2.proxy === "string") {
        request2.proxy = url6.parse(request2.proxy);
      }
      if (!request2.proxy || !request2.tunnel) {
        return false;
      }
      if (options.proxyHeaderWhiteList) {
        self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
      }
      if (options.proxyHeaderExclusiveList) {
        self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
      }
      var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
      var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
      var proxyHeaders = constructProxyHeaderWhiteList(request2.headers, proxyHeaderWhiteList);
      proxyHeaders.host = constructProxyHost(request2.uri);
      proxyHeaderExclusiveList.forEach(request2.removeHeader, request2);
      var tunnelFn = getTunnelFn(request2);
      var tunnelOptions = constructTunnelOptions(request2, proxyHeaders);
      request2.agent = tunnelFn(tunnelOptions);
      return true;
    };
    Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
    exports.Tunnel = Tunnel;
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// node_modules/request/request.js
var require_request2 = __commonJS({
  "node_modules/request/request.js"(exports, module) {
    "use strict";
    var http = __require("http");
    var https = __require("https");
    var url6 = __require("url");
    var util = __require("util");
    var stream = __require("stream");
    var zlib = __require("zlib");
    var aws2 = require_aws_sign2();
    var aws4 = require_aws4();
    var httpSignature = require_lib3();
    var mime = require_mime_types();
    var caseless = require_caseless();
    var ForeverAgent = require_forever_agent();
    var FormData = require_form_data();
    var extend = require_extend();
    var isstream = require_isstream();
    var isTypedArray = require_is_typedarray().strict;
    var helpers = require_helpers();
    var cookies = require_cookies();
    var getProxyFromURI = require_getProxyFromURI();
    var Querystring = require_querystring().Querystring;
    var Har = require_har2().Har;
    var Auth = require_auth().Auth;
    var OAuth = require_oauth().OAuth;
    var hawk = require_hawk();
    var Multipart = require_multipart().Multipart;
    var Redirect = require_redirect().Redirect;
    var Tunnel = require_tunnel().Tunnel;
    var now = require_performance_now();
    var Buffer2 = require_safe_buffer().Buffer;
    var safeStringify = helpers.safeStringify;
    var isReadStream = helpers.isReadStream;
    var toBase64 = helpers.toBase64;
    var defer = helpers.defer;
    var copy = helpers.copy;
    var version = helpers.version;
    var globalCookieJar = cookies.jar();
    var globalPool = {};
    function filterForNonReserved(reserved, options) {
      var object = {};
      for (var i in options) {
        var notReserved = reserved.indexOf(i) === -1;
        if (notReserved) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function filterOutReservedFunctions(reserved, options) {
      var object = {};
      for (var i in options) {
        var isReserved = !(reserved.indexOf(i) === -1);
        var isFunction = typeof options[i] === "function";
        if (!(isReserved && isFunction)) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function requestToJSON() {
      var self2 = this;
      return {
        uri: self2.uri,
        method: self2.method,
        headers: self2.headers
      };
    }
    function responseToJSON() {
      var self2 = this;
      return {
        statusCode: self2.statusCode,
        body: self2.body,
        headers: self2.headers,
        request: requestToJSON.call(self2.request)
      };
    }
    function Request(options) {
      var self2 = this;
      if (options.har) {
        self2._har = new Har(self2);
        options = self2._har.options(options);
      }
      stream.Stream.call(self2);
      var reserved = Object.keys(Request.prototype);
      var nonReserved = filterForNonReserved(reserved, options);
      extend(self2, nonReserved);
      options = filterOutReservedFunctions(reserved, options);
      self2.readable = true;
      self2.writable = true;
      if (options.method) {
        self2.explicitMethod = true;
      }
      self2._qs = new Querystring(self2);
      self2._auth = new Auth(self2);
      self2._oauth = new OAuth(self2);
      self2._multipart = new Multipart(self2);
      self2._redirect = new Redirect(self2);
      self2._tunnel = new Tunnel(self2);
      self2.init(options);
    }
    util.inherits(Request, stream.Stream);
    Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
    function debug9() {
      if (Request.debug) {
        console.error("REQUEST %s", util.format.apply(util, arguments));
      }
    }
    Request.prototype.debug = debug9;
    Request.prototype.init = function(options) {
      var self2 = this;
      if (!options) {
        options = {};
      }
      self2.headers = self2.headers ? copy(self2.headers) : {};
      for (var headerName in self2.headers) {
        if (typeof self2.headers[headerName] === "undefined") {
          delete self2.headers[headerName];
        }
      }
      caseless.httpify(self2, self2.headers);
      if (!self2.method) {
        self2.method = options.method || "GET";
      }
      if (!self2.localAddress) {
        self2.localAddress = options.localAddress;
      }
      self2._qs.init(options);
      debug9(options);
      if (!self2.pool && self2.pool !== false) {
        self2.pool = globalPool;
      }
      self2.dests = self2.dests || [];
      self2.__isRequestRequest = true;
      if (!self2._callback && self2.callback) {
        self2._callback = self2.callback;
        self2.callback = function() {
          if (self2._callbackCalled) {
            return;
          }
          self2._callbackCalled = true;
          self2._callback.apply(self2, arguments);
        };
        self2.on("error", self2.callback.bind());
        self2.on("complete", self2.callback.bind(self2, null));
      }
      if (!self2.uri && self2.url) {
        self2.uri = self2.url;
        delete self2.url;
      }
      if (self2.baseUrl) {
        if (typeof self2.baseUrl !== "string") {
          return self2.emit("error", new Error("options.baseUrl must be a string"));
        }
        if (typeof self2.uri !== "string") {
          return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
        }
        if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
          return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
        }
        var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
        var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
        if (baseUrlEndsWithSlash && uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri.slice(1);
        } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri;
        } else if (self2.uri === "") {
          self2.uri = self2.baseUrl;
        } else {
          self2.uri = self2.baseUrl + "/" + self2.uri;
        }
        delete self2.baseUrl;
      }
      if (!self2.uri) {
        return self2.emit("error", new Error("options.uri is a required argument"));
      }
      if (typeof self2.uri === "string") {
        self2.uri = url6.parse(self2.uri);
      }
      if (!self2.uri.href) {
        self2.uri.href = url6.format(self2.uri);
      }
      if (self2.uri.protocol === "unix:") {
        return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
      }
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      if (self2.strictSSL === false) {
        self2.rejectUnauthorized = false;
      }
      if (!self2.uri.pathname) {
        self2.uri.pathname = "/";
      }
      if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
        var faultyUri = url6.format(self2.uri);
        var message = 'Invalid URI "' + faultyUri + '"';
        if (Object.keys(options).length === 0) {
          message += ". This can be caused by a crappy redirection.";
        }
        self2.abort();
        return self2.emit("error", new Error(message));
      }
      if (!self2.hasOwnProperty("proxy")) {
        self2.proxy = getProxyFromURI(self2.uri);
      }
      self2.tunnel = self2._tunnel.isEnabled();
      if (self2.proxy) {
        self2._tunnel.setup(options);
      }
      self2._redirect.onRequest(options);
      self2.setHost = false;
      if (!self2.hasHeader("host")) {
        var hostHeaderName = self2.originalHostHeaderName || "host";
        self2.setHeader(hostHeaderName, self2.uri.host);
        if (self2.uri.port) {
          if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
            self2.setHeader(hostHeaderName, self2.uri.hostname);
          }
        }
        self2.setHost = true;
      }
      self2.jar(self2._jar || options.jar);
      if (!self2.uri.port) {
        if (self2.uri.protocol === "http:") {
          self2.uri.port = 80;
        } else if (self2.uri.protocol === "https:") {
          self2.uri.port = 443;
        }
      }
      if (self2.proxy && !self2.tunnel) {
        self2.port = self2.proxy.port;
        self2.host = self2.proxy.hostname;
      } else {
        self2.port = self2.uri.port;
        self2.host = self2.uri.hostname;
      }
      if (options.form) {
        self2.form(options.form);
      }
      if (options.formData) {
        var formData = options.formData;
        var requestForm = self2.form();
        var appendFormValue = function(key, value2) {
          if (value2 && value2.hasOwnProperty("value") && value2.hasOwnProperty("options")) {
            requestForm.append(key, value2.value, value2.options);
          } else {
            requestForm.append(key, value2);
          }
        };
        for (var formKey in formData) {
          if (formData.hasOwnProperty(formKey)) {
            var formValue = formData[formKey];
            if (formValue instanceof Array) {
              for (var j = 0; j < formValue.length; j++) {
                appendFormValue(formKey, formValue[j]);
              }
            } else {
              appendFormValue(formKey, formValue);
            }
          }
        }
      }
      if (options.qs) {
        self2.qs(options.qs);
      }
      if (self2.uri.path) {
        self2.path = self2.uri.path;
      } else {
        self2.path = self2.uri.pathname + (self2.uri.search || "");
      }
      if (self2.path.length === 0) {
        self2.path = "/";
      }
      if (options.aws) {
        self2.aws(options.aws);
      }
      if (options.hawk) {
        self2.hawk(options.hawk);
      }
      if (options.httpSignature) {
        self2.httpSignature(options.httpSignature);
      }
      if (options.auth) {
        if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
          options.auth.user = options.auth.username;
        }
        if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
          options.auth.pass = options.auth.password;
        }
        self2.auth(
          options.auth.user,
          options.auth.pass,
          options.auth.sendImmediately,
          options.auth.bearer
        );
      }
      if (self2.gzip && !self2.hasHeader("accept-encoding")) {
        self2.setHeader("accept-encoding", "gzip, deflate");
      }
      if (self2.uri.auth && !self2.hasHeader("authorization")) {
        var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
      }
      if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
        var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
        self2.setHeader("proxy-authorization", authHeader);
      }
      if (self2.proxy && !self2.tunnel) {
        self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
      }
      if (options.json) {
        self2.json(options.json);
      }
      if (options.multipart) {
        self2.multipart(options.multipart);
      }
      if (options.time) {
        self2.timing = true;
        self2.elapsedTime = self2.elapsedTime || 0;
      }
      function setContentLength() {
        if (isTypedArray(self2.body)) {
          self2.body = Buffer2.from(self2.body);
        }
        if (!self2.hasHeader("content-length")) {
          var length;
          if (typeof self2.body === "string") {
            length = Buffer2.byteLength(self2.body);
          } else if (Array.isArray(self2.body)) {
            length = self2.body.reduce(function(a, b) {
              return a + b.length;
            }, 0);
          } else {
            length = self2.body.length;
          }
          if (length) {
            self2.setHeader("content-length", length);
          } else {
            self2.emit("error", new Error("Argument error, options.body."));
          }
        }
      }
      if (self2.body && !isstream(self2.body)) {
        setContentLength();
      }
      if (options.oauth) {
        self2.oauth(options.oauth);
      } else if (self2._oauth.params && self2.hasHeader("authorization")) {
        self2.oauth(self2._oauth.params);
      }
      var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
      var defaultModules = { "http:": http, "https:": https };
      var httpModules = self2.httpModules || {};
      self2.httpModule = httpModules[protocol] || defaultModules[protocol];
      if (!self2.httpModule) {
        return self2.emit("error", new Error("Invalid protocol: " + protocol));
      }
      if (options.ca) {
        self2.ca = options.ca;
      }
      if (!self2.agent) {
        if (options.agentOptions) {
          self2.agentOptions = options.agentOptions;
        }
        if (options.agentClass) {
          self2.agentClass = options.agentClass;
        } else if (options.forever) {
          var v = version();
          if (v.major === 0 && v.minor <= 10) {
            self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
          } else {
            self2.agentClass = self2.httpModule.Agent;
            self2.agentOptions = self2.agentOptions || {};
            self2.agentOptions.keepAlive = true;
          }
        } else {
          self2.agentClass = self2.httpModule.Agent;
        }
      }
      if (self2.pool === false) {
        self2.agent = false;
      } else {
        self2.agent = self2.agent || self2.getNewAgent();
      }
      self2.on("pipe", function(src) {
        if (self2.ntick && self2._started) {
          self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
        }
        self2.src = src;
        if (isReadStream(src)) {
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", mime.lookup(src.path));
          }
        } else {
          if (src.headers) {
            for (var i in src.headers) {
              if (!self2.hasHeader(i)) {
                self2.setHeader(i, src.headers[i]);
              }
            }
          }
          if (self2._json && !self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
          if (src.method && !self2.explicitMethod) {
            self2.method = src.method;
          }
        }
      });
      defer(function() {
        if (self2._aborted) {
          return;
        }
        var end2 = function() {
          if (self2._form) {
            if (!self2._auth.hasAuth) {
              self2._form.pipe(self2);
            } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
              self2._form.pipe(self2);
            }
          }
          if (self2._multipart && self2._multipart.chunked) {
            self2._multipart.body.pipe(self2);
          }
          if (self2.body) {
            if (isstream(self2.body)) {
              self2.body.pipe(self2);
            } else {
              setContentLength();
              if (Array.isArray(self2.body)) {
                self2.body.forEach(function(part) {
                  self2.write(part);
                });
              } else {
                self2.write(self2.body);
              }
              self2.end();
            }
          } else if (self2.requestBodyStream) {
            console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
            self2.requestBodyStream.pipe(self2);
          } else if (!self2.src) {
            if (self2._auth.hasAuth && !self2._auth.sentAuth) {
              self2.end();
              return;
            }
            if (self2.method !== "GET" && typeof self2.method !== "undefined") {
              self2.setHeader("content-length", 0);
            }
            self2.end();
          }
        };
        if (self2._form && !self2.hasHeader("content-length")) {
          self2.setHeader(self2._form.getHeaders(), true);
          self2._form.getLength(function(err, length) {
            if (!err && !isNaN(length)) {
              self2.setHeader("content-length", length);
            }
            end2();
          });
        } else {
          end2();
        }
        self2.ntick = true;
      });
    };
    Request.prototype.getNewAgent = function() {
      var self2 = this;
      var Agent = self2.agentClass;
      var options = {};
      if (self2.agentOptions) {
        for (var i in self2.agentOptions) {
          options[i] = self2.agentOptions[i];
        }
      }
      if (self2.ca) {
        options.ca = self2.ca;
      }
      if (self2.ciphers) {
        options.ciphers = self2.ciphers;
      }
      if (self2.secureProtocol) {
        options.secureProtocol = self2.secureProtocol;
      }
      if (self2.secureOptions) {
        options.secureOptions = self2.secureOptions;
      }
      if (typeof self2.rejectUnauthorized !== "undefined") {
        options.rejectUnauthorized = self2.rejectUnauthorized;
      }
      if (self2.cert && self2.key) {
        options.key = self2.key;
        options.cert = self2.cert;
      }
      if (self2.pfx) {
        options.pfx = self2.pfx;
      }
      if (self2.passphrase) {
        options.passphrase = self2.passphrase;
      }
      var poolKey = "";
      if (Agent !== self2.httpModule.Agent) {
        poolKey += Agent.name;
      }
      var proxy = self2.proxy;
      if (typeof proxy === "string") {
        proxy = url6.parse(proxy);
      }
      var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
      if (isHttps) {
        if (options.ca) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ca;
        }
        if (typeof options.rejectUnauthorized !== "undefined") {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.rejectUnauthorized;
        }
        if (options.cert) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
        }
        if (options.pfx) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.pfx.toString("ascii");
        }
        if (options.ciphers) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ciphers;
        }
        if (options.secureProtocol) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureProtocol;
        }
        if (options.secureOptions) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureOptions;
        }
      }
      if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
        return self2.httpModule.globalAgent;
      }
      poolKey = self2.uri.protocol + poolKey;
      if (!self2.pool[poolKey]) {
        self2.pool[poolKey] = new Agent(options);
        if (self2.pool.maxSockets) {
          self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
        }
      }
      return self2.pool[poolKey];
    };
    Request.prototype.start = function() {
      var self2 = this;
      if (self2.timing) {
        var startTime = (/* @__PURE__ */ new Date()).getTime();
        var startTimeNow = now();
      }
      if (self2._aborted) {
        return;
      }
      self2._started = true;
      self2.method = self2.method || "GET";
      self2.href = self2.uri.href;
      if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
        self2.setHeader("content-length", self2.src.stat.size);
      }
      if (self2._aws) {
        self2.aws(self2._aws, true);
      }
      var reqOptions = copy(self2);
      delete reqOptions.auth;
      debug9("make request", self2.uri.href);
      delete reqOptions.timeout;
      try {
        self2.req = self2.httpModule.request(reqOptions);
      } catch (err) {
        self2.emit("error", err);
        return;
      }
      if (self2.timing) {
        self2.startTime = startTime;
        self2.startTimeNow = startTimeNow;
        self2.timings = {};
      }
      var timeout;
      if (self2.timeout && !self2.timeoutTimer) {
        if (self2.timeout < 0) {
          timeout = 0;
        } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
          timeout = self2.timeout;
        }
      }
      self2.req.on("response", self2.onRequestResponse.bind(self2));
      self2.req.on("error", self2.onRequestError.bind(self2));
      self2.req.on("drain", function() {
        self2.emit("drain");
      });
      self2.req.on("socket", function(socket) {
        var isConnecting = socket._connecting || socket.connecting;
        if (self2.timing) {
          self2.timings.socket = now() - self2.startTimeNow;
          if (isConnecting) {
            var onLookupTiming = function() {
              self2.timings.lookup = now() - self2.startTimeNow;
            };
            var onConnectTiming = function() {
              self2.timings.connect = now() - self2.startTimeNow;
            };
            socket.once("lookup", onLookupTiming);
            socket.once("connect", onConnectTiming);
            self2.req.once("error", function() {
              socket.removeListener("lookup", onLookupTiming);
              socket.removeListener("connect", onConnectTiming);
            });
          }
        }
        var setReqTimeout = function() {
          self2.req.setTimeout(timeout, function() {
            if (self2.req) {
              self2.abort();
              var e = new Error("ESOCKETTIMEDOUT");
              e.code = "ESOCKETTIMEDOUT";
              e.connect = false;
              self2.emit("error", e);
            }
          });
        };
        if (timeout !== void 0) {
          if (isConnecting) {
            var onReqSockConnect = function() {
              socket.removeListener("connect", onReqSockConnect);
              self2.clearTimeout();
              setReqTimeout();
            };
            socket.on("connect", onReqSockConnect);
            self2.req.on("error", function(err) {
              socket.removeListener("connect", onReqSockConnect);
            });
            self2.timeoutTimer = setTimeout(function() {
              socket.removeListener("connect", onReqSockConnect);
              self2.abort();
              var e = new Error("ETIMEDOUT");
              e.code = "ETIMEDOUT";
              e.connect = true;
              self2.emit("error", e);
            }, timeout);
          } else {
            setReqTimeout();
          }
        }
        self2.emit("socket", socket);
      });
      self2.emit("request", self2.req);
    };
    Request.prototype.onRequestError = function(error) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (self2.req && self2.req._reusedSocket && error.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
        self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
        self2.start();
        self2.req.end();
        return;
      }
      self2.clearTimeout();
      self2.emit("error", error);
    };
    Request.prototype.onRequestResponse = function(response2) {
      var self2 = this;
      if (self2.timing) {
        self2.timings.response = now() - self2.startTimeNow;
      }
      debug9("onRequestResponse", self2.uri.href, response2.statusCode, response2.headers);
      response2.on("end", function() {
        if (self2.timing) {
          self2.timings.end = now() - self2.startTimeNow;
          response2.timingStart = self2.startTime;
          if (!self2.timings.socket) {
            self2.timings.socket = 0;
          }
          if (!self2.timings.lookup) {
            self2.timings.lookup = self2.timings.socket;
          }
          if (!self2.timings.connect) {
            self2.timings.connect = self2.timings.lookup;
          }
          if (!self2.timings.response) {
            self2.timings.response = self2.timings.connect;
          }
          debug9("elapsed time", self2.timings.end);
          self2.elapsedTime += Math.round(self2.timings.end);
          response2.elapsedTime = self2.elapsedTime;
          response2.timings = self2.timings;
          response2.timingPhases = {
            wait: self2.timings.socket,
            dns: self2.timings.lookup - self2.timings.socket,
            tcp: self2.timings.connect - self2.timings.lookup,
            firstByte: self2.timings.response - self2.timings.connect,
            download: self2.timings.end - self2.timings.response,
            total: self2.timings.end
          };
        }
        debug9("response end", self2.uri.href, response2.statusCode, response2.headers);
      });
      if (self2._aborted) {
        debug9("aborted", self2.uri.href);
        response2.resume();
        return;
      }
      self2.response = response2;
      response2.request = self2;
      response2.toJSON = responseToJSON;
      if (self2.httpModule === https && self2.strictSSL && (!response2.hasOwnProperty("socket") || !response2.socket.authorized)) {
        debug9("strict ssl error", self2.uri.href);
        var sslErr = response2.hasOwnProperty("socket") ? response2.socket.authorizationError : self2.uri.href + " does not support SSL";
        self2.emit("error", new Error("SSL Error: " + sslErr));
        return;
      }
      self2.originalHost = self2.getHeader("host");
      if (!self2.originalHostHeaderName) {
        self2.originalHostHeaderName = self2.hasHeader("host");
      }
      if (self2.setHost) {
        self2.removeHeader("host");
      }
      self2.clearTimeout();
      var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
      var addCookie = function(cookie) {
        try {
          targetCookieJar.setCookie(cookie, self2.uri.href, { ignoreError: true });
        } catch (e) {
          self2.emit("error", e);
        }
      };
      response2.caseless = caseless(response2.headers);
      if (response2.caseless.has("set-cookie") && !self2._disableCookies) {
        var headerName = response2.caseless.has("set-cookie");
        if (Array.isArray(response2.headers[headerName])) {
          response2.headers[headerName].forEach(addCookie);
        } else {
          addCookie(response2.headers[headerName]);
        }
      }
      if (self2._redirect.onResponse(response2)) {
        return;
      } else {
        response2.on("close", function() {
          if (!self2._ended) {
            self2.response.emit("end");
          }
        });
        response2.once("end", function() {
          self2._ended = true;
        });
        var noBody = function(code) {
          return self2.method === "HEAD" || // Informational
          code >= 100 && code < 200 || // No Content
          code === 204 || // Not Modified
          code === 304;
        };
        var responseContent;
        if (self2.gzip && !noBody(response2.statusCode)) {
          var contentEncoding = response2.headers["content-encoding"] || "identity";
          contentEncoding = contentEncoding.trim().toLowerCase();
          var zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (contentEncoding === "gzip") {
            responseContent = zlib.createGunzip(zlibOptions);
            response2.pipe(responseContent);
          } else if (contentEncoding === "deflate") {
            responseContent = zlib.createInflate(zlibOptions);
            response2.pipe(responseContent);
          } else {
            if (contentEncoding !== "identity") {
              debug9("ignoring unrecognized Content-Encoding " + contentEncoding);
            }
            responseContent = response2;
          }
        } else {
          responseContent = response2;
        }
        if (self2.encoding) {
          if (self2.dests.length !== 0) {
            console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
          } else {
            responseContent.setEncoding(self2.encoding);
          }
        }
        if (self2._paused) {
          responseContent.pause();
        }
        self2.responseContent = responseContent;
        self2.emit("response", response2);
        self2.dests.forEach(function(dest) {
          self2.pipeDest(dest);
        });
        responseContent.on("data", function(chunk) {
          if (self2.timing && !self2.responseStarted) {
            self2.responseStartTime = (/* @__PURE__ */ new Date()).getTime();
            response2.responseStartTime = self2.responseStartTime;
          }
          self2._destdata = true;
          self2.emit("data", chunk);
        });
        responseContent.once("end", function(chunk) {
          self2.emit("end", chunk);
        });
        responseContent.on("error", function(error) {
          self2.emit("error", error);
        });
        responseContent.on("close", function() {
          self2.emit("close");
        });
        if (self2.callback) {
          self2.readResponseBody(response2);
        } else {
          self2.on("end", function() {
            if (self2._aborted) {
              debug9("aborted", self2.uri.href);
              return;
            }
            self2.emit("complete", response2);
          });
        }
      }
      debug9("finish init function", self2.uri.href);
    };
    Request.prototype.readResponseBody = function(response2) {
      var self2 = this;
      debug9("reading response's body");
      var buffers = [];
      var bufferLength = 0;
      var strings = [];
      self2.on("data", function(chunk) {
        if (!Buffer2.isBuffer(chunk)) {
          strings.push(chunk);
        } else if (chunk.length) {
          bufferLength += chunk.length;
          buffers.push(chunk);
        }
      });
      self2.on("end", function() {
        debug9("end event", self2.uri.href);
        if (self2._aborted) {
          debug9("aborted", self2.uri.href);
          buffers = [];
          bufferLength = 0;
          return;
        }
        if (bufferLength) {
          debug9("has body", self2.uri.href, bufferLength);
          response2.body = Buffer2.concat(buffers, bufferLength);
          if (self2.encoding !== null) {
            response2.body = response2.body.toString(self2.encoding);
          }
          buffers = [];
          bufferLength = 0;
        } else if (strings.length) {
          if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
            strings[0] = strings[0].substring(1);
          }
          response2.body = strings.join("");
        }
        if (self2._json) {
          try {
            response2.body = JSON.parse(response2.body, self2._jsonReviver);
          } catch (e) {
            debug9("invalid JSON received", self2.uri.href);
          }
        }
        debug9("emitting complete", self2.uri.href);
        if (typeof response2.body === "undefined" && !self2._json) {
          response2.body = self2.encoding === null ? Buffer2.alloc(0) : "";
        }
        self2.emit("complete", response2, response2.body);
      });
    };
    Request.prototype.abort = function() {
      var self2 = this;
      self2._aborted = true;
      if (self2.req) {
        self2.req.abort();
      } else if (self2.response) {
        self2.response.destroy();
      }
      self2.clearTimeout();
      self2.emit("abort");
    };
    Request.prototype.pipeDest = function(dest) {
      var self2 = this;
      var response2 = self2.response;
      if (dest.headers && !dest.headersSent) {
        if (response2.caseless.has("content-type")) {
          var ctname = response2.caseless.has("content-type");
          if (dest.setHeader) {
            dest.setHeader(ctname, response2.headers[ctname]);
          } else {
            dest.headers[ctname] = response2.headers[ctname];
          }
        }
        if (response2.caseless.has("content-length")) {
          var clname = response2.caseless.has("content-length");
          if (dest.setHeader) {
            dest.setHeader(clname, response2.headers[clname]);
          } else {
            dest.headers[clname] = response2.headers[clname];
          }
        }
      }
      if (dest.setHeader && !dest.headersSent) {
        for (var i in response2.headers) {
          if (!self2.gzip || i !== "content-encoding") {
            dest.setHeader(i, response2.headers[i]);
          }
        }
        dest.statusCode = response2.statusCode;
      }
      if (self2.pipefilter) {
        self2.pipefilter(response2, dest);
      }
    };
    Request.prototype.qs = function(q2, clobber) {
      var self2 = this;
      var base;
      if (!clobber && self2.uri.query) {
        base = self2._qs.parse(self2.uri.query);
      } else {
        base = {};
      }
      for (var i in q2) {
        base[i] = q2[i];
      }
      var qs3 = self2._qs.stringify(base);
      if (qs3 === "") {
        return self2;
      }
      self2.uri = url6.parse(self2.uri.href.split("?")[0] + "?" + qs3);
      self2.url = self2.uri;
      self2.path = self2.uri.path;
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      return self2;
    };
    Request.prototype.form = function(form) {
      var self2 = this;
      if (form) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.setHeader("content-type", "application/x-www-form-urlencoded");
        }
        self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
        return self2;
      }
      self2._form = new FormData();
      self2._form.on("error", function(err) {
        err.message = "form-data: " + err.message;
        self2.emit("error", err);
        self2.abort();
      });
      return self2._form;
    };
    Request.prototype.multipart = function(multipart) {
      var self2 = this;
      self2._multipart.onRequest(multipart);
      if (!self2._multipart.chunked) {
        self2.body = self2._multipart.body;
      }
      return self2;
    };
    Request.prototype.json = function(val2) {
      var self2 = this;
      if (!self2.hasHeader("accept")) {
        self2.setHeader("accept", "application/json");
      }
      if (typeof self2.jsonReplacer === "function") {
        self2._jsonReplacer = self2.jsonReplacer;
      }
      self2._json = true;
      if (typeof val2 === "boolean") {
        if (self2.body !== void 0) {
          if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
            self2.body = safeStringify(self2.body, self2._jsonReplacer);
          } else {
            self2.body = self2._qs.rfc3986(self2.body);
          }
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
        }
      } else {
        self2.body = safeStringify(val2, self2._jsonReplacer);
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
      if (typeof self2.jsonReviver === "function") {
        self2._jsonReviver = self2.jsonReviver;
      }
      return self2;
    };
    Request.prototype.getHeader = function(name, headers) {
      var self2 = this;
      var result, re, match;
      if (!headers) {
        headers = self2.headers;
      }
      Object.keys(headers).forEach(function(key) {
        if (key.length !== name.length) {
          return;
        }
        re = new RegExp(name, "i");
        match = key.match(re);
        if (match) {
          result = headers[key];
        }
      });
      return result;
    };
    Request.prototype.enableUnixSocket = function() {
      var unixParts = this.uri.path.split(":");
      var host = unixParts[0];
      var path3 = unixParts[1];
      this.socketPath = host;
      this.uri.pathname = path3;
      this.uri.path = path3;
      this.uri.host = host;
      this.uri.hostname = host;
      this.uri.isUnix = true;
    };
    Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      self2._auth.onRequest(user, pass, sendImmediately, bearer);
      return self2;
    };
    Request.prototype.aws = function(opts, now2) {
      var self2 = this;
      if (!now2) {
        self2._aws = opts;
        return self2;
      }
      if (opts.sign_version === 4 || opts.sign_version === "4") {
        var options = {
          host: self2.uri.host,
          path: self2.uri.path,
          method: self2.method,
          headers: self2.headers,
          body: self2.body
        };
        if (opts.service) {
          options.service = opts.service;
        }
        var signRes = aws4.sign(options, {
          accessKeyId: opts.key,
          secretAccessKey: opts.secret,
          sessionToken: opts.session
        });
        self2.setHeader("authorization", signRes.headers.Authorization);
        self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
        if (signRes.headers["X-Amz-Security-Token"]) {
          self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
        }
      } else {
        var date = /* @__PURE__ */ new Date();
        self2.setHeader("date", date.toUTCString());
        var auth = {
          key: opts.key,
          secret: opts.secret,
          verb: self2.method.toUpperCase(),
          date,
          contentType: self2.getHeader("content-type") || "",
          md5: self2.getHeader("content-md5") || "",
          amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
        };
        var path3 = self2.uri.path;
        if (opts.bucket && path3) {
          auth.resource = "/" + opts.bucket + path3;
        } else if (opts.bucket && !path3) {
          auth.resource = "/" + opts.bucket;
        } else if (!opts.bucket && path3) {
          auth.resource = path3;
        } else if (!opts.bucket && !path3) {
          auth.resource = "/";
        }
        auth.resource = aws2.canonicalizeResource(auth.resource);
        self2.setHeader("authorization", aws2.authorization(auth));
      }
      return self2;
    };
    Request.prototype.httpSignature = function(opts) {
      var self2 = this;
      httpSignature.signRequest({
        getHeader: function(header) {
          return self2.getHeader(header, self2.headers);
        },
        setHeader: function(header, value2) {
          self2.setHeader(header, value2);
        },
        method: self2.method,
        path: self2.path
      }, opts);
      debug9("httpSignature authorization", self2.getHeader("authorization"));
      return self2;
    };
    Request.prototype.hawk = function(opts) {
      var self2 = this;
      self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
    };
    Request.prototype.oauth = function(_oauth) {
      var self2 = this;
      self2._oauth.onRequest(_oauth);
      return self2;
    };
    Request.prototype.jar = function(jar) {
      var self2 = this;
      var cookies2;
      if (self2._redirect.redirectsFollowed === 0) {
        self2.originalCookieHeader = self2.getHeader("cookie");
      }
      if (!jar) {
        cookies2 = false;
        self2._disableCookies = true;
      } else {
        var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
        var urihref = self2.uri.href;
        if (targetCookieJar) {
          cookies2 = targetCookieJar.getCookieString(urihref);
        }
      }
      if (cookies2 && cookies2.length) {
        if (self2.originalCookieHeader) {
          self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
        } else {
          self2.setHeader("cookie", cookies2);
        }
      }
      self2._jar = jar;
      return self2;
    };
    Request.prototype.pipe = function(dest, opts) {
      var self2 = this;
      if (self2.response) {
        if (self2._destdata) {
          self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
        } else if (self2._ended) {
          self2.emit("error", new Error("You cannot pipe after the response has been ended."));
        } else {
          stream.Stream.prototype.pipe.call(self2, dest, opts);
          self2.pipeDest(dest);
          return dest;
        }
      } else {
        self2.dests.push(dest);
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        return dest;
      }
    };
    Request.prototype.write = function() {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        return self2.req.write.apply(self2.req, arguments);
      }
    };
    Request.prototype.end = function(chunk) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (chunk) {
        self2.write(chunk);
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        self2.req.end();
      }
    };
    Request.prototype.pause = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = true;
      } else {
        self2.responseContent.pause.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.resume = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = false;
      } else {
        self2.responseContent.resume.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.destroy = function() {
      var self2 = this;
      this.clearTimeout();
      if (!self2._ended) {
        self2.end();
      } else if (self2.response) {
        self2.response.destroy();
      }
    };
    Request.prototype.clearTimeout = function() {
      if (this.timeoutTimer) {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = null;
      }
    };
    Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
    Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
    Request.prototype.toJSON = requestToJSON;
    module.exports = Request;
  }
});

// node_modules/request/index.js
var require_request3 = __commonJS({
  "node_modules/request/index.js"(exports, module) {
    "use strict";
    var extend = require_extend();
    var cookies = require_cookies();
    var helpers = require_helpers();
    var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
    function initParams(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      var params = {};
      if (options !== null && typeof options === "object") {
        extend(params, options, { uri });
      } else if (typeof uri === "string") {
        extend(params, { uri });
      } else {
        extend(params, uri);
      }
      params.callback = callback || params.callback;
      return params;
    }
    function request2(uri, options, callback) {
      if (typeof uri === "undefined") {
        throw new Error("undefined is not a valid uri or options object.");
      }
      var params = initParams(uri, options, callback);
      if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
        throw new Error("HTTP HEAD requests MUST NOT include a request body.");
      }
      return new request2.Request(params);
    }
    function verbFunc(verb) {
      var method = verb.toUpperCase();
      return function(uri, options, callback) {
        var params = initParams(uri, options, callback);
        params.method = method;
        return request2(params, params.callback);
      };
    }
    request2.get = verbFunc("get");
    request2.head = verbFunc("head");
    request2.options = verbFunc("options");
    request2.post = verbFunc("post");
    request2.put = verbFunc("put");
    request2.patch = verbFunc("patch");
    request2.del = verbFunc("delete");
    request2["delete"] = verbFunc("delete");
    request2.jar = function(store2) {
      return cookies.jar(store2);
    };
    request2.cookie = function(str) {
      return cookies.parse(str);
    };
    function wrapRequestMethod(method, options, requester, verb) {
      return function(uri, opts, callback) {
        var params = initParams(uri, opts, callback);
        var target = {};
        extend(true, target, options, params);
        target.pool = params.pool || options.pool;
        if (verb) {
          target.method = verb.toUpperCase();
        }
        if (typeof requester === "function") {
          method = requester;
        }
        return method(target, target.callback);
      };
    }
    request2.defaults = function(options, requester) {
      var self2 = this;
      options = options || {};
      if (typeof options === "function") {
        requester = options;
        options = {};
      }
      var defaults = wrapRequestMethod(self2, options, requester);
      var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
      verbs.forEach(function(verb) {
        defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
      });
      defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
      defaults.jar = self2.jar;
      defaults.defaults = self2.defaults;
      return defaults;
    };
    request2.forever = function(agentOptions, optionsArg) {
      var options = {};
      if (optionsArg) {
        extend(options, optionsArg);
      }
      if (agentOptions) {
        options.agentOptions = agentOptions;
      }
      options.forever = true;
      return request2.defaults(options);
    };
    module.exports = request2;
    request2.Request = require_request2();
    request2.initParams = initParams;
    Object.defineProperty(request2, "debug", {
      enumerable: true,
      get: function() {
        return request2.Request.debug;
      },
      set: function(debug9) {
        request2.Request.debug = debug9;
      }
    });
  }
});

// node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val2, options) {
      options = options || {};
      var type3 = typeof val2;
      if (type3 === "string" && val2.length > 0) {
        return parse9(val2);
      } else if (type3 === "number" && isNaN(val2) === false) {
        return options.long ? fmtLong(val2) : fmtShort(val2);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val2)
      );
    };
    function parse9(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type3 = (match[2] || "ms").toLowerCase();
      switch (type3) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/debug/src/debug.js"(exports, module) {
    exports = module.exports = createDebug9.debug = createDebug9["default"] = createDebug9;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug9(namespace) {
      function debug9() {
        if (!debug9.enabled)
          return;
        var self2 = debug9;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index2++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val2 = args[index2];
            match = formatter.call(self2, val2);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug9.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug9.namespace = namespace;
      debug9.enabled = exports.enabled(namespace);
      debug9.useColors = exports.useColors();
      debug9.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug9);
      }
      return debug9;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val2) {
      if (val2 instanceof Error)
        return val2.stack || val2.message;
      return val2;
    }
  }
});

// node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports = module.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index2++;
        if ("%c" === match) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util = __require("util");
    exports = module.exports = require_debug();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop2 = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val2 = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val2))
        val2 = true;
      else if (/^(no|off|false|disabled)$/i.test(val2))
        val2 = false;
      else if (val2 === "null")
        val2 = null;
      else
        val2 = Number(val2);
      obj[prop2] = val2;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = __require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = __require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug9) {
      debug9.inspectOpts = {};
      var keys4 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys4.length; i++) {
        debug9.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
      }
    }
    exports.enable(load2());
  }
});

// node_modules/debug/src/index.js
var require_src6 = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module.exports = require_browser3();
    } else {
      module.exports = require_node2();
    }
  }
});

// node_modules/app-store-scraper/lib/common.js
var require_common2 = __commonJS({
  "node_modules/app-store-scraper/lib/common.js"(exports, module) {
    "use strict";
    var request2 = require_request3();
    var debug9 = require_src6()("app-store-scraper");
    var c = require_constants();
    function cleanApp(app2) {
      return {
        id: app2.trackId,
        appId: app2.bundleId,
        title: app2.trackName,
        url: app2.trackViewUrl,
        description: app2.description,
        icon: app2.artworkUrl512 || app2.artworkUrl100 || app2.artworkUrl60,
        genres: app2.genres,
        genreIds: app2.genreIds,
        primaryGenre: app2.primaryGenreName,
        primaryGenreId: app2.primaryGenreId,
        contentRating: app2.contentAdvisoryRating,
        languages: app2.languageCodesISO2A,
        size: app2.fileSizeBytes,
        requiredOsVersion: app2.minimumOsVersion,
        released: app2.releaseDate,
        updated: app2.currentVersionReleaseDate || app2.releaseDate,
        releaseNotes: app2.releaseNotes,
        version: app2.version,
        price: app2.price,
        currency: app2.currency,
        free: app2.price === 0,
        developerId: app2.artistId,
        developer: app2.artistName,
        developerUrl: app2.artistViewUrl,
        developerWebsite: app2.sellerUrl,
        score: app2.averageUserRating,
        reviews: app2.userRatingCount,
        currentVersionScore: app2.averageUserRatingForCurrentVersion,
        currentVersionReviews: app2.userRatingCountForCurrentVersion,
        screenshots: app2.screenshotUrls,
        ipadScreenshots: app2.ipadScreenshotUrls,
        appletvScreenshots: app2.appletvScreenshotUrls,
        supportedDevices: app2.supportedDevices
      };
    }
    var doRequest2 = (url6, headers, requestOptions) => new Promise(function(resolve, reject) {
      debug9("Making request: %s %j %o", url6, headers, requestOptions);
      requestOptions = Object.assign({ method: "GET" }, requestOptions);
      request2(Object.assign({ url: url6, headers }, requestOptions), (error, response2, body) => {
        if (error) {
          debug9("Request error", error);
          return reject(error);
        }
        if (response2.statusCode >= 400) {
          return reject({ response: response2 });
        }
        debug9("Finished request");
        resolve(body);
      });
    });
    var LOOKUP_URL = "https://itunes.apple.com/lookup";
    function lookup(ids, idField, country, lang, requestOptions) {
      idField = idField || "id";
      country = country || "us";
      const langParam = lang ? `&lang=${lang}` : "";
      const joinedIds = ids.join(",");
      const url6 = `${LOOKUP_URL}?${idField}=${joinedIds}&country=${country}&entity=software${langParam}`;
      return doRequest2(url6, {}, requestOptions).then(JSON.parse).then((res) => res.results.filter(function(app2) {
        return typeof app2.wrapperType === "undefined" || app2.wrapperType === "software";
      })).then((res) => res.map(cleanApp));
    }
    function storeId(countryCode) {
      const markets = c.markets;
      const defaultStore = "143441";
      return countryCode && markets[countryCode.toUpperCase()] || defaultStore;
    }
    module.exports = { cleanApp, lookup, request: doRequest2, storeId };
  }
});

// node_modules/cheerio/lib/types.js
var require_types5 = __commonJS({
  "node_modules/cheerio/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/cheerio/lib/options.js
var require_options = __commonJS({
  "node_modules/cheerio/lib/options.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatten = void 0;
    var defaultOpts4 = {
      xml: false,
      decodeEntities: true
    };
    exports.default = defaultOpts4;
    var xmlModeDefault2 = {
      _useHtmlParser2: true,
      xmlMode: true
    };
    function flatten2(options) {
      return (options === null || options === void 0 ? void 0 : options.xml) ? typeof options.xml === "boolean" ? xmlModeDefault2 : __assign(__assign({}, xmlModeDefault2), options.xml) : options !== null && options !== void 0 ? options : void 0;
    }
    exports.flatten = flatten2;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType2;
    (function(ElementType3) {
      ElementType3["Root"] = "root";
      ElementType3["Text"] = "text";
      ElementType3["Directive"] = "directive";
      ElementType3["Comment"] = "comment";
      ElementType3["Script"] = "script";
      ElementType3["Style"] = "style";
      ElementType3["Tag"] = "tag";
      ElementType3["CDATA"] = "cdata";
      ElementType3["Doctype"] = "doctype";
    })(ElementType2 = exports.ElementType || (exports.ElementType = {}));
    function isTag3(elem) {
      return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
    }
    exports.isTag = isTag3;
    exports.Root = ElementType2.Root;
    exports.Text = ElementType2.Text;
    exports.Directive = ElementType2.Directive;
    exports.Comment = ElementType2.Comment;
    exports.Script = ElementType2.Script;
    exports.Style = ElementType2.Style;
    exports.Tag = ElementType2.Tag;
    exports.CDATA = ElementType2.CDATA;
    exports.Doctype = ElementType2.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node3 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib6();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent2) {
            this.parent = parent2;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev2) {
            this.prev = prev2;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next2) {
            this.next = next2;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode2(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode2 = (
      /** @class */
      function(_super) {
        __extends(DataNode3, _super);
        function DataNode3(data3) {
          var _this = _super.call(this) || this;
          _this.data = data3;
          return _this;
        }
        Object.defineProperty(DataNode3.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data3) {
            this.data = data3;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode3;
      }(Node2)
    );
    exports.DataNode = DataNode2;
    var Text3 = (
      /** @class */
      function(_super) {
        __extends(Text4, _super);
        function Text4() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text4.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text4;
      }(DataNode2)
    );
    exports.Text = Text3;
    var Comment3 = (
      /** @class */
      function(_super) {
        __extends(Comment4, _super);
        function Comment4() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment4.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment4;
      }(DataNode2)
    );
    exports.Comment = Comment3;
    var ProcessingInstruction2 = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction3, _super);
        function ProcessingInstruction3(name, data3) {
          var _this = _super.call(this, data3) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction3.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction3;
      }(DataNode2)
    );
    exports.ProcessingInstruction = ProcessingInstruction2;
    var NodeWithChildren2 = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren3, _super);
        function NodeWithChildren3(children3) {
          var _this = _super.call(this) || this;
          _this.children = children3;
          return _this;
        }
        Object.defineProperty(NodeWithChildren3.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a2;
            return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children3) {
            this.children = children3;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren3;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren2;
    var CDATA3 = (
      /** @class */
      function(_super) {
        __extends(CDATA4, _super);
        function CDATA4() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA4.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA4;
      }(NodeWithChildren2)
    );
    exports.CDATA = CDATA3;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document3.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document3;
      }(NodeWithChildren2)
    );
    exports.Document = Document2;
    var Element2 = (
      /** @class */
      function(_super) {
        __extends(Element3, _super);
        function Element3(name, attribs, children3, type3) {
          if (children3 === void 0) {
            children3 = [];
          }
          if (type3 === void 0) {
            type3 = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children3) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type3;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a2, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a2 = _this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren2)
    );
    exports.Element = Element2;
    function isTag3(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag3;
    function isCDATA2(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA2;
    function isText2(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText2;
    function isComment2(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment2;
    function isDirective2(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective2;
    function isDocument2(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument2;
    function hasChildren2(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren2;
    function cloneNode2(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText2(node)) {
        result = new Text3(node.data);
      } else if (isComment2(node)) {
        result = new Comment3(node.data);
      } else if (isTag3(node)) {
        var children3 = recursive ? cloneChildren2(node.children) : [];
        var clone_1 = new Element2(node.name, __assign({}, node.attribs), children3);
        children3.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA2(node)) {
        var children3 = recursive ? cloneChildren2(node.children) : [];
        var clone_2 = new CDATA3(children3);
        children3.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument2(node)) {
        var children3 = recursive ? cloneChildren2(node.children) : [];
        var clone_3 = new Document2(children3);
        children3.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective2(node)) {
        var instruction = new ProcessingInstruction2(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode2;
    function cloneChildren2(childs) {
      var children3 = childs.map(function(child) {
        return cloneNode2(child, true);
      });
      for (var i = 1; i < children3.length; i++) {
        children3[i].prev = children3[i - 1];
        children3[i - 1].next = children3[i];
      }
      return children3;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib6();
    var node_js_1 = require_node3();
    __exportStar(require_node3(), exports);
    var defaultOpts4 = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler2 = (
      /** @class */
      function() {
        function DomHandler3(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts4;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts4;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler3.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler3.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler3.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler3.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler3.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler3.prototype.onopentag = function(name, attribs) {
          var type3 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type3);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler3.prototype.ontext = function(data3) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data3;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data3);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler3.prototype.oncomment = function(data3) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data3;
            return;
          }
          var node = new node_js_1.Comment(data3);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler3.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.oncdatastart = function() {
          var text3 = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text3]);
          this.addNode(node);
          text3.parent = node;
          this.lastNode = text3;
        };
        DomHandler3.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.onprocessinginstruction = function(name, data3) {
          var node = new node_js_1.ProcessingInstruction(name, data3);
          this.addNode(node);
        };
        DomHandler3.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler3.prototype.addNode = function(node) {
          var parent2 = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent2.children[parent2.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent2.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent2;
          this.lastNode = null;
        };
        return DomHandler3;
      }()
    );
    exports.DomHandler = DomHandler2;
    exports.default = DomHandler2;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap2 = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint2(codePoint) {
      var _a3;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint2;
    function decodeCodePoint2(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint2(codePoint));
    }
    exports.default = decodeCodePoint2;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes3;
    (function(CharCodes4) {
      CharCodes4[CharCodes4["NUM"] = 35] = "NUM";
      CharCodes4[CharCodes4["SEMI"] = 59] = "SEMI";
      CharCodes4[CharCodes4["EQUALS"] = 61] = "EQUALS";
      CharCodes4[CharCodes4["ZERO"] = 48] = "ZERO";
      CharCodes4[CharCodes4["NINE"] = 57] = "NINE";
      CharCodes4[CharCodes4["LOWER_A"] = 97] = "LOWER_A";
      CharCodes4[CharCodes4["LOWER_F"] = 102] = "LOWER_F";
      CharCodes4[CharCodes4["LOWER_X"] = 120] = "LOWER_X";
      CharCodes4[CharCodes4["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes4[CharCodes4["UPPER_A"] = 65] = "UPPER_A";
      CharCodes4[CharCodes4["UPPER_F"] = 70] = "UPPER_F";
      CharCodes4[CharCodes4["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes3 || (CharCodes3 = {}));
    var TO_LOWER_BIT2 = 32;
    var BinTrieFlags2;
    (function(BinTrieFlags3) {
      BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags2 = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber3(code) {
      return code >= CharCodes3.ZERO && code <= CharCodes3.NINE;
    }
    function isHexadecimalCharacter2(code) {
      return code >= CharCodes3.UPPER_A && code <= CharCodes3.UPPER_F || code >= CharCodes3.LOWER_A && code <= CharCodes3.LOWER_F;
    }
    function isAsciiAlphaNumeric3(code) {
      return code >= CharCodes3.UPPER_A && code <= CharCodes3.UPPER_Z || code >= CharCodes3.LOWER_A && code <= CharCodes3.LOWER_Z || isNumber3(code);
    }
    function isEntityInAttributeInvalidEnd3(code) {
      return code === CharCodes3.EQUALS || isAsciiAlphaNumeric3(code);
    }
    var EntityDecoderState2;
    (function(EntityDecoderState3) {
      EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState2 || (EntityDecoderState2 = {}));
    var DecodingMode2;
    (function(DecodingMode3) {
      DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
      DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
      DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
    })(DecodingMode2 = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder2 = (
      /** @class */
      function() {
        function EntityDecoder3(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState2.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode2.Strict;
        }
        EntityDecoder3.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState2.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder3.prototype.write = function(str, offset) {
          switch (this.state) {
            case EntityDecoderState2.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes3.NUM) {
                this.state = EntityDecoderState2.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState2.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState2.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState2.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState2.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState2.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder3.prototype.stateNumericStart = function(str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT2) === CharCodes3.LOWER_X) {
            this.state = EntityDecoderState2.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState2.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder3.prototype.addToNumericResult = function(str, start, end2, base) {
          if (start !== end2) {
            var digitCount = end2 - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder3.prototype.stateNumericHex = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber3(char) || isHexadecimalCharacter2(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder3.prototype.stateNumericDecimal = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber3(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder3.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a2;
          if (this.consumed <= expectedLength) {
            (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes3.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode2.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes3.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder3.prototype.stateNamedEntity = function(str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch2(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode2.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd3(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes3.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode2.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder3.prototype.emitNotTerminatedNamedEntity = function() {
          var _a2;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags2.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder3.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags2.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder3.prototype.end = function() {
          var _a2;
          switch (this.state) {
            case EntityDecoderState2.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode2.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState2.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState2.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState2.NumericStart: {
              (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState2.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder3;
      }()
    );
    exports.EntityDecoder = EntityDecoder2;
    function getDecoder2(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder2(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch2(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags2.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags2.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value2 = char - jumpOffset;
        return value2 < 0 || value2 >= branchCount ? -1 : decodeTree[nodeIdx + value2] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch2;
    var htmlDecoder2 = getDecoder2(decode_data_html_js_1.default);
    var xmlDecoder2 = getDecoder2(decode_data_xml_js_1.default);
    function decodeHTML2(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode2.Legacy;
      }
      return htmlDecoder2(str, mode);
    }
    exports.decodeHTML = decodeHTML2;
    function decodeHTMLAttribute2(str) {
      return htmlDecoder2(str, DecodingMode2.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute2;
    function decodeHTMLStrict2(str) {
      return htmlDecoder2(str, DecodingMode2.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict2;
    function decodeXML2(str) {
      return xmlDecoder2(str, DecodingMode2.Strict);
    }
    exports.decodeXML = decodeXML2;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff2(arr) {
      for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(/* @__PURE__ */ restoreDiff2([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff2([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff2([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff2([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap2 = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str, index2) {
      return str.codePointAt(index2);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c, index2) {
        return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
      }
    );
    function encodeXML2(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next2 = xmlCodeMap2.get(char);
        if (next2 !== void 0) {
          ret += str.substring(lastIdx, i) + next2;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML2;
    exports.escape = encodeXML2;
    function getEscaper2(regex, map4) {
      return function escape2(data3) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data3)) {
          if (lastIdx !== match.index) {
            result += data3.substring(lastIdx, match.index);
          }
          result += map4.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data3.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper2(/[&<>'"]/g, xmlCodeMap2);
    exports.escapeAttribute = getEscaper2(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper2(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML2(data3) {
      return encodeHTMLTrieRe(htmlReplacer, data3);
    }
    exports.encodeHTML = encodeHTML2;
    function encodeNonAsciiHTML2(data3) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data3);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML2;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next2 = encode_html_js_1.default.get(char);
        if (typeof next2 === "object") {
          if (i + 1 < str.length) {
            var nextChar = str.charCodeAt(i + 1);
            var value2 = typeof next2.n === "number" ? next2.n === nextChar ? next2.o : void 0 : next2.n.get(nextChar);
            if (value2 !== void 0) {
              ret += value2;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next2 = next2.v;
        }
        if (next2 !== void 0) {
          ret += next2;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel2;
    (function(EntityLevel3) {
      EntityLevel3[EntityLevel3["XML"] = 0] = "XML";
      EntityLevel3[EntityLevel3["HTML"] = 1] = "HTML";
    })(EntityLevel2 = exports.EntityLevel || (exports.EntityLevel = {}));
    var EncodingMode2;
    (function(EncodingMode3) {
      EncodingMode3[EncodingMode3["UTF8"] = 0] = "UTF8";
      EncodingMode3[EncodingMode3["ASCII"] = 1] = "ASCII";
      EncodingMode3[EncodingMode3["Extensive"] = 2] = "Extensive";
      EncodingMode3[EncodingMode3["Attribute"] = 3] = "Attribute";
      EncodingMode3[EncodingMode3["Text"] = 4] = "Text";
    })(EncodingMode2 = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data3, options) {
      if (options === void 0) {
        options = EntityLevel2.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel2.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data3, mode);
      }
      return (0, decode_js_1.decodeXML)(data3);
    }
    exports.decode = decode;
    function decodeStrict(data3, options) {
      var _a2;
      if (options === void 0) {
        options = EntityLevel2.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a2 = opts.mode) !== null && _a2 !== void 0 ? _a2 : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data3, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data3, options) {
      if (options === void 0) {
        options = EntityLevel2.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode2.UTF8)
        return (0, escape_js_1.escapeUTF8)(data3);
      if (opts.mode === EncodingMode2.Attribute)
        return (0, escape_js_1.escapeAttribute)(data3);
      if (opts.mode === EncodingMode2.Text)
        return (0, escape_js_1.escapeText)(data3);
      if (opts.level === EntityLevel2.HTML) {
        if (opts.mode === EncodingMode2.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data3);
        }
        return (0, encode_js_1.encodeHTML)(data3);
      }
      return (0, escape_js_1.encodeXML)(data3);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val2) {
      return [val2.toLowerCase(), val2];
    }));
    exports.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val2) {
      return [val2.toLowerCase(), val2];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType2 = __importStar(require_lib6());
    var entities_1 = require_lib8();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements2 = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes2(value2) {
      return value2.replace(/"/g, "&quot;");
    }
    function formatAttributes2(attributes2, opts) {
      var _a2;
      if (!attributes2)
        return;
      var encode = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes2 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes2).map(function(key) {
        var _a3, _b;
        var value2 = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value2 === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value2), '"');
      }).join(" ");
    }
    var singleTag2 = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render3(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode2(nodes[i], options);
      }
      return output;
    }
    exports.render = render3;
    exports.default = render3;
    function renderNode2(node, options) {
      switch (node.type) {
        case ElementType2.Root:
          return render3(node.children, options);
        case ElementType2.Doctype:
        case ElementType2.Directive:
          return renderDirective2(node);
        case ElementType2.Comment:
          return renderComment2(node);
        case ElementType2.CDATA:
          return renderCdata2(node);
        case ElementType2.Script:
        case ElementType2.Style:
        case ElementType2.Tag:
          return renderTag2(node, options);
        case ElementType2.Text:
          return renderText2(node, options);
      }
    }
    var foreignModeIntegrationPoints2 = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements2 = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag2(elem, opts) {
      var _a2;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a2 = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
        if (elem.parent && foreignModeIntegrationPoints2.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements2.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes2(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag2.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render3(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag2.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective2(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText2(elem, opts) {
      var _a2;
      var data3 = elem.data || "";
      if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements2.has(elem.parent.name))) {
        data3 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data3) : (0, entities_1.escapeText)(data3);
      }
      return data3;
    }
    function renderCdata2(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment2(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify4 = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib7();
    var dom_serializer_1 = __importDefault(require_lib9());
    var domelementtype_1 = require_lib6();
    function getOuterHTML2(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML2;
    function getInnerHTML2(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML2(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML2;
    function getText2(node) {
      if (Array.isArray(node))
        return node.map(getText2).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText2(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText2(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText2;
    function textContent2(node) {
      if (Array.isArray(node))
        return node.map(textContent2).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent2(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent2;
    function innerText2(node) {
      if (Array.isArray(node))
        return node.map(innerText2).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText2(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText2;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib7();
    function getChildren2(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren2;
    function getParent2(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent2;
    function getSiblings2(elem) {
      var _a2, _b;
      var parent2 = getParent2(elem);
      if (parent2 != null)
        return getChildren2(parent2);
      var siblings2 = [elem];
      var prev2 = elem.prev, next2 = elem.next;
      while (prev2 != null) {
        siblings2.unshift(prev2);
        _a2 = prev2, prev2 = _a2.prev;
      }
      while (next2 != null) {
        siblings2.push(next2);
        _b = next2, next2 = _b.next;
      }
      return siblings2;
    }
    exports.getSiblings = getSiblings2;
    function getAttributeValue2(elem, name) {
      var _a2;
      return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
    }
    exports.getAttributeValue = getAttributeValue2;
    function hasAttrib2(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib2;
    function getName2(elem) {
      return elem.name;
    }
    exports.getName = getName2;
    function nextElementSibling2(elem) {
      var _a2;
      var next2 = elem.next;
      while (next2 !== null && !(0, domhandler_1.isTag)(next2))
        _a2 = next2, next2 = _a2.next;
      return next2;
    }
    exports.nextElementSibling = nextElementSibling2;
    function prevElementSibling2(elem) {
      var _a2;
      var prev2 = elem.prev;
      while (prev2 !== null && !(0, domhandler_1.isTag)(prev2))
        _a2 = prev2, prev2 = _a2.prev;
      return prev2;
    }
    exports.prevElementSibling = prevElementSibling2;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement2(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports.removeElement = removeElement2;
    function replaceElement2(elem, replacement) {
      var prev2 = replacement.prev = elem.prev;
      if (prev2) {
        prev2.next = replacement;
      }
      var next2 = replacement.next = elem.next;
      if (next2) {
        next2.prev = replacement;
      }
      var parent2 = replacement.parent = elem.parent;
      if (parent2) {
        var childs = parent2.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports.replaceElement = replaceElement2;
    function appendChild2(parent2, child) {
      removeElement2(child);
      child.next = null;
      child.parent = parent2;
      if (parent2.children.push(child) > 1) {
        var sibling = parent2.children[parent2.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild2;
    function append3(elem, next2) {
      removeElement2(next2);
      var parent2 = elem.parent;
      var currNext = elem.next;
      next2.next = currNext;
      next2.prev = elem;
      elem.next = next2;
      next2.parent = parent2;
      if (currNext) {
        currNext.prev = next2;
        if (parent2) {
          var childs = parent2.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next2);
        }
      } else if (parent2) {
        parent2.children.push(next2);
      }
    }
    exports.append = append3;
    function prependChild2(parent2, child) {
      removeElement2(child);
      child.parent = parent2;
      child.prev = null;
      if (parent2.children.unshift(child) !== 1) {
        var sibling = parent2.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild2;
    function prepend3(elem, prev2) {
      removeElement2(prev2);
      var parent2 = elem.parent;
      if (parent2) {
        var childs = parent2.children;
        childs.splice(childs.indexOf(elem), 0, prev2);
      }
      if (elem.prev) {
        elem.prev.next = prev2;
      }
      prev2.parent = parent2;
      prev2.prev = elem.prev;
      prev2.next = elem;
      elem.prev = prev2;
    }
    exports.prepend = prepend3;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib7();
    function filter4(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find4(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports.filter = filter4;
    function find4(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.find = find4;
    function findOneChild2(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild2;
    function findOne2(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i = 0; i < nodes.length && !elem; i++) {
        var node = nodes[i];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne2(test, node.children, true);
        }
      }
      return elem;
    }
    exports.findOne = findOne2;
    function existsOne2(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne2(test, checked.children));
      });
    }
    exports.existsOne = existsOne2;
    function findAll2(test, nodes) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.findAll = findAll2;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib7();
    var querying_js_1 = require_querying();
    var Checks2 = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type3) {
        if (typeof type3 === "function") {
          return function(elem) {
            return type3(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type3;
        };
      },
      tag_contains: function(data3) {
        if (typeof data3 === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data3(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data3;
        };
      }
    };
    function getAttribCheck2(attrib, value2) {
      if (typeof value2 === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value2(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value2;
      };
    }
    function combineFuncs2(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest2(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value2 = options[key];
        return Object.prototype.hasOwnProperty.call(Checks2, key) ? Checks2[key](value2) : getAttribCheck2(key, value2);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs2);
    }
    function testElement2(options, node) {
      var test = compileTest2(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement2;
    function getElements2(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest2(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements2;
    function getElementById2(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck2("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById2;
    function getElementsByTagName2(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks2["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName2;
    function getElementsByTagType2(type3, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks2["tag_type"](type3), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType2;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib7();
    function removeSubsets2(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets2;
    var DocumentPosition2;
    (function(DocumentPosition3) {
      DocumentPosition3[DocumentPosition3["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition3[DocumentPosition3["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition3[DocumentPosition3["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition3[DocumentPosition3["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition3[DocumentPosition3["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition2 = exports.DocumentPosition || (exports.DocumentPosition = {}));
    function compareDocumentPosition2(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition2.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings2 = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition2.FOLLOWING | DocumentPosition2.CONTAINED_BY;
        }
        return DocumentPosition2.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition2.PRECEDING | DocumentPosition2.CONTAINS;
      }
      return DocumentPosition2.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition2;
    function uniqueSort2(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition2(a, b);
        if (relative & DocumentPosition2.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition2.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort2;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_js_1 = require_stringify4();
    var legacy_js_1 = require_legacy();
    function getFeed2(doc) {
      var feedRoot = getOneElement2(isValidFeed2, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed2(feedRoot) : getRssFeed2(feedRoot);
    }
    exports.getFeed = getFeed2;
    function getAtomFeed2(feedRoot) {
      var _a2;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a3;
          var children3 = item.children;
          var entry = { media: getMediaElements2(children3) };
          addConditionally2(entry, "id", "id", children3);
          addConditionally2(entry, "title", "title", children3);
          var href2 = (_a3 = getOneElement2("link", children3)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children3) || fetch2("content", children3);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children3);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally2(feed, "id", "id", childs);
      addConditionally2(feed, "title", "title", childs);
      var href = (_a2 = getOneElement2("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally2(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally2(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed2(feedRoot) {
      var _a2, _b;
      var childs = (_b = (_a2 = getOneElement2("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children3 = item.children;
          var entry = { media: getMediaElements2(children3) };
          addConditionally2(entry, "id", "guid", children3);
          addConditionally2(entry, "title", "title", children3);
          addConditionally2(entry, "link", "link", children3);
          addConditionally2(entry, "description", "description", children3);
          var pubDate = fetch2("pubDate", children3) || fetch2("dc:date", children3);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally2(feed, "title", "title", childs);
      addConditionally2(feed, "link", "link", childs);
      addConditionally2(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally2(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING2 = ["url", "type", "lang"];
    var MEDIA_KEYS_INT2 = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements2(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING2; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a2 = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT2; _a2 < MEDIA_KEYS_INT_1.length; _a2++) {
          var attrib = MEDIA_KEYS_INT_1[_a2];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement2(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally2(obj, prop2, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val2 = fetch2(tagName, where, recurse);
      if (val2)
        obj[prop2] = val2;
    }
    function isValidFeed2(value2) {
      return value2 === "rss" || value2 === "feed" || value2 === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify4(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy(), exports);
    __exportStar(require_helpers2(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib7();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/cheerio/lib/static.js
var require_static = __commonJS({
  "node_modules/cheerio/lib/static.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = exports.contains = exports.root = exports.parseHTML = exports.text = exports.xml = exports.html = void 0;
    var domutils_1 = require_lib10();
    var options_js_1 = __importStar(require_options());
    function render3(that, dom, options) {
      if (!that)
        return "";
      return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options).toString();
    }
    function isOptions2(dom, options) {
      return !options && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
    }
    function html3(dom, options) {
      var toRender = isOptions2(dom) ? (options = dom, void 0) : dom;
      var opts = __assign(__assign(__assign({}, options_js_1.default), this === null || this === void 0 ? void 0 : this._options), (0, options_js_1.flatten)(options !== null && options !== void 0 ? options : {}));
      return render3(this, toRender, opts);
    }
    exports.html = html3;
    function xml2(dom) {
      var options = __assign(__assign({}, this._options), { xmlMode: true });
      return render3(this, dom, options);
    }
    exports.xml = xml2;
    function text3(elements) {
      var elems = elements ? elements : this ? this.root() : [];
      var ret = "";
      for (var i = 0; i < elems.length; i++) {
        ret += (0, domutils_1.textContent)(elems[i]);
      }
      return ret;
    }
    exports.text = text3;
    function parseHTML3(data3, context, keepScripts) {
      if (keepScripts === void 0) {
        keepScripts = typeof context === "boolean" ? context : false;
      }
      if (!data3 || typeof data3 !== "string") {
        return null;
      }
      if (typeof context === "boolean") {
        keepScripts = context;
      }
      var parsed = this.load(data3, options_js_1.default, false);
      if (!keepScripts) {
        parsed("script").remove();
      }
      return parsed.root()[0].children.slice();
    }
    exports.parseHTML = parseHTML3;
    function root3() {
      return this(this._root);
    }
    exports.root = root3;
    function contains5(container, contained) {
      if (contained === container) {
        return false;
      }
      var next2 = contained;
      while (next2 && next2 !== next2.parent) {
        next2 = next2.parent;
        if (next2 === container) {
          return true;
        }
      }
      return false;
    }
    exports.contains = contains5;
    function merge3(arr1, arr2) {
      if (!isArrayLike3(arr1) || !isArrayLike3(arr2)) {
        return;
      }
      var newLength = arr1.length;
      var len = +arr2.length;
      for (var i = 0; i < len; i++) {
        arr1[newLength++] = arr2[i];
      }
      arr1.length = newLength;
      return arr1;
    }
    exports.merge = merge3;
    function isArrayLike3(item) {
      if (Array.isArray(item)) {
        return true;
      }
      if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
        return false;
      }
      for (var i = 0; i < item.length; i++) {
        if (!(i in item)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/cheerio/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/cheerio/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHtml = exports.cloneDom = exports.domEach = exports.cssCase = exports.camelCase = exports.isCheerio = exports.isTag = void 0;
    var domhandler_1 = require_lib7();
    var domhandler_2 = require_lib7();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_2.isTag;
    } });
    function isCheerio2(maybeCheerio) {
      return maybeCheerio.cheerio != null;
    }
    exports.isCheerio = isCheerio2;
    function camelCase2(str) {
      return str.replace(/[_.-](\w|$)/g, function(_, x) {
        return x.toUpperCase();
      });
    }
    exports.camelCase = camelCase2;
    function cssCase2(str) {
      return str.replace(/[A-Z]/g, "-$&").toLowerCase();
    }
    exports.cssCase = cssCase2;
    function domEach2(array, fn) {
      var len = array.length;
      for (var i = 0; i < len; i++)
        fn(array[i], i);
      return array;
    }
    exports.domEach = domEach2;
    function cloneDom2(dom) {
      var clone2 = "length" in dom ? Array.prototype.map.call(dom, function(el) {
        return (0, domhandler_1.cloneNode)(el, true);
      }) : [(0, domhandler_1.cloneNode)(dom, true)];
      var root3 = new domhandler_1.Document(clone2);
      clone2.forEach(function(node) {
        node.parent = root3;
      });
      return clone2;
    }
    exports.cloneDom = cloneDom2;
    var CharacterCodes2;
    (function(CharacterCodes3) {
      CharacterCodes3[CharacterCodes3["LowerA"] = 97] = "LowerA";
      CharacterCodes3[CharacterCodes3["LowerZ"] = 122] = "LowerZ";
      CharacterCodes3[CharacterCodes3["UpperA"] = 65] = "UpperA";
      CharacterCodes3[CharacterCodes3["UpperZ"] = 90] = "UpperZ";
      CharacterCodes3[CharacterCodes3["Exclamation"] = 33] = "Exclamation";
    })(CharacterCodes2 || (CharacterCodes2 = {}));
    function isHtml2(str) {
      var tagStart = str.indexOf("<");
      if (tagStart < 0 || tagStart > str.length - 3)
        return false;
      var tagChar = str.charCodeAt(tagStart + 1);
      return (tagChar >= CharacterCodes2.LowerA && tagChar <= CharacterCodes2.LowerZ || tagChar >= CharacterCodes2.UpperA && tagChar <= CharacterCodes2.UpperZ || tagChar === CharacterCodes2.Exclamation) && str.includes(">", tagStart + 2);
    }
    exports.isHtml = isHtml2;
  }
});

// node_modules/cheerio/lib/api/attributes.js
var require_attributes = __commonJS({
  "node_modules/cheerio/lib/api/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toggleClass = exports.removeClass = exports.addClass = exports.hasClass = exports.removeAttr = exports.val = exports.data = exports.prop = exports.attr = void 0;
    var static_js_1 = require_static();
    var utils_js_1 = require_utils4();
    var domutils_1 = require_lib10();
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var rspace2 = /\s+/;
    var dataAttrPrefix2 = "data-";
    var primitives2 = {
      null: null,
      true: true,
      false: false
    };
    var rboolean2 = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
    var rbrace2 = /^{[^]*}$|^\[[^]*]$/;
    function getAttr2(elem, name, xmlMode) {
      var _a2;
      if (!elem || !(0, utils_js_1.isTag)(elem))
        return void 0;
      (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
      if (!name) {
        return elem.attribs;
      }
      if (hasOwn2.call(elem.attribs, name)) {
        return !xmlMode && rboolean2.test(name) ? name : elem.attribs[name];
      }
      if (elem.name === "option" && name === "value") {
        return (0, static_js_1.text)(elem.children);
      }
      if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name === "value") {
        return "on";
      }
      return void 0;
    }
    function setAttr2(el, name, value2) {
      if (value2 === null) {
        removeAttribute2(el, name);
      } else {
        el.attribs[name] = "".concat(value2);
      }
    }
    function attr2(name, value2) {
      if (typeof name === "object" || value2 !== void 0) {
        if (typeof value2 === "function") {
          if (typeof name !== "string") {
            {
              throw new Error("Bad combination of arguments.");
            }
          }
          return (0, utils_js_1.domEach)(this, function(el, i) {
            if ((0, utils_js_1.isTag)(el))
              setAttr2(el, name, value2.call(el, i, el.attribs[name]));
          });
        }
        return (0, utils_js_1.domEach)(this, function(el) {
          if (!(0, utils_js_1.isTag)(el))
            return;
          if (typeof name === "object") {
            Object.keys(name).forEach(function(objName) {
              var objValue = name[objName];
              setAttr2(el, objName, objValue);
            });
          } else {
            setAttr2(el, name, value2);
          }
        });
      }
      return arguments.length > 1 ? this : getAttr2(this[0], name, this.options.xmlMode);
    }
    exports.attr = attr2;
    function getProp2(el, name, xmlMode) {
      return name in el ? (
        // @ts-expect-error TS doesn't like us accessing the value directly here.
        el[name]
      ) : !xmlMode && rboolean2.test(name) ? getAttr2(el, name, false) !== void 0 : getAttr2(el, name, xmlMode);
    }
    function setProp2(el, name, value2, xmlMode) {
      if (name in el) {
        el[name] = value2;
      } else {
        setAttr2(el, name, !xmlMode && rboolean2.test(name) ? value2 ? "" : null : "".concat(value2));
      }
    }
    function prop2(name, value2) {
      var _this = this;
      var _a2;
      if (typeof name === "string" && value2 === void 0) {
        var el = this[0];
        if (!el || !(0, utils_js_1.isTag)(el))
          return void 0;
        switch (name) {
          case "style": {
            var property_1 = this.css();
            var keys4 = Object.keys(property_1);
            keys4.forEach(function(p, i) {
              property_1[i] = p;
            });
            property_1.length = keys4.length;
            return property_1;
          }
          case "tagName":
          case "nodeName": {
            return el.name.toUpperCase();
          }
          case "href":
          case "src": {
            var prop_1 = (_a2 = el.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
            if (typeof URL !== "undefined" && (name === "href" && (el.tagName === "a" || el.name === "link") || name === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop_1 !== void 0 && this.options.baseURI) {
              return new URL(prop_1, this.options.baseURI).href;
            }
            return prop_1;
          }
          case "innerText": {
            return (0, domutils_1.innerText)(el);
          }
          case "textContent": {
            return (0, domutils_1.textContent)(el);
          }
          case "outerHTML":
            return this.clone().wrap("<container />").parent().html();
          case "innerHTML":
            return this.html();
          default:
            return getProp2(el, name, this.options.xmlMode);
        }
      }
      if (typeof name === "object" || value2 !== void 0) {
        if (typeof value2 === "function") {
          if (typeof name === "object") {
            throw new Error("Bad combination of arguments.");
          }
          return (0, utils_js_1.domEach)(this, function(el2, i) {
            if ((0, utils_js_1.isTag)(el2)) {
              setProp2(el2, name, value2.call(el2, i, getProp2(el2, name, _this.options.xmlMode)), _this.options.xmlMode);
            }
          });
        }
        return (0, utils_js_1.domEach)(this, function(el2) {
          if (!(0, utils_js_1.isTag)(el2))
            return;
          if (typeof name === "object") {
            Object.keys(name).forEach(function(key) {
              var val3 = name[key];
              setProp2(el2, key, val3, _this.options.xmlMode);
            });
          } else {
            setProp2(el2, name, value2, _this.options.xmlMode);
          }
        });
      }
      return void 0;
    }
    exports.prop = prop2;
    function setData2(el, name, value2) {
      var _a2;
      var elem = el;
      (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
      if (typeof name === "object")
        Object.assign(elem.data, name);
      else if (typeof name === "string" && value2 !== void 0) {
        elem.data[name] = value2;
      }
    }
    function readData2(el, name) {
      var domNames;
      var jsNames;
      var value2;
      if (name == null) {
        domNames = Object.keys(el.attribs).filter(function(attrName) {
          return attrName.startsWith(dataAttrPrefix2);
        });
        jsNames = domNames.map(function(domName2) {
          return (0, utils_js_1.camelCase)(domName2.slice(dataAttrPrefix2.length));
        });
      } else {
        domNames = [dataAttrPrefix2 + (0, utils_js_1.cssCase)(name)];
        jsNames = [name];
      }
      for (var idx = 0; idx < domNames.length; ++idx) {
        var domName = domNames[idx];
        var jsName = jsNames[idx];
        if (hasOwn2.call(el.attribs, domName) && !hasOwn2.call(el.data, jsName)) {
          value2 = el.attribs[domName];
          if (hasOwn2.call(primitives2, value2)) {
            value2 = primitives2[value2];
          } else if (value2 === String(Number(value2))) {
            value2 = Number(value2);
          } else if (rbrace2.test(value2)) {
            try {
              value2 = JSON.parse(value2);
            } catch (e) {
            }
          }
          el.data[jsName] = value2;
        }
      }
      return name == null ? el.data : value2;
    }
    function data3(name, value2) {
      var _a2;
      var elem = this[0];
      if (!elem || !(0, utils_js_1.isTag)(elem))
        return;
      var dataEl = elem;
      (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
      if (!name) {
        return readData2(dataEl);
      }
      if (typeof name === "object" || value2 !== void 0) {
        (0, utils_js_1.domEach)(this, function(el) {
          if ((0, utils_js_1.isTag)(el)) {
            if (typeof name === "object")
              setData2(el, name);
            else
              setData2(el, name, value2);
          }
        });
        return this;
      }
      if (hasOwn2.call(dataEl.data, name)) {
        return dataEl.data[name];
      }
      return readData2(dataEl, name);
    }
    exports.data = data3;
    function val2(value2) {
      var querying = arguments.length === 0;
      var element = this[0];
      if (!element || !(0, utils_js_1.isTag)(element))
        return querying ? void 0 : this;
      switch (element.name) {
        case "textarea":
          return this.text(value2);
        case "select": {
          var option = this.find("option:selected");
          if (!querying) {
            if (this.attr("multiple") == null && typeof value2 === "object") {
              return this;
            }
            this.find("option").removeAttr("selected");
            var values3 = typeof value2 !== "object" ? [value2] : value2;
            for (var i = 0; i < values3.length; i++) {
              this.find('option[value="'.concat(values3[i], '"]')).attr("selected", "");
            }
            return this;
          }
          return this.attr("multiple") ? option.toArray().map(function(el) {
            return (0, static_js_1.text)(el.children);
          }) : option.attr("value");
        }
        case "input":
        case "option":
          return querying ? this.attr("value") : this.attr("value", value2);
      }
      return void 0;
    }
    exports.val = val2;
    function removeAttribute2(elem, name) {
      if (!elem.attribs || !hasOwn2.call(elem.attribs, name))
        return;
      delete elem.attribs[name];
    }
    function splitNames2(names) {
      return names ? names.trim().split(rspace2) : [];
    }
    function removeAttr2(name) {
      var attrNames = splitNames2(name);
      var _loop_1 = function(i2) {
        (0, utils_js_1.domEach)(this_1, function(elem) {
          if ((0, utils_js_1.isTag)(elem))
            removeAttribute2(elem, attrNames[i2]);
        });
      };
      var this_1 = this;
      for (var i = 0; i < attrNames.length; i++) {
        _loop_1(i);
      }
      return this;
    }
    exports.removeAttr = removeAttr2;
    function hasClass2(className) {
      return this.toArray().some(function(elem) {
        var clazz = (0, utils_js_1.isTag)(elem) && elem.attribs["class"];
        var idx = -1;
        if (clazz && className.length) {
          while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
            var end2 = idx + className.length;
            if ((idx === 0 || rspace2.test(clazz[idx - 1])) && (end2 === clazz.length || rspace2.test(clazz[end2]))) {
              return true;
            }
          }
        }
        return false;
      });
    }
    exports.hasClass = hasClass2;
    function addClass2(value2) {
      if (typeof value2 === "function") {
        return (0, utils_js_1.domEach)(this, function(el2, i2) {
          if ((0, utils_js_1.isTag)(el2)) {
            var className2 = el2.attribs["class"] || "";
            addClass2.call([el2], value2.call(el2, i2, className2));
          }
        });
      }
      if (!value2 || typeof value2 !== "string")
        return this;
      var classNames = value2.split(rspace2);
      var numElements = this.length;
      for (var i = 0; i < numElements; i++) {
        var el = this[i];
        if (!(0, utils_js_1.isTag)(el))
          continue;
        var className = getAttr2(el, "class", false);
        if (!className) {
          setAttr2(el, "class", classNames.join(" ").trim());
        } else {
          var setClass = " ".concat(className, " ");
          for (var j = 0; j < classNames.length; j++) {
            var appendClass = "".concat(classNames[j], " ");
            if (!setClass.includes(" ".concat(appendClass)))
              setClass += appendClass;
          }
          setAttr2(el, "class", setClass.trim());
        }
      }
      return this;
    }
    exports.addClass = addClass2;
    function removeClass2(name) {
      if (typeof name === "function") {
        return (0, utils_js_1.domEach)(this, function(el, i) {
          if ((0, utils_js_1.isTag)(el)) {
            removeClass2.call([el], name.call(el, i, el.attribs["class"] || ""));
          }
        });
      }
      var classes = splitNames2(name);
      var numClasses = classes.length;
      var removeAll = arguments.length === 0;
      return (0, utils_js_1.domEach)(this, function(el) {
        if (!(0, utils_js_1.isTag)(el))
          return;
        if (removeAll) {
          el.attribs["class"] = "";
        } else {
          var elClasses = splitNames2(el.attribs["class"]);
          var changed = false;
          for (var j = 0; j < numClasses; j++) {
            var index2 = elClasses.indexOf(classes[j]);
            if (index2 >= 0) {
              elClasses.splice(index2, 1);
              changed = true;
              j--;
            }
          }
          if (changed) {
            el.attribs["class"] = elClasses.join(" ");
          }
        }
      });
    }
    exports.removeClass = removeClass2;
    function toggleClass2(value2, stateVal) {
      if (typeof value2 === "function") {
        return (0, utils_js_1.domEach)(this, function(el2, i2) {
          if ((0, utils_js_1.isTag)(el2)) {
            toggleClass2.call([el2], value2.call(el2, i2, el2.attribs["class"] || "", stateVal), stateVal);
          }
        });
      }
      if (!value2 || typeof value2 !== "string")
        return this;
      var classNames = value2.split(rspace2);
      var numClasses = classNames.length;
      var state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
      var numElements = this.length;
      for (var i = 0; i < numElements; i++) {
        var el = this[i];
        if (!(0, utils_js_1.isTag)(el))
          continue;
        var elementClasses = splitNames2(el.attribs["class"]);
        for (var j = 0; j < numClasses; j++) {
          var index2 = elementClasses.indexOf(classNames[j]);
          if (state >= 0 && index2 < 0) {
            elementClasses.push(classNames[j]);
          } else if (state <= 0 && index2 >= 0) {
            elementClasses.splice(index2, 1);
          }
        }
        el.attribs["class"] = elementClasses.join(" ");
      }
      return this;
    }
    exports.toggleClass = toggleClass2;
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = void 0;
    var css_what_1 = require_commonjs();
    var procedure2 = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal3(token) {
      return !procedure2.has(token.type);
    }
    exports.isTraversal = isTraversal3;
    var attributes2 = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure2(arr) {
      var procs = arr.map(getProcedure2);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports.default = sortByProcedure2;
    function getProcedure2(token) {
      var _a2, _b;
      var proc = (_a2 = procedure2.get(token.type)) !== null && _a2 !== void 0 ? _a2 : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes2.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d) {
            return Math.min.apply(Math, d.map(getProcedure2));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes2 = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars2 = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex2(value2) {
      return value2.replace(reChars2, "\\$&");
    }
    var caseInsensitiveAttributes2 = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase2(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes2.has(selector.name);
    }
    exports.attributeRules = {
      equals: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name;
        var value2 = data3.value;
        if (shouldIgnoreCase2(data3, options)) {
          value2 = value2.toLowerCase();
          return function(elem) {
            var attr2 = adapter2.getAttributeValue(elem, name);
            return attr2 != null && attr2.length === value2.length && attr2.toLowerCase() === value2 && next2(elem);
          };
        }
        return function(elem) {
          return adapter2.getAttributeValue(elem, name) === value2 && next2(elem);
        };
      },
      hyphen: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name;
        var value2 = data3.value;
        var len = value2.length;
        if (shouldIgnoreCase2(data3, options)) {
          value2 = value2.toLowerCase();
          return function hyphenIC(elem) {
            var attr2 = adapter2.getAttributeValue(elem, name);
            return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value2 && next2(elem);
          };
        }
        return function hyphen(elem) {
          var attr2 = adapter2.getAttributeValue(elem, name);
          return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value2 && next2(elem);
        };
      },
      element: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name, value2 = data3.value;
        if (/\s/.test(value2)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex2(value2), "(?:$|\\s)"), shouldIgnoreCase2(data3, options) ? "i" : "");
        return function element(elem) {
          var attr2 = adapter2.getAttributeValue(elem, name);
          return attr2 != null && attr2.length >= value2.length && regex.test(attr2) && next2(elem);
        };
      },
      exists: function(next2, _a2, _b) {
        var name = _a2.name;
        var adapter2 = _b.adapter;
        return function(elem) {
          return adapter2.hasAttrib(elem, name) && next2(elem);
        };
      },
      start: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name;
        var value2 = data3.value;
        var len = value2.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase2(data3, options)) {
          value2 = value2.toLowerCase();
          return function(elem) {
            var attr2 = adapter2.getAttributeValue(elem, name);
            return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value2 && next2(elem);
          };
        }
        return function(elem) {
          var _a2;
          return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value2)) && next2(elem);
        };
      },
      end: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name;
        var value2 = data3.value;
        var len = -value2.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase2(data3, options)) {
          value2 = value2.toLowerCase();
          return function(elem) {
            var _a2;
            return ((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value2 && next2(elem);
          };
        }
        return function(elem) {
          var _a2;
          return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value2)) && next2(elem);
        };
      },
      any: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name, value2 = data3.value;
        if (value2 === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase2(data3, options)) {
          var regex_1 = new RegExp(escapeRegex2(value2), "i");
          return function anyIC(elem) {
            var attr2 = adapter2.getAttributeValue(elem, name);
            return attr2 != null && attr2.length >= value2.length && regex_1.test(attr2) && next2(elem);
          };
        }
        return function(elem) {
          var _a2;
          return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.includes(value2)) && next2(elem);
        };
      },
      not: function(next2, data3, options) {
        var adapter2 = options.adapter;
        var name = data3.name;
        var value2 = data3.value;
        if (value2 === "") {
          return function(elem) {
            return !!adapter2.getAttributeValue(elem, name) && next2(elem);
          };
        } else if (shouldIgnoreCase2(data3, options)) {
          value2 = value2.toLowerCase();
          return function(elem) {
            var attr2 = adapter2.getAttributeValue(elem, name);
            return (attr2 == null || attr2.length !== value2.length || attr2.toLowerCase() !== value2) && next2(elem);
          };
        }
        return function(elem) {
          return adapter2.getAttributeValue(elem, name) !== value2 && next2(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace2 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO2 = "0".charCodeAt(0);
    var NINE2 = "9".charCodeAt(0);
    function parse9(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value2 = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO2 && formula.charCodeAt(idx) <= NINE2) {
          value2 = value2 * 10 + (formula.charCodeAt(idx) - ZERO2);
          idx++;
        }
        return idx === start ? null : value2;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace2.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports.parse = parse9;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = exports.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile4(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return boolbase_1.default.falseFunc;
      if (a === -1)
        return function(index2) {
          return index2 <= b;
        };
      if (a === 0)
        return function(index2) {
          return index2 === b;
        };
      if (a === 1)
        return b < 0 ? boolbase_1.default.trueFunc : function(index2) {
          return index2 >= b;
        };
      var absA = Math.abs(a);
      var bMod = (b % absA + absA) % absA;
      return a > 1 ? function(index2) {
        return index2 >= b && index2 % absA === bMod;
      } : function(index2) {
        return index2 <= b && index2 % absA === bMod;
      };
    }
    exports.compile = compile4;
    function generate2(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      var n = 0;
      if (a < 0) {
        var aPos_1 = -a;
        var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val2 = minValue_1 + aPos_1 * n++;
          return val2 > b ? null : val2;
        };
      }
      if (a === 0)
        return b < 0 ? (
          // There are no result  always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n++ === 0 ? b : null;
          }
        );
      if (b < 0) {
        b += a * Math.ceil(-b / a);
      }
      return function() {
        return a * n++ + b;
      };
    }
    exports.generate = generate2;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
    var parse_js_1 = require_parse3();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile2();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck2(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports.default = nthCheck2;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib11());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc2(next2, adapter2) {
      return function(elem) {
        var parent2 = adapter2.getParent(elem);
        return parent2 != null && adapter2.isTag(parent2) && next2(elem);
      };
    }
    exports.filters = {
      contains: function(next2, text3, _a2) {
        var adapter2 = _a2.adapter;
        return function contains5(elem) {
          return next2(elem) && adapter2.getText(elem).includes(text3);
        };
      },
      icontains: function(next2, text3, _a2) {
        var adapter2 = _a2.adapter;
        var itext = text3.toLowerCase();
        return function icontains(elem) {
          return next2(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next2, rule, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc2(next2, adapter2);
        return function nthChild(elem) {
          var siblings2 = adapter2.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings2.length; i++) {
            if (equals3(elem, siblings2[i]))
              break;
            if (adapter2.isTag(siblings2[i])) {
              pos++;
            }
          }
          return func(pos) && next2(elem);
        };
      },
      "nth-last-child": function(next2, rule, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc2(next2, adapter2);
        return function nthLastChild(elem) {
          var siblings2 = adapter2.getSiblings(elem);
          var pos = 0;
          for (var i = siblings2.length - 1; i >= 0; i--) {
            if (equals3(elem, siblings2[i]))
              break;
            if (adapter2.isTag(siblings2[i])) {
              pos++;
            }
          }
          return func(pos) && next2(elem);
        };
      },
      "nth-of-type": function(next2, rule, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc2(next2, adapter2);
        return function nthOfType(elem) {
          var siblings2 = adapter2.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings2.length; i++) {
            var currentSibling = siblings2[i];
            if (equals3(elem, currentSibling))
              break;
            if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next2(elem);
        };
      },
      "nth-last-of-type": function(next2, rule, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc2(next2, adapter2);
        return function nthLastOfType(elem) {
          var siblings2 = adapter2.getSiblings(elem);
          var pos = 0;
          for (var i = siblings2.length - 1; i >= 0; i--) {
            var currentSibling = siblings2[i];
            if (equals3(elem, currentSibling))
              break;
            if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next2(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next2, _rule, _a2) {
        var adapter2 = _a2.adapter;
        return function(elem) {
          var parent2 = adapter2.getParent(elem);
          return (parent2 == null || !adapter2.isTag(parent2)) && next2(elem);
        };
      },
      scope: function(next2, rule, options, context) {
        var equals3 = options.equals;
        if (!context || context.length === 0) {
          return exports.filters["root"](next2, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals3(context[0], elem) && next2(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next2(elem);
        };
      },
      hover: dynamicStatePseudo2("isHovered"),
      visited: dynamicStatePseudo2("isVisited"),
      active: dynamicStatePseudo2("isActive")
    };
    function dynamicStatePseudo2(name) {
      return function dynamicPseudo(next2, _rule, _a2) {
        var adapter2 = _a2.adapter;
        var func = adapter2[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next2(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function(elem, _a2) {
        var adapter2 = _a2.adapter;
        return !adapter2.getChildren(elem).some(function(elem2) {
          return adapter2.isTag(elem2) || adapter2.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        if (adapter2.prevElementSibling) {
          return adapter2.prevElementSibling(elem) == null;
        }
        var firstChild = adapter2.getSiblings(elem).find(function(elem2) {
          return adapter2.isTag(elem2);
        });
        return firstChild != null && equals3(elem, firstChild);
      },
      "last-child": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var siblings2 = adapter2.getSiblings(elem);
        for (var i = siblings2.length - 1; i >= 0; i--) {
          if (equals3(elem, siblings2[i]))
            return true;
          if (adapter2.isTag(siblings2[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var siblings2 = adapter2.getSiblings(elem);
        var elemName = adapter2.getName(elem);
        for (var i = 0; i < siblings2.length; i++) {
          var currentSibling = siblings2[i];
          if (equals3(elem, currentSibling))
            return true;
          if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var siblings2 = adapter2.getSiblings(elem);
        var elemName = adapter2.getName(elem);
        for (var i = siblings2.length - 1; i >= 0; i--) {
          var currentSibling = siblings2[i];
          if (equals3(elem, currentSibling))
            return true;
          if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        var elemName = adapter2.getName(elem);
        return adapter2.getSiblings(elem).every(function(sibling) {
          return equals3(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a2) {
        var adapter2 = _a2.adapter, equals3 = _a2.equals;
        return adapter2.getSiblings(elem).every(function(sibling) {
          return equals3(elem, sibling) || !adapter2.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs2(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs2;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag2(next2, adapter2) {
      if (next2 === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter2.isTag(elem) && next2(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag2;
    function getNextSiblings2(elem, adapter2) {
      var siblings2 = adapter2.getSiblings(elem);
      if (siblings2.length <= 1)
        return [];
      var elemIndex = siblings2.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings2.length - 1)
        return [];
      return siblings2.slice(elemIndex + 1).filter(adapter2.isTag);
    }
    exports.getNextSiblings = getNextSiblings2;
    function copyOptions2(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is6 = function(next2, token, options, context, compileToken2) {
      var func = compileToken2(token, copyOptions2(options), context);
      return func === boolbase_1.default.trueFunc ? next2 : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next2(elem);
      };
    };
    exports.subselects = {
      is: is6,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is6,
      where: is6,
      not: function(next2, token, options, context, compileToken2) {
        var func = compileToken2(token, copyOptions2(options), context);
        return func === boolbase_1.default.falseFunc ? next2 : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next2(elem);
        };
      },
      has: function(next2, subselect, options, _context, compileToken2) {
        var adapter2 = options.adapter;
        var opts = copyOptions2(options);
        opts.relativeSelector = true;
        var context = subselect.some(function(s) {
          return s.some(sort_js_1.isTraversal);
        }) ? (
          // Used as a placeholder. Will be replaced with the actual element.
          [exports.PLACEHOLDER_ELEMENT]
        ) : void 0;
        var compiled = compileToken2(subselect, opts, context);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag2(compiled, adapter2);
        if (context && compiled !== boolbase_1.default.trueFunc) {
          var _a2 = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a2 === void 0 ? false : _a2;
          return function(elem) {
            if (!next2(elem))
              return false;
            context[0] = elem;
            var childs = adapter2.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings2(elem, adapter2), true) : childs;
            return adapter2.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next2(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
    var css_what_1 = require_commonjs();
    var filters_js_1 = require_filters();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector2(next2, selector, options, context, compileToken2) {
      var _a2;
      var name = selector.name, data3 = selector.data;
      if (Array.isArray(data3)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data3, ")"));
        }
        return subselects_js_1.subselects[name](next2, data3, options, context, compileToken2);
      }
      var userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data3 != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next2, alias, options, context, compileToken2);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data3, 1);
        return function(elem) {
          return userPseudo(elem, data3) && next2(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next2, data3, options, context);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data3, 2);
        return function(elem) {
          return pseudo_1(elem, options, data3) && next2(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports.compilePseudoSelector = compilePseudoSelector2;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes2();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = require_commonjs();
    function getElementParent2(node, adapter2) {
      var parent2 = adapter2.getParent(node);
      if (parent2 && adapter2.isTag(parent2)) {
        return parent2;
      }
      return null;
    }
    function compileGeneralSelector2(next2, selector, options, context, compileToken2) {
      var adapter2 = options.adapter, equals3 = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next2, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next2, selector, options, context, compileToken2);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter2.getName(elem) === name_1 && next2(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent2(current, adapter2)) {
                if (next2(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent2(current, adapter2)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter2.isTag(current) && next2(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next2(current))
                return true;
            } while (current = getElementParent2(current, adapter2));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent2(elem) {
            return adapter2.getChildren(elem).some(function(elem2) {
              return adapter2.isTag(elem2) && next2(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent2 = adapter2.getParent(elem);
            return parent2 != null && adapter2.isTag(parent2) && next2(parent2);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings2 = adapter2.getSiblings(elem);
            for (var i = 0; i < siblings2.length; i++) {
              var currentSibling = siblings2[i];
              if (equals3(elem, currentSibling))
                break;
              if (adapter2.isTag(currentSibling) && next2(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter2.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter2.prevElementSibling(elem);
              return previous != null && next2(previous);
            };
          }
          return function adjacent(elem) {
            var siblings2 = adapter2.getSiblings(elem);
            var lastElement;
            for (var i = 0; i < siblings2.length; i++) {
              var currentSibling = siblings2[i];
              if (equals3(elem, currentSibling))
                break;
              if (adapter2.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next2(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next2;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector2;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile3 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = require_commonjs();
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile4(selector, options, context) {
      var next2 = compileUnsafe2(selector, options, context);
      return (0, subselects_js_1.ensureIsTag)(next2, options.adapter);
    }
    exports.compile = compile4;
    function compileUnsafe2(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken2(token, options, context);
    }
    exports.compileUnsafe = compileUnsafe2;
    function includesScopePseudo2(t) {
      return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data3) {
        return data3.some(includesScopePseudo2);
      }));
    }
    var DESCENDANT_TOKEN2 = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN2 = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN2 = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize2(token, _a2, context) {
      var adapter2 = _a2.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
        var parent2 = adapter2.isTag(e) && adapter2.getParent(e);
        return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent2 && adapter2.isTag(parent2);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t.some(includesScopePseudo2)) {
          t.unshift(DESCENDANT_TOKEN2);
        } else {
          continue;
        }
        t.unshift(SCOPE_TOKEN2);
      }
    }
    function compileToken2(token, options, context) {
      var _a2;
      token.forEach(sort_js_1.default);
      context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      if (options.relativeSelector !== false) {
        absolutize2(token, options, finalContext);
      } else if (token.some(function(t) {
        return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first2 = rules[0], second = rules[1];
          if (first2.type !== css_what_1.SelectorType.Pseudo || first2.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN2;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules2(rules, options, finalContext);
      }).reduce(reduceRules2, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken2;
    function compileRules2(rules, options, context) {
      var _a2;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken2);
      }, (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : boolbase_1.default.trueFunc);
    }
    function reduceRules2(a, b) {
      if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
        return a;
      }
      if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
    var DomUtils = __importStar(require_lib10());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile3();
    var subselects_js_1 = require_subselects();
    var defaultEquals2 = function(a, b) {
      return a === b;
    };
    var defaultOptions2 = {
      adapter: DomUtils,
      equals: defaultEquals2
    };
    function convertOptionFormats2(options) {
      var _a2, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions2;
      (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals2;
      return opts;
    }
    function wrapCompile2(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats2(options);
        return func(selector, opts, context);
      };
    }
    exports.compile = wrapCompile2(compile_js_1.compile);
    exports._compileUnsafe = wrapCompile2(compile_js_1.compileUnsafe);
    exports._compileToken = wrapCompile2(compile_js_1.compileToken);
    function getSelectorFunc2(searchFunc) {
      return function select2(query, elements, options) {
        var opts = convertOptionFormats2(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext2(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext2(elems, adapter2, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings2(elems, adapter2);
      }
      return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
    }
    exports.prepareContext = prepareContext2;
    function appendNextSiblings2(elem, adapter2) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter2);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc2(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc2(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is6(elem, query, options) {
      var opts = convertOptionFormats2(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports.is = is6;
    exports.default = exports.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/cheerio-select/lib/positionals.js
var require_positionals = __commonJS({
  "node_modules/cheerio-select/lib/positionals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLimit = exports.isFilter = exports.filterNames = void 0;
    exports.filterNames = /* @__PURE__ */ new Set([
      "first",
      "last",
      "eq",
      "gt",
      "nth",
      "lt",
      "even",
      "odd"
    ]);
    function isFilter2(s) {
      if (s.type !== "pseudo")
        return false;
      if (exports.filterNames.has(s.name))
        return true;
      if (s.name === "not" && Array.isArray(s.data)) {
        return s.data.some(function(s2) {
          return s2.some(isFilter2);
        });
      }
      return false;
    }
    exports.isFilter = isFilter2;
    function getLimit2(filter4, data3, partLimit) {
      var num = data3 != null ? parseInt(data3, 10) : NaN;
      switch (filter4) {
        case "first":
          return 1;
        case "nth":
        case "eq":
          return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
        case "lt":
          return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
        case "gt":
          return isFinite(num) ? Infinity : 0;
        case "odd":
          return 2 * partLimit;
        case "even":
          return 2 * partLimit - 1;
        case "last":
        case "not":
          return Infinity;
      }
    }
    exports.getLimit = getLimit2;
  }
});

// node_modules/cheerio-select/lib/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/cheerio-select/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupSelectors = exports.getDocumentRoot = void 0;
    var positionals_js_1 = require_positionals();
    function getDocumentRoot2(node) {
      while (node.parent)
        node = node.parent;
      return node;
    }
    exports.getDocumentRoot = getDocumentRoot2;
    function groupSelectors2(selectors) {
      var filteredSelectors = [];
      var plainSelectors = [];
      for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
        var selector = selectors_1[_i];
        if (selector.some(positionals_js_1.isFilter)) {
          filteredSelectors.push(selector);
        } else {
          plainSelectors.push(selector);
        }
      }
      return [plainSelectors, filteredSelectors];
    }
    exports.groupSelectors = groupSelectors2;
  }
});

// node_modules/cheerio-select/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/cheerio-select/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.select = exports.filter = exports.some = exports.is = exports.aliases = exports.pseudos = exports.filters = void 0;
    var css_what_1 = require_commonjs();
    var css_select_1 = require_lib12();
    var DomUtils = __importStar(require_lib10());
    var boolbase8 = __importStar(require_boolbase());
    var helpers_js_1 = require_helpers3();
    var positionals_js_1 = require_positionals();
    var css_select_2 = require_lib12();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return css_select_2.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return css_select_2.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return css_select_2.aliases;
    } });
    var UNIVERSAL_SELECTOR2 = {
      type: css_what_1.SelectorType.Universal,
      namespace: null
    };
    var SCOPE_PSEUDO2 = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function is6(element, selector, options) {
      if (options === void 0) {
        options = {};
      }
      return some2([element], selector, options);
    }
    exports.is = is6;
    function some2(elements, selector, options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof selector === "function")
        return elements.some(selector);
      var _a2 = (0, helpers_js_1.groupSelectors)((0, css_what_1.parse)(selector)), plain = _a2[0], filtered = _a2[1];
      return plain.length > 0 && elements.some((0, css_select_1._compileToken)(plain, options)) || filtered.some(function(sel) {
        return filterBySelector2(sel, elements, options).length > 0;
      });
    }
    exports.some = some2;
    function filterByPosition2(filter5, elems, data3, options) {
      var num = typeof data3 === "string" ? parseInt(data3, 10) : NaN;
      switch (filter5) {
        case "first":
        case "lt":
          return elems;
        case "last":
          return elems.length > 0 ? [elems[elems.length - 1]] : elems;
        case "nth":
        case "eq":
          return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
        case "gt":
          return isFinite(num) ? elems.slice(num + 1) : [];
        case "even":
          return elems.filter(function(_, i) {
            return i % 2 === 0;
          });
        case "odd":
          return elems.filter(function(_, i) {
            return i % 2 === 1;
          });
        case "not": {
          var filtered_1 = new Set(filterParsed2(data3, elems, options));
          return elems.filter(function(e) {
            return !filtered_1.has(e);
          });
        }
      }
    }
    function filter4(selector, elements, options) {
      if (options === void 0) {
        options = {};
      }
      return filterParsed2((0, css_what_1.parse)(selector), elements, options);
    }
    exports.filter = filter4;
    function filterParsed2(selector, elements, options) {
      if (elements.length === 0)
        return [];
      var _a2 = (0, helpers_js_1.groupSelectors)(selector), plainSelectors = _a2[0], filteredSelectors = _a2[1];
      var found;
      if (plainSelectors.length) {
        var filtered = filterElements2(elements, plainSelectors, options);
        if (filteredSelectors.length === 0) {
          return filtered;
        }
        if (filtered.length) {
          found = new Set(filtered);
        }
      }
      for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
        var filteredSelector = filteredSelectors[i];
        var missing = found ? elements.filter(function(e) {
          return DomUtils.isTag(e) && !found.has(e);
        }) : elements;
        if (missing.length === 0)
          break;
        var filtered = filterBySelector2(filteredSelector, elements, options);
        if (filtered.length) {
          if (!found) {
            if (i === filteredSelectors.length - 1) {
              return filtered;
            }
            found = new Set(filtered);
          } else {
            filtered.forEach(function(el) {
              return found.add(el);
            });
          }
        }
      }
      return typeof found !== "undefined" ? found.size === elements.length ? elements : (
        // Filter elements to preserve order
        elements.filter(function(el) {
          return found.has(el);
        })
      ) : [];
    }
    function filterBySelector2(selector, elements, options) {
      var _a2;
      if (selector.some(css_what_1.isTraversal)) {
        var root3 = (_a2 = options.root) !== null && _a2 !== void 0 ? _a2 : (0, helpers_js_1.getDocumentRoot)(elements[0]);
        var opts = __assign(__assign({}, options), { context: elements, relativeSelector: false });
        selector.push(SCOPE_PSEUDO2);
        return findFilterElements2(root3, selector, opts, true, elements.length);
      }
      return findFilterElements2(elements, selector, options, false, elements.length);
    }
    function select2(selector, root3, options, limit) {
      if (options === void 0) {
        options = {};
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (typeof selector === "function") {
        return find4(root3, selector);
      }
      var _a2 = (0, helpers_js_1.groupSelectors)((0, css_what_1.parse)(selector)), plain = _a2[0], filtered = _a2[1];
      var results = filtered.map(function(sel) {
        return findFilterElements2(root3, sel, options, true, limit);
      });
      if (plain.length) {
        results.push(findElements2(root3, plain, options, limit));
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return results[0];
      }
      return DomUtils.uniqueSort(results.reduce(function(a, b) {
        return __spreadArray(__spreadArray([], a, true), b, true);
      }));
    }
    exports.select = select2;
    function findFilterElements2(root3, selector, options, queryForSelector, totalLimit) {
      var filterIndex = selector.findIndex(positionals_js_1.isFilter);
      var sub = selector.slice(0, filterIndex);
      var filter5 = selector[filterIndex];
      var partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
      var limit = (0, positionals_js_1.getLimit)(filter5.name, filter5.data, partLimit);
      if (limit === 0)
        return [];
      var elemsNoLimit = sub.length === 0 && !Array.isArray(root3) ? DomUtils.getChildren(root3).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root3) ? root3 : [root3]).filter(DomUtils.isTag) : queryForSelector || sub.some(css_what_1.isTraversal) ? findElements2(root3, [sub], options, limit) : filterElements2(root3, [sub], options);
      var elems = elemsNoLimit.slice(0, limit);
      var result = filterByPosition2(filter5.name, elems, filter5.data, options);
      if (result.length === 0 || selector.length === filterIndex + 1) {
        return result;
      }
      var remainingSelector = selector.slice(filterIndex + 1);
      var remainingHasTraversal = remainingSelector.some(css_what_1.isTraversal);
      if (remainingHasTraversal) {
        if ((0, css_what_1.isTraversal)(remainingSelector[0])) {
          var type3 = remainingSelector[0].type;
          if (type3 === css_what_1.SelectorType.Sibling || type3 === css_what_1.SelectorType.Adjacent) {
            result = (0, css_select_1.prepareContext)(result, DomUtils, true);
          }
          remainingSelector.unshift(UNIVERSAL_SELECTOR2);
        }
        options = __assign(__assign({}, options), {
          // Avoid absolutizing the selector
          relativeSelector: false,
          /*
           * Add a custom root func, to make sure traversals don't match elements
           * that aren't a part of the considered tree.
           */
          rootFunc: function(el) {
            return result.includes(el);
          }
        });
      } else if (options.rootFunc && options.rootFunc !== boolbase8.trueFunc) {
        options = __assign(__assign({}, options), { rootFunc: boolbase8.trueFunc });
      }
      return remainingSelector.some(positionals_js_1.isFilter) ? findFilterElements2(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
        // Query existing elements to resolve traversal.
        findElements2(result, [remainingSelector], options, totalLimit)
      ) : (
        // If we don't have any more traversals, simply filter elements.
        filterElements2(result, [remainingSelector], options)
      );
    }
    function findElements2(root3, sel, options, limit) {
      var query = (0, css_select_1._compileToken)(sel, options, root3);
      return find4(root3, query, limit);
    }
    function find4(root3, query, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var elems = (0, css_select_1.prepareContext)(root3, DomUtils, query.shouldTestNextSiblings);
      return DomUtils.find(function(node) {
        return DomUtils.isTag(node) && query(node);
      }, elems, true, limit);
    }
    function filterElements2(elements, sel, options) {
      var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
      if (els.length === 0)
        return els;
      var query = (0, css_select_1._compileToken)(sel, options);
      return query === boolbase8.trueFunc ? els : els.filter(query);
    }
  }
});

// node_modules/cheerio/lib/api/traversing.js
var require_traversing = __commonJS({
  "node_modules/cheerio/lib/api/traversing.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addBack = exports.add = exports.end = exports.slice = exports.index = exports.toArray = exports.get = exports.eq = exports.last = exports.first = exports.has = exports.not = exports.is = exports.filterArray = exports.filter = exports.map = exports.each = exports.contents = exports.children = exports.siblings = exports.prevUntil = exports.prevAll = exports.prev = exports.nextUntil = exports.nextAll = exports.next = exports.closest = exports.parentsUntil = exports.parents = exports.parent = exports.find = void 0;
    var domhandler_1 = require_lib7();
    var select2 = __importStar(require_lib13());
    var utils_js_1 = require_utils4();
    var static_js_1 = require_static();
    var domutils_1 = require_lib10();
    var reSiblingSelector2 = /^\s*[~+]/;
    function find4(selectorOrHaystack) {
      var _a2;
      if (!selectorOrHaystack) {
        return this._make([]);
      }
      var context = this.toArray();
      if (typeof selectorOrHaystack !== "string") {
        var haystack = (0, utils_js_1.isCheerio)(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
        return this._make(haystack.filter(function(elem) {
          return context.some(function(node) {
            return (0, static_js_1.contains)(node, elem);
          });
        }));
      }
      var elems = reSiblingSelector2.test(selectorOrHaystack) ? context : this.children().toArray();
      var options = {
        context,
        root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
        // Pass options that are recognized by `cheerio-select`
        xmlMode: this.options.xmlMode,
        lowerCaseTags: this.options.lowerCaseTags,
        lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
        pseudos: this.options.pseudos,
        quirksMode: this.options.quirksMode
      };
      return this._make(select2.select(selectorOrHaystack, elems, options));
    }
    exports.find = find4;
    function _getMatcher2(matchMap) {
      return function(fn) {
        var postFns = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          postFns[_i - 1] = arguments[_i];
        }
        return function(selector) {
          var _a2;
          var matched = matchMap(fn, this);
          if (selector) {
            matched = filterArray2(matched, selector, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
          }
          return this._make(
            // Post processing is only necessary if there is more than one element.
            this.length > 1 && matched.length > 1 ? postFns.reduce(function(elems, fn2) {
              return fn2(elems);
            }, matched) : matched
          );
        };
      };
    }
    var _matcher2 = _getMatcher2(function(fn, elems) {
      var _a2;
      var ret = [];
      for (var i = 0; i < elems.length; i++) {
        var value2 = fn(elems[i]);
        ret.push(value2);
      }
      return (_a2 = new Array()).concat.apply(_a2, ret);
    });
    var _singleMatcher2 = _getMatcher2(function(fn, elems) {
      var ret = [];
      for (var i = 0; i < elems.length; i++) {
        var value2 = fn(elems[i]);
        if (value2 !== null) {
          ret.push(value2);
        }
      }
      return ret;
    });
    function _matchUntil2(nextElem) {
      var postFns = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        postFns[_i - 1] = arguments[_i];
      }
      var matches2 = null;
      var innerMatcher = _getMatcher2(function(nextElem2, elems) {
        var matched = [];
        (0, utils_js_1.domEach)(elems, function(elem) {
          for (var next_1; next_1 = nextElem2(elem); elem = next_1) {
            if (matches2 === null || matches2 === void 0 ? void 0 : matches2(next_1, matched.length))
              break;
            matched.push(next_1);
          }
        });
        return matched;
      }).apply(void 0, __spreadArray([nextElem], postFns, false));
      return function(selector, filterSelector) {
        var _this = this;
        matches2 = typeof selector === "string" ? function(elem) {
          return select2.is(elem, selector, _this.options);
        } : selector ? getFilterFn2(selector) : null;
        var ret = innerMatcher.call(this, filterSelector);
        matches2 = null;
        return ret;
      };
    }
    function _removeDuplicates2(elems) {
      return Array.from(new Set(elems));
    }
    exports.parent = _singleMatcher2(function(_a2) {
      var parent2 = _a2.parent;
      return parent2 && !(0, domhandler_1.isDocument)(parent2) ? parent2 : null;
    }, _removeDuplicates2);
    exports.parents = _matcher2(function(elem) {
      var matched = [];
      while (elem.parent && !(0, domhandler_1.isDocument)(elem.parent)) {
        matched.push(elem.parent);
        elem = elem.parent;
      }
      return matched;
    }, domutils_1.uniqueSort, function(elems) {
      return elems.reverse();
    });
    exports.parentsUntil = _matchUntil2(function(_a2) {
      var parent2 = _a2.parent;
      return parent2 && !(0, domhandler_1.isDocument)(parent2) ? parent2 : null;
    }, domutils_1.uniqueSort, function(elems) {
      return elems.reverse();
    });
    function closest2(selector) {
      var _a2;
      var set = [];
      if (!selector) {
        return this._make(set);
      }
      var selectOpts = {
        xmlMode: this.options.xmlMode,
        root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
      };
      var selectFn = typeof selector === "string" ? function(elem) {
        return select2.is(elem, selector, selectOpts);
      } : getFilterFn2(selector);
      (0, utils_js_1.domEach)(this, function(elem) {
        while (elem && (0, utils_js_1.isTag)(elem)) {
          if (selectFn(elem, 0)) {
            if (!set.includes(elem)) {
              set.push(elem);
            }
            break;
          }
          elem = elem.parent;
        }
      });
      return this._make(set);
    }
    exports.closest = closest2;
    exports.next = _singleMatcher2(function(elem) {
      return (0, domutils_1.nextElementSibling)(elem);
    });
    exports.nextAll = _matcher2(function(elem) {
      var matched = [];
      while (elem.next) {
        elem = elem.next;
        if ((0, utils_js_1.isTag)(elem))
          matched.push(elem);
      }
      return matched;
    }, _removeDuplicates2);
    exports.nextUntil = _matchUntil2(function(el) {
      return (0, domutils_1.nextElementSibling)(el);
    }, _removeDuplicates2);
    exports.prev = _singleMatcher2(function(elem) {
      return (0, domutils_1.prevElementSibling)(elem);
    });
    exports.prevAll = _matcher2(function(elem) {
      var matched = [];
      while (elem.prev) {
        elem = elem.prev;
        if ((0, utils_js_1.isTag)(elem))
          matched.push(elem);
      }
      return matched;
    }, _removeDuplicates2);
    exports.prevUntil = _matchUntil2(function(el) {
      return (0, domutils_1.prevElementSibling)(el);
    }, _removeDuplicates2);
    exports.siblings = _matcher2(function(elem) {
      return (0, domutils_1.getSiblings)(elem).filter(function(el) {
        return (0, utils_js_1.isTag)(el) && el !== elem;
      });
    }, domutils_1.uniqueSort);
    exports.children = _matcher2(function(elem) {
      return (0, domutils_1.getChildren)(elem).filter(utils_js_1.isTag);
    }, _removeDuplicates2);
    function contents2() {
      var elems = this.toArray().reduce(function(newElems, elem) {
        return (0, domhandler_1.hasChildren)(elem) ? newElems.concat(elem.children) : newElems;
      }, []);
      return this._make(elems);
    }
    exports.contents = contents2;
    function each2(fn) {
      var i = 0;
      var len = this.length;
      while (i < len && fn.call(this[i], i, this[i]) !== false)
        ++i;
      return this;
    }
    exports.each = each2;
    function map4(fn) {
      var elems = [];
      for (var i = 0; i < this.length; i++) {
        var el = this[i];
        var val2 = fn.call(el, i, el);
        if (val2 != null) {
          elems = elems.concat(val2);
        }
      }
      return this._make(elems);
    }
    exports.map = map4;
    function getFilterFn2(match) {
      if (typeof match === "function") {
        return function(el, i) {
          return match.call(el, i, el);
        };
      }
      if ((0, utils_js_1.isCheerio)(match)) {
        return function(el) {
          return Array.prototype.includes.call(match, el);
        };
      }
      return function(el) {
        return match === el;
      };
    }
    function filter4(match) {
      var _a2;
      return this._make(filterArray2(this.toArray(), match, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
    }
    exports.filter = filter4;
    function filterArray2(nodes, match, xmlMode, root3) {
      return typeof match === "string" ? select2.filter(match, nodes, { xmlMode, root: root3 }) : nodes.filter(getFilterFn2(match));
    }
    exports.filterArray = filterArray2;
    function is6(selector) {
      var nodes = this.toArray();
      return typeof selector === "string" ? select2.some(nodes.filter(utils_js_1.isTag), selector, this.options) : selector ? nodes.some(getFilterFn2(selector)) : false;
    }
    exports.is = is6;
    function not2(match) {
      var nodes = this.toArray();
      if (typeof match === "string") {
        var matches_1 = new Set(select2.filter(match, nodes, this.options));
        nodes = nodes.filter(function(el) {
          return !matches_1.has(el);
        });
      } else {
        var filterFn_1 = getFilterFn2(match);
        nodes = nodes.filter(function(el, i) {
          return !filterFn_1(el, i);
        });
      }
      return this._make(nodes);
    }
    exports.not = not2;
    function has2(selectorOrHaystack) {
      var _this = this;
      return this.filter(typeof selectorOrHaystack === "string" ? (
        // Using the `:has` selector here short-circuits searches.
        ":has(".concat(selectorOrHaystack, ")")
      ) : function(_, el) {
        return _this._make(el).find(selectorOrHaystack).length > 0;
      });
    }
    exports.has = has2;
    function first2() {
      return this.length > 1 ? this._make(this[0]) : this;
    }
    exports.first = first2;
    function last2() {
      return this.length > 0 ? this._make(this[this.length - 1]) : this;
    }
    exports.last = last2;
    function eq2(i) {
      var _a2;
      i = +i;
      if (i === 0 && this.length <= 1)
        return this;
      if (i < 0)
        i = this.length + i;
      return this._make((_a2 = this[i]) !== null && _a2 !== void 0 ? _a2 : []);
    }
    exports.eq = eq2;
    function get2(i) {
      if (i == null) {
        return this.toArray();
      }
      return this[i < 0 ? this.length + i : i];
    }
    exports.get = get2;
    function toArray2() {
      return Array.prototype.slice.call(this);
    }
    exports.toArray = toArray2;
    function index2(selectorOrNeedle) {
      var $haystack;
      var needle;
      if (selectorOrNeedle == null) {
        $haystack = this.parent().children();
        needle = this[0];
      } else if (typeof selectorOrNeedle === "string") {
        $haystack = this._make(selectorOrNeedle);
        needle = this[0];
      } else {
        $haystack = this;
        needle = (0, utils_js_1.isCheerio)(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
      }
      return Array.prototype.indexOf.call($haystack, needle);
    }
    exports.index = index2;
    function slice2(start, end3) {
      return this._make(Array.prototype.slice.call(this, start, end3));
    }
    exports.slice = slice2;
    function end2() {
      var _a2;
      return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
    }
    exports.end = end2;
    function add2(other, context) {
      var selection = this._make(other, context);
      var contents3 = (0, domutils_1.uniqueSort)(__spreadArray(__spreadArray([], this.get(), true), selection.get(), true));
      return this._make(contents3);
    }
    exports.add = add2;
    function addBack2(selector) {
      return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
    }
    exports.addBack = addBack2;
  }
});

// node_modules/cheerio/lib/parse.js
var require_parse4 = __commonJS({
  "node_modules/cheerio/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.update = exports.getParse = void 0;
    var domutils_1 = require_lib10();
    var domhandler_1 = require_lib7();
    function getParse2(parser) {
      return function parse9(content, options, isDocument2, context) {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
          content = content.toString();
        }
        if (typeof content === "string") {
          return parser(content, options, isDocument2, context);
        }
        var doc = content;
        if (!Array.isArray(doc) && (0, domhandler_1.isDocument)(doc)) {
          return doc;
        }
        var root3 = new domhandler_1.Document([]);
        update2(doc, root3);
        return root3;
      };
    }
    exports.getParse = getParse2;
    function update2(newChilds, parent2) {
      var arr = Array.isArray(newChilds) ? newChilds : [newChilds];
      if (parent2) {
        parent2.children = arr;
      } else {
        parent2 = null;
      }
      for (var i = 0; i < arr.length; i++) {
        var node = arr[i];
        if (node.parent && node.parent.children !== arr) {
          (0, domutils_1.removeElement)(node);
        }
        if (parent2) {
          node.prev = arr[i - 1] || null;
          node.next = arr[i + 1] || null;
        } else {
          node.prev = node.next = null;
        }
        node.parent = parent2;
      }
      return parent2;
    }
    exports.update = update2;
  }
});

// node_modules/cheerio/lib/api/manipulation.js
var require_manipulation2 = __commonJS({
  "node_modules/cheerio/lib/api/manipulation.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.text = exports.toString = exports.html = exports.empty = exports.replaceWith = exports.remove = exports.insertBefore = exports.before = exports.insertAfter = exports.after = exports.wrapAll = exports.unwrap = exports.wrapInner = exports.wrap = exports.prepend = exports.append = exports.prependTo = exports.appendTo = exports._makeDomArray = void 0;
    var domhandler_1 = require_lib7();
    var parse_js_1 = require_parse4();
    var static_js_1 = require_static();
    var utils_js_1 = require_utils4();
    var domutils_1 = require_lib10();
    function _makeDomArray2(elem, clone3) {
      var _this = this;
      if (elem == null) {
        return [];
      }
      if ((0, utils_js_1.isCheerio)(elem)) {
        return clone3 ? (0, utils_js_1.cloneDom)(elem.get()) : elem.get();
      }
      if (Array.isArray(elem)) {
        return elem.reduce(function(newElems, el) {
          return newElems.concat(_this._makeDomArray(el, clone3));
        }, []);
      }
      if (typeof elem === "string") {
        return this._parse(elem, this.options, false, null).children;
      }
      return clone3 ? (0, utils_js_1.cloneDom)([elem]) : [elem];
    }
    exports._makeDomArray = _makeDomArray2;
    function _insert2(concatenator) {
      return function() {
        var _this = this;
        var elems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          elems[_i] = arguments[_i];
        }
        var lastIdx = this.length - 1;
        return (0, utils_js_1.domEach)(this, function(el, i) {
          if (!(0, domhandler_1.hasChildren)(el))
            return;
          var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
          var dom = _this._makeDomArray(domSrc, i < lastIdx);
          concatenator(dom, el.children, el);
        });
      };
    }
    function uniqueSplice2(array, spliceIdx, spliceCount, newElems, parent2) {
      var _a2, _b;
      var spliceArgs = __spreadArray([
        spliceIdx,
        spliceCount
      ], newElems, true);
      var prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
      var next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
      for (var idx = 0; idx < newElems.length; ++idx) {
        var node = newElems[idx];
        var oldParent = node.parent;
        if (oldParent) {
          var oldSiblings = oldParent.children;
          var prevIdx = oldSiblings.indexOf(node);
          if (prevIdx > -1) {
            oldParent.children.splice(prevIdx, 1);
            if (parent2 === oldParent && spliceIdx > prevIdx) {
              spliceArgs[0]--;
            }
          }
        }
        node.parent = parent2;
        if (node.prev) {
          node.prev.next = (_a2 = node.next) !== null && _a2 !== void 0 ? _a2 : null;
        }
        if (node.next) {
          node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
        }
        node.prev = idx === 0 ? prev2 : newElems[idx - 1];
        node.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
      }
      if (prev2) {
        prev2.next = newElems[0];
      }
      if (next2) {
        next2.prev = newElems[newElems.length - 1];
      }
      return array.splice.apply(array, spliceArgs);
    }
    function appendTo2(target) {
      var appendTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);
      appendTarget.append(this);
      return this;
    }
    exports.appendTo = appendTo2;
    function prependTo2(target) {
      var prependTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);
      prependTarget.prepend(this);
      return this;
    }
    exports.prependTo = prependTo2;
    exports.append = _insert2(function(dom, children3, parent2) {
      uniqueSplice2(children3, children3.length, 0, dom, parent2);
    });
    exports.prepend = _insert2(function(dom, children3, parent2) {
      uniqueSplice2(children3, 0, 0, dom, parent2);
    });
    function _wrap2(insert) {
      return function(wrapper) {
        var lastIdx = this.length - 1;
        var lastParent = this.parents().last();
        for (var i = 0; i < this.length; i++) {
          var el = this[i];
          var wrap_1 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !(0, utils_js_1.isHtml)(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
          var wrapperDom = this._makeDomArray(wrap_1, i < lastIdx)[0];
          if (!wrapperDom || !(0, domhandler_1.hasChildren)(wrapperDom))
            continue;
          var elInsertLocation = wrapperDom;
          var j = 0;
          while (j < elInsertLocation.children.length) {
            var child = elInsertLocation.children[j];
            if ((0, utils_js_1.isTag)(child)) {
              elInsertLocation = child;
              j = 0;
            } else {
              j++;
            }
          }
          insert(el, elInsertLocation, [wrapperDom]);
        }
        return this;
      };
    }
    exports.wrap = _wrap2(function(el, elInsertLocation, wrapperDom) {
      var parent2 = el.parent;
      if (!parent2)
        return;
      var siblings2 = parent2.children;
      var index2 = siblings2.indexOf(el);
      (0, parse_js_1.update)([el], elInsertLocation);
      uniqueSplice2(siblings2, index2, 0, wrapperDom, parent2);
    });
    exports.wrapInner = _wrap2(function(el, elInsertLocation, wrapperDom) {
      if (!(0, domhandler_1.hasChildren)(el))
        return;
      (0, parse_js_1.update)(el.children, elInsertLocation);
      (0, parse_js_1.update)(wrapperDom, el);
    });
    function unwrap2(selector) {
      var _this = this;
      this.parent(selector).not("body").each(function(_, el) {
        _this._make(el).replaceWith(el.children);
      });
      return this;
    }
    exports.unwrap = unwrap2;
    function wrapAll2(wrapper) {
      var el = this[0];
      if (el) {
        var wrap_2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
        var elInsertLocation = void 0;
        for (var i = 0; i < wrap_2.length; i++) {
          if (wrap_2[i].type === "tag")
            elInsertLocation = wrap_2[i];
        }
        var j = 0;
        while (elInsertLocation && j < elInsertLocation.children.length) {
          var child = elInsertLocation.children[j];
          if (child.type === "tag") {
            elInsertLocation = child;
            j = 0;
          } else {
            j++;
          }
        }
        if (elInsertLocation)
          this._make(elInsertLocation).append(this);
      }
      return this;
    }
    exports.wrapAll = wrapAll2;
    function after2() {
      var _this = this;
      var elems = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elems[_i] = arguments[_i];
      }
      var lastIdx = this.length - 1;
      return (0, utils_js_1.domEach)(this, function(el, i) {
        var parent2 = el.parent;
        if (!(0, domhandler_1.hasChildren)(el) || !parent2) {
          return;
        }
        var siblings2 = parent2.children;
        var index2 = siblings2.indexOf(el);
        if (index2 < 0)
          return;
        var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
        var dom = _this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice2(siblings2, index2 + 1, 0, dom, parent2);
      });
    }
    exports.after = after2;
    function insertAfter2(target) {
      var _this = this;
      if (typeof target === "string") {
        target = this._make(target);
      }
      this.remove();
      var clones = [];
      this._makeDomArray(target).forEach(function(el) {
        var clonedSelf = _this.clone().toArray();
        var parent2 = el.parent;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children;
        var index2 = siblings2.indexOf(el);
        if (index2 < 0)
          return;
        uniqueSplice2(siblings2, index2 + 1, 0, clonedSelf, parent2);
        clones.push.apply(clones, clonedSelf);
      });
      return this._make(clones);
    }
    exports.insertAfter = insertAfter2;
    function before2() {
      var _this = this;
      var elems = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elems[_i] = arguments[_i];
      }
      var lastIdx = this.length - 1;
      return (0, utils_js_1.domEach)(this, function(el, i) {
        var parent2 = el.parent;
        if (!(0, domhandler_1.hasChildren)(el) || !parent2) {
          return;
        }
        var siblings2 = parent2.children;
        var index2 = siblings2.indexOf(el);
        if (index2 < 0)
          return;
        var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
        var dom = _this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice2(siblings2, index2, 0, dom, parent2);
      });
    }
    exports.before = before2;
    function insertBefore2(target) {
      var _this = this;
      var targetArr = this._make(target);
      this.remove();
      var clones = [];
      (0, utils_js_1.domEach)(targetArr, function(el) {
        var clonedSelf = _this.clone().toArray();
        var parent2 = el.parent;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children;
        var index2 = siblings2.indexOf(el);
        if (index2 < 0)
          return;
        uniqueSplice2(siblings2, index2, 0, clonedSelf, parent2);
        clones.push.apply(clones, clonedSelf);
      });
      return this._make(clones);
    }
    exports.insertBefore = insertBefore2;
    function remove2(selector) {
      var elems = selector ? this.filter(selector) : this;
      (0, utils_js_1.domEach)(elems, function(el) {
        (0, domutils_1.removeElement)(el);
        el.prev = el.next = el.parent = null;
      });
      return this;
    }
    exports.remove = remove2;
    function replaceWith2(content) {
      var _this = this;
      return (0, utils_js_1.domEach)(this, function(el, i) {
        var parent2 = el.parent;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children;
        var cont = typeof content === "function" ? content.call(el, i, el) : content;
        var dom = _this._makeDomArray(cont);
        (0, parse_js_1.update)(dom, null);
        var index2 = siblings2.indexOf(el);
        uniqueSplice2(siblings2, index2, 1, dom, parent2);
        if (!dom.includes(el)) {
          el.parent = el.prev = el.next = null;
        }
      });
    }
    exports.replaceWith = replaceWith2;
    function empty2() {
      return (0, utils_js_1.domEach)(this, function(el) {
        if (!(0, domhandler_1.hasChildren)(el))
          return;
        el.children.forEach(function(child) {
          child.next = child.prev = child.parent = null;
        });
        el.children.length = 0;
      });
    }
    exports.empty = empty2;
    function html3(str) {
      var _this = this;
      if (str === void 0) {
        var el = this[0];
        if (!el || !(0, domhandler_1.hasChildren)(el))
          return null;
        return this._render(el.children);
      }
      return (0, utils_js_1.domEach)(this, function(el2) {
        if (!(0, domhandler_1.hasChildren)(el2))
          return;
        el2.children.forEach(function(child) {
          child.next = child.prev = child.parent = null;
        });
        var content = (0, utils_js_1.isCheerio)(str) ? str.toArray() : _this._parse("".concat(str), _this.options, false, el2).children;
        (0, parse_js_1.update)(content, el2);
      });
    }
    exports.html = html3;
    function toString3() {
      return this._render(this);
    }
    exports.toString = toString3;
    function text3(str) {
      var _this = this;
      if (str === void 0) {
        return (0, static_js_1.text)(this);
      }
      if (typeof str === "function") {
        return (0, utils_js_1.domEach)(this, function(el, i) {
          return _this._make(el).text(str.call(el, i, (0, static_js_1.text)([el])));
        });
      }
      return (0, utils_js_1.domEach)(this, function(el) {
        if (!(0, domhandler_1.hasChildren)(el))
          return;
        el.children.forEach(function(child) {
          child.next = child.prev = child.parent = null;
        });
        var textNode = new domhandler_1.Text("".concat(str));
        (0, parse_js_1.update)(textNode, el);
      });
    }
    exports.text = text3;
    function clone2() {
      return this._make((0, utils_js_1.cloneDom)(this.get()));
    }
    exports.clone = clone2;
  }
});

// node_modules/cheerio/lib/api/css.js
var require_css = __commonJS({
  "node_modules/cheerio/lib/api/css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.css = void 0;
    var utils_js_1 = require_utils4();
    function css2(prop2, val2) {
      if (prop2 != null && val2 != null || // When `prop` is a "plain" object
      typeof prop2 === "object" && !Array.isArray(prop2)) {
        return (0, utils_js_1.domEach)(this, function(el, i) {
          if ((0, utils_js_1.isTag)(el)) {
            setCss2(el, prop2, val2, i);
          }
        });
      }
      if (this.length === 0) {
        return void 0;
      }
      return getCss2(this[0], prop2);
    }
    exports.css = css2;
    function setCss2(el, prop2, value2, idx) {
      if (typeof prop2 === "string") {
        var styles = getCss2(el);
        var val2 = typeof value2 === "function" ? value2.call(el, idx, styles[prop2]) : value2;
        if (val2 === "") {
          delete styles[prop2];
        } else if (val2 != null) {
          styles[prop2] = val2;
        }
        el.attribs["style"] = stringify2(styles);
      } else if (typeof prop2 === "object") {
        Object.keys(prop2).forEach(function(k, i) {
          setCss2(el, k, prop2[k], i);
        });
      }
    }
    function getCss2(el, prop2) {
      if (!el || !(0, utils_js_1.isTag)(el))
        return;
      var styles = parse9(el.attribs["style"]);
      if (typeof prop2 === "string") {
        return styles[prop2];
      }
      if (Array.isArray(prop2)) {
        var newStyles_1 = {};
        prop2.forEach(function(item) {
          if (styles[item] != null) {
            newStyles_1[item] = styles[item];
          }
        });
        return newStyles_1;
      }
      return styles;
    }
    function stringify2(obj) {
      return Object.keys(obj).reduce(function(str, prop2) {
        return "".concat(str).concat(str ? " " : "").concat(prop2, ": ").concat(obj[prop2], ";");
      }, "");
    }
    function parse9(styles) {
      styles = (styles || "").trim();
      if (!styles)
        return {};
      var obj = {};
      var key;
      for (var _i = 0, _a2 = styles.split(";"); _i < _a2.length; _i++) {
        var str = _a2[_i];
        var n = str.indexOf(":");
        if (n < 1 || n === str.length - 1) {
          var trimmed = str.trimEnd();
          if (trimmed.length > 0 && key !== void 0) {
            obj[key] += ";".concat(trimmed);
          }
        } else {
          key = str.slice(0, n).trim();
          obj[key] = str.slice(n + 1).trim();
        }
      }
      return obj;
    }
  }
});

// node_modules/cheerio/lib/api/forms.js
var require_forms = __commonJS({
  "node_modules/cheerio/lib/api/forms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeArray = exports.serialize = void 0;
    var utils_js_1 = require_utils4();
    var submittableSelector2 = "input,select,textarea,keygen";
    var r202 = /%20/g;
    var rCRLF2 = /\r?\n/g;
    function serialize3() {
      var arr = this.serializeArray();
      var retArr = arr.map(function(data3) {
        return "".concat(encodeURIComponent(data3.name), "=").concat(encodeURIComponent(data3.value));
      });
      return retArr.join("&").replace(r202, "+");
    }
    exports.serialize = serialize3;
    function serializeArray2() {
      var _this = this;
      return this.map(function(_, elem) {
        var $elem = _this._make(elem);
        if ((0, utils_js_1.isTag)(elem) && elem.name === "form") {
          return $elem.find(submittableSelector2).toArray();
        }
        return $elem.filter(submittableSelector2).toArray();
      }).filter(
        // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
        '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
        // Convert each of the elements to its value(s)
      ).map(function(_, elem) {
        var _a2;
        var $elem = _this._make(elem);
        var name = $elem.attr("name");
        var value2 = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
        if (Array.isArray(value2)) {
          return value2.map(function(val2) {
            return { name, value: val2.replace(rCRLF2, "\r\n") };
          });
        }
        return { name, value: value2.replace(rCRLF2, "\r\n") };
      }).toArray();
    }
    exports.serializeArray = serializeArray2;
  }
});

// node_modules/cheerio/lib/cheerio.js
var require_cheerio = __commonJS({
  "node_modules/cheerio/lib/cheerio.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cheerio = void 0;
    var Attributes = __importStar(require_attributes());
    var Traversing = __importStar(require_traversing());
    var Manipulation = __importStar(require_manipulation2());
    var Css = __importStar(require_css());
    var Forms = __importStar(require_forms());
    var Cheerio2 = (
      /** @class */
      function() {
        function Cheerio3(elements, root3, options) {
          this.length = 0;
          this.options = options;
          this._root = root3;
          if (elements) {
            for (var idx = 0; idx < elements.length; idx++) {
              this[idx] = elements[idx];
            }
            this.length = elements.length;
          }
        }
        return Cheerio3;
      }()
    );
    exports.Cheerio = Cheerio2;
    Cheerio2.prototype.cheerio = "[cheerio object]";
    Cheerio2.prototype.splice = Array.prototype.splice;
    Cheerio2.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    Object.assign(Cheerio2.prototype, Attributes, Traversing, Manipulation, Css, Forms);
  }
});

// node_modules/cheerio/lib/load.js
var require_load = __commonJS({
  "node_modules/cheerio/lib/load.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLoad = void 0;
    var options_js_1 = __importStar(require_options());
    var staticMethods = __importStar(require_static());
    var cheerio_js_1 = require_cheerio();
    var utils_js_1 = require_utils4();
    function getLoad2(parse9, render3) {
      return function load2(content, options, isDocument2) {
        if (isDocument2 === void 0) {
          isDocument2 = true;
        }
        if (content == null) {
          throw new Error("cheerio.load() expects a string");
        }
        var internalOpts = __assign(__assign({}, options_js_1.default), (0, options_js_1.flatten)(options));
        var initialRoot = parse9(content, internalOpts, isDocument2, null);
        var LoadedCheerio = (
          /** @class */
          function(_super) {
            __extends(LoadedCheerio2, _super);
            function LoadedCheerio2() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            LoadedCheerio2.prototype._make = function(selector, context) {
              var cheerio = initialize(selector, context);
              cheerio.prevObject = this;
              return cheerio;
            };
            LoadedCheerio2.prototype._parse = function(content2, options2, isDocument3, context) {
              return parse9(content2, options2, isDocument3, context);
            };
            LoadedCheerio2.prototype._render = function(dom) {
              return render3(dom, this.options);
            };
            return LoadedCheerio2;
          }(cheerio_js_1.Cheerio)
        );
        function initialize(selector, context, root3, opts) {
          if (root3 === void 0) {
            root3 = initialRoot;
          }
          if (selector && (0, utils_js_1.isCheerio)(selector))
            return selector;
          var options2 = __assign(__assign({}, internalOpts), (0, options_js_1.flatten)(opts));
          var r = typeof root3 === "string" ? [parse9(root3, options2, false, null)] : "length" in root3 ? root3 : [root3];
          var rootInstance = (0, utils_js_1.isCheerio)(r) ? r : new LoadedCheerio(r, null, options2);
          rootInstance._root = rootInstance;
          if (!selector) {
            return new LoadedCheerio(void 0, rootInstance, options2);
          }
          var elements = typeof selector === "string" && (0, utils_js_1.isHtml)(selector) ? (
            // $(<html>)
            parse9(selector, options2, false, null).children
          ) : isNode2(selector) ? (
            // $(dom)
            [selector]
          ) : Array.isArray(selector) ? (
            // $([dom])
            selector
          ) : void 0;
          var instance = new LoadedCheerio(elements, rootInstance, options2);
          if (elements) {
            return instance;
          }
          if (typeof selector !== "string") {
            throw new Error("Unexpected type of selector");
          }
          var search2 = selector;
          var searchContext = !context ? (
            // If we don't have a context, maybe we have a root, from loading
            rootInstance
          ) : typeof context === "string" ? (0, utils_js_1.isHtml)(context) ? (
            // $('li', '<ul>...</ul>')
            new LoadedCheerio([parse9(context, options2, false, null)], rootInstance, options2)
          ) : (
            // $('li', 'ul')
            (search2 = "".concat(context, " ").concat(search2), rootInstance)
          ) : (0, utils_js_1.isCheerio)(context) ? (
            // $('li', $)
            context
          ) : (
            // $('li', node), $('li', [nodes])
            new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2)
          );
          if (!searchContext)
            return instance;
          return searchContext.find(search2);
        }
        Object.assign(initialize, staticMethods, {
          load: load2,
          // `_root` and `_options` are used in static methods.
          _root: initialRoot,
          _options: internalOpts,
          // Add `fn` for plugins
          fn: LoadedCheerio.prototype,
          // Add the prototype here to maintain `instanceof` behavior.
          prototype: LoadedCheerio.prototype
        });
        return initialize;
      };
    }
    exports.getLoad = getLoad2;
    function isNode2(obj) {
      return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
    }
  }
});

// node_modules/parse5/dist/cjs/common/unicode.js
var require_unicode = __commonJS({
  "node_modules/parse5/dist/cjs/common/unicode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUndefinedCodePoint = exports.isControlCodePoint = exports.getSurrogatePairCodePoint = exports.isSurrogatePair = exports.isSurrogate = exports.SEQUENCES = exports.CODE_POINTS = exports.REPLACEMENT_CHARACTER = void 0;
    var UNDEFINED_CODE_POINTS2 = /* @__PURE__ */ new Set([
      65534,
      65535,
      131070,
      131071,
      196606,
      196607,
      262142,
      262143,
      327678,
      327679,
      393214,
      393215,
      458750,
      458751,
      524286,
      524287,
      589822,
      589823,
      655358,
      655359,
      720894,
      720895,
      786430,
      786431,
      851966,
      851967,
      917502,
      917503,
      983038,
      983039,
      1048574,
      1048575,
      1114110,
      1114111
    ]);
    exports.REPLACEMENT_CHARACTER = "\uFFFD";
    var CODE_POINTS2;
    (function(CODE_POINTS3) {
      CODE_POINTS3[CODE_POINTS3["EOF"] = -1] = "EOF";
      CODE_POINTS3[CODE_POINTS3["NULL"] = 0] = "NULL";
      CODE_POINTS3[CODE_POINTS3["TABULATION"] = 9] = "TABULATION";
      CODE_POINTS3[CODE_POINTS3["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
      CODE_POINTS3[CODE_POINTS3["LINE_FEED"] = 10] = "LINE_FEED";
      CODE_POINTS3[CODE_POINTS3["FORM_FEED"] = 12] = "FORM_FEED";
      CODE_POINTS3[CODE_POINTS3["SPACE"] = 32] = "SPACE";
      CODE_POINTS3[CODE_POINTS3["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
      CODE_POINTS3[CODE_POINTS3["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
      CODE_POINTS3[CODE_POINTS3["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
      CODE_POINTS3[CODE_POINTS3["AMPERSAND"] = 38] = "AMPERSAND";
      CODE_POINTS3[CODE_POINTS3["APOSTROPHE"] = 39] = "APOSTROPHE";
      CODE_POINTS3[CODE_POINTS3["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
      CODE_POINTS3[CODE_POINTS3["SOLIDUS"] = 47] = "SOLIDUS";
      CODE_POINTS3[CODE_POINTS3["DIGIT_0"] = 48] = "DIGIT_0";
      CODE_POINTS3[CODE_POINTS3["DIGIT_9"] = 57] = "DIGIT_9";
      CODE_POINTS3[CODE_POINTS3["SEMICOLON"] = 59] = "SEMICOLON";
      CODE_POINTS3[CODE_POINTS3["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
      CODE_POINTS3[CODE_POINTS3["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
      CODE_POINTS3[CODE_POINTS3["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
      CODE_POINTS3[CODE_POINTS3["QUESTION_MARK"] = 63] = "QUESTION_MARK";
      CODE_POINTS3[CODE_POINTS3["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
      CODE_POINTS3[CODE_POINTS3["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
      CODE_POINTS3[CODE_POINTS3["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
      CODE_POINTS3[CODE_POINTS3["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
      CODE_POINTS3[CODE_POINTS3["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
      CODE_POINTS3[CODE_POINTS3["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
      CODE_POINTS3[CODE_POINTS3["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
      CODE_POINTS3[CODE_POINTS3["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
      CODE_POINTS3[CODE_POINTS3["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
      CODE_POINTS3[CODE_POINTS3["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
      CODE_POINTS3[CODE_POINTS3["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
    })(CODE_POINTS2 = exports.CODE_POINTS || (exports.CODE_POINTS = {}));
    exports.SEQUENCES = {
      DASH_DASH: "--",
      CDATA_START: "[CDATA[",
      DOCTYPE: "doctype",
      SCRIPT: "script",
      PUBLIC: "public",
      SYSTEM: "system"
    };
    function isSurrogate2(cp) {
      return cp >= 55296 && cp <= 57343;
    }
    exports.isSurrogate = isSurrogate2;
    function isSurrogatePair2(cp) {
      return cp >= 56320 && cp <= 57343;
    }
    exports.isSurrogatePair = isSurrogatePair2;
    function getSurrogatePairCodePoint2(cp1, cp2) {
      return (cp1 - 55296) * 1024 + 9216 + cp2;
    }
    exports.getSurrogatePairCodePoint = getSurrogatePairCodePoint2;
    function isControlCodePoint2(cp) {
      return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
    }
    exports.isControlCodePoint = isControlCodePoint2;
    function isUndefinedCodePoint2(cp) {
      return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS2.has(cp);
    }
    exports.isUndefinedCodePoint = isUndefinedCodePoint2;
  }
});

// node_modules/parse5/dist/cjs/common/error-codes.js
var require_error_codes = __commonJS({
  "node_modules/parse5/dist/cjs/common/error-codes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERR = void 0;
    var ERR2;
    (function(ERR3) {
      ERR3["controlCharacterInInputStream"] = "control-character-in-input-stream";
      ERR3["noncharacterInInputStream"] = "noncharacter-in-input-stream";
      ERR3["surrogateInInputStream"] = "surrogate-in-input-stream";
      ERR3["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
      ERR3["endTagWithAttributes"] = "end-tag-with-attributes";
      ERR3["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
      ERR3["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
      ERR3["unexpectedNullCharacter"] = "unexpected-null-character";
      ERR3["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
      ERR3["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
      ERR3["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
      ERR3["missingEndTagName"] = "missing-end-tag-name";
      ERR3["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
      ERR3["unknownNamedCharacterReference"] = "unknown-named-character-reference";
      ERR3["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
      ERR3["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
      ERR3["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
      ERR3["eofBeforeTagName"] = "eof-before-tag-name";
      ERR3["eofInTag"] = "eof-in-tag";
      ERR3["missingAttributeValue"] = "missing-attribute-value";
      ERR3["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
      ERR3["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
      ERR3["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
      ERR3["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
      ERR3["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
      ERR3["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
      ERR3["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
      ERR3["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
      ERR3["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
      ERR3["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
      ERR3["cdataInHtmlContent"] = "cdata-in-html-content";
      ERR3["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
      ERR3["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
      ERR3["eofInDoctype"] = "eof-in-doctype";
      ERR3["nestedComment"] = "nested-comment";
      ERR3["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
      ERR3["eofInComment"] = "eof-in-comment";
      ERR3["incorrectlyClosedComment"] = "incorrectly-closed-comment";
      ERR3["eofInCdata"] = "eof-in-cdata";
      ERR3["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
      ERR3["nullCharacterReference"] = "null-character-reference";
      ERR3["surrogateCharacterReference"] = "surrogate-character-reference";
      ERR3["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
      ERR3["controlCharacterReference"] = "control-character-reference";
      ERR3["noncharacterCharacterReference"] = "noncharacter-character-reference";
      ERR3["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
      ERR3["missingDoctypeName"] = "missing-doctype-name";
      ERR3["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
      ERR3["duplicateAttribute"] = "duplicate-attribute";
      ERR3["nonConformingDoctype"] = "non-conforming-doctype";
      ERR3["missingDoctype"] = "missing-doctype";
      ERR3["misplacedDoctype"] = "misplaced-doctype";
      ERR3["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
      ERR3["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
      ERR3["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
      ERR3["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
      ERR3["abandonedHeadElementChild"] = "abandoned-head-element-child";
      ERR3["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
      ERR3["nestedNoscriptInHead"] = "nested-noscript-in-head";
      ERR3["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
    })(ERR2 = exports.ERR || (exports.ERR = {}));
  }
});

// node_modules/parse5/dist/cjs/tokenizer/preprocessor.js
var require_preprocessor = __commonJS({
  "node_modules/parse5/dist/cjs/tokenizer/preprocessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Preprocessor = void 0;
    var unicode_js_1 = require_unicode();
    var error_codes_js_1 = require_error_codes();
    var DEFAULT_BUFFER_WATERLINE2 = 1 << 16;
    var Preprocessor2 = class {
      constructor(handler) {
        this.handler = handler;
        this.html = "";
        this.pos = -1;
        this.lastGapPos = -2;
        this.gapStack = [];
        this.skipNextNewLine = false;
        this.lastChunkWritten = false;
        this.endOfChunkHit = false;
        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE2;
        this.isEol = false;
        this.lineStartPos = 0;
        this.droppedBufferSize = 0;
        this.line = 1;
        this.lastErrOffset = -1;
      }
      /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
      get col() {
        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
      }
      get offset() {
        return this.droppedBufferSize + this.pos;
      }
      getError(code) {
        const { line, col, offset } = this;
        return {
          code,
          startLine: line,
          endLine: line,
          startCol: col,
          endCol: col,
          startOffset: offset,
          endOffset: offset
        };
      }
      _err(code) {
        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
          this.lastErrOffset = this.offset;
          this.handler.onParseError(this.getError(code));
        }
      }
      _addGap() {
        this.gapStack.push(this.lastGapPos);
        this.lastGapPos = this.pos;
      }
      _processSurrogate(cp) {
        if (this.pos !== this.html.length - 1) {
          const nextCp = this.html.charCodeAt(this.pos + 1);
          if ((0, unicode_js_1.isSurrogatePair)(nextCp)) {
            this.pos++;
            this._addGap();
            return (0, unicode_js_1.getSurrogatePairCodePoint)(cp, nextCp);
          }
        } else if (!this.lastChunkWritten) {
          this.endOfChunkHit = true;
          return unicode_js_1.CODE_POINTS.EOF;
        }
        this._err(error_codes_js_1.ERR.surrogateInInputStream);
        return cp;
      }
      willDropParsedChunk() {
        return this.pos > this.bufferWaterline;
      }
      dropParsedChunk() {
        if (this.willDropParsedChunk()) {
          this.html = this.html.substring(this.pos);
          this.lineStartPos -= this.pos;
          this.droppedBufferSize += this.pos;
          this.pos = 0;
          this.lastGapPos = -2;
          this.gapStack.length = 0;
        }
      }
      write(chunk, isLastChunk) {
        if (this.html.length > 0) {
          this.html += chunk;
        } else {
          this.html = chunk;
        }
        this.endOfChunkHit = false;
        this.lastChunkWritten = isLastChunk;
      }
      insertHtmlAtCurrentPos(chunk) {
        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
        this.endOfChunkHit = false;
      }
      startsWith(pattern, caseSensitive) {
        if (this.pos + pattern.length > this.html.length) {
          this.endOfChunkHit = !this.lastChunkWritten;
          return false;
        }
        if (caseSensitive) {
          return this.html.startsWith(pattern, this.pos);
        }
        for (let i = 0; i < pattern.length; i++) {
          const cp = this.html.charCodeAt(this.pos + i) | 32;
          if (cp !== pattern.charCodeAt(i)) {
            return false;
          }
        }
        return true;
      }
      peek(offset) {
        const pos = this.pos + offset;
        if (pos >= this.html.length) {
          this.endOfChunkHit = !this.lastChunkWritten;
          return unicode_js_1.CODE_POINTS.EOF;
        }
        const code = this.html.charCodeAt(pos);
        return code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1.CODE_POINTS.LINE_FEED : code;
      }
      advance() {
        this.pos++;
        if (this.isEol) {
          this.isEol = false;
          this.line++;
          this.lineStartPos = this.pos;
        }
        if (this.pos >= this.html.length) {
          this.endOfChunkHit = !this.lastChunkWritten;
          return unicode_js_1.CODE_POINTS.EOF;
        }
        let cp = this.html.charCodeAt(this.pos);
        if (cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
          this.isEol = true;
          this.skipNextNewLine = true;
          return unicode_js_1.CODE_POINTS.LINE_FEED;
        }
        if (cp === unicode_js_1.CODE_POINTS.LINE_FEED) {
          this.isEol = true;
          if (this.skipNextNewLine) {
            this.line--;
            this.skipNextNewLine = false;
            this._addGap();
            return this.advance();
          }
        }
        this.skipNextNewLine = false;
        if ((0, unicode_js_1.isSurrogate)(cp)) {
          cp = this._processSurrogate(cp);
        }
        const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
        if (!isCommonValidRange) {
          this._checkForProblematicCharacters(cp);
        }
        return cp;
      }
      _checkForProblematicCharacters(cp) {
        if ((0, unicode_js_1.isControlCodePoint)(cp)) {
          this._err(error_codes_js_1.ERR.controlCharacterInInputStream);
        } else if ((0, unicode_js_1.isUndefinedCodePoint)(cp)) {
          this._err(error_codes_js_1.ERR.noncharacterInInputStream);
        }
      }
      retreat(count) {
        this.pos -= count;
        while (this.pos < this.lastGapPos) {
          this.lastGapPos = this.gapStack.pop();
          this.pos--;
        }
        this.isEol = false;
      }
    };
    exports.Preprocessor = Preprocessor2;
  }
});

// node_modules/parse5/dist/cjs/common/token.js
var require_token = __commonJS({
  "node_modules/parse5/dist/cjs/common/token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTokenAttr = exports.TokenType = void 0;
    var TokenType2;
    (function(TokenType3) {
      TokenType3[TokenType3["CHARACTER"] = 0] = "CHARACTER";
      TokenType3[TokenType3["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
      TokenType3[TokenType3["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
      TokenType3[TokenType3["START_TAG"] = 3] = "START_TAG";
      TokenType3[TokenType3["END_TAG"] = 4] = "END_TAG";
      TokenType3[TokenType3["COMMENT"] = 5] = "COMMENT";
      TokenType3[TokenType3["DOCTYPE"] = 6] = "DOCTYPE";
      TokenType3[TokenType3["EOF"] = 7] = "EOF";
      TokenType3[TokenType3["HIBERNATION"] = 8] = "HIBERNATION";
    })(TokenType2 = exports.TokenType || (exports.TokenType = {}));
    function getTokenAttr2(token, attrName) {
      for (let i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName) {
          return token.attrs[i].value;
        }
      }
      return null;
    }
    exports.getTokenAttr = getTokenAttr2;
  }
});

// node_modules/parse5/dist/cjs/common/html.js
var require_html = __commonJS({
  "node_modules/parse5/dist/cjs/common/html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasUnescapedText = exports.isNumberedHeader = exports.SPECIAL_ELEMENTS = exports.getTagID = exports.TAG_ID = exports.TAG_NAMES = exports.DOCUMENT_MODE = exports.ATTRS = exports.NS = void 0;
    var NS2;
    (function(NS3) {
      NS3["HTML"] = "http://www.w3.org/1999/xhtml";
      NS3["MATHML"] = "http://www.w3.org/1998/Math/MathML";
      NS3["SVG"] = "http://www.w3.org/2000/svg";
      NS3["XLINK"] = "http://www.w3.org/1999/xlink";
      NS3["XML"] = "http://www.w3.org/XML/1998/namespace";
      NS3["XMLNS"] = "http://www.w3.org/2000/xmlns/";
    })(NS2 = exports.NS || (exports.NS = {}));
    var ATTRS2;
    (function(ATTRS3) {
      ATTRS3["TYPE"] = "type";
      ATTRS3["ACTION"] = "action";
      ATTRS3["ENCODING"] = "encoding";
      ATTRS3["PROMPT"] = "prompt";
      ATTRS3["NAME"] = "name";
      ATTRS3["COLOR"] = "color";
      ATTRS3["FACE"] = "face";
      ATTRS3["SIZE"] = "size";
    })(ATTRS2 = exports.ATTRS || (exports.ATTRS = {}));
    var DOCUMENT_MODE2;
    (function(DOCUMENT_MODE3) {
      DOCUMENT_MODE3["NO_QUIRKS"] = "no-quirks";
      DOCUMENT_MODE3["QUIRKS"] = "quirks";
      DOCUMENT_MODE3["LIMITED_QUIRKS"] = "limited-quirks";
    })(DOCUMENT_MODE2 = exports.DOCUMENT_MODE || (exports.DOCUMENT_MODE = {}));
    var TAG_NAMES2;
    (function(TAG_NAMES3) {
      TAG_NAMES3["A"] = "a";
      TAG_NAMES3["ADDRESS"] = "address";
      TAG_NAMES3["ANNOTATION_XML"] = "annotation-xml";
      TAG_NAMES3["APPLET"] = "applet";
      TAG_NAMES3["AREA"] = "area";
      TAG_NAMES3["ARTICLE"] = "article";
      TAG_NAMES3["ASIDE"] = "aside";
      TAG_NAMES3["B"] = "b";
      TAG_NAMES3["BASE"] = "base";
      TAG_NAMES3["BASEFONT"] = "basefont";
      TAG_NAMES3["BGSOUND"] = "bgsound";
      TAG_NAMES3["BIG"] = "big";
      TAG_NAMES3["BLOCKQUOTE"] = "blockquote";
      TAG_NAMES3["BODY"] = "body";
      TAG_NAMES3["BR"] = "br";
      TAG_NAMES3["BUTTON"] = "button";
      TAG_NAMES3["CAPTION"] = "caption";
      TAG_NAMES3["CENTER"] = "center";
      TAG_NAMES3["CODE"] = "code";
      TAG_NAMES3["COL"] = "col";
      TAG_NAMES3["COLGROUP"] = "colgroup";
      TAG_NAMES3["DD"] = "dd";
      TAG_NAMES3["DESC"] = "desc";
      TAG_NAMES3["DETAILS"] = "details";
      TAG_NAMES3["DIALOG"] = "dialog";
      TAG_NAMES3["DIR"] = "dir";
      TAG_NAMES3["DIV"] = "div";
      TAG_NAMES3["DL"] = "dl";
      TAG_NAMES3["DT"] = "dt";
      TAG_NAMES3["EM"] = "em";
      TAG_NAMES3["EMBED"] = "embed";
      TAG_NAMES3["FIELDSET"] = "fieldset";
      TAG_NAMES3["FIGCAPTION"] = "figcaption";
      TAG_NAMES3["FIGURE"] = "figure";
      TAG_NAMES3["FONT"] = "font";
      TAG_NAMES3["FOOTER"] = "footer";
      TAG_NAMES3["FOREIGN_OBJECT"] = "foreignObject";
      TAG_NAMES3["FORM"] = "form";
      TAG_NAMES3["FRAME"] = "frame";
      TAG_NAMES3["FRAMESET"] = "frameset";
      TAG_NAMES3["H1"] = "h1";
      TAG_NAMES3["H2"] = "h2";
      TAG_NAMES3["H3"] = "h3";
      TAG_NAMES3["H4"] = "h4";
      TAG_NAMES3["H5"] = "h5";
      TAG_NAMES3["H6"] = "h6";
      TAG_NAMES3["HEAD"] = "head";
      TAG_NAMES3["HEADER"] = "header";
      TAG_NAMES3["HGROUP"] = "hgroup";
      TAG_NAMES3["HR"] = "hr";
      TAG_NAMES3["HTML"] = "html";
      TAG_NAMES3["I"] = "i";
      TAG_NAMES3["IMG"] = "img";
      TAG_NAMES3["IMAGE"] = "image";
      TAG_NAMES3["INPUT"] = "input";
      TAG_NAMES3["IFRAME"] = "iframe";
      TAG_NAMES3["KEYGEN"] = "keygen";
      TAG_NAMES3["LABEL"] = "label";
      TAG_NAMES3["LI"] = "li";
      TAG_NAMES3["LINK"] = "link";
      TAG_NAMES3["LISTING"] = "listing";
      TAG_NAMES3["MAIN"] = "main";
      TAG_NAMES3["MALIGNMARK"] = "malignmark";
      TAG_NAMES3["MARQUEE"] = "marquee";
      TAG_NAMES3["MATH"] = "math";
      TAG_NAMES3["MENU"] = "menu";
      TAG_NAMES3["META"] = "meta";
      TAG_NAMES3["MGLYPH"] = "mglyph";
      TAG_NAMES3["MI"] = "mi";
      TAG_NAMES3["MO"] = "mo";
      TAG_NAMES3["MN"] = "mn";
      TAG_NAMES3["MS"] = "ms";
      TAG_NAMES3["MTEXT"] = "mtext";
      TAG_NAMES3["NAV"] = "nav";
      TAG_NAMES3["NOBR"] = "nobr";
      TAG_NAMES3["NOFRAMES"] = "noframes";
      TAG_NAMES3["NOEMBED"] = "noembed";
      TAG_NAMES3["NOSCRIPT"] = "noscript";
      TAG_NAMES3["OBJECT"] = "object";
      TAG_NAMES3["OL"] = "ol";
      TAG_NAMES3["OPTGROUP"] = "optgroup";
      TAG_NAMES3["OPTION"] = "option";
      TAG_NAMES3["P"] = "p";
      TAG_NAMES3["PARAM"] = "param";
      TAG_NAMES3["PLAINTEXT"] = "plaintext";
      TAG_NAMES3["PRE"] = "pre";
      TAG_NAMES3["RB"] = "rb";
      TAG_NAMES3["RP"] = "rp";
      TAG_NAMES3["RT"] = "rt";
      TAG_NAMES3["RTC"] = "rtc";
      TAG_NAMES3["RUBY"] = "ruby";
      TAG_NAMES3["S"] = "s";
      TAG_NAMES3["SCRIPT"] = "script";
      TAG_NAMES3["SECTION"] = "section";
      TAG_NAMES3["SELECT"] = "select";
      TAG_NAMES3["SOURCE"] = "source";
      TAG_NAMES3["SMALL"] = "small";
      TAG_NAMES3["SPAN"] = "span";
      TAG_NAMES3["STRIKE"] = "strike";
      TAG_NAMES3["STRONG"] = "strong";
      TAG_NAMES3["STYLE"] = "style";
      TAG_NAMES3["SUB"] = "sub";
      TAG_NAMES3["SUMMARY"] = "summary";
      TAG_NAMES3["SUP"] = "sup";
      TAG_NAMES3["TABLE"] = "table";
      TAG_NAMES3["TBODY"] = "tbody";
      TAG_NAMES3["TEMPLATE"] = "template";
      TAG_NAMES3["TEXTAREA"] = "textarea";
      TAG_NAMES3["TFOOT"] = "tfoot";
      TAG_NAMES3["TD"] = "td";
      TAG_NAMES3["TH"] = "th";
      TAG_NAMES3["THEAD"] = "thead";
      TAG_NAMES3["TITLE"] = "title";
      TAG_NAMES3["TR"] = "tr";
      TAG_NAMES3["TRACK"] = "track";
      TAG_NAMES3["TT"] = "tt";
      TAG_NAMES3["U"] = "u";
      TAG_NAMES3["UL"] = "ul";
      TAG_NAMES3["SVG"] = "svg";
      TAG_NAMES3["VAR"] = "var";
      TAG_NAMES3["WBR"] = "wbr";
      TAG_NAMES3["XMP"] = "xmp";
    })(TAG_NAMES2 = exports.TAG_NAMES || (exports.TAG_NAMES = {}));
    var TAG_ID2;
    (function(TAG_ID3) {
      TAG_ID3[TAG_ID3["UNKNOWN"] = 0] = "UNKNOWN";
      TAG_ID3[TAG_ID3["A"] = 1] = "A";
      TAG_ID3[TAG_ID3["ADDRESS"] = 2] = "ADDRESS";
      TAG_ID3[TAG_ID3["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
      TAG_ID3[TAG_ID3["APPLET"] = 4] = "APPLET";
      TAG_ID3[TAG_ID3["AREA"] = 5] = "AREA";
      TAG_ID3[TAG_ID3["ARTICLE"] = 6] = "ARTICLE";
      TAG_ID3[TAG_ID3["ASIDE"] = 7] = "ASIDE";
      TAG_ID3[TAG_ID3["B"] = 8] = "B";
      TAG_ID3[TAG_ID3["BASE"] = 9] = "BASE";
      TAG_ID3[TAG_ID3["BASEFONT"] = 10] = "BASEFONT";
      TAG_ID3[TAG_ID3["BGSOUND"] = 11] = "BGSOUND";
      TAG_ID3[TAG_ID3["BIG"] = 12] = "BIG";
      TAG_ID3[TAG_ID3["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
      TAG_ID3[TAG_ID3["BODY"] = 14] = "BODY";
      TAG_ID3[TAG_ID3["BR"] = 15] = "BR";
      TAG_ID3[TAG_ID3["BUTTON"] = 16] = "BUTTON";
      TAG_ID3[TAG_ID3["CAPTION"] = 17] = "CAPTION";
      TAG_ID3[TAG_ID3["CENTER"] = 18] = "CENTER";
      TAG_ID3[TAG_ID3["CODE"] = 19] = "CODE";
      TAG_ID3[TAG_ID3["COL"] = 20] = "COL";
      TAG_ID3[TAG_ID3["COLGROUP"] = 21] = "COLGROUP";
      TAG_ID3[TAG_ID3["DD"] = 22] = "DD";
      TAG_ID3[TAG_ID3["DESC"] = 23] = "DESC";
      TAG_ID3[TAG_ID3["DETAILS"] = 24] = "DETAILS";
      TAG_ID3[TAG_ID3["DIALOG"] = 25] = "DIALOG";
      TAG_ID3[TAG_ID3["DIR"] = 26] = "DIR";
      TAG_ID3[TAG_ID3["DIV"] = 27] = "DIV";
      TAG_ID3[TAG_ID3["DL"] = 28] = "DL";
      TAG_ID3[TAG_ID3["DT"] = 29] = "DT";
      TAG_ID3[TAG_ID3["EM"] = 30] = "EM";
      TAG_ID3[TAG_ID3["EMBED"] = 31] = "EMBED";
      TAG_ID3[TAG_ID3["FIELDSET"] = 32] = "FIELDSET";
      TAG_ID3[TAG_ID3["FIGCAPTION"] = 33] = "FIGCAPTION";
      TAG_ID3[TAG_ID3["FIGURE"] = 34] = "FIGURE";
      TAG_ID3[TAG_ID3["FONT"] = 35] = "FONT";
      TAG_ID3[TAG_ID3["FOOTER"] = 36] = "FOOTER";
      TAG_ID3[TAG_ID3["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
      TAG_ID3[TAG_ID3["FORM"] = 38] = "FORM";
      TAG_ID3[TAG_ID3["FRAME"] = 39] = "FRAME";
      TAG_ID3[TAG_ID3["FRAMESET"] = 40] = "FRAMESET";
      TAG_ID3[TAG_ID3["H1"] = 41] = "H1";
      TAG_ID3[TAG_ID3["H2"] = 42] = "H2";
      TAG_ID3[TAG_ID3["H3"] = 43] = "H3";
      TAG_ID3[TAG_ID3["H4"] = 44] = "H4";
      TAG_ID3[TAG_ID3["H5"] = 45] = "H5";
      TAG_ID3[TAG_ID3["H6"] = 46] = "H6";
      TAG_ID3[TAG_ID3["HEAD"] = 47] = "HEAD";
      TAG_ID3[TAG_ID3["HEADER"] = 48] = "HEADER";
      TAG_ID3[TAG_ID3["HGROUP"] = 49] = "HGROUP";
      TAG_ID3[TAG_ID3["HR"] = 50] = "HR";
      TAG_ID3[TAG_ID3["HTML"] = 51] = "HTML";
      TAG_ID3[TAG_ID3["I"] = 52] = "I";
      TAG_ID3[TAG_ID3["IMG"] = 53] = "IMG";
      TAG_ID3[TAG_ID3["IMAGE"] = 54] = "IMAGE";
      TAG_ID3[TAG_ID3["INPUT"] = 55] = "INPUT";
      TAG_ID3[TAG_ID3["IFRAME"] = 56] = "IFRAME";
      TAG_ID3[TAG_ID3["KEYGEN"] = 57] = "KEYGEN";
      TAG_ID3[TAG_ID3["LABEL"] = 58] = "LABEL";
      TAG_ID3[TAG_ID3["LI"] = 59] = "LI";
      TAG_ID3[TAG_ID3["LINK"] = 60] = "LINK";
      TAG_ID3[TAG_ID3["LISTING"] = 61] = "LISTING";
      TAG_ID3[TAG_ID3["MAIN"] = 62] = "MAIN";
      TAG_ID3[TAG_ID3["MALIGNMARK"] = 63] = "MALIGNMARK";
      TAG_ID3[TAG_ID3["MARQUEE"] = 64] = "MARQUEE";
      TAG_ID3[TAG_ID3["MATH"] = 65] = "MATH";
      TAG_ID3[TAG_ID3["MENU"] = 66] = "MENU";
      TAG_ID3[TAG_ID3["META"] = 67] = "META";
      TAG_ID3[TAG_ID3["MGLYPH"] = 68] = "MGLYPH";
      TAG_ID3[TAG_ID3["MI"] = 69] = "MI";
      TAG_ID3[TAG_ID3["MO"] = 70] = "MO";
      TAG_ID3[TAG_ID3["MN"] = 71] = "MN";
      TAG_ID3[TAG_ID3["MS"] = 72] = "MS";
      TAG_ID3[TAG_ID3["MTEXT"] = 73] = "MTEXT";
      TAG_ID3[TAG_ID3["NAV"] = 74] = "NAV";
      TAG_ID3[TAG_ID3["NOBR"] = 75] = "NOBR";
      TAG_ID3[TAG_ID3["NOFRAMES"] = 76] = "NOFRAMES";
      TAG_ID3[TAG_ID3["NOEMBED"] = 77] = "NOEMBED";
      TAG_ID3[TAG_ID3["NOSCRIPT"] = 78] = "NOSCRIPT";
      TAG_ID3[TAG_ID3["OBJECT"] = 79] = "OBJECT";
      TAG_ID3[TAG_ID3["OL"] = 80] = "OL";
      TAG_ID3[TAG_ID3["OPTGROUP"] = 81] = "OPTGROUP";
      TAG_ID3[TAG_ID3["OPTION"] = 82] = "OPTION";
      TAG_ID3[TAG_ID3["P"] = 83] = "P";
      TAG_ID3[TAG_ID3["PARAM"] = 84] = "PARAM";
      TAG_ID3[TAG_ID3["PLAINTEXT"] = 85] = "PLAINTEXT";
      TAG_ID3[TAG_ID3["PRE"] = 86] = "PRE";
      TAG_ID3[TAG_ID3["RB"] = 87] = "RB";
      TAG_ID3[TAG_ID3["RP"] = 88] = "RP";
      TAG_ID3[TAG_ID3["RT"] = 89] = "RT";
      TAG_ID3[TAG_ID3["RTC"] = 90] = "RTC";
      TAG_ID3[TAG_ID3["RUBY"] = 91] = "RUBY";
      TAG_ID3[TAG_ID3["S"] = 92] = "S";
      TAG_ID3[TAG_ID3["SCRIPT"] = 93] = "SCRIPT";
      TAG_ID3[TAG_ID3["SECTION"] = 94] = "SECTION";
      TAG_ID3[TAG_ID3["SELECT"] = 95] = "SELECT";
      TAG_ID3[TAG_ID3["SOURCE"] = 96] = "SOURCE";
      TAG_ID3[TAG_ID3["SMALL"] = 97] = "SMALL";
      TAG_ID3[TAG_ID3["SPAN"] = 98] = "SPAN";
      TAG_ID3[TAG_ID3["STRIKE"] = 99] = "STRIKE";
      TAG_ID3[TAG_ID3["STRONG"] = 100] = "STRONG";
      TAG_ID3[TAG_ID3["STYLE"] = 101] = "STYLE";
      TAG_ID3[TAG_ID3["SUB"] = 102] = "SUB";
      TAG_ID3[TAG_ID3["SUMMARY"] = 103] = "SUMMARY";
      TAG_ID3[TAG_ID3["SUP"] = 104] = "SUP";
      TAG_ID3[TAG_ID3["TABLE"] = 105] = "TABLE";
      TAG_ID3[TAG_ID3["TBODY"] = 106] = "TBODY";
      TAG_ID3[TAG_ID3["TEMPLATE"] = 107] = "TEMPLATE";
      TAG_ID3[TAG_ID3["TEXTAREA"] = 108] = "TEXTAREA";
      TAG_ID3[TAG_ID3["TFOOT"] = 109] = "TFOOT";
      TAG_ID3[TAG_ID3["TD"] = 110] = "TD";
      TAG_ID3[TAG_ID3["TH"] = 111] = "TH";
      TAG_ID3[TAG_ID3["THEAD"] = 112] = "THEAD";
      TAG_ID3[TAG_ID3["TITLE"] = 113] = "TITLE";
      TAG_ID3[TAG_ID3["TR"] = 114] = "TR";
      TAG_ID3[TAG_ID3["TRACK"] = 115] = "TRACK";
      TAG_ID3[TAG_ID3["TT"] = 116] = "TT";
      TAG_ID3[TAG_ID3["U"] = 117] = "U";
      TAG_ID3[TAG_ID3["UL"] = 118] = "UL";
      TAG_ID3[TAG_ID3["SVG"] = 119] = "SVG";
      TAG_ID3[TAG_ID3["VAR"] = 120] = "VAR";
      TAG_ID3[TAG_ID3["WBR"] = 121] = "WBR";
      TAG_ID3[TAG_ID3["XMP"] = 122] = "XMP";
    })(TAG_ID2 = exports.TAG_ID || (exports.TAG_ID = {}));
    var TAG_NAME_TO_ID2 = /* @__PURE__ */ new Map([
      [TAG_NAMES2.A, TAG_ID2.A],
      [TAG_NAMES2.ADDRESS, TAG_ID2.ADDRESS],
      [TAG_NAMES2.ANNOTATION_XML, TAG_ID2.ANNOTATION_XML],
      [TAG_NAMES2.APPLET, TAG_ID2.APPLET],
      [TAG_NAMES2.AREA, TAG_ID2.AREA],
      [TAG_NAMES2.ARTICLE, TAG_ID2.ARTICLE],
      [TAG_NAMES2.ASIDE, TAG_ID2.ASIDE],
      [TAG_NAMES2.B, TAG_ID2.B],
      [TAG_NAMES2.BASE, TAG_ID2.BASE],
      [TAG_NAMES2.BASEFONT, TAG_ID2.BASEFONT],
      [TAG_NAMES2.BGSOUND, TAG_ID2.BGSOUND],
      [TAG_NAMES2.BIG, TAG_ID2.BIG],
      [TAG_NAMES2.BLOCKQUOTE, TAG_ID2.BLOCKQUOTE],
      [TAG_NAMES2.BODY, TAG_ID2.BODY],
      [TAG_NAMES2.BR, TAG_ID2.BR],
      [TAG_NAMES2.BUTTON, TAG_ID2.BUTTON],
      [TAG_NAMES2.CAPTION, TAG_ID2.CAPTION],
      [TAG_NAMES2.CENTER, TAG_ID2.CENTER],
      [TAG_NAMES2.CODE, TAG_ID2.CODE],
      [TAG_NAMES2.COL, TAG_ID2.COL],
      [TAG_NAMES2.COLGROUP, TAG_ID2.COLGROUP],
      [TAG_NAMES2.DD, TAG_ID2.DD],
      [TAG_NAMES2.DESC, TAG_ID2.DESC],
      [TAG_NAMES2.DETAILS, TAG_ID2.DETAILS],
      [TAG_NAMES2.DIALOG, TAG_ID2.DIALOG],
      [TAG_NAMES2.DIR, TAG_ID2.DIR],
      [TAG_NAMES2.DIV, TAG_ID2.DIV],
      [TAG_NAMES2.DL, TAG_ID2.DL],
      [TAG_NAMES2.DT, TAG_ID2.DT],
      [TAG_NAMES2.EM, TAG_ID2.EM],
      [TAG_NAMES2.EMBED, TAG_ID2.EMBED],
      [TAG_NAMES2.FIELDSET, TAG_ID2.FIELDSET],
      [TAG_NAMES2.FIGCAPTION, TAG_ID2.FIGCAPTION],
      [TAG_NAMES2.FIGURE, TAG_ID2.FIGURE],
      [TAG_NAMES2.FONT, TAG_ID2.FONT],
      [TAG_NAMES2.FOOTER, TAG_ID2.FOOTER],
      [TAG_NAMES2.FOREIGN_OBJECT, TAG_ID2.FOREIGN_OBJECT],
      [TAG_NAMES2.FORM, TAG_ID2.FORM],
      [TAG_NAMES2.FRAME, TAG_ID2.FRAME],
      [TAG_NAMES2.FRAMESET, TAG_ID2.FRAMESET],
      [TAG_NAMES2.H1, TAG_ID2.H1],
      [TAG_NAMES2.H2, TAG_ID2.H2],
      [TAG_NAMES2.H3, TAG_ID2.H3],
      [TAG_NAMES2.H4, TAG_ID2.H4],
      [TAG_NAMES2.H5, TAG_ID2.H5],
      [TAG_NAMES2.H6, TAG_ID2.H6],
      [TAG_NAMES2.HEAD, TAG_ID2.HEAD],
      [TAG_NAMES2.HEADER, TAG_ID2.HEADER],
      [TAG_NAMES2.HGROUP, TAG_ID2.HGROUP],
      [TAG_NAMES2.HR, TAG_ID2.HR],
      [TAG_NAMES2.HTML, TAG_ID2.HTML],
      [TAG_NAMES2.I, TAG_ID2.I],
      [TAG_NAMES2.IMG, TAG_ID2.IMG],
      [TAG_NAMES2.IMAGE, TAG_ID2.IMAGE],
      [TAG_NAMES2.INPUT, TAG_ID2.INPUT],
      [TAG_NAMES2.IFRAME, TAG_ID2.IFRAME],
      [TAG_NAMES2.KEYGEN, TAG_ID2.KEYGEN],
      [TAG_NAMES2.LABEL, TAG_ID2.LABEL],
      [TAG_NAMES2.LI, TAG_ID2.LI],
      [TAG_NAMES2.LINK, TAG_ID2.LINK],
      [TAG_NAMES2.LISTING, TAG_ID2.LISTING],
      [TAG_NAMES2.MAIN, TAG_ID2.MAIN],
      [TAG_NAMES2.MALIGNMARK, TAG_ID2.MALIGNMARK],
      [TAG_NAMES2.MARQUEE, TAG_ID2.MARQUEE],
      [TAG_NAMES2.MATH, TAG_ID2.MATH],
      [TAG_NAMES2.MENU, TAG_ID2.MENU],
      [TAG_NAMES2.META, TAG_ID2.META],
      [TAG_NAMES2.MGLYPH, TAG_ID2.MGLYPH],
      [TAG_NAMES2.MI, TAG_ID2.MI],
      [TAG_NAMES2.MO, TAG_ID2.MO],
      [TAG_NAMES2.MN, TAG_ID2.MN],
      [TAG_NAMES2.MS, TAG_ID2.MS],
      [TAG_NAMES2.MTEXT, TAG_ID2.MTEXT],
      [TAG_NAMES2.NAV, TAG_ID2.NAV],
      [TAG_NAMES2.NOBR, TAG_ID2.NOBR],
      [TAG_NAMES2.NOFRAMES, TAG_ID2.NOFRAMES],
      [TAG_NAMES2.NOEMBED, TAG_ID2.NOEMBED],
      [TAG_NAMES2.NOSCRIPT, TAG_ID2.NOSCRIPT],
      [TAG_NAMES2.OBJECT, TAG_ID2.OBJECT],
      [TAG_NAMES2.OL, TAG_ID2.OL],
      [TAG_NAMES2.OPTGROUP, TAG_ID2.OPTGROUP],
      [TAG_NAMES2.OPTION, TAG_ID2.OPTION],
      [TAG_NAMES2.P, TAG_ID2.P],
      [TAG_NAMES2.PARAM, TAG_ID2.PARAM],
      [TAG_NAMES2.PLAINTEXT, TAG_ID2.PLAINTEXT],
      [TAG_NAMES2.PRE, TAG_ID2.PRE],
      [TAG_NAMES2.RB, TAG_ID2.RB],
      [TAG_NAMES2.RP, TAG_ID2.RP],
      [TAG_NAMES2.RT, TAG_ID2.RT],
      [TAG_NAMES2.RTC, TAG_ID2.RTC],
      [TAG_NAMES2.RUBY, TAG_ID2.RUBY],
      [TAG_NAMES2.S, TAG_ID2.S],
      [TAG_NAMES2.SCRIPT, TAG_ID2.SCRIPT],
      [TAG_NAMES2.SECTION, TAG_ID2.SECTION],
      [TAG_NAMES2.SELECT, TAG_ID2.SELECT],
      [TAG_NAMES2.SOURCE, TAG_ID2.SOURCE],
      [TAG_NAMES2.SMALL, TAG_ID2.SMALL],
      [TAG_NAMES2.SPAN, TAG_ID2.SPAN],
      [TAG_NAMES2.STRIKE, TAG_ID2.STRIKE],
      [TAG_NAMES2.STRONG, TAG_ID2.STRONG],
      [TAG_NAMES2.STYLE, TAG_ID2.STYLE],
      [TAG_NAMES2.SUB, TAG_ID2.SUB],
      [TAG_NAMES2.SUMMARY, TAG_ID2.SUMMARY],
      [TAG_NAMES2.SUP, TAG_ID2.SUP],
      [TAG_NAMES2.TABLE, TAG_ID2.TABLE],
      [TAG_NAMES2.TBODY, TAG_ID2.TBODY],
      [TAG_NAMES2.TEMPLATE, TAG_ID2.TEMPLATE],
      [TAG_NAMES2.TEXTAREA, TAG_ID2.TEXTAREA],
      [TAG_NAMES2.TFOOT, TAG_ID2.TFOOT],
      [TAG_NAMES2.TD, TAG_ID2.TD],
      [TAG_NAMES2.TH, TAG_ID2.TH],
      [TAG_NAMES2.THEAD, TAG_ID2.THEAD],
      [TAG_NAMES2.TITLE, TAG_ID2.TITLE],
      [TAG_NAMES2.TR, TAG_ID2.TR],
      [TAG_NAMES2.TRACK, TAG_ID2.TRACK],
      [TAG_NAMES2.TT, TAG_ID2.TT],
      [TAG_NAMES2.U, TAG_ID2.U],
      [TAG_NAMES2.UL, TAG_ID2.UL],
      [TAG_NAMES2.SVG, TAG_ID2.SVG],
      [TAG_NAMES2.VAR, TAG_ID2.VAR],
      [TAG_NAMES2.WBR, TAG_ID2.WBR],
      [TAG_NAMES2.XMP, TAG_ID2.XMP]
    ]);
    function getTagID2(tagName) {
      var _a2;
      return (_a2 = TAG_NAME_TO_ID2.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID2.UNKNOWN;
    }
    exports.getTagID = getTagID2;
    var $2 = TAG_ID2;
    exports.SPECIAL_ELEMENTS = {
      [NS2.HTML]: /* @__PURE__ */ new Set([
        $2.ADDRESS,
        $2.APPLET,
        $2.AREA,
        $2.ARTICLE,
        $2.ASIDE,
        $2.BASE,
        $2.BASEFONT,
        $2.BGSOUND,
        $2.BLOCKQUOTE,
        $2.BODY,
        $2.BR,
        $2.BUTTON,
        $2.CAPTION,
        $2.CENTER,
        $2.COL,
        $2.COLGROUP,
        $2.DD,
        $2.DETAILS,
        $2.DIR,
        $2.DIV,
        $2.DL,
        $2.DT,
        $2.EMBED,
        $2.FIELDSET,
        $2.FIGCAPTION,
        $2.FIGURE,
        $2.FOOTER,
        $2.FORM,
        $2.FRAME,
        $2.FRAMESET,
        $2.H1,
        $2.H2,
        $2.H3,
        $2.H4,
        $2.H5,
        $2.H6,
        $2.HEAD,
        $2.HEADER,
        $2.HGROUP,
        $2.HR,
        $2.HTML,
        $2.IFRAME,
        $2.IMG,
        $2.INPUT,
        $2.LI,
        $2.LINK,
        $2.LISTING,
        $2.MAIN,
        $2.MARQUEE,
        $2.MENU,
        $2.META,
        $2.NAV,
        $2.NOEMBED,
        $2.NOFRAMES,
        $2.NOSCRIPT,
        $2.OBJECT,
        $2.OL,
        $2.P,
        $2.PARAM,
        $2.PLAINTEXT,
        $2.PRE,
        $2.SCRIPT,
        $2.SECTION,
        $2.SELECT,
        $2.SOURCE,
        $2.STYLE,
        $2.SUMMARY,
        $2.TABLE,
        $2.TBODY,
        $2.TD,
        $2.TEMPLATE,
        $2.TEXTAREA,
        $2.TFOOT,
        $2.TH,
        $2.THEAD,
        $2.TITLE,
        $2.TR,
        $2.TRACK,
        $2.UL,
        $2.WBR,
        $2.XMP
      ]),
      [NS2.MATHML]: /* @__PURE__ */ new Set([$2.MI, $2.MO, $2.MN, $2.MS, $2.MTEXT, $2.ANNOTATION_XML]),
      [NS2.SVG]: /* @__PURE__ */ new Set([$2.TITLE, $2.FOREIGN_OBJECT, $2.DESC]),
      [NS2.XLINK]: /* @__PURE__ */ new Set(),
      [NS2.XML]: /* @__PURE__ */ new Set(),
      [NS2.XMLNS]: /* @__PURE__ */ new Set()
    };
    function isNumberedHeader2(tn) {
      return tn === $2.H1 || tn === $2.H2 || tn === $2.H3 || tn === $2.H4 || tn === $2.H5 || tn === $2.H6;
    }
    exports.isNumberedHeader = isNumberedHeader2;
    var UNESCAPED_TEXT2 = /* @__PURE__ */ new Set([
      TAG_NAMES2.STYLE,
      TAG_NAMES2.SCRIPT,
      TAG_NAMES2.XMP,
      TAG_NAMES2.IFRAME,
      TAG_NAMES2.NOEMBED,
      TAG_NAMES2.NOFRAMES,
      TAG_NAMES2.PLAINTEXT
    ]);
    function hasUnescapedText2(tn, scriptingEnabled) {
      return UNESCAPED_TEXT2.has(tn) || scriptingEnabled && tn === TAG_NAMES2.NOSCRIPT;
    }
    exports.hasUnescapedText = hasUnescapedText2;
  }
});

// node_modules/parse5/dist/cjs/tokenizer/index.js
var require_tokenizer = __commonJS({
  "node_modules/parse5/dist/cjs/tokenizer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tokenizer = exports.TokenizerMode = void 0;
    var preprocessor_js_1 = require_preprocessor();
    var unicode_js_1 = require_unicode();
    var token_js_1 = require_token();
    var decode_js_1 = require_decode();
    var error_codes_js_1 = require_error_codes();
    var html_js_1 = require_html();
    var C1_CONTROLS_REFERENCE_REPLACEMENTS2 = /* @__PURE__ */ new Map([
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    var State3;
    (function(State4) {
      State4[State4["DATA"] = 0] = "DATA";
      State4[State4["RCDATA"] = 1] = "RCDATA";
      State4[State4["RAWTEXT"] = 2] = "RAWTEXT";
      State4[State4["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
      State4[State4["PLAINTEXT"] = 4] = "PLAINTEXT";
      State4[State4["TAG_OPEN"] = 5] = "TAG_OPEN";
      State4[State4["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
      State4[State4["TAG_NAME"] = 7] = "TAG_NAME";
      State4[State4["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
      State4[State4["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
      State4[State4["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
      State4[State4["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
      State4[State4["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
      State4[State4["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
      State4[State4["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
      State4[State4["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
      State4[State4["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
      State4[State4["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
      State4[State4["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
      State4[State4["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
      State4[State4["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
      State4[State4["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
      State4[State4["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
      State4[State4["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
      State4[State4["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
      State4[State4["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
      State4[State4["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
      State4[State4["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
      State4[State4["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
      State4[State4["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
      State4[State4["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
      State4[State4["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
      State4[State4["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
      State4[State4["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
      State4[State4["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
      State4[State4["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
      State4[State4["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
      State4[State4["COMMENT_START"] = 42] = "COMMENT_START";
      State4[State4["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
      State4[State4["COMMENT"] = 44] = "COMMENT";
      State4[State4["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
      State4[State4["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
      State4[State4["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
      State4[State4["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
      State4[State4["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
      State4[State4["COMMENT_END"] = 50] = "COMMENT_END";
      State4[State4["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
      State4[State4["DOCTYPE"] = 52] = "DOCTYPE";
      State4[State4["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
      State4[State4["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
      State4[State4["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
      State4[State4["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
      State4[State4["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
      State4[State4["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
      State4[State4["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
      State4[State4["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
      State4[State4["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
      State4[State4["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
      State4[State4["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
      State4[State4["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
      State4[State4["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
      State4[State4["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
      State4[State4["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
      State4[State4["CDATA_SECTION"] = 68] = "CDATA_SECTION";
      State4[State4["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
      State4[State4["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
      State4[State4["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
      State4[State4["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
      State4[State4["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
      State4[State4["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
      State4[State4["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
      State4[State4["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
      State4[State4["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
      State4[State4["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
    })(State3 || (State3 = {}));
    exports.TokenizerMode = {
      DATA: State3.DATA,
      RCDATA: State3.RCDATA,
      RAWTEXT: State3.RAWTEXT,
      SCRIPT_DATA: State3.SCRIPT_DATA,
      PLAINTEXT: State3.PLAINTEXT,
      CDATA_SECTION: State3.CDATA_SECTION
    };
    function isAsciiDigit2(cp) {
      return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;
    }
    function isAsciiUpper2(cp) {
      return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;
    }
    function isAsciiLower2(cp) {
      return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;
    }
    function isAsciiLetter2(cp) {
      return isAsciiLower2(cp) || isAsciiUpper2(cp);
    }
    function isAsciiAlphaNumeric3(cp) {
      return isAsciiLetter2(cp) || isAsciiDigit2(cp);
    }
    function isAsciiUpperHexDigit2(cp) {
      return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_F;
    }
    function isAsciiLowerHexDigit2(cp) {
      return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_F;
    }
    function isAsciiHexDigit2(cp) {
      return isAsciiDigit2(cp) || isAsciiUpperHexDigit2(cp) || isAsciiLowerHexDigit2(cp);
    }
    function toAsciiLower2(cp) {
      return cp + 32;
    }
    function isWhitespace3(cp) {
      return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;
    }
    function isEntityInAttributeInvalidEnd3(nextCp) {
      return nextCp === unicode_js_1.CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric3(nextCp);
    }
    function isScriptDataDoubleEscapeSequenceEnd2(cp) {
      return isWhitespace3(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;
    }
    var Tokenizer3 = class {
      constructor(options, handler) {
        this.options = options;
        this.handler = handler;
        this.paused = false;
        this.inLoop = false;
        this.inForeignNode = false;
        this.lastStartTagName = "";
        this.active = false;
        this.state = State3.DATA;
        this.returnState = State3.DATA;
        this.charRefCode = -1;
        this.consumedAfterSnapshot = -1;
        this.currentCharacterToken = null;
        this.currentToken = null;
        this.currentAttr = { name: "", value: "" };
        this.preprocessor = new preprocessor_js_1.Preprocessor(handler);
        this.currentLocation = this.getCurrentLocation(-1);
      }
      //Errors
      _err(code) {
        var _a2, _b;
        (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code));
      }
      // NOTE: `offset` may never run across line boundaries.
      getCurrentLocation(offset) {
        if (!this.options.sourceCodeLocationInfo) {
          return null;
        }
        return {
          startLine: this.preprocessor.line,
          startCol: this.preprocessor.col - offset,
          startOffset: this.preprocessor.offset - offset,
          endLine: -1,
          endCol: -1,
          endOffset: -1
        };
      }
      _runParsingLoop() {
        if (this.inLoop)
          return;
        this.inLoop = true;
        while (this.active && !this.paused) {
          this.consumedAfterSnapshot = 0;
          const cp = this._consume();
          if (!this._ensureHibernation()) {
            this._callState(cp);
          }
        }
        this.inLoop = false;
      }
      //API
      pause() {
        this.paused = true;
      }
      resume(writeCallback) {
        if (!this.paused) {
          throw new Error("Parser was already resumed");
        }
        this.paused = false;
        if (this.inLoop)
          return;
        this._runParsingLoop();
        if (!this.paused) {
          writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
        }
      }
      write(chunk, isLastChunk, writeCallback) {
        this.active = true;
        this.preprocessor.write(chunk, isLastChunk);
        this._runParsingLoop();
        if (!this.paused) {
          writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
        }
      }
      insertHtmlAtCurrentPos(chunk) {
        this.active = true;
        this.preprocessor.insertHtmlAtCurrentPos(chunk);
        this._runParsingLoop();
      }
      //Hibernation
      _ensureHibernation() {
        if (this.preprocessor.endOfChunkHit) {
          this._unconsume(this.consumedAfterSnapshot);
          this.active = false;
          return true;
        }
        return false;
      }
      //Consumption
      _consume() {
        this.consumedAfterSnapshot++;
        return this.preprocessor.advance();
      }
      _unconsume(count) {
        this.consumedAfterSnapshot -= count;
        this.preprocessor.retreat(count);
      }
      _reconsumeInState(state, cp) {
        this.state = state;
        this._callState(cp);
      }
      _advanceBy(count) {
        this.consumedAfterSnapshot += count;
        for (let i = 0; i < count; i++) {
          this.preprocessor.advance();
        }
      }
      _consumeSequenceIfMatch(pattern, caseSensitive) {
        if (this.preprocessor.startsWith(pattern, caseSensitive)) {
          this._advanceBy(pattern.length - 1);
          return true;
        }
        return false;
      }
      //Token creation
      _createStartTagToken() {
        this.currentToken = {
          type: token_js_1.TokenType.START_TAG,
          tagName: "",
          tagID: html_js_1.TAG_ID.UNKNOWN,
          selfClosing: false,
          ackSelfClosing: false,
          attrs: [],
          location: this.getCurrentLocation(1)
        };
      }
      _createEndTagToken() {
        this.currentToken = {
          type: token_js_1.TokenType.END_TAG,
          tagName: "",
          tagID: html_js_1.TAG_ID.UNKNOWN,
          selfClosing: false,
          ackSelfClosing: false,
          attrs: [],
          location: this.getCurrentLocation(2)
        };
      }
      _createCommentToken(offset) {
        this.currentToken = {
          type: token_js_1.TokenType.COMMENT,
          data: "",
          location: this.getCurrentLocation(offset)
        };
      }
      _createDoctypeToken(initialName) {
        this.currentToken = {
          type: token_js_1.TokenType.DOCTYPE,
          name: initialName,
          forceQuirks: false,
          publicId: null,
          systemId: null,
          location: this.currentLocation
        };
      }
      _createCharacterToken(type3, chars) {
        this.currentCharacterToken = {
          type: type3,
          chars,
          location: this.currentLocation
        };
      }
      //Tag attributes
      _createAttr(attrNameFirstCh) {
        this.currentAttr = {
          name: attrNameFirstCh,
          value: ""
        };
        this.currentLocation = this.getCurrentLocation(0);
      }
      _leaveAttrName() {
        var _a2;
        var _b;
        const token = this.currentToken;
        if ((0, token_js_1.getTokenAttr)(token, this.currentAttr.name) === null) {
          token.attrs.push(this.currentAttr);
          if (token.location && this.currentLocation) {
            const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
            attrLocations[this.currentAttr.name] = this.currentLocation;
            this._leaveAttrValue();
          }
        } else {
          this._err(error_codes_js_1.ERR.duplicateAttribute);
        }
      }
      _leaveAttrValue() {
        if (this.currentLocation) {
          this.currentLocation.endLine = this.preprocessor.line;
          this.currentLocation.endCol = this.preprocessor.col;
          this.currentLocation.endOffset = this.preprocessor.offset;
        }
      }
      //Token emission
      prepareToken(ct) {
        this._emitCurrentCharacterToken(ct.location);
        this.currentToken = null;
        if (ct.location) {
          ct.location.endLine = this.preprocessor.line;
          ct.location.endCol = this.preprocessor.col + 1;
          ct.location.endOffset = this.preprocessor.offset + 1;
        }
        this.currentLocation = this.getCurrentLocation(-1);
      }
      emitCurrentTagToken() {
        const ct = this.currentToken;
        this.prepareToken(ct);
        ct.tagID = (0, html_js_1.getTagID)(ct.tagName);
        if (ct.type === token_js_1.TokenType.START_TAG) {
          this.lastStartTagName = ct.tagName;
          this.handler.onStartTag(ct);
        } else {
          if (ct.attrs.length > 0) {
            this._err(error_codes_js_1.ERR.endTagWithAttributes);
          }
          if (ct.selfClosing) {
            this._err(error_codes_js_1.ERR.endTagWithTrailingSolidus);
          }
          this.handler.onEndTag(ct);
        }
        this.preprocessor.dropParsedChunk();
      }
      emitCurrentComment(ct) {
        this.prepareToken(ct);
        this.handler.onComment(ct);
        this.preprocessor.dropParsedChunk();
      }
      emitCurrentDoctype(ct) {
        this.prepareToken(ct);
        this.handler.onDoctype(ct);
        this.preprocessor.dropParsedChunk();
      }
      _emitCurrentCharacterToken(nextLocation) {
        if (this.currentCharacterToken) {
          if (nextLocation && this.currentCharacterToken.location) {
            this.currentCharacterToken.location.endLine = nextLocation.startLine;
            this.currentCharacterToken.location.endCol = nextLocation.startCol;
            this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
          }
          switch (this.currentCharacterToken.type) {
            case token_js_1.TokenType.CHARACTER: {
              this.handler.onCharacter(this.currentCharacterToken);
              break;
            }
            case token_js_1.TokenType.NULL_CHARACTER: {
              this.handler.onNullCharacter(this.currentCharacterToken);
              break;
            }
            case token_js_1.TokenType.WHITESPACE_CHARACTER: {
              this.handler.onWhitespaceCharacter(this.currentCharacterToken);
              break;
            }
          }
          this.currentCharacterToken = null;
        }
      }
      _emitEOFToken() {
        const location = this.getCurrentLocation(0);
        if (location) {
          location.endLine = location.startLine;
          location.endCol = location.startCol;
          location.endOffset = location.startOffset;
        }
        this._emitCurrentCharacterToken(location);
        this.handler.onEof({ type: token_js_1.TokenType.EOF, location });
        this.active = false;
      }
      //Characters emission
      //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
      //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
      //If we have a sequence of characters that belong to the same group, the parser can process it
      //as a single solid character token.
      //So, there are 3 types of character tokens in parse5:
      //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
      //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
      //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
      _appendCharToCurrentCharacterToken(type3, ch) {
        if (this.currentCharacterToken) {
          if (this.currentCharacterToken.type !== type3) {
            this.currentLocation = this.getCurrentLocation(0);
            this._emitCurrentCharacterToken(this.currentLocation);
            this.preprocessor.dropParsedChunk();
          } else {
            this.currentCharacterToken.chars += ch;
            return;
          }
        }
        this._createCharacterToken(type3, ch);
      }
      _emitCodePoint(cp) {
        const type3 = isWhitespace3(cp) ? token_js_1.TokenType.WHITESPACE_CHARACTER : cp === unicode_js_1.CODE_POINTS.NULL ? token_js_1.TokenType.NULL_CHARACTER : token_js_1.TokenType.CHARACTER;
        this._appendCharToCurrentCharacterToken(type3, String.fromCodePoint(cp));
      }
      //NOTE: used when we emit characters explicitly.
      //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
      _emitChars(ch) {
        this._appendCharToCurrentCharacterToken(token_js_1.TokenType.CHARACTER, ch);
      }
      // Character reference helpers
      _matchNamedCharacterReference(cp) {
        let result = null;
        let excess = 0;
        let withoutSemicolon = false;
        for (let i = 0, current = decode_js_1.htmlDecodeTree[0]; i >= 0; cp = this._consume()) {
          i = (0, decode_js_1.determineBranch)(decode_js_1.htmlDecodeTree, current, i + 1, cp);
          if (i < 0)
            break;
          excess += 1;
          current = decode_js_1.htmlDecodeTree[i];
          const masked = current & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            const valueLength = (masked >> 14) - 1;
            if (cp !== unicode_js_1.CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd3(this.preprocessor.peek(1))) {
              result = [unicode_js_1.CODE_POINTS.AMPERSAND];
              i += valueLength;
            } else {
              result = valueLength === 0 ? [decode_js_1.htmlDecodeTree[i] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_js_1.htmlDecodeTree[++i]] : [decode_js_1.htmlDecodeTree[++i], decode_js_1.htmlDecodeTree[++i]];
              excess = 0;
              withoutSemicolon = cp !== unicode_js_1.CODE_POINTS.SEMICOLON;
            }
            if (valueLength === 0) {
              this._consume();
              break;
            }
          }
        }
        this._unconsume(excess);
        if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
          this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);
        }
        this._unconsume(1);
        return result;
      }
      _isCharacterReferenceInAttribute() {
        return this.returnState === State3.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State3.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State3.ATTRIBUTE_VALUE_UNQUOTED;
      }
      _flushCodePointConsumedAsCharacterReference(cp) {
        if (this._isCharacterReferenceInAttribute()) {
          this.currentAttr.value += String.fromCodePoint(cp);
        } else {
          this._emitCodePoint(cp);
        }
      }
      // Calling states this way turns out to be much faster than any other approach.
      _callState(cp) {
        switch (this.state) {
          case State3.DATA: {
            this._stateData(cp);
            break;
          }
          case State3.RCDATA: {
            this._stateRcdata(cp);
            break;
          }
          case State3.RAWTEXT: {
            this._stateRawtext(cp);
            break;
          }
          case State3.SCRIPT_DATA: {
            this._stateScriptData(cp);
            break;
          }
          case State3.PLAINTEXT: {
            this._statePlaintext(cp);
            break;
          }
          case State3.TAG_OPEN: {
            this._stateTagOpen(cp);
            break;
          }
          case State3.END_TAG_OPEN: {
            this._stateEndTagOpen(cp);
            break;
          }
          case State3.TAG_NAME: {
            this._stateTagName(cp);
            break;
          }
          case State3.RCDATA_LESS_THAN_SIGN: {
            this._stateRcdataLessThanSign(cp);
            break;
          }
          case State3.RCDATA_END_TAG_OPEN: {
            this._stateRcdataEndTagOpen(cp);
            break;
          }
          case State3.RCDATA_END_TAG_NAME: {
            this._stateRcdataEndTagName(cp);
            break;
          }
          case State3.RAWTEXT_LESS_THAN_SIGN: {
            this._stateRawtextLessThanSign(cp);
            break;
          }
          case State3.RAWTEXT_END_TAG_OPEN: {
            this._stateRawtextEndTagOpen(cp);
            break;
          }
          case State3.RAWTEXT_END_TAG_NAME: {
            this._stateRawtextEndTagName(cp);
            break;
          }
          case State3.SCRIPT_DATA_LESS_THAN_SIGN: {
            this._stateScriptDataLessThanSign(cp);
            break;
          }
          case State3.SCRIPT_DATA_END_TAG_OPEN: {
            this._stateScriptDataEndTagOpen(cp);
            break;
          }
          case State3.SCRIPT_DATA_END_TAG_NAME: {
            this._stateScriptDataEndTagName(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPE_START: {
            this._stateScriptDataEscapeStart(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPE_START_DASH: {
            this._stateScriptDataEscapeStartDash(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED: {
            this._stateScriptDataEscaped(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED_DASH: {
            this._stateScriptDataEscapedDash(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED_DASH_DASH: {
            this._stateScriptDataEscapedDashDash(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
            this._stateScriptDataEscapedLessThanSign(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
            this._stateScriptDataEscapedEndTagOpen(cp);
            break;
          }
          case State3.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
            this._stateScriptDataEscapedEndTagName(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
            this._stateScriptDataDoubleEscapeStart(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPED: {
            this._stateScriptDataDoubleEscaped(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
            this._stateScriptDataDoubleEscapedDash(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
            this._stateScriptDataDoubleEscapedDashDash(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
            this._stateScriptDataDoubleEscapedLessThanSign(cp);
            break;
          }
          case State3.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
            this._stateScriptDataDoubleEscapeEnd(cp);
            break;
          }
          case State3.BEFORE_ATTRIBUTE_NAME: {
            this._stateBeforeAttributeName(cp);
            break;
          }
          case State3.ATTRIBUTE_NAME: {
            this._stateAttributeName(cp);
            break;
          }
          case State3.AFTER_ATTRIBUTE_NAME: {
            this._stateAfterAttributeName(cp);
            break;
          }
          case State3.BEFORE_ATTRIBUTE_VALUE: {
            this._stateBeforeAttributeValue(cp);
            break;
          }
          case State3.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
            this._stateAttributeValueDoubleQuoted(cp);
            break;
          }
          case State3.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
            this._stateAttributeValueSingleQuoted(cp);
            break;
          }
          case State3.ATTRIBUTE_VALUE_UNQUOTED: {
            this._stateAttributeValueUnquoted(cp);
            break;
          }
          case State3.AFTER_ATTRIBUTE_VALUE_QUOTED: {
            this._stateAfterAttributeValueQuoted(cp);
            break;
          }
          case State3.SELF_CLOSING_START_TAG: {
            this._stateSelfClosingStartTag(cp);
            break;
          }
          case State3.BOGUS_COMMENT: {
            this._stateBogusComment(cp);
            break;
          }
          case State3.MARKUP_DECLARATION_OPEN: {
            this._stateMarkupDeclarationOpen(cp);
            break;
          }
          case State3.COMMENT_START: {
            this._stateCommentStart(cp);
            break;
          }
          case State3.COMMENT_START_DASH: {
            this._stateCommentStartDash(cp);
            break;
          }
          case State3.COMMENT: {
            this._stateComment(cp);
            break;
          }
          case State3.COMMENT_LESS_THAN_SIGN: {
            this._stateCommentLessThanSign(cp);
            break;
          }
          case State3.COMMENT_LESS_THAN_SIGN_BANG: {
            this._stateCommentLessThanSignBang(cp);
            break;
          }
          case State3.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
            this._stateCommentLessThanSignBangDash(cp);
            break;
          }
          case State3.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
            this._stateCommentLessThanSignBangDashDash(cp);
            break;
          }
          case State3.COMMENT_END_DASH: {
            this._stateCommentEndDash(cp);
            break;
          }
          case State3.COMMENT_END: {
            this._stateCommentEnd(cp);
            break;
          }
          case State3.COMMENT_END_BANG: {
            this._stateCommentEndBang(cp);
            break;
          }
          case State3.DOCTYPE: {
            this._stateDoctype(cp);
            break;
          }
          case State3.BEFORE_DOCTYPE_NAME: {
            this._stateBeforeDoctypeName(cp);
            break;
          }
          case State3.DOCTYPE_NAME: {
            this._stateDoctypeName(cp);
            break;
          }
          case State3.AFTER_DOCTYPE_NAME: {
            this._stateAfterDoctypeName(cp);
            break;
          }
          case State3.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
            this._stateAfterDoctypePublicKeyword(cp);
            break;
          }
          case State3.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
            this._stateBeforeDoctypePublicIdentifier(cp);
            break;
          }
          case State3.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
            this._stateDoctypePublicIdentifierDoubleQuoted(cp);
            break;
          }
          case State3.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
            this._stateDoctypePublicIdentifierSingleQuoted(cp);
            break;
          }
          case State3.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
            this._stateAfterDoctypePublicIdentifier(cp);
            break;
          }
          case State3.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
            this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
            break;
          }
          case State3.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
            this._stateAfterDoctypeSystemKeyword(cp);
            break;
          }
          case State3.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
            this._stateBeforeDoctypeSystemIdentifier(cp);
            break;
          }
          case State3.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
            this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
            break;
          }
          case State3.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
            this._stateDoctypeSystemIdentifierSingleQuoted(cp);
            break;
          }
          case State3.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
            this._stateAfterDoctypeSystemIdentifier(cp);
            break;
          }
          case State3.BOGUS_DOCTYPE: {
            this._stateBogusDoctype(cp);
            break;
          }
          case State3.CDATA_SECTION: {
            this._stateCdataSection(cp);
            break;
          }
          case State3.CDATA_SECTION_BRACKET: {
            this._stateCdataSectionBracket(cp);
            break;
          }
          case State3.CDATA_SECTION_END: {
            this._stateCdataSectionEnd(cp);
            break;
          }
          case State3.CHARACTER_REFERENCE: {
            this._stateCharacterReference(cp);
            break;
          }
          case State3.NAMED_CHARACTER_REFERENCE: {
            this._stateNamedCharacterReference(cp);
            break;
          }
          case State3.AMBIGUOUS_AMPERSAND: {
            this._stateAmbiguousAmpersand(cp);
            break;
          }
          case State3.NUMERIC_CHARACTER_REFERENCE: {
            this._stateNumericCharacterReference(cp);
            break;
          }
          case State3.HEXADEMICAL_CHARACTER_REFERENCE_START: {
            this._stateHexademicalCharacterReferenceStart(cp);
            break;
          }
          case State3.HEXADEMICAL_CHARACTER_REFERENCE: {
            this._stateHexademicalCharacterReference(cp);
            break;
          }
          case State3.DECIMAL_CHARACTER_REFERENCE: {
            this._stateDecimalCharacterReference(cp);
            break;
          }
          case State3.NUMERIC_CHARACTER_REFERENCE_END: {
            this._stateNumericCharacterReferenceEnd(cp);
            break;
          }
          default: {
            throw new Error("Unknown state");
          }
        }
      }
      // State machine
      // Data state
      //------------------------------------------------------------------
      _stateData(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.TAG_OPEN;
            break;
          }
          case unicode_js_1.CODE_POINTS.AMPERSAND: {
            this.returnState = State3.DATA;
            this.state = State3.CHARACTER_REFERENCE;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitCodePoint(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      //  RCDATA state
      //------------------------------------------------------------------
      _stateRcdata(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.AMPERSAND: {
            this.returnState = State3.RCDATA;
            this.state = State3.CHARACTER_REFERENCE;
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.RCDATA_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // RAWTEXT state
      //------------------------------------------------------------------
      _stateRawtext(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.RAWTEXT_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data state
      //------------------------------------------------------------------
      _stateScriptData(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // PLAINTEXT state
      //------------------------------------------------------------------
      _statePlaintext(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // Tag open state
      //------------------------------------------------------------------
      _stateTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this._createStartTagToken();
          this.state = State3.TAG_NAME;
          this._stateTagName(cp);
        } else
          switch (cp) {
            case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
              this.state = State3.MARKUP_DECLARATION_OPEN;
              break;
            }
            case unicode_js_1.CODE_POINTS.SOLIDUS: {
              this.state = State3.END_TAG_OPEN;
              break;
            }
            case unicode_js_1.CODE_POINTS.QUESTION_MARK: {
              this._err(error_codes_js_1.ERR.unexpectedQuestionMarkInsteadOfTagName);
              this._createCommentToken(1);
              this.state = State3.BOGUS_COMMENT;
              this._stateBogusComment(cp);
              break;
            }
            case unicode_js_1.CODE_POINTS.EOF: {
              this._err(error_codes_js_1.ERR.eofBeforeTagName);
              this._emitChars("<");
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
              this._emitChars("<");
              this.state = State3.DATA;
              this._stateData(cp);
            }
          }
      }
      // End tag open state
      //------------------------------------------------------------------
      _stateEndTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this._createEndTagToken();
          this.state = State3.TAG_NAME;
          this._stateTagName(cp);
        } else
          switch (cp) {
            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(error_codes_js_1.ERR.missingEndTagName);
              this.state = State3.DATA;
              break;
            }
            case unicode_js_1.CODE_POINTS.EOF: {
              this._err(error_codes_js_1.ERR.eofBeforeTagName);
              this._emitChars("</");
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
              this._createCommentToken(2);
              this.state = State3.BOGUS_COMMENT;
              this._stateBogusComment(cp);
            }
          }
      }
      // Tag name state
      //------------------------------------------------------------------
      _stateTagName(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            break;
          }
          case unicode_js_1.CODE_POINTS.SOLIDUS: {
            this.state = State3.SELF_CLOSING_START_TAG;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.tagName += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            token.tagName += String.fromCodePoint(isAsciiUpper2(cp) ? toAsciiLower2(cp) : cp);
          }
        }
      }
      // RCDATA less-than sign state
      //------------------------------------------------------------------
      _stateRcdataLessThanSign(cp) {
        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
          this.state = State3.RCDATA_END_TAG_OPEN;
        } else {
          this._emitChars("<");
          this.state = State3.RCDATA;
          this._stateRcdata(cp);
        }
      }
      // RCDATA end tag open state
      //------------------------------------------------------------------
      _stateRcdataEndTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this.state = State3.RCDATA_END_TAG_NAME;
          this._stateRcdataEndTagName(cp);
        } else {
          this._emitChars("</");
          this.state = State3.RCDATA;
          this._stateRcdata(cp);
        }
      }
      handleSpecialEndTag(_cp) {
        if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
          return !this._ensureHibernation();
        }
        this._createEndTagToken();
        const token = this.currentToken;
        token.tagName = this.lastStartTagName;
        const cp = this.preprocessor.peek(this.lastStartTagName.length);
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this._advanceBy(this.lastStartTagName.length);
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            return false;
          }
          case unicode_js_1.CODE_POINTS.SOLIDUS: {
            this._advanceBy(this.lastStartTagName.length);
            this.state = State3.SELF_CLOSING_START_TAG;
            return false;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._advanceBy(this.lastStartTagName.length);
            this.emitCurrentTagToken();
            this.state = State3.DATA;
            return false;
          }
          default: {
            return !this._ensureHibernation();
          }
        }
      }
      // RCDATA end tag name state
      //------------------------------------------------------------------
      _stateRcdataEndTagName(cp) {
        if (this.handleSpecialEndTag(cp)) {
          this._emitChars("</");
          this.state = State3.RCDATA;
          this._stateRcdata(cp);
        }
      }
      // RAWTEXT less-than sign state
      //------------------------------------------------------------------
      _stateRawtextLessThanSign(cp) {
        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
          this.state = State3.RAWTEXT_END_TAG_OPEN;
        } else {
          this._emitChars("<");
          this.state = State3.RAWTEXT;
          this._stateRawtext(cp);
        }
      }
      // RAWTEXT end tag open state
      //------------------------------------------------------------------
      _stateRawtextEndTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this.state = State3.RAWTEXT_END_TAG_NAME;
          this._stateRawtextEndTagName(cp);
        } else {
          this._emitChars("</");
          this.state = State3.RAWTEXT;
          this._stateRawtext(cp);
        }
      }
      // RAWTEXT end tag name state
      //------------------------------------------------------------------
      _stateRawtextEndTagName(cp) {
        if (this.handleSpecialEndTag(cp)) {
          this._emitChars("</");
          this.state = State3.RAWTEXT;
          this._stateRawtext(cp);
        }
      }
      // Script data less-than sign state
      //------------------------------------------------------------------
      _stateScriptDataLessThanSign(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SOLIDUS: {
            this.state = State3.SCRIPT_DATA_END_TAG_OPEN;
            break;
          }
          case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
            this.state = State3.SCRIPT_DATA_ESCAPE_START;
            this._emitChars("<!");
            break;
          }
          default: {
            this._emitChars("<");
            this.state = State3.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
      }
      // Script data end tag open state
      //------------------------------------------------------------------
      _stateScriptDataEndTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this.state = State3.SCRIPT_DATA_END_TAG_NAME;
          this._stateScriptDataEndTagName(cp);
        } else {
          this._emitChars("</");
          this.state = State3.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
      }
      // Script data end tag name state
      //------------------------------------------------------------------
      _stateScriptDataEndTagName(cp) {
        if (this.handleSpecialEndTag(cp)) {
          this._emitChars("</");
          this.state = State3.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
      }
      // Script data escape start state
      //------------------------------------------------------------------
      _stateScriptDataEscapeStart(cp) {
        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
          this.state = State3.SCRIPT_DATA_ESCAPE_START_DASH;
          this._emitChars("-");
        } else {
          this.state = State3.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
      }
      // Script data escape start dash state
      //------------------------------------------------------------------
      _stateScriptDataEscapeStartDash(cp) {
        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
          this.state = State3.SCRIPT_DATA_ESCAPED_DASH_DASH;
          this._emitChars("-");
        } else {
          this.state = State3.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
      }
      // Script data escaped state
      //------------------------------------------------------------------
      _stateScriptDataEscaped(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.SCRIPT_DATA_ESCAPED_DASH;
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data escaped dash state
      //------------------------------------------------------------------
      _stateScriptDataEscapedDash(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.SCRIPT_DATA_ESCAPED_DASH_DASH;
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.state = State3.SCRIPT_DATA_ESCAPED;
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this.state = State3.SCRIPT_DATA_ESCAPED;
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data escaped dash dash state
      //------------------------------------------------------------------
      _stateScriptDataEscapedDashDash(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA;
            this._emitChars(">");
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.state = State3.SCRIPT_DATA_ESCAPED;
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this.state = State3.SCRIPT_DATA_ESCAPED;
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data escaped less-than sign state
      //------------------------------------------------------------------
      _stateScriptDataEscapedLessThanSign(cp) {
        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
          this.state = State3.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
        } else if (isAsciiLetter2(cp)) {
          this._emitChars("<");
          this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPE_START;
          this._stateScriptDataDoubleEscapeStart(cp);
        } else {
          this._emitChars("<");
          this.state = State3.SCRIPT_DATA_ESCAPED;
          this._stateScriptDataEscaped(cp);
        }
      }
      // Script data escaped end tag open state
      //------------------------------------------------------------------
      _stateScriptDataEscapedEndTagOpen(cp) {
        if (isAsciiLetter2(cp)) {
          this.state = State3.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
          this._stateScriptDataEscapedEndTagName(cp);
        } else {
          this._emitChars("</");
          this.state = State3.SCRIPT_DATA_ESCAPED;
          this._stateScriptDataEscaped(cp);
        }
      }
      // Script data escaped end tag name state
      //------------------------------------------------------------------
      _stateScriptDataEscapedEndTagName(cp) {
        if (this.handleSpecialEndTag(cp)) {
          this._emitChars("</");
          this.state = State3.SCRIPT_DATA_ESCAPED;
          this._stateScriptDataEscaped(cp);
        }
      }
      // Script data double escape start state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscapeStart(cp) {
        if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd2(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
          this._emitCodePoint(cp);
          for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
            this._emitCodePoint(this._consume());
          }
          this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
        } else if (!this._ensureHibernation()) {
          this.state = State3.SCRIPT_DATA_ESCAPED;
          this._stateScriptDataEscaped(cp);
        }
      }
      // Script data double escaped state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscaped(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
            this._emitChars("<");
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data double escaped dash state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscapedDash(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
            this._emitChars("<");
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data double escaped dash dash state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscapedDashDash(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this._emitChars("-");
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
            this._emitChars("<");
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.SCRIPT_DATA;
            this._emitChars(">");
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
            break;
          }
          default: {
            this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._emitCodePoint(cp);
          }
        }
      }
      // Script data double escaped less-than sign state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscapedLessThanSign(cp) {
        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
          this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPE_END;
          this._emitChars("/");
        } else {
          this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._stateScriptDataDoubleEscaped(cp);
        }
      }
      // Script data double escape end state
      //------------------------------------------------------------------
      _stateScriptDataDoubleEscapeEnd(cp) {
        if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd2(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
          this._emitCodePoint(cp);
          for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
            this._emitCodePoint(this._consume());
          }
          this.state = State3.SCRIPT_DATA_ESCAPED;
        } else if (!this._ensureHibernation()) {
          this.state = State3.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._stateScriptDataDoubleEscaped(cp);
        }
      }
      // Before attribute name state
      //------------------------------------------------------------------
      _stateBeforeAttributeName(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.SOLIDUS:
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
          case unicode_js_1.CODE_POINTS.EOF: {
            this.state = State3.AFTER_ATTRIBUTE_NAME;
            this._stateAfterAttributeName(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
            this._err(error_codes_js_1.ERR.unexpectedEqualsSignBeforeAttributeName);
            this._createAttr("=");
            this.state = State3.ATTRIBUTE_NAME;
            break;
          }
          default: {
            this._createAttr("");
            this.state = State3.ATTRIBUTE_NAME;
            this._stateAttributeName(cp);
          }
        }
      }
      // Attribute name state
      //------------------------------------------------------------------
      _stateAttributeName(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED:
          case unicode_js_1.CODE_POINTS.SOLIDUS:
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
          case unicode_js_1.CODE_POINTS.EOF: {
            this._leaveAttrName();
            this.state = State3.AFTER_ATTRIBUTE_NAME;
            this._stateAfterAttributeName(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
            this._leaveAttrName();
            this.state = State3.BEFORE_ATTRIBUTE_VALUE;
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
          case unicode_js_1.CODE_POINTS.APOSTROPHE:
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.unexpectedCharacterInAttributeName);
            this.currentAttr.name += String.fromCodePoint(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          default: {
            this.currentAttr.name += String.fromCodePoint(isAsciiUpper2(cp) ? toAsciiLower2(cp) : cp);
          }
        }
      }
      // After attribute name state
      //------------------------------------------------------------------
      _stateAfterAttributeName(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.SOLIDUS: {
            this.state = State3.SELF_CLOSING_START_TAG;
            break;
          }
          case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
            this.state = State3.BEFORE_ATTRIBUTE_VALUE;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this._createAttr("");
            this.state = State3.ATTRIBUTE_NAME;
            this._stateAttributeName(cp);
          }
        }
      }
      // Before attribute value state
      //------------------------------------------------------------------
      _stateBeforeAttributeValue(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this.state = State3.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this.state = State3.ATTRIBUTE_VALUE_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.missingAttributeValue);
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          default: {
            this.state = State3.ATTRIBUTE_VALUE_UNQUOTED;
            this._stateAttributeValueUnquoted(cp);
          }
        }
      }
      // Attribute value (double-quoted) state
      //------------------------------------------------------------------
      _stateAttributeValueDoubleQuoted(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this.state = State3.AFTER_ATTRIBUTE_VALUE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.AMPERSAND: {
            this.returnState = State3.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
            this.state = State3.CHARACTER_REFERENCE;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this.currentAttr.value += String.fromCodePoint(cp);
          }
        }
      }
      // Attribute value (single-quoted) state
      //------------------------------------------------------------------
      _stateAttributeValueSingleQuoted(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this.state = State3.AFTER_ATTRIBUTE_VALUE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.AMPERSAND: {
            this.returnState = State3.ATTRIBUTE_VALUE_SINGLE_QUOTED;
            this.state = State3.CHARACTER_REFERENCE;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this.currentAttr.value += String.fromCodePoint(cp);
          }
        }
      }
      // Attribute value (unquoted) state
      //------------------------------------------------------------------
      _stateAttributeValueUnquoted(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this._leaveAttrValue();
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            break;
          }
          case unicode_js_1.CODE_POINTS.AMPERSAND: {
            this.returnState = State3.ATTRIBUTE_VALUE_UNQUOTED;
            this.state = State3.CHARACTER_REFERENCE;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._leaveAttrValue();
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
          case unicode_js_1.CODE_POINTS.APOSTROPHE:
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
          case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
          case unicode_js_1.CODE_POINTS.GRAVE_ACCENT: {
            this._err(error_codes_js_1.ERR.unexpectedCharacterInUnquotedAttributeValue);
            this.currentAttr.value += String.fromCodePoint(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this.currentAttr.value += String.fromCodePoint(cp);
          }
        }
      }
      // After attribute value (quoted) state
      //------------------------------------------------------------------
      _stateAfterAttributeValueQuoted(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this._leaveAttrValue();
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            break;
          }
          case unicode_js_1.CODE_POINTS.SOLIDUS: {
            this._leaveAttrValue();
            this.state = State3.SELF_CLOSING_START_TAG;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._leaveAttrValue();
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingWhitespaceBetweenAttributes);
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            this._stateBeforeAttributeName(cp);
          }
        }
      }
      // Self-closing start tag state
      //------------------------------------------------------------------
      _stateSelfClosingStartTag(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            const token = this.currentToken;
            token.selfClosing = true;
            this.state = State3.DATA;
            this.emitCurrentTagToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInTag);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.unexpectedSolidusInTag);
            this.state = State3.BEFORE_ATTRIBUTE_NAME;
            this._stateBeforeAttributeName(cp);
          }
        }
      }
      // Bogus comment state
      //------------------------------------------------------------------
      _stateBogusComment(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentComment(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.data += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          default: {
            token.data += String.fromCodePoint(cp);
          }
        }
      }
      // Markup declaration open state
      //------------------------------------------------------------------
      _stateMarkupDeclarationOpen(cp) {
        if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {
          this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);
          this.state = State3.COMMENT_START;
        } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {
          this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);
          this.state = State3.DOCTYPE;
        } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {
          if (this.inForeignNode) {
            this.state = State3.CDATA_SECTION;
          } else {
            this._err(error_codes_js_1.ERR.cdataInHtmlContent);
            this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);
            this.currentToken.data = "[CDATA[";
            this.state = State3.BOGUS_COMMENT;
          }
        } else if (!this._ensureHibernation()) {
          this._err(error_codes_js_1.ERR.incorrectlyOpenedComment);
          this._createCommentToken(2);
          this.state = State3.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
      // Comment start state
      //------------------------------------------------------------------
      _stateCommentStart(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.COMMENT_START_DASH;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
            this.state = State3.DATA;
            const token = this.currentToken;
            this.emitCurrentComment(token);
            break;
          }
          default: {
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // Comment start dash state
      //------------------------------------------------------------------
      _stateCommentStartDash(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.COMMENT_END;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
            this.state = State3.DATA;
            this.emitCurrentComment(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInComment);
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.data += "-";
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // Comment state
      //------------------------------------------------------------------
      _stateComment(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.COMMENT_END_DASH;
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            token.data += "<";
            this.state = State3.COMMENT_LESS_THAN_SIGN;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.data += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInComment);
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.data += String.fromCodePoint(cp);
          }
        }
      }
      // Comment less-than sign state
      //------------------------------------------------------------------
      _stateCommentLessThanSign(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
            token.data += "!";
            this.state = State3.COMMENT_LESS_THAN_SIGN_BANG;
            break;
          }
          case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
            token.data += "<";
            break;
          }
          default: {
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // Comment less-than sign bang state
      //------------------------------------------------------------------
      _stateCommentLessThanSignBang(cp) {
        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
          this.state = State3.COMMENT_LESS_THAN_SIGN_BANG_DASH;
        } else {
          this.state = State3.COMMENT;
          this._stateComment(cp);
        }
      }
      // Comment less-than sign bang dash state
      //------------------------------------------------------------------
      _stateCommentLessThanSignBangDash(cp) {
        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
          this.state = State3.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
        } else {
          this.state = State3.COMMENT_END_DASH;
          this._stateCommentEndDash(cp);
        }
      }
      // Comment less-than sign bang dash dash state
      //------------------------------------------------------------------
      _stateCommentLessThanSignBangDashDash(cp) {
        if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {
          this._err(error_codes_js_1.ERR.nestedComment);
        }
        this.state = State3.COMMENT_END;
        this._stateCommentEnd(cp);
      }
      // Comment end dash state
      //------------------------------------------------------------------
      _stateCommentEndDash(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            this.state = State3.COMMENT_END;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInComment);
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.data += "-";
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // Comment end state
      //------------------------------------------------------------------
      _stateCommentEnd(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentComment(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
            this.state = State3.COMMENT_END_BANG;
            break;
          }
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            token.data += "-";
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInComment);
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.data += "--";
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // Comment end bang state
      //------------------------------------------------------------------
      _stateCommentEndBang(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
            token.data += "--!";
            this.state = State3.COMMENT_END_DASH;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.incorrectlyClosedComment);
            this.state = State3.DATA;
            this.emitCurrentComment(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInComment);
            this.emitCurrentComment(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.data += "--!";
            this.state = State3.COMMENT;
            this._stateComment(cp);
          }
        }
      }
      // DOCTYPE state
      //------------------------------------------------------------------
      _stateDoctype(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.BEFORE_DOCTYPE_NAME;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.BEFORE_DOCTYPE_NAME;
            this._stateBeforeDoctypeName(cp);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            this._createDoctypeToken(null);
            const token = this.currentToken;
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingWhitespaceBeforeDoctypeName);
            this.state = State3.BEFORE_DOCTYPE_NAME;
            this._stateBeforeDoctypeName(cp);
          }
        }
      }
      // Before DOCTYPE name state
      //------------------------------------------------------------------
      _stateBeforeDoctypeName(cp) {
        if (isAsciiUpper2(cp)) {
          this._createDoctypeToken(String.fromCharCode(toAsciiLower2(cp)));
          this.state = State3.DOCTYPE_NAME;
        } else
          switch (cp) {
            case unicode_js_1.CODE_POINTS.SPACE:
            case unicode_js_1.CODE_POINTS.LINE_FEED:
            case unicode_js_1.CODE_POINTS.TABULATION:
            case unicode_js_1.CODE_POINTS.FORM_FEED: {
              break;
            }
            case unicode_js_1.CODE_POINTS.NULL: {
              this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
              this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);
              this.state = State3.DOCTYPE_NAME;
              break;
            }
            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(error_codes_js_1.ERR.missingDoctypeName);
              this._createDoctypeToken(null);
              const token = this.currentToken;
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State3.DATA;
              break;
            }
            case unicode_js_1.CODE_POINTS.EOF: {
              this._err(error_codes_js_1.ERR.eofInDoctype);
              this._createDoctypeToken(null);
              const token = this.currentToken;
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._createDoctypeToken(String.fromCodePoint(cp));
              this.state = State3.DOCTYPE_NAME;
            }
          }
      }
      // DOCTYPE name state
      //------------------------------------------------------------------
      _stateDoctypeName(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.AFTER_DOCTYPE_NAME;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.name += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.name += String.fromCodePoint(isAsciiUpper2(cp) ? toAsciiLower2(cp) : cp);
          }
        }
      }
      // After DOCTYPE name state
      //------------------------------------------------------------------
      _stateAfterDoctypeName(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {
              this.state = State3.AFTER_DOCTYPE_PUBLIC_KEYWORD;
            } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {
              this.state = State3.AFTER_DOCTYPE_SYSTEM_KEYWORD;
            } else if (!this._ensureHibernation()) {
              this._err(error_codes_js_1.ERR.invalidCharacterSequenceAfterDoctypeName);
              token.forceQuirks = true;
              this.state = State3.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
      }
      // After DOCTYPE public keyword state
      //------------------------------------------------------------------
      _stateAfterDoctypePublicKeyword(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
            token.publicId = "";
            this.state = State3.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
            token.publicId = "";
            this.state = State3.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // Before DOCTYPE public identifier state
      //------------------------------------------------------------------
      _stateBeforeDoctypePublicIdentifier(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            token.publicId = "";
            this.state = State3.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            token.publicId = "";
            this.state = State3.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // DOCTYPE public identifier (double-quoted) state
      //------------------------------------------------------------------
      _stateDoctypePublicIdentifierDoubleQuoted(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this.state = State3.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.publicId += String.fromCodePoint(cp);
          }
        }
      }
      // DOCTYPE public identifier (single-quoted) state
      //------------------------------------------------------------------
      _stateDoctypePublicIdentifierSingleQuoted(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this.state = State3.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.publicId += String.fromCodePoint(cp);
          }
        }
      }
      // After DOCTYPE public identifier state
      //------------------------------------------------------------------
      _stateAfterDoctypePublicIdentifier(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // Between DOCTYPE public and system identifiers state
      //------------------------------------------------------------------
      _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // After DOCTYPE system keyword state
      //------------------------------------------------------------------
      _stateAfterDoctypeSystemKeyword(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            this.state = State3.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // Before DOCTYPE system identifier state
      //------------------------------------------------------------------
      _stateBeforeDoctypeSystemIdentifier(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            token.systemId = "";
            this.state = State3.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.DATA;
            this.emitCurrentDoctype(token);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // DOCTYPE system identifier (double-quoted) state
      //------------------------------------------------------------------
      _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
            this.state = State3.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.systemId += String.fromCodePoint(cp);
          }
        }
      }
      // DOCTYPE system identifier (single-quoted) state
      //------------------------------------------------------------------
      _stateDoctypeSystemIdentifierSingleQuoted(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.APOSTROPHE: {
            this.state = State3.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            token.systemId += String.fromCodePoint(cp);
          }
        }
      }
      // After DOCTYPE system identifier state
      //------------------------------------------------------------------
      _stateAfterDoctypeSystemIdentifier(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.SPACE:
          case unicode_js_1.CODE_POINTS.LINE_FEED:
          case unicode_js_1.CODE_POINTS.TABULATION:
          case unicode_js_1.CODE_POINTS.FORM_FEED: {
            break;
          }
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInDoctype);
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(error_codes_js_1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
            this.state = State3.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
      // Bogus DOCTYPE state
      //------------------------------------------------------------------
      _stateBogusDoctype(cp) {
        const token = this.currentToken;
        switch (cp) {
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.emitCurrentDoctype(token);
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.NULL: {
            this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default:
        }
      }
      // CDATA section state
      //------------------------------------------------------------------
      _stateCdataSection(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
            this.state = State3.CDATA_SECTION_BRACKET;
            break;
          }
          case unicode_js_1.CODE_POINTS.EOF: {
            this._err(error_codes_js_1.ERR.eofInCdata);
            this._emitEOFToken();
            break;
          }
          default: {
            this._emitCodePoint(cp);
          }
        }
      }
      // CDATA section bracket state
      //------------------------------------------------------------------
      _stateCdataSectionBracket(cp) {
        if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {
          this.state = State3.CDATA_SECTION_END;
        } else {
          this._emitChars("]");
          this.state = State3.CDATA_SECTION;
          this._stateCdataSection(cp);
        }
      }
      // CDATA section end state
      //------------------------------------------------------------------
      _stateCdataSectionEnd(cp) {
        switch (cp) {
          case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
            this.state = State3.DATA;
            break;
          }
          case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
            this._emitChars("]");
            break;
          }
          default: {
            this._emitChars("]]");
            this.state = State3.CDATA_SECTION;
            this._stateCdataSection(cp);
          }
        }
      }
      // Character reference state
      //------------------------------------------------------------------
      _stateCharacterReference(cp) {
        if (cp === unicode_js_1.CODE_POINTS.NUMBER_SIGN) {
          this.state = State3.NUMERIC_CHARACTER_REFERENCE;
        } else if (isAsciiAlphaNumeric3(cp)) {
          this.state = State3.NAMED_CHARACTER_REFERENCE;
          this._stateNamedCharacterReference(cp);
        } else {
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
          this._reconsumeInState(this.returnState, cp);
        }
      }
      // Named character reference state
      //------------------------------------------------------------------
      _stateNamedCharacterReference(cp) {
        const matchResult = this._matchNamedCharacterReference(cp);
        if (this._ensureHibernation()) {
        } else if (matchResult) {
          for (let i = 0; i < matchResult.length; i++) {
            this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
          }
          this.state = this.returnState;
        } else {
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
          this.state = State3.AMBIGUOUS_AMPERSAND;
        }
      }
      // Ambiguos ampersand state
      //------------------------------------------------------------------
      _stateAmbiguousAmpersand(cp) {
        if (isAsciiAlphaNumeric3(cp)) {
          this._flushCodePointConsumedAsCharacterReference(cp);
        } else {
          if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
            this._err(error_codes_js_1.ERR.unknownNamedCharacterReference);
          }
          this._reconsumeInState(this.returnState, cp);
        }
      }
      // Numeric character reference state
      //------------------------------------------------------------------
      _stateNumericCharacterReference(cp) {
        this.charRefCode = 0;
        if (cp === unicode_js_1.CODE_POINTS.LATIN_SMALL_X || cp === unicode_js_1.CODE_POINTS.LATIN_CAPITAL_X) {
          this.state = State3.HEXADEMICAL_CHARACTER_REFERENCE_START;
        } else if (isAsciiDigit2(cp)) {
          this.state = State3.DECIMAL_CHARACTER_REFERENCE;
          this._stateDecimalCharacterReference(cp);
        } else {
          this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
          this._reconsumeInState(this.returnState, cp);
        }
      }
      // Hexademical character reference start state
      //------------------------------------------------------------------
      _stateHexademicalCharacterReferenceStart(cp) {
        if (isAsciiHexDigit2(cp)) {
          this.state = State3.HEXADEMICAL_CHARACTER_REFERENCE;
          this._stateHexademicalCharacterReference(cp);
        } else {
          this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
          this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
          this._unconsume(2);
          this.state = this.returnState;
        }
      }
      // Hexademical character reference state
      //------------------------------------------------------------------
      _stateHexademicalCharacterReference(cp) {
        if (isAsciiUpperHexDigit2(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 55;
        } else if (isAsciiLowerHexDigit2(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 87;
        } else if (isAsciiDigit2(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 48;
        } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
          this.state = State3.NUMERIC_CHARACTER_REFERENCE_END;
        } else {
          this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);
          this.state = State3.NUMERIC_CHARACTER_REFERENCE_END;
          this._stateNumericCharacterReferenceEnd(cp);
        }
      }
      // Decimal character reference state
      //------------------------------------------------------------------
      _stateDecimalCharacterReference(cp) {
        if (isAsciiDigit2(cp)) {
          this.charRefCode = this.charRefCode * 10 + cp - 48;
        } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
          this.state = State3.NUMERIC_CHARACTER_REFERENCE_END;
        } else {
          this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);
          this.state = State3.NUMERIC_CHARACTER_REFERENCE_END;
          this._stateNumericCharacterReferenceEnd(cp);
        }
      }
      // Numeric character reference end state
      //------------------------------------------------------------------
      _stateNumericCharacterReferenceEnd(cp) {
        if (this.charRefCode === unicode_js_1.CODE_POINTS.NULL) {
          this._err(error_codes_js_1.ERR.nullCharacterReference);
          this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
        } else if (this.charRefCode > 1114111) {
          this._err(error_codes_js_1.ERR.characterReferenceOutsideUnicodeRange);
          this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
        } else if ((0, unicode_js_1.isSurrogate)(this.charRefCode)) {
          this._err(error_codes_js_1.ERR.surrogateCharacterReference);
          this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
        } else if ((0, unicode_js_1.isUndefinedCodePoint)(this.charRefCode)) {
          this._err(error_codes_js_1.ERR.noncharacterCharacterReference);
        } else if ((0, unicode_js_1.isControlCodePoint)(this.charRefCode) || this.charRefCode === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
          this._err(error_codes_js_1.ERR.controlCharacterReference);
          const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS2.get(this.charRefCode);
          if (replacement !== void 0) {
            this.charRefCode = replacement;
          }
        }
        this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
        this._reconsumeInState(this.returnState, cp);
      }
    };
    exports.Tokenizer = Tokenizer3;
  }
});

// node_modules/parse5/dist/cjs/parser/open-element-stack.js
var require_open_element_stack = __commonJS({
  "node_modules/parse5/dist/cjs/parser/open-element-stack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenElementStack = void 0;
    var html_js_1 = require_html();
    var IMPLICIT_END_TAG_REQUIRED2 = /* @__PURE__ */ new Set([html_js_1.TAG_ID.DD, html_js_1.TAG_ID.DT, html_js_1.TAG_ID.LI, html_js_1.TAG_ID.OPTGROUP, html_js_1.TAG_ID.OPTION, html_js_1.TAG_ID.P, html_js_1.TAG_ID.RB, html_js_1.TAG_ID.RP, html_js_1.TAG_ID.RT, html_js_1.TAG_ID.RTC]);
    var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY2 = /* @__PURE__ */ new Set([
      ...IMPLICIT_END_TAG_REQUIRED2,
      html_js_1.TAG_ID.CAPTION,
      html_js_1.TAG_ID.COLGROUP,
      html_js_1.TAG_ID.TBODY,
      html_js_1.TAG_ID.TD,
      html_js_1.TAG_ID.TFOOT,
      html_js_1.TAG_ID.TH,
      html_js_1.TAG_ID.THEAD,
      html_js_1.TAG_ID.TR
    ]);
    var SCOPING_ELEMENT_NS2 = /* @__PURE__ */ new Map([
      [html_js_1.TAG_ID.APPLET, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.CAPTION, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.HTML, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.MARQUEE, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.OBJECT, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.TABLE, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.TD, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.TEMPLATE, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.TH, html_js_1.NS.HTML],
      [html_js_1.TAG_ID.ANNOTATION_XML, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.MI, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.MN, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.MO, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.MS, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.MTEXT, html_js_1.NS.MATHML],
      [html_js_1.TAG_ID.DESC, html_js_1.NS.SVG],
      [html_js_1.TAG_ID.FOREIGN_OBJECT, html_js_1.NS.SVG],
      [html_js_1.TAG_ID.TITLE, html_js_1.NS.SVG]
    ]);
    var NAMED_HEADERS2 = [html_js_1.TAG_ID.H1, html_js_1.TAG_ID.H2, html_js_1.TAG_ID.H3, html_js_1.TAG_ID.H4, html_js_1.TAG_ID.H5, html_js_1.TAG_ID.H6];
    var TABLE_ROW_CONTEXT2 = [html_js_1.TAG_ID.TR, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML];
    var TABLE_BODY_CONTEXT2 = [html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML];
    var TABLE_CONTEXT2 = [html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML];
    var TABLE_CELLS2 = [html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TH];
    var OpenElementStack2 = class {
      get currentTmplContentOrNode() {
        return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
      }
      constructor(document2, treeAdapter, handler) {
        this.treeAdapter = treeAdapter;
        this.handler = handler;
        this.items = [];
        this.tagIDs = [];
        this.stackTop = -1;
        this.tmplCount = 0;
        this.currentTagId = html_js_1.TAG_ID.UNKNOWN;
        this.current = document2;
      }
      //Index of element
      _indexOf(element) {
        return this.items.lastIndexOf(element, this.stackTop);
      }
      //Update current element
      _isInTemplate() {
        return this.currentTagId === html_js_1.TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === html_js_1.NS.HTML;
      }
      _updateCurrentElement() {
        this.current = this.items[this.stackTop];
        this.currentTagId = this.tagIDs[this.stackTop];
      }
      //Mutations
      push(element, tagID) {
        this.stackTop++;
        this.items[this.stackTop] = element;
        this.current = element;
        this.tagIDs[this.stackTop] = tagID;
        this.currentTagId = tagID;
        if (this._isInTemplate()) {
          this.tmplCount++;
        }
        this.handler.onItemPush(element, tagID, true);
      }
      pop() {
        const popped = this.current;
        if (this.tmplCount > 0 && this._isInTemplate()) {
          this.tmplCount--;
        }
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(popped, true);
      }
      replace(oldElement, newElement) {
        const idx = this._indexOf(oldElement);
        this.items[idx] = newElement;
        if (idx === this.stackTop) {
          this.current = newElement;
        }
      }
      insertAfter(referenceElement, newElement, newElementID) {
        const insertionIdx = this._indexOf(referenceElement) + 1;
        this.items.splice(insertionIdx, 0, newElement);
        this.tagIDs.splice(insertionIdx, 0, newElementID);
        this.stackTop++;
        if (insertionIdx === this.stackTop) {
          this._updateCurrentElement();
        }
        this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
      }
      popUntilTagNamePopped(tagName) {
        let targetIdx = this.stackTop + 1;
        do {
          targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
        } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== html_js_1.NS.HTML);
        this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
      }
      shortenToLength(idx) {
        while (this.stackTop >= idx) {
          const popped = this.current;
          if (this.tmplCount > 0 && this._isInTemplate()) {
            this.tmplCount -= 1;
          }
          this.stackTop--;
          this._updateCurrentElement();
          this.handler.onItemPop(popped, this.stackTop < idx);
        }
      }
      popUntilElementPopped(element) {
        const idx = this._indexOf(element);
        this.shortenToLength(idx < 0 ? 0 : idx);
      }
      popUntilPopped(tagNames, targetNS) {
        const idx = this._indexOfTagNames(tagNames, targetNS);
        this.shortenToLength(idx < 0 ? 0 : idx);
      }
      popUntilNumberedHeaderPopped() {
        this.popUntilPopped(NAMED_HEADERS2, html_js_1.NS.HTML);
      }
      popUntilTableCellPopped() {
        this.popUntilPopped(TABLE_CELLS2, html_js_1.NS.HTML);
      }
      popAllUpToHtmlElement() {
        this.tmplCount = 0;
        this.shortenToLength(1);
      }
      _indexOfTagNames(tagNames, namespace) {
        for (let i = this.stackTop; i >= 0; i--) {
          if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
            return i;
          }
        }
        return -1;
      }
      clearBackTo(tagNames, targetNS) {
        const idx = this._indexOfTagNames(tagNames, targetNS);
        this.shortenToLength(idx + 1);
      }
      clearBackToTableContext() {
        this.clearBackTo(TABLE_CONTEXT2, html_js_1.NS.HTML);
      }
      clearBackToTableBodyContext() {
        this.clearBackTo(TABLE_BODY_CONTEXT2, html_js_1.NS.HTML);
      }
      clearBackToTableRowContext() {
        this.clearBackTo(TABLE_ROW_CONTEXT2, html_js_1.NS.HTML);
      }
      remove(element) {
        const idx = this._indexOf(element);
        if (idx >= 0) {
          if (idx === this.stackTop) {
            this.pop();
          } else {
            this.items.splice(idx, 1);
            this.tagIDs.splice(idx, 1);
            this.stackTop--;
            this._updateCurrentElement();
            this.handler.onItemPop(element, false);
          }
        }
      }
      //Search
      tryPeekProperlyNestedBodyElement() {
        return this.stackTop >= 1 && this.tagIDs[1] === html_js_1.TAG_ID.BODY ? this.items[1] : null;
      }
      contains(element) {
        return this._indexOf(element) > -1;
      }
      getCommonAncestor(element) {
        const elementIdx = this._indexOf(element) - 1;
        return elementIdx >= 0 ? this.items[elementIdx] : null;
      }
      isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.tagIDs[0] === html_js_1.TAG_ID.HTML;
      }
      //Element in scope
      hasInScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === html_js_1.NS.HTML) {
            return true;
          }
          if (SCOPING_ELEMENT_NS2.get(tn) === ns) {
            return false;
          }
        }
        return true;
      }
      hasNumberedHeaderInScope() {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if ((0, html_js_1.isNumberedHeader)(tn) && ns === html_js_1.NS.HTML) {
            return true;
          }
          if (SCOPING_ELEMENT_NS2.get(tn) === ns) {
            return false;
          }
        }
        return true;
      }
      hasInListItemScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === html_js_1.NS.HTML) {
            return true;
          }
          if ((tn === html_js_1.TAG_ID.UL || tn === html_js_1.TAG_ID.OL) && ns === html_js_1.NS.HTML || SCOPING_ELEMENT_NS2.get(tn) === ns) {
            return false;
          }
        }
        return true;
      }
      hasInButtonScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === html_js_1.NS.HTML) {
            return true;
          }
          if (tn === html_js_1.TAG_ID.BUTTON && ns === html_js_1.NS.HTML || SCOPING_ELEMENT_NS2.get(tn) === ns) {
            return false;
          }
        }
        return true;
      }
      hasInTableScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== html_js_1.NS.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.TEMPLATE || tn === html_js_1.TAG_ID.HTML) {
            return false;
          }
        }
        return true;
      }
      hasTableBodyContextInTableScope() {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== html_js_1.NS.HTML) {
            continue;
          }
          if (tn === html_js_1.TAG_ID.TBODY || tn === html_js_1.TAG_ID.THEAD || tn === html_js_1.TAG_ID.TFOOT) {
            return true;
          }
          if (tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.HTML) {
            return false;
          }
        }
        return true;
      }
      hasInSelectScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.tagIDs[i];
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== html_js_1.NS.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn !== html_js_1.TAG_ID.OPTION && tn !== html_js_1.TAG_ID.OPTGROUP) {
            return false;
          }
        }
        return true;
      }
      //Implied end tags
      generateImpliedEndTags() {
        while (IMPLICIT_END_TAG_REQUIRED2.has(this.currentTagId)) {
          this.pop();
        }
      }
      generateImpliedEndTagsThoroughly() {
        while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY2.has(this.currentTagId)) {
          this.pop();
        }
      }
      generateImpliedEndTagsWithExclusion(exclusionId) {
        while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY2.has(this.currentTagId)) {
          this.pop();
        }
      }
    };
    exports.OpenElementStack = OpenElementStack2;
  }
});

// node_modules/parse5/dist/cjs/parser/formatting-element-list.js
var require_formatting_element_list = __commonJS({
  "node_modules/parse5/dist/cjs/parser/formatting-element-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormattingElementList = exports.EntryType = void 0;
    var NOAH_ARK_CAPACITY2 = 3;
    var EntryType2;
    (function(EntryType3) {
      EntryType3[EntryType3["Marker"] = 0] = "Marker";
      EntryType3[EntryType3["Element"] = 1] = "Element";
    })(EntryType2 = exports.EntryType || (exports.EntryType = {}));
    var MARKER2 = { type: EntryType2.Marker };
    var FormattingElementList2 = class {
      constructor(treeAdapter) {
        this.treeAdapter = treeAdapter;
        this.entries = [];
        this.bookmark = null;
      }
      //Noah Ark's condition
      //OPTIMIZATION: at first we try to find possible candidates for exclusion using
      //lightweight heuristics without thorough attributes check.
      _getNoahArkConditionCandidates(newElement, neAttrs) {
        const candidates = [];
        const neAttrsLength = neAttrs.length;
        const neTagName = this.treeAdapter.getTagName(newElement);
        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
        for (let i = 0; i < this.entries.length; i++) {
          const entry = this.entries[i];
          if (entry.type === EntryType2.Marker) {
            break;
          }
          const { element } = entry;
          if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
            const elementAttrs = this.treeAdapter.getAttrList(element);
            if (elementAttrs.length === neAttrsLength) {
              candidates.push({ idx: i, attrs: elementAttrs });
            }
          }
        }
        return candidates;
      }
      _ensureNoahArkCondition(newElement) {
        if (this.entries.length < NOAH_ARK_CAPACITY2)
          return;
        const neAttrs = this.treeAdapter.getAttrList(newElement);
        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
        if (candidates.length < NOAH_ARK_CAPACITY2)
          return;
        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
        let validCandidates = 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
            validCandidates += 1;
            if (validCandidates >= NOAH_ARK_CAPACITY2) {
              this.entries.splice(candidate.idx, 1);
            }
          }
        }
      }
      //Mutations
      insertMarker() {
        this.entries.unshift(MARKER2);
      }
      pushElement(element, token) {
        this._ensureNoahArkCondition(element);
        this.entries.unshift({
          type: EntryType2.Element,
          element,
          token
        });
      }
      insertElementAfterBookmark(element, token) {
        const bookmarkIdx = this.entries.indexOf(this.bookmark);
        this.entries.splice(bookmarkIdx, 0, {
          type: EntryType2.Element,
          element,
          token
        });
      }
      removeEntry(entry) {
        const entryIndex = this.entries.indexOf(entry);
        if (entryIndex >= 0) {
          this.entries.splice(entryIndex, 1);
        }
      }
      /**
       * Clears the list of formatting elements up to the last marker.
       *
       * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
       */
      clearToLastMarker() {
        const markerIdx = this.entries.indexOf(MARKER2);
        if (markerIdx >= 0) {
          this.entries.splice(0, markerIdx + 1);
        } else {
          this.entries.length = 0;
        }
      }
      //Search
      getElementEntryInScopeWithTagName(tagName) {
        const entry = this.entries.find((entry2) => entry2.type === EntryType2.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
        return entry && entry.type === EntryType2.Element ? entry : null;
      }
      getElementEntry(element) {
        return this.entries.find((entry) => entry.type === EntryType2.Element && entry.element === element);
      }
    };
    exports.FormattingElementList = FormattingElementList2;
  }
});

// node_modules/parse5/dist/cjs/tree-adapters/default.js
var require_default = __commonJS({
  "node_modules/parse5/dist/cjs/tree-adapters/default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultTreeAdapter = void 0;
    var html_js_1 = require_html();
    function createTextNode3(value2) {
      return {
        nodeName: "#text",
        value: value2,
        parentNode: null
      };
    }
    exports.defaultTreeAdapter = {
      //Node construction
      createDocument() {
        return {
          nodeName: "#document",
          mode: html_js_1.DOCUMENT_MODE.NO_QUIRKS,
          childNodes: []
        };
      },
      createDocumentFragment() {
        return {
          nodeName: "#document-fragment",
          childNodes: []
        };
      },
      createElement(tagName, namespaceURI, attrs) {
        return {
          nodeName: tagName,
          tagName,
          attrs,
          namespaceURI,
          childNodes: [],
          parentNode: null
        };
      },
      createCommentNode(data3) {
        return {
          nodeName: "#comment",
          data: data3,
          parentNode: null
        };
      },
      //Tree mutation
      appendChild(parentNode, newNode) {
        parentNode.childNodes.push(newNode);
        newNode.parentNode = parentNode;
      },
      insertBefore(parentNode, newNode, referenceNode) {
        const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
        parentNode.childNodes.splice(insertionIdx, 0, newNode);
        newNode.parentNode = parentNode;
      },
      setTemplateContent(templateElement, contentElement) {
        templateElement.content = contentElement;
      },
      getTemplateContent(templateElement) {
        return templateElement.content;
      },
      setDocumentType(document2, name, publicId, systemId) {
        const doctypeNode = document2.childNodes.find((node) => node.nodeName === "#documentType");
        if (doctypeNode) {
          doctypeNode.name = name;
          doctypeNode.publicId = publicId;
          doctypeNode.systemId = systemId;
        } else {
          const node = {
            nodeName: "#documentType",
            name,
            publicId,
            systemId,
            parentNode: null
          };
          exports.defaultTreeAdapter.appendChild(document2, node);
        }
      },
      setDocumentMode(document2, mode) {
        document2.mode = mode;
      },
      getDocumentMode(document2) {
        return document2.mode;
      },
      detachNode(node) {
        if (node.parentNode) {
          const idx = node.parentNode.childNodes.indexOf(node);
          node.parentNode.childNodes.splice(idx, 1);
          node.parentNode = null;
        }
      },
      insertText(parentNode, text3) {
        if (parentNode.childNodes.length > 0) {
          const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
          if (exports.defaultTreeAdapter.isTextNode(prevNode)) {
            prevNode.value += text3;
            return;
          }
        }
        exports.defaultTreeAdapter.appendChild(parentNode, createTextNode3(text3));
      },
      insertTextBefore(parentNode, text3, referenceNode) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
        if (prevNode && exports.defaultTreeAdapter.isTextNode(prevNode)) {
          prevNode.value += text3;
        } else {
          exports.defaultTreeAdapter.insertBefore(parentNode, createTextNode3(text3), referenceNode);
        }
      },
      adoptAttributes(recipient, attrs) {
        const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
        for (let j = 0; j < attrs.length; j++) {
          if (!recipientAttrsMap.has(attrs[j].name)) {
            recipient.attrs.push(attrs[j]);
          }
        }
      },
      //Tree traversing
      getFirstChild(node) {
        return node.childNodes[0];
      },
      getChildNodes(node) {
        return node.childNodes;
      },
      getParentNode(node) {
        return node.parentNode;
      },
      getAttrList(element) {
        return element.attrs;
      },
      //Node data
      getTagName(element) {
        return element.tagName;
      },
      getNamespaceURI(element) {
        return element.namespaceURI;
      },
      getTextNodeContent(textNode) {
        return textNode.value;
      },
      getCommentNodeContent(commentNode) {
        return commentNode.data;
      },
      getDocumentTypeNodeName(doctypeNode) {
        return doctypeNode.name;
      },
      getDocumentTypeNodePublicId(doctypeNode) {
        return doctypeNode.publicId;
      },
      getDocumentTypeNodeSystemId(doctypeNode) {
        return doctypeNode.systemId;
      },
      //Node types
      isTextNode(node) {
        return node.nodeName === "#text";
      },
      isCommentNode(node) {
        return node.nodeName === "#comment";
      },
      isDocumentTypeNode(node) {
        return node.nodeName === "#documentType";
      },
      isElementNode(node) {
        return Object.prototype.hasOwnProperty.call(node, "tagName");
      },
      // Source code location
      setNodeSourceCodeLocation(node, location) {
        node.sourceCodeLocation = location;
      },
      getNodeSourceCodeLocation(node) {
        return node.sourceCodeLocation;
      },
      updateNodeSourceCodeLocation(node, endLocation) {
        node.sourceCodeLocation = Object.assign(Object.assign({}, node.sourceCodeLocation), endLocation);
      }
    };
  }
});

// node_modules/parse5/dist/cjs/common/doctype.js
var require_doctype = __commonJS({
  "node_modules/parse5/dist/cjs/common/doctype.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDocumentMode = exports.isConforming = void 0;
    var html_js_1 = require_html();
    var VALID_DOCTYPE_NAME2 = "html";
    var VALID_SYSTEM_ID2 = "about:legacy-compat";
    var QUIRKS_MODE_SYSTEM_ID2 = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
    var QUIRKS_MODE_PUBLIC_ID_PREFIXES2 = [
      "+//silmaril//dtd html pro v0r11 19970101//",
      "-//as//dtd html 3.0 aswedit + extensions//",
      "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
      "-//ietf//dtd html 2.0 level 1//",
      "-//ietf//dtd html 2.0 level 2//",
      "-//ietf//dtd html 2.0 strict level 1//",
      "-//ietf//dtd html 2.0 strict level 2//",
      "-//ietf//dtd html 2.0 strict//",
      "-//ietf//dtd html 2.0//",
      "-//ietf//dtd html 2.1e//",
      "-//ietf//dtd html 3.0//",
      "-//ietf//dtd html 3.2 final//",
      "-//ietf//dtd html 3.2//",
      "-//ietf//dtd html 3//",
      "-//ietf//dtd html level 0//",
      "-//ietf//dtd html level 1//",
      "-//ietf//dtd html level 2//",
      "-//ietf//dtd html level 3//",
      "-//ietf//dtd html strict level 0//",
      "-//ietf//dtd html strict level 1//",
      "-//ietf//dtd html strict level 2//",
      "-//ietf//dtd html strict level 3//",
      "-//ietf//dtd html strict//",
      "-//ietf//dtd html//",
      "-//metrius//dtd metrius presentational//",
      "-//microsoft//dtd internet explorer 2.0 html strict//",
      "-//microsoft//dtd internet explorer 2.0 html//",
      "-//microsoft//dtd internet explorer 2.0 tables//",
      "-//microsoft//dtd internet explorer 3.0 html strict//",
      "-//microsoft//dtd internet explorer 3.0 html//",
      "-//microsoft//dtd internet explorer 3.0 tables//",
      "-//netscape comm. corp.//dtd html//",
      "-//netscape comm. corp.//dtd strict html//",
      "-//o'reilly and associates//dtd html 2.0//",
      "-//o'reilly and associates//dtd html extended 1.0//",
      "-//o'reilly and associates//dtd html extended relaxed 1.0//",
      "-//sq//dtd html 2.0 hotmetal + extensions//",
      "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
      "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
      "-//spyglass//dtd html 2.0 extended//",
      "-//sun microsystems corp.//dtd hotjava html//",
      "-//sun microsystems corp.//dtd hotjava strict html//",
      "-//w3c//dtd html 3 1995-03-24//",
      "-//w3c//dtd html 3.2 draft//",
      "-//w3c//dtd html 3.2 final//",
      "-//w3c//dtd html 3.2//",
      "-//w3c//dtd html 3.2s draft//",
      "-//w3c//dtd html 4.0 frameset//",
      "-//w3c//dtd html 4.0 transitional//",
      "-//w3c//dtd html experimental 19960712//",
      "-//w3c//dtd html experimental 970421//",
      "-//w3c//dtd w3 html//",
      "-//w3o//dtd w3 html 3.0//",
      "-//webtechs//dtd mozilla html 2.0//",
      "-//webtechs//dtd mozilla html//"
    ];
    var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES2 = [
      ...QUIRKS_MODE_PUBLIC_ID_PREFIXES2,
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ];
    var QUIRKS_MODE_PUBLIC_IDS2 = /* @__PURE__ */ new Set([
      "-//w3o//dtd w3 html strict 3.0//en//",
      "-/w3c/dtd html 4.0 transitional/en",
      "html"
    ]);
    var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES2 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
    var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES2 = [
      ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES2,
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ];
    function hasPrefix2(publicId, prefixes) {
      return prefixes.some((prefix) => publicId.startsWith(prefix));
    }
    function isConforming2(token) {
      return token.name === VALID_DOCTYPE_NAME2 && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID2);
    }
    exports.isConforming = isConforming2;
    function getDocumentMode2(token) {
      if (token.name !== VALID_DOCTYPE_NAME2) {
        return html_js_1.DOCUMENT_MODE.QUIRKS;
      }
      const { systemId } = token;
      if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID2) {
        return html_js_1.DOCUMENT_MODE.QUIRKS;
      }
      let { publicId } = token;
      if (publicId !== null) {
        publicId = publicId.toLowerCase();
        if (QUIRKS_MODE_PUBLIC_IDS2.has(publicId)) {
          return html_js_1.DOCUMENT_MODE.QUIRKS;
        }
        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES2 : QUIRKS_MODE_PUBLIC_ID_PREFIXES2;
        if (hasPrefix2(publicId, prefixes)) {
          return html_js_1.DOCUMENT_MODE.QUIRKS;
        }
        prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES2 : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES2;
        if (hasPrefix2(publicId, prefixes)) {
          return html_js_1.DOCUMENT_MODE.LIMITED_QUIRKS;
        }
      }
      return html_js_1.DOCUMENT_MODE.NO_QUIRKS;
    }
    exports.getDocumentMode = getDocumentMode2;
  }
});

// node_modules/parse5/dist/cjs/common/foreign-content.js
var require_foreign_content = __commonJS({
  "node_modules/parse5/dist/cjs/common/foreign-content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIntegrationPoint = exports.adjustTokenSVGTagName = exports.adjustTokenXMLAttrs = exports.adjustTokenSVGAttrs = exports.adjustTokenMathMLAttrs = exports.causesExit = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = void 0;
    var html_js_1 = require_html();
    var MIME_TYPES2 = {
      TEXT_HTML: "text/html",
      APPLICATION_XML: "application/xhtml+xml"
    };
    var DEFINITION_URL_ATTR2 = "definitionurl";
    var ADJUSTED_DEFINITION_URL_ATTR2 = "definitionURL";
    var SVG_ATTRS_ADJUSTMENT_MAP2 = new Map([
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map((attr2) => [attr2.toLowerCase(), attr2]));
    var XML_ATTRS_ADJUSTMENT_MAP2 = /* @__PURE__ */ new Map([
      ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: html_js_1.NS.XLINK }],
      ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: html_js_1.NS.XLINK }],
      ["xlink:href", { prefix: "xlink", name: "href", namespace: html_js_1.NS.XLINK }],
      ["xlink:role", { prefix: "xlink", name: "role", namespace: html_js_1.NS.XLINK }],
      ["xlink:show", { prefix: "xlink", name: "show", namespace: html_js_1.NS.XLINK }],
      ["xlink:title", { prefix: "xlink", name: "title", namespace: html_js_1.NS.XLINK }],
      ["xlink:type", { prefix: "xlink", name: "type", namespace: html_js_1.NS.XLINK }],
      ["xml:base", { prefix: "xml", name: "base", namespace: html_js_1.NS.XML }],
      ["xml:lang", { prefix: "xml", name: "lang", namespace: html_js_1.NS.XML }],
      ["xml:space", { prefix: "xml", name: "space", namespace: html_js_1.NS.XML }],
      ["xmlns", { prefix: "", name: "xmlns", namespace: html_js_1.NS.XMLNS }],
      ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: html_js_1.NS.XMLNS }]
    ]);
    exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map((tn) => [tn.toLowerCase(), tn]));
    var EXITS_FOREIGN_CONTENT2 = /* @__PURE__ */ new Set([
      html_js_1.TAG_ID.B,
      html_js_1.TAG_ID.BIG,
      html_js_1.TAG_ID.BLOCKQUOTE,
      html_js_1.TAG_ID.BODY,
      html_js_1.TAG_ID.BR,
      html_js_1.TAG_ID.CENTER,
      html_js_1.TAG_ID.CODE,
      html_js_1.TAG_ID.DD,
      html_js_1.TAG_ID.DIV,
      html_js_1.TAG_ID.DL,
      html_js_1.TAG_ID.DT,
      html_js_1.TAG_ID.EM,
      html_js_1.TAG_ID.EMBED,
      html_js_1.TAG_ID.H1,
      html_js_1.TAG_ID.H2,
      html_js_1.TAG_ID.H3,
      html_js_1.TAG_ID.H4,
      html_js_1.TAG_ID.H5,
      html_js_1.TAG_ID.H6,
      html_js_1.TAG_ID.HEAD,
      html_js_1.TAG_ID.HR,
      html_js_1.TAG_ID.I,
      html_js_1.TAG_ID.IMG,
      html_js_1.TAG_ID.LI,
      html_js_1.TAG_ID.LISTING,
      html_js_1.TAG_ID.MENU,
      html_js_1.TAG_ID.META,
      html_js_1.TAG_ID.NOBR,
      html_js_1.TAG_ID.OL,
      html_js_1.TAG_ID.P,
      html_js_1.TAG_ID.PRE,
      html_js_1.TAG_ID.RUBY,
      html_js_1.TAG_ID.S,
      html_js_1.TAG_ID.SMALL,
      html_js_1.TAG_ID.SPAN,
      html_js_1.TAG_ID.STRONG,
      html_js_1.TAG_ID.STRIKE,
      html_js_1.TAG_ID.SUB,
      html_js_1.TAG_ID.SUP,
      html_js_1.TAG_ID.TABLE,
      html_js_1.TAG_ID.TT,
      html_js_1.TAG_ID.U,
      html_js_1.TAG_ID.UL,
      html_js_1.TAG_ID.VAR
    ]);
    function causesExit2(startTagToken) {
      const tn = startTagToken.tagID;
      const isFontWithAttrs = tn === html_js_1.TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === html_js_1.ATTRS.COLOR || name === html_js_1.ATTRS.SIZE || name === html_js_1.ATTRS.FACE);
      return isFontWithAttrs || EXITS_FOREIGN_CONTENT2.has(tn);
    }
    exports.causesExit = causesExit2;
    function adjustTokenMathMLAttrs2(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR2) {
          token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR2;
          break;
        }
      }
    }
    exports.adjustTokenMathMLAttrs = adjustTokenMathMLAttrs2;
    function adjustTokenSVGAttrs2(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP2.get(token.attrs[i].name);
        if (adjustedAttrName != null) {
          token.attrs[i].name = adjustedAttrName;
        }
      }
    }
    exports.adjustTokenSVGAttrs = adjustTokenSVGAttrs2;
    function adjustTokenXMLAttrs2(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP2.get(token.attrs[i].name);
        if (adjustedAttrEntry) {
          token.attrs[i].prefix = adjustedAttrEntry.prefix;
          token.attrs[i].name = adjustedAttrEntry.name;
          token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
      }
    }
    exports.adjustTokenXMLAttrs = adjustTokenXMLAttrs2;
    function adjustTokenSVGTagName2(token) {
      const adjustedTagName = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
      if (adjustedTagName != null) {
        token.tagName = adjustedTagName;
        token.tagID = (0, html_js_1.getTagID)(token.tagName);
      }
    }
    exports.adjustTokenSVGTagName = adjustTokenSVGTagName2;
    function isMathMLTextIntegrationPoint2(tn, ns) {
      return ns === html_js_1.NS.MATHML && (tn === html_js_1.TAG_ID.MI || tn === html_js_1.TAG_ID.MO || tn === html_js_1.TAG_ID.MN || tn === html_js_1.TAG_ID.MS || tn === html_js_1.TAG_ID.MTEXT);
    }
    function isHtmlIntegrationPoint2(tn, ns, attrs) {
      if (ns === html_js_1.NS.MATHML && tn === html_js_1.TAG_ID.ANNOTATION_XML) {
        for (let i = 0; i < attrs.length; i++) {
          if (attrs[i].name === html_js_1.ATTRS.ENCODING) {
            const value2 = attrs[i].value.toLowerCase();
            return value2 === MIME_TYPES2.TEXT_HTML || value2 === MIME_TYPES2.APPLICATION_XML;
          }
        }
      }
      return ns === html_js_1.NS.SVG && (tn === html_js_1.TAG_ID.FOREIGN_OBJECT || tn === html_js_1.TAG_ID.DESC || tn === html_js_1.TAG_ID.TITLE);
    }
    function isIntegrationPoint2(tn, ns, attrs, foreignNS) {
      return (!foreignNS || foreignNS === html_js_1.NS.HTML) && isHtmlIntegrationPoint2(tn, ns, attrs) || (!foreignNS || foreignNS === html_js_1.NS.MATHML) && isMathMLTextIntegrationPoint2(tn, ns);
    }
    exports.isIntegrationPoint = isIntegrationPoint2;
  }
});

// node_modules/parse5/dist/cjs/parser/index.js
var require_parser2 = __commonJS({
  "node_modules/parse5/dist/cjs/parser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var index_js_1 = require_tokenizer();
    var open_element_stack_js_1 = require_open_element_stack();
    var formatting_element_list_js_1 = require_formatting_element_list();
    var default_js_1 = require_default();
    var doctype = require_doctype();
    var foreignContent = require_foreign_content();
    var error_codes_js_1 = require_error_codes();
    var unicode = require_unicode();
    var html_js_1 = require_html();
    var token_js_1 = require_token();
    var HIDDEN_INPUT_TYPE2 = "hidden";
    var AA_OUTER_LOOP_ITER2 = 8;
    var AA_INNER_LOOP_ITER2 = 3;
    var InsertionMode2;
    (function(InsertionMode3) {
      InsertionMode3[InsertionMode3["INITIAL"] = 0] = "INITIAL";
      InsertionMode3[InsertionMode3["BEFORE_HTML"] = 1] = "BEFORE_HTML";
      InsertionMode3[InsertionMode3["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
      InsertionMode3[InsertionMode3["IN_HEAD"] = 3] = "IN_HEAD";
      InsertionMode3[InsertionMode3["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
      InsertionMode3[InsertionMode3["AFTER_HEAD"] = 5] = "AFTER_HEAD";
      InsertionMode3[InsertionMode3["IN_BODY"] = 6] = "IN_BODY";
      InsertionMode3[InsertionMode3["TEXT"] = 7] = "TEXT";
      InsertionMode3[InsertionMode3["IN_TABLE"] = 8] = "IN_TABLE";
      InsertionMode3[InsertionMode3["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
      InsertionMode3[InsertionMode3["IN_CAPTION"] = 10] = "IN_CAPTION";
      InsertionMode3[InsertionMode3["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
      InsertionMode3[InsertionMode3["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
      InsertionMode3[InsertionMode3["IN_ROW"] = 13] = "IN_ROW";
      InsertionMode3[InsertionMode3["IN_CELL"] = 14] = "IN_CELL";
      InsertionMode3[InsertionMode3["IN_SELECT"] = 15] = "IN_SELECT";
      InsertionMode3[InsertionMode3["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
      InsertionMode3[InsertionMode3["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
      InsertionMode3[InsertionMode3["AFTER_BODY"] = 18] = "AFTER_BODY";
      InsertionMode3[InsertionMode3["IN_FRAMESET"] = 19] = "IN_FRAMESET";
      InsertionMode3[InsertionMode3["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
      InsertionMode3[InsertionMode3["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
      InsertionMode3[InsertionMode3["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
    })(InsertionMode2 || (InsertionMode2 = {}));
    var BASE_LOC2 = {
      startLine: -1,
      startCol: -1,
      startOffset: -1,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    var TABLE_STRUCTURE_TAGS2 = /* @__PURE__ */ new Set([html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
    var defaultParserOptions2 = {
      scriptingEnabled: true,
      sourceCodeLocationInfo: false,
      treeAdapter: default_js_1.defaultTreeAdapter,
      onParseError: null
    };
    var Parser3 = class {
      constructor(options, document2, fragmentContext = null, scriptHandler = null) {
        this.fragmentContext = fragmentContext;
        this.scriptHandler = scriptHandler;
        this.currentToken = null;
        this.stopped = false;
        this.insertionMode = InsertionMode2.INITIAL;
        this.originalInsertionMode = InsertionMode2.INITIAL;
        this.headElement = null;
        this.formElement = null;
        this.currentNotInHTML = false;
        this.tmplInsertionModeStack = [];
        this.pendingCharacterTokens = [];
        this.hasNonWhitespacePendingCharacterToken = false;
        this.framesetOk = true;
        this.skipNextNewLine = false;
        this.fosterParentingEnabled = false;
        this.options = Object.assign(Object.assign({}, defaultParserOptions2), options);
        this.treeAdapter = this.options.treeAdapter;
        this.onParseError = this.options.onParseError;
        if (this.onParseError) {
          this.options.sourceCodeLocationInfo = true;
        }
        this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
        this.tokenizer = new index_js_1.Tokenizer(this.options, this);
        this.activeFormattingElements = new formatting_element_list_js_1.FormattingElementList(this.treeAdapter);
        this.fragmentContextID = fragmentContext ? (0, html_js_1.getTagID)(this.treeAdapter.getTagName(fragmentContext)) : html_js_1.TAG_ID.UNKNOWN;
        this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
        this.openElements = new open_element_stack_js_1.OpenElementStack(this.document, this.treeAdapter, this);
      }
      // API
      static parse(html3, options) {
        const parser = new this(options);
        parser.tokenizer.write(html3, true);
        return parser.document;
      }
      static getFragmentParser(fragmentContext, options) {
        const opts = Object.assign(Object.assign({}, defaultParserOptions2), options);
        fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(html_js_1.TAG_NAMES.TEMPLATE, html_js_1.NS.HTML, []);
        const documentMock = opts.treeAdapter.createElement("documentmock", html_js_1.NS.HTML, []);
        const parser = new this(opts, documentMock, fragmentContext);
        if (parser.fragmentContextID === html_js_1.TAG_ID.TEMPLATE) {
          parser.tmplInsertionModeStack.unshift(InsertionMode2.IN_TEMPLATE);
        }
        parser._initTokenizerForFragmentParsing();
        parser._insertFakeRootElement();
        parser._resetInsertionMode();
        parser._findFormInFragmentContext();
        return parser;
      }
      getFragment() {
        const rootElement = this.treeAdapter.getFirstChild(this.document);
        const fragment = this.treeAdapter.createDocumentFragment();
        this._adoptNodes(rootElement, fragment);
        return fragment;
      }
      //Errors
      _err(token, code, beforeToken) {
        var _a2;
        if (!this.onParseError)
          return;
        const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC2;
        const err = {
          code,
          startLine: loc.startLine,
          startCol: loc.startCol,
          startOffset: loc.startOffset,
          endLine: beforeToken ? loc.startLine : loc.endLine,
          endCol: beforeToken ? loc.startCol : loc.endCol,
          endOffset: beforeToken ? loc.startOffset : loc.endOffset
        };
        this.onParseError(err);
      }
      //Stack events
      onItemPush(node, tid, isTop) {
        var _a2, _b;
        (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
        if (isTop && this.openElements.stackTop > 0)
          this._setContextModes(node, tid);
      }
      onItemPop(node, isTop) {
        var _a2, _b;
        if (this.options.sourceCodeLocationInfo) {
          this._setEndLocation(node, this.currentToken);
        }
        (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node, this.openElements.current);
        if (isTop) {
          let current;
          let currentTagId;
          if (this.openElements.stackTop === 0 && this.fragmentContext) {
            current = this.fragmentContext;
            currentTagId = this.fragmentContextID;
          } else {
            ({ current, currentTagId } = this.openElements);
          }
          this._setContextModes(current, currentTagId);
        }
      }
      _setContextModes(current, tid) {
        const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.HTML;
        this.currentNotInHTML = !isHTML;
        this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
      }
      _switchToTextParsing(currentToken, nextTokenizerState) {
        this._insertElement(currentToken, html_js_1.NS.HTML);
        this.tokenizer.state = nextTokenizerState;
        this.originalInsertionMode = this.insertionMode;
        this.insertionMode = InsertionMode2.TEXT;
      }
      switchToPlaintextParsing() {
        this.insertionMode = InsertionMode2.TEXT;
        this.originalInsertionMode = InsertionMode2.IN_BODY;
        this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
      }
      //Fragment parsing
      _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
      }
      _findFormInFragmentContext() {
        let node = this.fragmentContext;
        while (node) {
          if (this.treeAdapter.getTagName(node) === html_js_1.TAG_NAMES.FORM) {
            this.formElement = node;
            break;
          }
          node = this.treeAdapter.getParentNode(node);
        }
      }
      _initTokenizerForFragmentParsing() {
        if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== html_js_1.NS.HTML) {
          return;
        }
        switch (this.fragmentContextID) {
          case html_js_1.TAG_ID.TITLE:
          case html_js_1.TAG_ID.TEXTAREA: {
            this.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
            break;
          }
          case html_js_1.TAG_ID.STYLE:
          case html_js_1.TAG_ID.XMP:
          case html_js_1.TAG_ID.IFRAME:
          case html_js_1.TAG_ID.NOEMBED:
          case html_js_1.TAG_ID.NOFRAMES:
          case html_js_1.TAG_ID.NOSCRIPT: {
            this.tokenizer.state = index_js_1.TokenizerMode.RAWTEXT;
            break;
          }
          case html_js_1.TAG_ID.SCRIPT: {
            this.tokenizer.state = index_js_1.TokenizerMode.SCRIPT_DATA;
            break;
          }
          case html_js_1.TAG_ID.PLAINTEXT: {
            this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
            break;
          }
          default:
        }
      }
      //Tree mutation
      _setDocumentType(token) {
        const name = token.name || "";
        const publicId = token.publicId || "";
        const systemId = token.systemId || "";
        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
        if (token.location) {
          const documentChildren = this.treeAdapter.getChildNodes(this.document);
          const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
          if (docTypeNode) {
            this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
          }
        }
      }
      _attachElementToTree(element, location) {
        if (this.options.sourceCodeLocationInfo) {
          const loc = location && Object.assign(Object.assign({}, location), { startTag: location });
          this.treeAdapter.setNodeSourceCodeLocation(element, loc);
        }
        if (this._shouldFosterParentOnInsertion()) {
          this._fosterParentElement(element);
        } else {
          const parent2 = this.openElements.currentTmplContentOrNode;
          this.treeAdapter.appendChild(parent2, element);
        }
      }
      _appendElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
        this._attachElementToTree(element, token.location);
      }
      _insertElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
        this._attachElementToTree(element, token.location);
        this.openElements.push(element, token.tagID);
      }
      _insertFakeElement(tagName, tagID) {
        const element = this.treeAdapter.createElement(tagName, html_js_1.NS.HTML, []);
        this._attachElementToTree(element, null);
        this.openElements.push(element, tagID);
      }
      _insertTemplate(token) {
        const tmpl = this.treeAdapter.createElement(token.tagName, html_js_1.NS.HTML, token.attrs);
        const content = this.treeAdapter.createDocumentFragment();
        this.treeAdapter.setTemplateContent(tmpl, content);
        this._attachElementToTree(tmpl, token.location);
        this.openElements.push(tmpl, token.tagID);
        if (this.options.sourceCodeLocationInfo)
          this.treeAdapter.setNodeSourceCodeLocation(content, null);
      }
      _insertFakeRootElement() {
        const element = this.treeAdapter.createElement(html_js_1.TAG_NAMES.HTML, html_js_1.NS.HTML, []);
        if (this.options.sourceCodeLocationInfo)
          this.treeAdapter.setNodeSourceCodeLocation(element, null);
        this.treeAdapter.appendChild(this.openElements.current, element);
        this.openElements.push(element, html_js_1.TAG_ID.HTML);
      }
      _appendCommentNode(token, parent2) {
        const commentNode = this.treeAdapter.createCommentNode(token.data);
        this.treeAdapter.appendChild(parent2, commentNode);
        if (this.options.sourceCodeLocationInfo) {
          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
        }
      }
      _insertCharacters(token) {
        let parent2;
        let beforeElement;
        if (this._shouldFosterParentOnInsertion()) {
          ({ parent: parent2, beforeElement } = this._findFosterParentingLocation());
          if (beforeElement) {
            this.treeAdapter.insertTextBefore(parent2, token.chars, beforeElement);
          } else {
            this.treeAdapter.insertText(parent2, token.chars);
          }
        } else {
          parent2 = this.openElements.currentTmplContentOrNode;
          this.treeAdapter.insertText(parent2, token.chars);
        }
        if (!token.location)
          return;
        const siblings2 = this.treeAdapter.getChildNodes(parent2);
        const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
        const textNode = siblings2[textNodeIdx - 1];
        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
        if (tnLoc) {
          const { endLine, endCol, endOffset } = token.location;
          this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
        } else if (this.options.sourceCodeLocationInfo) {
          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
        }
      }
      _adoptNodes(donor, recipient) {
        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
          this.treeAdapter.detachNode(child);
          this.treeAdapter.appendChild(recipient, child);
        }
      }
      _setEndLocation(element, closingToken) {
        if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
          const ctLoc = closingToken.location;
          const tn = this.treeAdapter.getTagName(element);
          const endLoc = (
            // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
            // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
            closingToken.type === token_js_1.TokenType.END_TAG && tn === closingToken.tagName ? {
              endTag: Object.assign({}, ctLoc),
              endLine: ctLoc.endLine,
              endCol: ctLoc.endCol,
              endOffset: ctLoc.endOffset
            } : {
              endLine: ctLoc.startLine,
              endCol: ctLoc.startCol,
              endOffset: ctLoc.startOffset
            }
          );
          this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
        }
      }
      //Token processing
      shouldProcessStartTagTokenInForeignContent(token) {
        if (!this.currentNotInHTML)
          return false;
        let current;
        let currentTagId;
        if (this.openElements.stackTop === 0 && this.fragmentContext) {
          current = this.fragmentContext;
          currentTagId = this.fragmentContextID;
        } else {
          ({ current, currentTagId } = this.openElements);
        }
        if (token.tagID === html_js_1.TAG_ID.SVG && this.treeAdapter.getTagName(current) === html_js_1.TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.MATHML) {
          return false;
        }
        return (
          // Check that `current` is not an integration point for HTML or MathML elements.
          this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
          // integration point.
          (token.tagID === html_js_1.TAG_ID.MGLYPH || token.tagID === html_js_1.TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, html_js_1.NS.HTML)
        );
      }
      _processToken(token) {
        switch (token.type) {
          case token_js_1.TokenType.CHARACTER: {
            this.onCharacter(token);
            break;
          }
          case token_js_1.TokenType.NULL_CHARACTER: {
            this.onNullCharacter(token);
            break;
          }
          case token_js_1.TokenType.COMMENT: {
            this.onComment(token);
            break;
          }
          case token_js_1.TokenType.DOCTYPE: {
            this.onDoctype(token);
            break;
          }
          case token_js_1.TokenType.START_TAG: {
            this._processStartTag(token);
            break;
          }
          case token_js_1.TokenType.END_TAG: {
            this.onEndTag(token);
            break;
          }
          case token_js_1.TokenType.EOF: {
            this.onEof(token);
            break;
          }
          case token_js_1.TokenType.WHITESPACE_CHARACTER: {
            this.onWhitespaceCharacter(token);
            break;
          }
        }
      }
      //Integration points
      _isIntegrationPoint(tid, element, foreignNS) {
        const ns = this.treeAdapter.getNamespaceURI(element);
        const attrs = this.treeAdapter.getAttrList(element);
        return foreignContent.isIntegrationPoint(tid, ns, attrs, foreignNS);
      }
      //Active formatting elements reconstruction
      _reconstructActiveFormattingElements() {
        const listLength = this.activeFormattingElements.entries.length;
        if (listLength) {
          const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === formatting_element_list_js_1.EntryType.Marker || this.openElements.contains(entry.element));
          const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
          for (let i = unopenIdx; i >= 0; i--) {
            const entry = this.activeFormattingElements.entries[i];
            this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
            entry.element = this.openElements.current;
          }
        }
      }
      //Close elements
      _closeTableCell() {
        this.openElements.generateImpliedEndTags();
        this.openElements.popUntilTableCellPopped();
        this.activeFormattingElements.clearToLastMarker();
        this.insertionMode = InsertionMode2.IN_ROW;
      }
      _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.P);
        this.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.P);
      }
      //Insertion modes
      _resetInsertionMode() {
        for (let i = this.openElements.stackTop; i >= 0; i--) {
          switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
            case html_js_1.TAG_ID.TR: {
              this.insertionMode = InsertionMode2.IN_ROW;
              return;
            }
            case html_js_1.TAG_ID.TBODY:
            case html_js_1.TAG_ID.THEAD:
            case html_js_1.TAG_ID.TFOOT: {
              this.insertionMode = InsertionMode2.IN_TABLE_BODY;
              return;
            }
            case html_js_1.TAG_ID.CAPTION: {
              this.insertionMode = InsertionMode2.IN_CAPTION;
              return;
            }
            case html_js_1.TAG_ID.COLGROUP: {
              this.insertionMode = InsertionMode2.IN_COLUMN_GROUP;
              return;
            }
            case html_js_1.TAG_ID.TABLE: {
              this.insertionMode = InsertionMode2.IN_TABLE;
              return;
            }
            case html_js_1.TAG_ID.BODY: {
              this.insertionMode = InsertionMode2.IN_BODY;
              return;
            }
            case html_js_1.TAG_ID.FRAMESET: {
              this.insertionMode = InsertionMode2.IN_FRAMESET;
              return;
            }
            case html_js_1.TAG_ID.SELECT: {
              this._resetInsertionModeForSelect(i);
              return;
            }
            case html_js_1.TAG_ID.TEMPLATE: {
              this.insertionMode = this.tmplInsertionModeStack[0];
              return;
            }
            case html_js_1.TAG_ID.HTML: {
              this.insertionMode = this.headElement ? InsertionMode2.AFTER_HEAD : InsertionMode2.BEFORE_HEAD;
              return;
            }
            case html_js_1.TAG_ID.TD:
            case html_js_1.TAG_ID.TH: {
              if (i > 0) {
                this.insertionMode = InsertionMode2.IN_CELL;
                return;
              }
              break;
            }
            case html_js_1.TAG_ID.HEAD: {
              if (i > 0) {
                this.insertionMode = InsertionMode2.IN_HEAD;
                return;
              }
              break;
            }
          }
        }
        this.insertionMode = InsertionMode2.IN_BODY;
      }
      _resetInsertionModeForSelect(selectIdx) {
        if (selectIdx > 0) {
          for (let i = selectIdx - 1; i > 0; i--) {
            const tn = this.openElements.tagIDs[i];
            if (tn === html_js_1.TAG_ID.TEMPLATE) {
              break;
            } else if (tn === html_js_1.TAG_ID.TABLE) {
              this.insertionMode = InsertionMode2.IN_SELECT_IN_TABLE;
              return;
            }
          }
        }
        this.insertionMode = InsertionMode2.IN_SELECT;
      }
      //Foster parenting
      _isElementCausesFosterParenting(tn) {
        return TABLE_STRUCTURE_TAGS2.has(tn);
      }
      _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
      }
      _findFosterParentingLocation() {
        for (let i = this.openElements.stackTop; i >= 0; i--) {
          const openElement = this.openElements.items[i];
          switch (this.openElements.tagIDs[i]) {
            case html_js_1.TAG_ID.TEMPLATE: {
              if (this.treeAdapter.getNamespaceURI(openElement) === html_js_1.NS.HTML) {
                return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
              }
              break;
            }
            case html_js_1.TAG_ID.TABLE: {
              const parent2 = this.treeAdapter.getParentNode(openElement);
              if (parent2) {
                return { parent: parent2, beforeElement: openElement };
              }
              return { parent: this.openElements.items[i - 1], beforeElement: null };
            }
            default:
          }
        }
        return { parent: this.openElements.items[0], beforeElement: null };
      }
      _fosterParentElement(element) {
        const location = this._findFosterParentingLocation();
        if (location.beforeElement) {
          this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
        } else {
          this.treeAdapter.appendChild(location.parent, element);
        }
      }
      //Special elements
      _isSpecialElement(element, id) {
        const ns = this.treeAdapter.getNamespaceURI(element);
        return html_js_1.SPECIAL_ELEMENTS[ns].has(id);
      }
      onCharacter(token) {
        this.skipNextNewLine = false;
        if (this.tokenizer.inForeignNode) {
          characterInForeignContent2(this, token);
          return;
        }
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            tokenInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HTML: {
            tokenBeforeHtml2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD: {
            tokenBeforeHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD: {
            tokenInHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD_NO_SCRIPT: {
            tokenInHeadNoScript2(this, token);
            break;
          }
          case InsertionMode2.AFTER_HEAD: {
            tokenAfterHead2(this, token);
            break;
          }
          case InsertionMode2.IN_BODY:
          case InsertionMode2.IN_CAPTION:
          case InsertionMode2.IN_CELL:
          case InsertionMode2.IN_TEMPLATE: {
            characterInBody2(this, token);
            break;
          }
          case InsertionMode2.TEXT:
          case InsertionMode2.IN_SELECT:
          case InsertionMode2.IN_SELECT_IN_TABLE: {
            this._insertCharacters(token);
            break;
          }
          case InsertionMode2.IN_TABLE:
          case InsertionMode2.IN_TABLE_BODY:
          case InsertionMode2.IN_ROW: {
            characterInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            characterInTableText2(this, token);
            break;
          }
          case InsertionMode2.IN_COLUMN_GROUP: {
            tokenInColumnGroup2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY: {
            tokenAfterBody2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_BODY: {
            tokenAfterAfterBody2(this, token);
            break;
          }
          default:
        }
      }
      onNullCharacter(token) {
        this.skipNextNewLine = false;
        if (this.tokenizer.inForeignNode) {
          nullCharacterInForeignContent2(this, token);
          return;
        }
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            tokenInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HTML: {
            tokenBeforeHtml2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD: {
            tokenBeforeHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD: {
            tokenInHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD_NO_SCRIPT: {
            tokenInHeadNoScript2(this, token);
            break;
          }
          case InsertionMode2.AFTER_HEAD: {
            tokenAfterHead2(this, token);
            break;
          }
          case InsertionMode2.TEXT: {
            this._insertCharacters(token);
            break;
          }
          case InsertionMode2.IN_TABLE:
          case InsertionMode2.IN_TABLE_BODY:
          case InsertionMode2.IN_ROW: {
            characterInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_COLUMN_GROUP: {
            tokenInColumnGroup2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY: {
            tokenAfterBody2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_BODY: {
            tokenAfterAfterBody2(this, token);
            break;
          }
          default:
        }
      }
      onComment(token) {
        this.skipNextNewLine = false;
        if (this.currentNotInHTML) {
          appendComment2(this, token);
          return;
        }
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL:
          case InsertionMode2.BEFORE_HTML:
          case InsertionMode2.BEFORE_HEAD:
          case InsertionMode2.IN_HEAD:
          case InsertionMode2.IN_HEAD_NO_SCRIPT:
          case InsertionMode2.AFTER_HEAD:
          case InsertionMode2.IN_BODY:
          case InsertionMode2.IN_TABLE:
          case InsertionMode2.IN_CAPTION:
          case InsertionMode2.IN_COLUMN_GROUP:
          case InsertionMode2.IN_TABLE_BODY:
          case InsertionMode2.IN_ROW:
          case InsertionMode2.IN_CELL:
          case InsertionMode2.IN_SELECT:
          case InsertionMode2.IN_SELECT_IN_TABLE:
          case InsertionMode2.IN_TEMPLATE:
          case InsertionMode2.IN_FRAMESET:
          case InsertionMode2.AFTER_FRAMESET: {
            appendComment2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            tokenInTableText2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY: {
            appendCommentToRootHtmlElement2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_BODY:
          case InsertionMode2.AFTER_AFTER_FRAMESET: {
            appendCommentToDocument2(this, token);
            break;
          }
          default:
        }
      }
      onDoctype(token) {
        this.skipNextNewLine = false;
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            doctypeInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD:
          case InsertionMode2.IN_HEAD:
          case InsertionMode2.IN_HEAD_NO_SCRIPT:
          case InsertionMode2.AFTER_HEAD: {
            this._err(token, error_codes_js_1.ERR.misplacedDoctype);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            tokenInTableText2(this, token);
            break;
          }
          default:
        }
      }
      onStartTag(token) {
        this.skipNextNewLine = false;
        this.currentToken = token;
        this._processStartTag(token);
        if (token.selfClosing && !token.ackSelfClosing) {
          this._err(token, error_codes_js_1.ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
        }
      }
      /**
       * Processes a given start tag.
       *
       * `onStartTag` checks if a self-closing tag was recognized. When a token
       * is moved inbetween multiple insertion modes, this check for self-closing
       * could lead to false positives. To avoid this, `_processStartTag` is used
       * for nested calls.
       *
       * @param token The token to process.
       */
      _processStartTag(token) {
        if (this.shouldProcessStartTagTokenInForeignContent(token)) {
          startTagInForeignContent2(this, token);
        } else {
          this._startTagOutsideForeignContent(token);
        }
      }
      _startTagOutsideForeignContent(token) {
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            tokenInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HTML: {
            startTagBeforeHtml2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD: {
            startTagBeforeHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD: {
            startTagInHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD_NO_SCRIPT: {
            startTagInHeadNoScript2(this, token);
            break;
          }
          case InsertionMode2.AFTER_HEAD: {
            startTagAfterHead2(this, token);
            break;
          }
          case InsertionMode2.IN_BODY: {
            startTagInBody2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE: {
            startTagInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            tokenInTableText2(this, token);
            break;
          }
          case InsertionMode2.IN_CAPTION: {
            startTagInCaption2(this, token);
            break;
          }
          case InsertionMode2.IN_COLUMN_GROUP: {
            startTagInColumnGroup2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_BODY: {
            startTagInTableBody2(this, token);
            break;
          }
          case InsertionMode2.IN_ROW: {
            startTagInRow2(this, token);
            break;
          }
          case InsertionMode2.IN_CELL: {
            startTagInCell2(this, token);
            break;
          }
          case InsertionMode2.IN_SELECT: {
            startTagInSelect2(this, token);
            break;
          }
          case InsertionMode2.IN_SELECT_IN_TABLE: {
            startTagInSelectInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TEMPLATE: {
            startTagInTemplate2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY: {
            startTagAfterBody2(this, token);
            break;
          }
          case InsertionMode2.IN_FRAMESET: {
            startTagInFrameset2(this, token);
            break;
          }
          case InsertionMode2.AFTER_FRAMESET: {
            startTagAfterFrameset2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_BODY: {
            startTagAfterAfterBody2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_FRAMESET: {
            startTagAfterAfterFrameset2(this, token);
            break;
          }
          default:
        }
      }
      onEndTag(token) {
        this.skipNextNewLine = false;
        this.currentToken = token;
        if (this.currentNotInHTML) {
          endTagInForeignContent2(this, token);
        } else {
          this._endTagOutsideForeignContent(token);
        }
      }
      _endTagOutsideForeignContent(token) {
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            tokenInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HTML: {
            endTagBeforeHtml2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD: {
            endTagBeforeHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD: {
            endTagInHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD_NO_SCRIPT: {
            endTagInHeadNoScript2(this, token);
            break;
          }
          case InsertionMode2.AFTER_HEAD: {
            endTagAfterHead2(this, token);
            break;
          }
          case InsertionMode2.IN_BODY: {
            endTagInBody2(this, token);
            break;
          }
          case InsertionMode2.TEXT: {
            endTagInText2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE: {
            endTagInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            tokenInTableText2(this, token);
            break;
          }
          case InsertionMode2.IN_CAPTION: {
            endTagInCaption2(this, token);
            break;
          }
          case InsertionMode2.IN_COLUMN_GROUP: {
            endTagInColumnGroup2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_BODY: {
            endTagInTableBody2(this, token);
            break;
          }
          case InsertionMode2.IN_ROW: {
            endTagInRow2(this, token);
            break;
          }
          case InsertionMode2.IN_CELL: {
            endTagInCell2(this, token);
            break;
          }
          case InsertionMode2.IN_SELECT: {
            endTagInSelect2(this, token);
            break;
          }
          case InsertionMode2.IN_SELECT_IN_TABLE: {
            endTagInSelectInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TEMPLATE: {
            endTagInTemplate2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY: {
            endTagAfterBody2(this, token);
            break;
          }
          case InsertionMode2.IN_FRAMESET: {
            endTagInFrameset2(this, token);
            break;
          }
          case InsertionMode2.AFTER_FRAMESET: {
            endTagAfterFrameset2(this, token);
            break;
          }
          case InsertionMode2.AFTER_AFTER_BODY: {
            tokenAfterAfterBody2(this, token);
            break;
          }
          default:
        }
      }
      onEof(token) {
        switch (this.insertionMode) {
          case InsertionMode2.INITIAL: {
            tokenInInitialMode2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HTML: {
            tokenBeforeHtml2(this, token);
            break;
          }
          case InsertionMode2.BEFORE_HEAD: {
            tokenBeforeHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD: {
            tokenInHead2(this, token);
            break;
          }
          case InsertionMode2.IN_HEAD_NO_SCRIPT: {
            tokenInHeadNoScript2(this, token);
            break;
          }
          case InsertionMode2.AFTER_HEAD: {
            tokenAfterHead2(this, token);
            break;
          }
          case InsertionMode2.IN_BODY:
          case InsertionMode2.IN_TABLE:
          case InsertionMode2.IN_CAPTION:
          case InsertionMode2.IN_COLUMN_GROUP:
          case InsertionMode2.IN_TABLE_BODY:
          case InsertionMode2.IN_ROW:
          case InsertionMode2.IN_CELL:
          case InsertionMode2.IN_SELECT:
          case InsertionMode2.IN_SELECT_IN_TABLE: {
            eofInBody2(this, token);
            break;
          }
          case InsertionMode2.TEXT: {
            eofInText2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            tokenInTableText2(this, token);
            break;
          }
          case InsertionMode2.IN_TEMPLATE: {
            eofInTemplate2(this, token);
            break;
          }
          case InsertionMode2.AFTER_BODY:
          case InsertionMode2.IN_FRAMESET:
          case InsertionMode2.AFTER_FRAMESET:
          case InsertionMode2.AFTER_AFTER_BODY:
          case InsertionMode2.AFTER_AFTER_FRAMESET: {
            stopParsing2(this, token);
            break;
          }
          default:
        }
      }
      onWhitespaceCharacter(token) {
        if (this.skipNextNewLine) {
          this.skipNextNewLine = false;
          if (token.chars.charCodeAt(0) === unicode.CODE_POINTS.LINE_FEED) {
            if (token.chars.length === 1) {
              return;
            }
            token.chars = token.chars.substr(1);
          }
        }
        if (this.tokenizer.inForeignNode) {
          this._insertCharacters(token);
          return;
        }
        switch (this.insertionMode) {
          case InsertionMode2.IN_HEAD:
          case InsertionMode2.IN_HEAD_NO_SCRIPT:
          case InsertionMode2.AFTER_HEAD:
          case InsertionMode2.TEXT:
          case InsertionMode2.IN_COLUMN_GROUP:
          case InsertionMode2.IN_SELECT:
          case InsertionMode2.IN_SELECT_IN_TABLE:
          case InsertionMode2.IN_FRAMESET:
          case InsertionMode2.AFTER_FRAMESET: {
            this._insertCharacters(token);
            break;
          }
          case InsertionMode2.IN_BODY:
          case InsertionMode2.IN_CAPTION:
          case InsertionMode2.IN_CELL:
          case InsertionMode2.IN_TEMPLATE:
          case InsertionMode2.AFTER_BODY:
          case InsertionMode2.AFTER_AFTER_BODY:
          case InsertionMode2.AFTER_AFTER_FRAMESET: {
            whitespaceCharacterInBody2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE:
          case InsertionMode2.IN_TABLE_BODY:
          case InsertionMode2.IN_ROW: {
            characterInTable2(this, token);
            break;
          }
          case InsertionMode2.IN_TABLE_TEXT: {
            whitespaceCharacterInTableText2(this, token);
            break;
          }
          default:
        }
      }
    };
    exports.Parser = Parser3;
    function aaObtainFormattingElementEntry2(p, token) {
      let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
      if (formattingElementEntry) {
        if (!p.openElements.contains(formattingElementEntry.element)) {
          p.activeFormattingElements.removeEntry(formattingElementEntry);
          formattingElementEntry = null;
        } else if (!p.openElements.hasInScope(token.tagID)) {
          formattingElementEntry = null;
        }
      } else {
        genericEndTagInBody2(p, token);
      }
      return formattingElementEntry;
    }
    function aaObtainFurthestBlock2(p, formattingElementEntry) {
      let furthestBlock = null;
      let idx = p.openElements.stackTop;
      for (; idx >= 0; idx--) {
        const element = p.openElements.items[idx];
        if (element === formattingElementEntry.element) {
          break;
        }
        if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
          furthestBlock = element;
        }
      }
      if (!furthestBlock) {
        p.openElements.shortenToLength(idx < 0 ? 0 : idx);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
      }
      return furthestBlock;
    }
    function aaInnerLoop2(p, furthestBlock, formattingElement) {
      let lastElement = furthestBlock;
      let nextElement = p.openElements.getCommonAncestor(furthestBlock);
      for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
        nextElement = p.openElements.getCommonAncestor(element);
        const elementEntry = p.activeFormattingElements.getElementEntry(element);
        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER2;
        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
        if (shouldRemoveFromOpenElements) {
          if (counterOverflow) {
            p.activeFormattingElements.removeEntry(elementEntry);
          }
          p.openElements.remove(element);
        } else {
          element = aaRecreateElementFromEntry2(p, elementEntry);
          if (lastElement === furthestBlock) {
            p.activeFormattingElements.bookmark = elementEntry;
          }
          p.treeAdapter.detachNode(lastElement);
          p.treeAdapter.appendChild(element, lastElement);
          lastElement = element;
        }
      }
      return lastElement;
    }
    function aaRecreateElementFromEntry2(p, elementEntry) {
      const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
      const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
      p.openElements.replace(elementEntry.element, newElement);
      elementEntry.element = newElement;
      return newElement;
    }
    function aaInsertLastNodeInCommonAncestor2(p, commonAncestor, lastElement) {
      const tn = p.treeAdapter.getTagName(commonAncestor);
      const tid = (0, html_js_1.getTagID)(tn);
      if (p._isElementCausesFosterParenting(tid)) {
        p._fosterParentElement(lastElement);
      } else {
        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
        if (tid === html_js_1.TAG_ID.TEMPLATE && ns === html_js_1.NS.HTML) {
          commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
        }
        p.treeAdapter.appendChild(commonAncestor, lastElement);
      }
    }
    function aaReplaceFormattingElement2(p, furthestBlock, formattingElementEntry) {
      const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
      const { token } = formattingElementEntry;
      const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
      p._adoptNodes(furthestBlock, newElement);
      p.treeAdapter.appendChild(furthestBlock, newElement);
      p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      p.openElements.remove(formattingElementEntry.element);
      p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
    }
    function callAdoptionAgency2(p, token) {
      for (let i = 0; i < AA_OUTER_LOOP_ITER2; i++) {
        const formattingElementEntry = aaObtainFormattingElementEntry2(p, token);
        if (!formattingElementEntry) {
          break;
        }
        const furthestBlock = aaObtainFurthestBlock2(p, formattingElementEntry);
        if (!furthestBlock) {
          break;
        }
        p.activeFormattingElements.bookmark = formattingElementEntry;
        const lastElement = aaInnerLoop2(p, furthestBlock, formattingElementEntry.element);
        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
        p.treeAdapter.detachNode(lastElement);
        if (commonAncestor)
          aaInsertLastNodeInCommonAncestor2(p, commonAncestor, lastElement);
        aaReplaceFormattingElement2(p, furthestBlock, formattingElementEntry);
      }
    }
    function appendComment2(p, token) {
      p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
    }
    function appendCommentToRootHtmlElement2(p, token) {
      p._appendCommentNode(token, p.openElements.items[0]);
    }
    function appendCommentToDocument2(p, token) {
      p._appendCommentNode(token, p.document);
    }
    function stopParsing2(p, token) {
      p.stopped = true;
      if (token.location) {
        const target = p.fragmentContext ? 0 : 2;
        for (let i = p.openElements.stackTop; i >= target; i--) {
          p._setEndLocation(p.openElements.items[i], token);
        }
        if (!p.fragmentContext && p.openElements.stackTop >= 0) {
          const htmlElement = p.openElements.items[0];
          const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
          if (htmlLocation && !htmlLocation.endTag) {
            p._setEndLocation(htmlElement, token);
            if (p.openElements.stackTop >= 1) {
              const bodyElement = p.openElements.items[1];
              const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
              if (bodyLocation && !bodyLocation.endTag) {
                p._setEndLocation(bodyElement, token);
              }
            }
          }
        }
      }
    }
    function doctypeInInitialMode2(p, token) {
      p._setDocumentType(token);
      const mode = token.forceQuirks ? html_js_1.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);
      if (!doctype.isConforming(token)) {
        p._err(token, error_codes_js_1.ERR.nonConformingDoctype);
      }
      p.treeAdapter.setDocumentMode(p.document, mode);
      p.insertionMode = InsertionMode2.BEFORE_HTML;
    }
    function tokenInInitialMode2(p, token) {
      p._err(token, error_codes_js_1.ERR.missingDoctype, true);
      p.treeAdapter.setDocumentMode(p.document, html_js_1.DOCUMENT_MODE.QUIRKS);
      p.insertionMode = InsertionMode2.BEFORE_HTML;
      p._processToken(token);
    }
    function startTagBeforeHtml2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.HTML) {
        p._insertElement(token, html_js_1.NS.HTML);
        p.insertionMode = InsertionMode2.BEFORE_HEAD;
      } else {
        tokenBeforeHtml2(p, token);
      }
    }
    function endTagBeforeHtml2(p, token) {
      const tn = token.tagID;
      if (tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.BR) {
        tokenBeforeHtml2(p, token);
      }
    }
    function tokenBeforeHtml2(p, token) {
      p._insertFakeRootElement();
      p.insertionMode = InsertionMode2.BEFORE_HEAD;
      p._processToken(token);
    }
    function startTagBeforeHead2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.HEAD: {
          p._insertElement(token, html_js_1.NS.HTML);
          p.headElement = p.openElements.current;
          p.insertionMode = InsertionMode2.IN_HEAD;
          break;
        }
        default: {
          tokenBeforeHead2(p, token);
        }
      }
    }
    function endTagBeforeHead2(p, token) {
      const tn = token.tagID;
      if (tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.BR) {
        tokenBeforeHead2(p, token);
      } else {
        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenBeforeHead2(p, token) {
      p._insertFakeElement(html_js_1.TAG_NAMES.HEAD, html_js_1.TAG_ID.HEAD);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode2.IN_HEAD;
      p._processToken(token);
    }
    function startTagInHead2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BASE:
        case html_js_1.TAG_ID.BASEFONT:
        case html_js_1.TAG_ID.BGSOUND:
        case html_js_1.TAG_ID.LINK:
        case html_js_1.TAG_ID.META: {
          p._appendElement(token, html_js_1.NS.HTML);
          token.ackSelfClosing = true;
          break;
        }
        case html_js_1.TAG_ID.TITLE: {
          p._switchToTextParsing(token, index_js_1.TokenizerMode.RCDATA);
          break;
        }
        case html_js_1.TAG_ID.NOSCRIPT: {
          if (p.options.scriptingEnabled) {
            p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
          } else {
            p._insertElement(token, html_js_1.NS.HTML);
            p.insertionMode = InsertionMode2.IN_HEAD_NO_SCRIPT;
          }
          break;
        }
        case html_js_1.TAG_ID.NOFRAMES:
        case html_js_1.TAG_ID.STYLE: {
          p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
          break;
        }
        case html_js_1.TAG_ID.SCRIPT: {
          p._switchToTextParsing(token, index_js_1.TokenizerMode.SCRIPT_DATA);
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          p._insertTemplate(token);
          p.activeFormattingElements.insertMarker();
          p.framesetOk = false;
          p.insertionMode = InsertionMode2.IN_TEMPLATE;
          p.tmplInsertionModeStack.unshift(InsertionMode2.IN_TEMPLATE);
          break;
        }
        case html_js_1.TAG_ID.HEAD: {
          p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
          break;
        }
        default: {
          tokenInHead2(p, token);
        }
      }
    }
    function endTagInHead2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HEAD: {
          p.openElements.pop();
          p.insertionMode = InsertionMode2.AFTER_HEAD;
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.BR:
        case html_js_1.TAG_ID.HTML: {
          tokenInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        default: {
          p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
        }
      }
    }
    function templateEndTagInHead2(p, token) {
      if (p.openElements.tmplCount > 0) {
        p.openElements.generateImpliedEndTagsThoroughly();
        if (p.openElements.currentTagId !== html_js_1.TAG_ID.TEMPLATE) {
          p._err(token, error_codes_js_1.ERR.closingOfElementWithOpenChildElements);
        }
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p.tmplInsertionModeStack.shift();
        p._resetInsertionMode();
      } else {
        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenInHead2(p, token) {
      p.openElements.pop();
      p.insertionMode = InsertionMode2.AFTER_HEAD;
      p._processToken(token);
    }
    function startTagInHeadNoScript2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BASEFONT:
        case html_js_1.TAG_ID.BGSOUND:
        case html_js_1.TAG_ID.HEAD:
        case html_js_1.TAG_ID.LINK:
        case html_js_1.TAG_ID.META:
        case html_js_1.TAG_ID.NOFRAMES:
        case html_js_1.TAG_ID.STYLE: {
          startTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOSCRIPT: {
          p._err(token, error_codes_js_1.ERR.nestedNoscriptInHead);
          break;
        }
        default: {
          tokenInHeadNoScript2(p, token);
        }
      }
    }
    function endTagInHeadNoScript2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.NOSCRIPT: {
          p.openElements.pop();
          p.insertionMode = InsertionMode2.IN_HEAD;
          break;
        }
        case html_js_1.TAG_ID.BR: {
          tokenInHeadNoScript2(p, token);
          break;
        }
        default: {
          p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
        }
      }
    }
    function tokenInHeadNoScript2(p, token) {
      const errCode = token.type === token_js_1.TokenType.EOF ? error_codes_js_1.ERR.openElementsLeftAfterEof : error_codes_js_1.ERR.disallowedContentInNoscriptInHead;
      p._err(token, errCode);
      p.openElements.pop();
      p.insertionMode = InsertionMode2.IN_HEAD;
      p._processToken(token);
    }
    function startTagAfterHead2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BODY: {
          p._insertElement(token, html_js_1.NS.HTML);
          p.framesetOk = false;
          p.insertionMode = InsertionMode2.IN_BODY;
          break;
        }
        case html_js_1.TAG_ID.FRAMESET: {
          p._insertElement(token, html_js_1.NS.HTML);
          p.insertionMode = InsertionMode2.IN_FRAMESET;
          break;
        }
        case html_js_1.TAG_ID.BASE:
        case html_js_1.TAG_ID.BASEFONT:
        case html_js_1.TAG_ID.BGSOUND:
        case html_js_1.TAG_ID.LINK:
        case html_js_1.TAG_ID.META:
        case html_js_1.TAG_ID.NOFRAMES:
        case html_js_1.TAG_ID.SCRIPT:
        case html_js_1.TAG_ID.STYLE:
        case html_js_1.TAG_ID.TEMPLATE:
        case html_js_1.TAG_ID.TITLE: {
          p._err(token, error_codes_js_1.ERR.abandonedHeadElementChild);
          p.openElements.push(p.headElement, html_js_1.TAG_ID.HEAD);
          startTagInHead2(p, token);
          p.openElements.remove(p.headElement);
          break;
        }
        case html_js_1.TAG_ID.HEAD: {
          p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
          break;
        }
        default: {
          tokenAfterHead2(p, token);
        }
      }
    }
    function endTagAfterHead2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.HTML:
        case html_js_1.TAG_ID.BR: {
          tokenAfterHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        default: {
          p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
        }
      }
    }
    function tokenAfterHead2(p, token) {
      p._insertFakeElement(html_js_1.TAG_NAMES.BODY, html_js_1.TAG_ID.BODY);
      p.insertionMode = InsertionMode2.IN_BODY;
      modeInBody2(p, token);
    }
    function modeInBody2(p, token) {
      switch (token.type) {
        case token_js_1.TokenType.CHARACTER: {
          characterInBody2(p, token);
          break;
        }
        case token_js_1.TokenType.WHITESPACE_CHARACTER: {
          whitespaceCharacterInBody2(p, token);
          break;
        }
        case token_js_1.TokenType.COMMENT: {
          appendComment2(p, token);
          break;
        }
        case token_js_1.TokenType.START_TAG: {
          startTagInBody2(p, token);
          break;
        }
        case token_js_1.TokenType.END_TAG: {
          endTagInBody2(p, token);
          break;
        }
        case token_js_1.TokenType.EOF: {
          eofInBody2(p, token);
          break;
        }
        default:
      }
    }
    function whitespaceCharacterInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertCharacters(token);
    }
    function characterInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertCharacters(token);
      p.framesetOk = false;
    }
    function htmlStartTagInBody2(p, token) {
      if (p.openElements.tmplCount === 0) {
        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
      }
    }
    function bodyStartTagInBody2(p, token) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement && p.openElements.tmplCount === 0) {
        p.framesetOk = false;
        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
      }
    }
    function framesetStartTagInBody2(p, token) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (p.framesetOk && bodyElement) {
        p.treeAdapter.detachNode(bodyElement);
        p.openElements.popAllUpToHtmlElement();
        p._insertElement(token, html_js_1.NS.HTML);
        p.insertionMode = InsertionMode2.IN_FRAMESET;
      }
    }
    function addressStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function numberedHeaderStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      if ((0, html_js_1.isNumberedHeader)(p.openElements.currentTagId)) {
        p.openElements.pop();
      }
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function preStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, html_js_1.NS.HTML);
      p.skipNextNewLine = true;
      p.framesetOk = false;
    }
    function formStartTagInBody2(p, token) {
      const inTemplate = p.openElements.tmplCount > 0;
      if (!p.formElement || inTemplate) {
        if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, html_js_1.NS.HTML);
        if (!inTemplate) {
          p.formElement = p.openElements.current;
        }
      }
    }
    function listItemStartTagInBody2(p, token) {
      p.framesetOk = false;
      const tn = token.tagID;
      for (let i = p.openElements.stackTop; i >= 0; i--) {
        const elementId = p.openElements.tagIDs[i];
        if (tn === html_js_1.TAG_ID.LI && elementId === html_js_1.TAG_ID.LI || (tn === html_js_1.TAG_ID.DD || tn === html_js_1.TAG_ID.DT) && (elementId === html_js_1.TAG_ID.DD || elementId === html_js_1.TAG_ID.DT)) {
          p.openElements.generateImpliedEndTagsWithExclusion(elementId);
          p.openElements.popUntilTagNamePopped(elementId);
          break;
        }
        if (elementId !== html_js_1.TAG_ID.ADDRESS && elementId !== html_js_1.TAG_ID.DIV && elementId !== html_js_1.TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
          break;
        }
      }
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function plaintextStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, html_js_1.NS.HTML);
      p.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
    }
    function buttonStartTagInBody2(p, token) {
      if (p.openElements.hasInScope(html_js_1.TAG_ID.BUTTON)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.BUTTON);
      }
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
      p.framesetOk = false;
    }
    function aStartTagInBody2(p, token) {
      const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(html_js_1.TAG_NAMES.A);
      if (activeElementEntry) {
        callAdoptionAgency2(p, token);
        p.openElements.remove(activeElementEntry.element);
        p.activeFormattingElements.removeEntry(activeElementEntry);
      }
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
      p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function bStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
      p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function nobrStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      if (p.openElements.hasInScope(html_js_1.TAG_ID.NOBR)) {
        callAdoptionAgency2(p, token);
        p._reconstructActiveFormattingElements();
      }
      p._insertElement(token, html_js_1.NS.HTML);
      p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function appletStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
    }
    function tableStartTagInBody2(p, token) {
      if (p.treeAdapter.getDocumentMode(p.document) !== html_js_1.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, html_js_1.NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode2.IN_TABLE;
    }
    function areaStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._appendElement(token, html_js_1.NS.HTML);
      p.framesetOk = false;
      token.ackSelfClosing = true;
    }
    function isHiddenInput2(token) {
      const inputType = (0, token_js_1.getTokenAttr)(token, html_js_1.ATTRS.TYPE);
      return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE2;
    }
    function inputStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._appendElement(token, html_js_1.NS.HTML);
      if (!isHiddenInput2(token)) {
        p.framesetOk = false;
      }
      token.ackSelfClosing = true;
    }
    function paramStartTagInBody2(p, token) {
      p._appendElement(token, html_js_1.NS.HTML);
      token.ackSelfClosing = true;
    }
    function hrStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._appendElement(token, html_js_1.NS.HTML);
      p.framesetOk = false;
      token.ackSelfClosing = true;
    }
    function imageStartTagInBody2(p, token) {
      token.tagName = html_js_1.TAG_NAMES.IMG;
      token.tagID = html_js_1.TAG_ID.IMG;
      areaStartTagInBody2(p, token);
    }
    function textareaStartTagInBody2(p, token) {
      p._insertElement(token, html_js_1.NS.HTML);
      p.skipNextNewLine = true;
      p.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
      p.originalInsertionMode = p.insertionMode;
      p.framesetOk = false;
      p.insertionMode = InsertionMode2.TEXT;
    }
    function xmpStartTagInBody2(p, token) {
      if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._closePElement();
      }
      p._reconstructActiveFormattingElements();
      p.framesetOk = false;
      p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
    }
    function iframeStartTagInBody2(p, token) {
      p.framesetOk = false;
      p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
    }
    function noembedStartTagInBody2(p, token) {
      p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
    }
    function selectStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
      p.framesetOk = false;
      p.insertionMode = p.insertionMode === InsertionMode2.IN_TABLE || p.insertionMode === InsertionMode2.IN_CAPTION || p.insertionMode === InsertionMode2.IN_TABLE_BODY || p.insertionMode === InsertionMode2.IN_ROW || p.insertionMode === InsertionMode2.IN_CELL ? InsertionMode2.IN_SELECT_IN_TABLE : InsertionMode2.IN_SELECT;
    }
    function optgroupStartTagInBody2(p, token) {
      if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function rbStartTagInBody2(p, token) {
      if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
        p.openElements.generateImpliedEndTags();
      }
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function rtStartTagInBody2(p, token) {
      if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
        p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.RTC);
      }
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function mathStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      foreignContent.adjustTokenMathMLAttrs(token);
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p._appendElement(token, html_js_1.NS.MATHML);
      } else {
        p._insertElement(token, html_js_1.NS.MATHML);
      }
      token.ackSelfClosing = true;
    }
    function svgStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      foreignContent.adjustTokenSVGAttrs(token);
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p._appendElement(token, html_js_1.NS.SVG);
      } else {
        p._insertElement(token, html_js_1.NS.SVG);
      }
      token.ackSelfClosing = true;
    }
    function genericStartTagInBody2(p, token) {
      p._reconstructActiveFormattingElements();
      p._insertElement(token, html_js_1.NS.HTML);
    }
    function startTagInBody2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.I:
        case html_js_1.TAG_ID.S:
        case html_js_1.TAG_ID.B:
        case html_js_1.TAG_ID.U:
        case html_js_1.TAG_ID.EM:
        case html_js_1.TAG_ID.TT:
        case html_js_1.TAG_ID.BIG:
        case html_js_1.TAG_ID.CODE:
        case html_js_1.TAG_ID.FONT:
        case html_js_1.TAG_ID.SMALL:
        case html_js_1.TAG_ID.STRIKE:
        case html_js_1.TAG_ID.STRONG: {
          bStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.A: {
          aStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.H1:
        case html_js_1.TAG_ID.H2:
        case html_js_1.TAG_ID.H3:
        case html_js_1.TAG_ID.H4:
        case html_js_1.TAG_ID.H5:
        case html_js_1.TAG_ID.H6: {
          numberedHeaderStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.P:
        case html_js_1.TAG_ID.DL:
        case html_js_1.TAG_ID.OL:
        case html_js_1.TAG_ID.UL:
        case html_js_1.TAG_ID.DIV:
        case html_js_1.TAG_ID.DIR:
        case html_js_1.TAG_ID.NAV:
        case html_js_1.TAG_ID.MAIN:
        case html_js_1.TAG_ID.MENU:
        case html_js_1.TAG_ID.ASIDE:
        case html_js_1.TAG_ID.CENTER:
        case html_js_1.TAG_ID.FIGURE:
        case html_js_1.TAG_ID.FOOTER:
        case html_js_1.TAG_ID.HEADER:
        case html_js_1.TAG_ID.HGROUP:
        case html_js_1.TAG_ID.DIALOG:
        case html_js_1.TAG_ID.DETAILS:
        case html_js_1.TAG_ID.ADDRESS:
        case html_js_1.TAG_ID.ARTICLE:
        case html_js_1.TAG_ID.SECTION:
        case html_js_1.TAG_ID.SUMMARY:
        case html_js_1.TAG_ID.FIELDSET:
        case html_js_1.TAG_ID.BLOCKQUOTE:
        case html_js_1.TAG_ID.FIGCAPTION: {
          addressStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.LI:
        case html_js_1.TAG_ID.DD:
        case html_js_1.TAG_ID.DT: {
          listItemStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BR:
        case html_js_1.TAG_ID.IMG:
        case html_js_1.TAG_ID.WBR:
        case html_js_1.TAG_ID.AREA:
        case html_js_1.TAG_ID.EMBED:
        case html_js_1.TAG_ID.KEYGEN: {
          areaStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.HR: {
          hrStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.RB:
        case html_js_1.TAG_ID.RTC: {
          rbStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.RT:
        case html_js_1.TAG_ID.RP: {
          rtStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.PRE:
        case html_js_1.TAG_ID.LISTING: {
          preStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.XMP: {
          xmpStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.SVG: {
          svgStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.HTML: {
          htmlStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BASE:
        case html_js_1.TAG_ID.LINK:
        case html_js_1.TAG_ID.META:
        case html_js_1.TAG_ID.STYLE:
        case html_js_1.TAG_ID.TITLE:
        case html_js_1.TAG_ID.SCRIPT:
        case html_js_1.TAG_ID.BGSOUND:
        case html_js_1.TAG_ID.BASEFONT:
        case html_js_1.TAG_ID.TEMPLATE: {
          startTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BODY: {
          bodyStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.FORM: {
          formStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOBR: {
          nobrStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.MATH: {
          mathStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TABLE: {
          tableStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.INPUT: {
          inputStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.PARAM:
        case html_js_1.TAG_ID.TRACK:
        case html_js_1.TAG_ID.SOURCE: {
          paramStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.IMAGE: {
          imageStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BUTTON: {
          buttonStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.APPLET:
        case html_js_1.TAG_ID.OBJECT:
        case html_js_1.TAG_ID.MARQUEE: {
          appletStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.IFRAME: {
          iframeStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.SELECT: {
          selectStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.OPTION:
        case html_js_1.TAG_ID.OPTGROUP: {
          optgroupStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOEMBED: {
          noembedStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.FRAMESET: {
          framesetStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TEXTAREA: {
          textareaStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOSCRIPT: {
          if (p.options.scriptingEnabled) {
            noembedStartTagInBody2(p, token);
          } else {
            genericStartTagInBody2(p, token);
          }
          break;
        }
        case html_js_1.TAG_ID.PLAINTEXT: {
          plaintextStartTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TR:
        case html_js_1.TAG_ID.HEAD:
        case html_js_1.TAG_ID.FRAME:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COLGROUP: {
          break;
        }
        default: {
          genericStartTagInBody2(p, token);
        }
      }
    }
    function bodyEndTagInBody2(p, token) {
      if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
        p.insertionMode = InsertionMode2.AFTER_BODY;
        if (p.options.sourceCodeLocationInfo) {
          const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
          if (bodyElement) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
    function htmlEndTagInBody2(p, token) {
      if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
        p.insertionMode = InsertionMode2.AFTER_BODY;
        endTagAfterBody2(p, token);
      }
    }
    function addressEndTagInBody2(p, token) {
      const tn = token.tagID;
      if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
      }
    }
    function formEndTagInBody2(p) {
      const inTemplate = p.openElements.tmplCount > 0;
      const { formElement } = p;
      if (!inTemplate) {
        p.formElement = null;
      }
      if ((formElement || inTemplate) && p.openElements.hasInScope(html_js_1.TAG_ID.FORM)) {
        p.openElements.generateImpliedEndTags();
        if (inTemplate) {
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.FORM);
        } else if (formElement) {
          p.openElements.remove(formElement);
        }
      }
    }
    function pEndTagInBody2(p) {
      if (!p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
        p._insertFakeElement(html_js_1.TAG_NAMES.P, html_js_1.TAG_ID.P);
      }
      p._closePElement();
    }
    function liEndTagInBody2(p) {
      if (p.openElements.hasInListItemScope(html_js_1.TAG_ID.LI)) {
        p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.LI);
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.LI);
      }
    }
    function ddEndTagInBody2(p, token) {
      const tn = token.tagID;
      if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tn);
        p.openElements.popUntilTagNamePopped(tn);
      }
    }
    function numberedHeaderEndTagInBody2(p) {
      if (p.openElements.hasNumberedHeaderInScope()) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilNumberedHeaderPopped();
      }
    }
    function appletEndTagInBody2(p, token) {
      const tn = token.tagID;
      if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
      }
    }
    function brEndTagInBody2(p) {
      p._reconstructActiveFormattingElements();
      p._insertFakeElement(html_js_1.TAG_NAMES.BR, html_js_1.TAG_ID.BR);
      p.openElements.pop();
      p.framesetOk = false;
    }
    function genericEndTagInBody2(p, token) {
      const tn = token.tagName;
      const tid = token.tagID;
      for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];
        const elementId = p.openElements.tagIDs[i];
        if (tid === elementId && (tid !== html_js_1.TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
          p.openElements.generateImpliedEndTagsWithExclusion(tid);
          if (p.openElements.stackTop >= i)
            p.openElements.shortenToLength(i);
          break;
        }
        if (p._isSpecialElement(element, elementId)) {
          break;
        }
      }
    }
    function endTagInBody2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.A:
        case html_js_1.TAG_ID.B:
        case html_js_1.TAG_ID.I:
        case html_js_1.TAG_ID.S:
        case html_js_1.TAG_ID.U:
        case html_js_1.TAG_ID.EM:
        case html_js_1.TAG_ID.TT:
        case html_js_1.TAG_ID.BIG:
        case html_js_1.TAG_ID.CODE:
        case html_js_1.TAG_ID.FONT:
        case html_js_1.TAG_ID.NOBR:
        case html_js_1.TAG_ID.SMALL:
        case html_js_1.TAG_ID.STRIKE:
        case html_js_1.TAG_ID.STRONG: {
          callAdoptionAgency2(p, token);
          break;
        }
        case html_js_1.TAG_ID.P: {
          pEndTagInBody2(p);
          break;
        }
        case html_js_1.TAG_ID.DL:
        case html_js_1.TAG_ID.UL:
        case html_js_1.TAG_ID.OL:
        case html_js_1.TAG_ID.DIR:
        case html_js_1.TAG_ID.DIV:
        case html_js_1.TAG_ID.NAV:
        case html_js_1.TAG_ID.PRE:
        case html_js_1.TAG_ID.MAIN:
        case html_js_1.TAG_ID.MENU:
        case html_js_1.TAG_ID.ASIDE:
        case html_js_1.TAG_ID.BUTTON:
        case html_js_1.TAG_ID.CENTER:
        case html_js_1.TAG_ID.FIGURE:
        case html_js_1.TAG_ID.FOOTER:
        case html_js_1.TAG_ID.HEADER:
        case html_js_1.TAG_ID.HGROUP:
        case html_js_1.TAG_ID.DIALOG:
        case html_js_1.TAG_ID.ADDRESS:
        case html_js_1.TAG_ID.ARTICLE:
        case html_js_1.TAG_ID.DETAILS:
        case html_js_1.TAG_ID.SECTION:
        case html_js_1.TAG_ID.SUMMARY:
        case html_js_1.TAG_ID.LISTING:
        case html_js_1.TAG_ID.FIELDSET:
        case html_js_1.TAG_ID.BLOCKQUOTE:
        case html_js_1.TAG_ID.FIGCAPTION: {
          addressEndTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.LI: {
          liEndTagInBody2(p);
          break;
        }
        case html_js_1.TAG_ID.DD:
        case html_js_1.TAG_ID.DT: {
          ddEndTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.H1:
        case html_js_1.TAG_ID.H2:
        case html_js_1.TAG_ID.H3:
        case html_js_1.TAG_ID.H4:
        case html_js_1.TAG_ID.H5:
        case html_js_1.TAG_ID.H6: {
          numberedHeaderEndTagInBody2(p);
          break;
        }
        case html_js_1.TAG_ID.BR: {
          brEndTagInBody2(p);
          break;
        }
        case html_js_1.TAG_ID.BODY: {
          bodyEndTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.HTML: {
          htmlEndTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.FORM: {
          formEndTagInBody2(p);
          break;
        }
        case html_js_1.TAG_ID.APPLET:
        case html_js_1.TAG_ID.OBJECT:
        case html_js_1.TAG_ID.MARQUEE: {
          appletEndTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        default: {
          genericEndTagInBody2(p, token);
        }
      }
    }
    function eofInBody2(p, token) {
      if (p.tmplInsertionModeStack.length > 0) {
        eofInTemplate2(p, token);
      } else {
        stopParsing2(p, token);
      }
    }
    function endTagInText2(p, token) {
      var _a2;
      if (token.tagID === html_js_1.TAG_ID.SCRIPT) {
        (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
      }
      p.openElements.pop();
      p.insertionMode = p.originalInsertionMode;
    }
    function eofInText2(p, token) {
      p._err(token, error_codes_js_1.ERR.eofInElementThatCanContainOnlyText);
      p.openElements.pop();
      p.insertionMode = p.originalInsertionMode;
      p.onEof(token);
    }
    function characterInTable2(p, token) {
      if (TABLE_STRUCTURE_TAGS2.has(p.openElements.currentTagId)) {
        p.pendingCharacterTokens.length = 0;
        p.hasNonWhitespacePendingCharacterToken = false;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = InsertionMode2.IN_TABLE_TEXT;
        switch (token.type) {
          case token_js_1.TokenType.CHARACTER: {
            characterInTableText2(p, token);
            break;
          }
          case token_js_1.TokenType.WHITESPACE_CHARACTER: {
            whitespaceCharacterInTableText2(p, token);
            break;
          }
        }
      } else {
        tokenInTable2(p, token);
      }
    }
    function captionStartTagInTable2(p, token) {
      p.openElements.clearBackToTableContext();
      p.activeFormattingElements.insertMarker();
      p._insertElement(token, html_js_1.NS.HTML);
      p.insertionMode = InsertionMode2.IN_CAPTION;
    }
    function colgroupStartTagInTable2(p, token) {
      p.openElements.clearBackToTableContext();
      p._insertElement(token, html_js_1.NS.HTML);
      p.insertionMode = InsertionMode2.IN_COLUMN_GROUP;
    }
    function colStartTagInTable2(p, token) {
      p.openElements.clearBackToTableContext();
      p._insertFakeElement(html_js_1.TAG_NAMES.COLGROUP, html_js_1.TAG_ID.COLGROUP);
      p.insertionMode = InsertionMode2.IN_COLUMN_GROUP;
      startTagInColumnGroup2(p, token);
    }
    function tbodyStartTagInTable2(p, token) {
      p.openElements.clearBackToTableContext();
      p._insertElement(token, html_js_1.NS.HTML);
      p.insertionMode = InsertionMode2.IN_TABLE_BODY;
    }
    function tdStartTagInTable2(p, token) {
      p.openElements.clearBackToTableContext();
      p._insertFakeElement(html_js_1.TAG_NAMES.TBODY, html_js_1.TAG_ID.TBODY);
      p.insertionMode = InsertionMode2.IN_TABLE_BODY;
      startTagInTableBody2(p, token);
    }
    function tableStartTagInTable2(p, token) {
      if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
        p._resetInsertionMode();
        p._processStartTag(token);
      }
    }
    function inputStartTagInTable2(p, token) {
      if (isHiddenInput2(token)) {
        p._appendElement(token, html_js_1.NS.HTML);
      } else {
        tokenInTable2(p, token);
      }
      token.ackSelfClosing = true;
    }
    function formStartTagInTable2(p, token) {
      if (!p.formElement && p.openElements.tmplCount === 0) {
        p._insertElement(token, html_js_1.NS.HTML);
        p.formElement = p.openElements.current;
        p.openElements.pop();
      }
    }
    function startTagInTable2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.TR: {
          tdStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.STYLE:
        case html_js_1.TAG_ID.SCRIPT:
        case html_js_1.TAG_ID.TEMPLATE: {
          startTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COL: {
          colStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.FORM: {
          formStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TABLE: {
          tableStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD: {
          tbodyStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.INPUT: {
          inputStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.CAPTION: {
          captionStartTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COLGROUP: {
          colgroupStartTagInTable2(p, token);
          break;
        }
        default: {
          tokenInTable2(p, token);
        }
      }
    }
    function endTagInTable2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.TABLE: {
          if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
            p._resetInsertionMode();
          }
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.HTML:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TR: {
          break;
        }
        default: {
          tokenInTable2(p, token);
        }
      }
    }
    function tokenInTable2(p, token) {
      const savedFosterParentingState = p.fosterParentingEnabled;
      p.fosterParentingEnabled = true;
      modeInBody2(p, token);
      p.fosterParentingEnabled = savedFosterParentingState;
    }
    function whitespaceCharacterInTableText2(p, token) {
      p.pendingCharacterTokens.push(token);
    }
    function characterInTableText2(p, token) {
      p.pendingCharacterTokens.push(token);
      p.hasNonWhitespacePendingCharacterToken = true;
    }
    function tokenInTableText2(p, token) {
      let i = 0;
      if (p.hasNonWhitespacePendingCharacterToken) {
        for (; i < p.pendingCharacterTokens.length; i++) {
          tokenInTable2(p, p.pendingCharacterTokens[i]);
        }
      } else {
        for (; i < p.pendingCharacterTokens.length; i++) {
          p._insertCharacters(p.pendingCharacterTokens[i]);
        }
      }
      p.insertionMode = p.originalInsertionMode;
      p._processToken(token);
    }
    var TABLE_VOID_ELEMENTS2 = /* @__PURE__ */ new Set([html_js_1.TAG_ID.CAPTION, html_js_1.TAG_ID.COL, html_js_1.TAG_ID.COLGROUP, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.TH, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
    function startTagInCaption2(p, token) {
      const tn = token.tagID;
      if (TABLE_VOID_ELEMENTS2.has(tn)) {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
          p.activeFormattingElements.clearToLastMarker();
          p.insertionMode = InsertionMode2.IN_TABLE;
          startTagInTable2(p, token);
        }
      } else {
        startTagInBody2(p, token);
      }
    }
    function endTagInCaption2(p, token) {
      const tn = token.tagID;
      switch (tn) {
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.TABLE: {
          if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = InsertionMode2.IN_TABLE;
            if (tn === html_js_1.TAG_ID.TABLE) {
              endTagInTable2(p, token);
            }
          }
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.HTML:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TR: {
          break;
        }
        default: {
          endTagInBody2(p, token);
        }
      }
    }
    function startTagInColumnGroup2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COL: {
          p._appendElement(token, html_js_1.NS.HTML);
          token.ackSelfClosing = true;
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          startTagInHead2(p, token);
          break;
        }
        default: {
          tokenInColumnGroup2(p, token);
        }
      }
    }
    function endTagInColumnGroup2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.COLGROUP: {
          if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE;
          }
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COL: {
          break;
        }
        default: {
          tokenInColumnGroup2(p, token);
        }
      }
    }
    function tokenInColumnGroup2(p, token) {
      if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode2.IN_TABLE;
        p._processToken(token);
      }
    }
    function startTagInTableBody2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.TR: {
          p.openElements.clearBackToTableBodyContext();
          p._insertElement(token, html_js_1.NS.HTML);
          p.insertionMode = InsertionMode2.IN_ROW;
          break;
        }
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.TD: {
          p.openElements.clearBackToTableBodyContext();
          p._insertFakeElement(html_js_1.TAG_NAMES.TR, html_js_1.TAG_ID.TR);
          p.insertionMode = InsertionMode2.IN_ROW;
          startTagInRow2(p, token);
          break;
        }
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD: {
          if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE;
            startTagInTable2(p, token);
          }
          break;
        }
        default: {
          startTagInTable2(p, token);
        }
      }
    }
    function endTagInTableBody2(p, token) {
      const tn = token.tagID;
      switch (token.tagID) {
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD: {
          if (p.openElements.hasInTableScope(tn)) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE;
          }
          break;
        }
        case html_js_1.TAG_ID.TABLE: {
          if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE;
            endTagInTable2(p, token);
          }
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.HTML:
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.TR: {
          break;
        }
        default: {
          endTagInTable2(p, token);
        }
      }
    }
    function startTagInRow2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.TH:
        case html_js_1.TAG_ID.TD: {
          p.openElements.clearBackToTableRowContext();
          p._insertElement(token, html_js_1.NS.HTML);
          p.insertionMode = InsertionMode2.IN_CELL;
          p.activeFormattingElements.insertMarker();
          break;
        }
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TR: {
          if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE_BODY;
            startTagInTableBody2(p, token);
          }
          break;
        }
        default: {
          startTagInTable2(p, token);
        }
      }
    }
    function endTagInRow2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.TR: {
          if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE_BODY;
          }
          break;
        }
        case html_js_1.TAG_ID.TABLE: {
          if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE_BODY;
            endTagInTableBody2(p, token);
          }
          break;
        }
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD: {
          if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = InsertionMode2.IN_TABLE_BODY;
            endTagInTableBody2(p, token);
          }
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.HTML:
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH: {
          break;
        }
        default: {
          endTagInTable2(p, token);
        }
      }
    }
    function startTagInCell2(p, token) {
      const tn = token.tagID;
      if (TABLE_VOID_ELEMENTS2.has(tn)) {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TD) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TH)) {
          p._closeTableCell();
          startTagInRow2(p, token);
        }
      } else {
        startTagInBody2(p, token);
      }
    }
    function endTagInCell2(p, token) {
      const tn = token.tagID;
      switch (tn) {
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH: {
          if (p.openElements.hasInTableScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = InsertionMode2.IN_ROW;
          }
          break;
        }
        case html_js_1.TAG_ID.TABLE:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TR: {
          if (p.openElements.hasInTableScope(tn)) {
            p._closeTableCell();
            endTagInRow2(p, token);
          }
          break;
        }
        case html_js_1.TAG_ID.BODY:
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COL:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.HTML: {
          break;
        }
        default: {
          endTagInBody2(p, token);
        }
      }
    }
    function startTagInSelect2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.OPTION: {
          if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
            p.openElements.pop();
          }
          p._insertElement(token, html_js_1.NS.HTML);
          break;
        }
        case html_js_1.TAG_ID.OPTGROUP: {
          if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
            p.openElements.pop();
          }
          if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
            p.openElements.pop();
          }
          p._insertElement(token, html_js_1.NS.HTML);
          break;
        }
        case html_js_1.TAG_ID.INPUT:
        case html_js_1.TAG_ID.KEYGEN:
        case html_js_1.TAG_ID.TEXTAREA:
        case html_js_1.TAG_ID.SELECT: {
          if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
            p._resetInsertionMode();
            if (token.tagID !== html_js_1.TAG_ID.SELECT) {
              p._processStartTag(token);
            }
          }
          break;
        }
        case html_js_1.TAG_ID.SCRIPT:
        case html_js_1.TAG_ID.TEMPLATE: {
          startTagInHead2(p, token);
          break;
        }
        default:
      }
    }
    function endTagInSelect2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.OPTGROUP: {
          if (p.openElements.stackTop > 0 && p.openElements.currentTagId === html_js_1.TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === html_js_1.TAG_ID.OPTGROUP) {
            p.openElements.pop();
          }
          if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
            p.openElements.pop();
          }
          break;
        }
        case html_js_1.TAG_ID.OPTION: {
          if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
            p.openElements.pop();
          }
          break;
        }
        case html_js_1.TAG_ID.SELECT: {
          if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
            p._resetInsertionMode();
          }
          break;
        }
        case html_js_1.TAG_ID.TEMPLATE: {
          templateEndTagInHead2(p, token);
          break;
        }
        default:
      }
    }
    function startTagInSelectInTable2(p, token) {
      const tn = token.tagID;
      if (tn === html_js_1.TAG_ID.CAPTION || tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.TBODY || tn === html_js_1.TAG_ID.TFOOT || tn === html_js_1.TAG_ID.THEAD || tn === html_js_1.TAG_ID.TR || tn === html_js_1.TAG_ID.TD || tn === html_js_1.TAG_ID.TH) {
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
        p._resetInsertionMode();
        p._processStartTag(token);
      } else {
        startTagInSelect2(p, token);
      }
    }
    function endTagInSelectInTable2(p, token) {
      const tn = token.tagID;
      if (tn === html_js_1.TAG_ID.CAPTION || tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.TBODY || tn === html_js_1.TAG_ID.TFOOT || tn === html_js_1.TAG_ID.THEAD || tn === html_js_1.TAG_ID.TR || tn === html_js_1.TAG_ID.TD || tn === html_js_1.TAG_ID.TH) {
        if (p.openElements.hasInTableScope(tn)) {
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
          p._resetInsertionMode();
          p.onEndTag(token);
        }
      } else {
        endTagInSelect2(p, token);
      }
    }
    function startTagInTemplate2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.BASE:
        case html_js_1.TAG_ID.BASEFONT:
        case html_js_1.TAG_ID.BGSOUND:
        case html_js_1.TAG_ID.LINK:
        case html_js_1.TAG_ID.META:
        case html_js_1.TAG_ID.NOFRAMES:
        case html_js_1.TAG_ID.SCRIPT:
        case html_js_1.TAG_ID.STYLE:
        case html_js_1.TAG_ID.TEMPLATE:
        case html_js_1.TAG_ID.TITLE: {
          startTagInHead2(p, token);
          break;
        }
        case html_js_1.TAG_ID.CAPTION:
        case html_js_1.TAG_ID.COLGROUP:
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.TFOOT:
        case html_js_1.TAG_ID.THEAD: {
          p.tmplInsertionModeStack[0] = InsertionMode2.IN_TABLE;
          p.insertionMode = InsertionMode2.IN_TABLE;
          startTagInTable2(p, token);
          break;
        }
        case html_js_1.TAG_ID.COL: {
          p.tmplInsertionModeStack[0] = InsertionMode2.IN_COLUMN_GROUP;
          p.insertionMode = InsertionMode2.IN_COLUMN_GROUP;
          startTagInColumnGroup2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TR: {
          p.tmplInsertionModeStack[0] = InsertionMode2.IN_TABLE_BODY;
          p.insertionMode = InsertionMode2.IN_TABLE_BODY;
          startTagInTableBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH: {
          p.tmplInsertionModeStack[0] = InsertionMode2.IN_ROW;
          p.insertionMode = InsertionMode2.IN_ROW;
          startTagInRow2(p, token);
          break;
        }
        default: {
          p.tmplInsertionModeStack[0] = InsertionMode2.IN_BODY;
          p.insertionMode = InsertionMode2.IN_BODY;
          startTagInBody2(p, token);
        }
      }
    }
    function endTagInTemplate2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.TEMPLATE) {
        templateEndTagInHead2(p, token);
      }
    }
    function eofInTemplate2(p, token) {
      if (p.openElements.tmplCount > 0) {
        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p.tmplInsertionModeStack.shift();
        p._resetInsertionMode();
        p.onEof(token);
      } else {
        stopParsing2(p, token);
      }
    }
    function startTagAfterBody2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.HTML) {
        startTagInBody2(p, token);
      } else {
        tokenAfterBody2(p, token);
      }
    }
    function endTagAfterBody2(p, token) {
      var _a2;
      if (token.tagID === html_js_1.TAG_ID.HTML) {
        if (!p.fragmentContext) {
          p.insertionMode = InsertionMode2.AFTER_AFTER_BODY;
        }
        if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === html_js_1.TAG_ID.HTML) {
          p._setEndLocation(p.openElements.items[0], token);
          const bodyElement = p.openElements.items[1];
          if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
            p._setEndLocation(bodyElement, token);
          }
        }
      } else {
        tokenAfterBody2(p, token);
      }
    }
    function tokenAfterBody2(p, token) {
      p.insertionMode = InsertionMode2.IN_BODY;
      modeInBody2(p, token);
    }
    function startTagInFrameset2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.FRAMESET: {
          p._insertElement(token, html_js_1.NS.HTML);
          break;
        }
        case html_js_1.TAG_ID.FRAME: {
          p._appendElement(token, html_js_1.NS.HTML);
          token.ackSelfClosing = true;
          break;
        }
        case html_js_1.TAG_ID.NOFRAMES: {
          startTagInHead2(p, token);
          break;
        }
        default:
      }
    }
    function endTagInFrameset2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
        p.openElements.pop();
        if (!p.fragmentContext && p.openElements.currentTagId !== html_js_1.TAG_ID.FRAMESET) {
          p.insertionMode = InsertionMode2.AFTER_FRAMESET;
        }
      }
    }
    function startTagAfterFrameset2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOFRAMES: {
          startTagInHead2(p, token);
          break;
        }
        default:
      }
    }
    function endTagAfterFrameset2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.HTML) {
        p.insertionMode = InsertionMode2.AFTER_AFTER_FRAMESET;
      }
    }
    function startTagAfterAfterBody2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.HTML) {
        startTagInBody2(p, token);
      } else {
        tokenAfterAfterBody2(p, token);
      }
    }
    function tokenAfterAfterBody2(p, token) {
      p.insertionMode = InsertionMode2.IN_BODY;
      modeInBody2(p, token);
    }
    function startTagAfterAfterFrameset2(p, token) {
      switch (token.tagID) {
        case html_js_1.TAG_ID.HTML: {
          startTagInBody2(p, token);
          break;
        }
        case html_js_1.TAG_ID.NOFRAMES: {
          startTagInHead2(p, token);
          break;
        }
        default:
      }
    }
    function nullCharacterInForeignContent2(p, token) {
      token.chars = unicode.REPLACEMENT_CHARACTER;
      p._insertCharacters(token);
    }
    function characterInForeignContent2(p, token) {
      p._insertCharacters(token);
      p.framesetOk = false;
    }
    function popUntilHtmlOrIntegrationPoint2(p) {
      while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== html_js_1.NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
        p.openElements.pop();
      }
    }
    function startTagInForeignContent2(p, token) {
      if (foreignContent.causesExit(token)) {
        popUntilHtmlOrIntegrationPoint2(p);
        p._startTagOutsideForeignContent(token);
      } else {
        const current = p._getAdjustedCurrentElement();
        const currentNs = p.treeAdapter.getNamespaceURI(current);
        if (currentNs === html_js_1.NS.MATHML) {
          foreignContent.adjustTokenMathMLAttrs(token);
        } else if (currentNs === html_js_1.NS.SVG) {
          foreignContent.adjustTokenSVGTagName(token);
          foreignContent.adjustTokenSVGAttrs(token);
        }
        foreignContent.adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
          p._appendElement(token, currentNs);
        } else {
          p._insertElement(token, currentNs);
        }
        token.ackSelfClosing = true;
      }
    }
    function endTagInForeignContent2(p, token) {
      if (token.tagID === html_js_1.TAG_ID.P || token.tagID === html_js_1.TAG_ID.BR) {
        popUntilHtmlOrIntegrationPoint2(p);
        p._endTagOutsideForeignContent(token);
        return;
      }
      for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];
        if (p.treeAdapter.getNamespaceURI(element) === html_js_1.NS.HTML) {
          p._endTagOutsideForeignContent(token);
          break;
        }
        const tagName = p.treeAdapter.getTagName(element);
        if (tagName.toLowerCase() === token.tagName) {
          token.tagName = tagName;
          p.openElements.shortenToLength(i);
          break;
        }
      }
    }
  }
});

// node_modules/parse5/dist/cjs/serializer/index.js
var require_serializer = __commonJS({
  "node_modules/parse5/dist/cjs/serializer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeOuter = exports.serialize = void 0;
    var html_js_1 = require_html();
    var escape_js_1 = require_escape();
    var default_js_1 = require_default();
    var VOID_ELEMENTS2 = /* @__PURE__ */ new Set([
      html_js_1.TAG_NAMES.AREA,
      html_js_1.TAG_NAMES.BASE,
      html_js_1.TAG_NAMES.BASEFONT,
      html_js_1.TAG_NAMES.BGSOUND,
      html_js_1.TAG_NAMES.BR,
      html_js_1.TAG_NAMES.COL,
      html_js_1.TAG_NAMES.EMBED,
      html_js_1.TAG_NAMES.FRAME,
      html_js_1.TAG_NAMES.HR,
      html_js_1.TAG_NAMES.IMG,
      html_js_1.TAG_NAMES.INPUT,
      html_js_1.TAG_NAMES.KEYGEN,
      html_js_1.TAG_NAMES.LINK,
      html_js_1.TAG_NAMES.META,
      html_js_1.TAG_NAMES.PARAM,
      html_js_1.TAG_NAMES.SOURCE,
      html_js_1.TAG_NAMES.TRACK,
      html_js_1.TAG_NAMES.WBR
    ]);
    function isVoidElement2(node, options) {
      return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === html_js_1.NS.HTML && VOID_ELEMENTS2.has(options.treeAdapter.getTagName(node));
    }
    var defaultOpts4 = { treeAdapter: default_js_1.defaultTreeAdapter, scriptingEnabled: true };
    function serialize3(node, options) {
      const opts = Object.assign(Object.assign({}, defaultOpts4), options);
      if (isVoidElement2(node, opts)) {
        return "";
      }
      return serializeChildNodes2(node, opts);
    }
    exports.serialize = serialize3;
    function serializeOuter2(node, options) {
      const opts = Object.assign(Object.assign({}, defaultOpts4), options);
      return serializeNode2(node, opts);
    }
    exports.serializeOuter = serializeOuter2;
    function serializeChildNodes2(parentNode, options) {
      let html3 = "";
      const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === html_js_1.TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === html_js_1.NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
      const childNodes = options.treeAdapter.getChildNodes(container);
      if (childNodes) {
        for (const currentNode of childNodes) {
          html3 += serializeNode2(currentNode, options);
        }
      }
      return html3;
    }
    function serializeNode2(node, options) {
      if (options.treeAdapter.isElementNode(node)) {
        return serializeElement2(node, options);
      }
      if (options.treeAdapter.isTextNode(node)) {
        return serializeTextNode2(node, options);
      }
      if (options.treeAdapter.isCommentNode(node)) {
        return serializeCommentNode2(node, options);
      }
      if (options.treeAdapter.isDocumentTypeNode(node)) {
        return serializeDocumentTypeNode2(node, options);
      }
      return "";
    }
    function serializeElement2(node, options) {
      const tn = options.treeAdapter.getTagName(node);
      return `<${tn}${serializeAttributes2(node, options)}>${isVoidElement2(node, options) ? "" : `${serializeChildNodes2(node, options)}</${tn}>`}`;
    }
    function serializeAttributes2(node, { treeAdapter }) {
      let html3 = "";
      for (const attr2 of treeAdapter.getAttrList(node)) {
        html3 += " ";
        if (!attr2.namespace) {
          html3 += attr2.name;
        } else
          switch (attr2.namespace) {
            case html_js_1.NS.XML: {
              html3 += `xml:${attr2.name}`;
              break;
            }
            case html_js_1.NS.XMLNS: {
              if (attr2.name !== "xmlns") {
                html3 += "xmlns:";
              }
              html3 += attr2.name;
              break;
            }
            case html_js_1.NS.XLINK: {
              html3 += `xlink:${attr2.name}`;
              break;
            }
            default: {
              html3 += `${attr2.prefix}:${attr2.name}`;
            }
          }
        html3 += `="${(0, escape_js_1.escapeAttribute)(attr2.value)}"`;
      }
      return html3;
    }
    function serializeTextNode2(node, options) {
      const { treeAdapter } = options;
      const content = treeAdapter.getTextNodeContent(node);
      const parent2 = treeAdapter.getParentNode(node);
      const parentTn = parent2 && treeAdapter.isElementNode(parent2) && treeAdapter.getTagName(parent2);
      return parentTn && treeAdapter.getNamespaceURI(parent2) === html_js_1.NS.HTML && (0, html_js_1.hasUnescapedText)(parentTn, options.scriptingEnabled) ? content : (0, escape_js_1.escapeText)(content);
    }
    function serializeCommentNode2(node, { treeAdapter }) {
      return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
    }
    function serializeDocumentTypeNode2(node, { treeAdapter }) {
      return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
    }
  }
});

// node_modules/parse5/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/parse5/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFragment = exports.parse = exports.TokenizerMode = exports.Tokenizer = exports.Token = exports.html = exports.foreignContent = exports.ErrorCodes = exports.serializeOuter = exports.serialize = exports.Parser = exports.defaultTreeAdapter = void 0;
    var index_js_1 = require_parser2();
    var default_js_1 = require_default();
    Object.defineProperty(exports, "defaultTreeAdapter", { enumerable: true, get: function() {
      return default_js_1.defaultTreeAdapter;
    } });
    var index_js_2 = require_parser2();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return index_js_2.Parser;
    } });
    var index_js_3 = require_serializer();
    Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
      return index_js_3.serialize;
    } });
    Object.defineProperty(exports, "serializeOuter", { enumerable: true, get: function() {
      return index_js_3.serializeOuter;
    } });
    var error_codes_js_1 = require_error_codes();
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return error_codes_js_1.ERR;
    } });
    exports.foreignContent = require_foreign_content();
    exports.html = require_html();
    exports.Token = require_token();
    var index_js_4 = require_tokenizer();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return index_js_4.Tokenizer;
    } });
    Object.defineProperty(exports, "TokenizerMode", { enumerable: true, get: function() {
      return index_js_4.TokenizerMode;
    } });
    function parse9(html3, options) {
      return index_js_1.Parser.parse(html3, options);
    }
    exports.parse = parse9;
    function parseFragment2(fragmentContext, html3, options) {
      if (typeof fragmentContext === "string") {
        options = html3;
        html3 = fragmentContext;
        fragmentContext = null;
      }
      const parser = index_js_1.Parser.getFragmentParser(fragmentContext, options);
      parser.tokenizer.write(html3, true);
      return parser.getFragment();
    }
    exports.parseFragment = parseFragment2;
  }
});

// node_modules/parse5-htmlparser2-tree-adapter/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/parse5-htmlparser2-tree-adapter/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.adapter = exports.serializeDoctypeContent = void 0;
    var parse5_1 = require_cjs();
    var domhandler_1 = require_lib7();
    function createTextNode3(value2) {
      return new domhandler_1.Text(value2);
    }
    function enquoteDoctypeId2(id) {
      const quote = id.includes('"') ? "'" : '"';
      return quote + id + quote;
    }
    function serializeDoctypeContent2(name, publicId, systemId) {
      let str = "!DOCTYPE ";
      if (name) {
        str += name;
      }
      if (publicId) {
        str += ` PUBLIC ${enquoteDoctypeId2(publicId)}`;
      } else if (systemId) {
        str += " SYSTEM";
      }
      if (systemId) {
        str += ` ${enquoteDoctypeId2(systemId)}`;
      }
      return str;
    }
    exports.serializeDoctypeContent = serializeDoctypeContent2;
    exports.adapter = {
      // Re-exports from domhandler
      isCommentNode: domhandler_1.isComment,
      isElementNode: domhandler_1.isTag,
      isTextNode: domhandler_1.isText,
      //Node construction
      createDocument() {
        const node = new domhandler_1.Document([]);
        node["x-mode"] = parse5_1.html.DOCUMENT_MODE.NO_QUIRKS;
        return node;
      },
      createDocumentFragment() {
        return new domhandler_1.Document([]);
      },
      createElement(tagName, namespaceURI, attrs) {
        const attribs = /* @__PURE__ */ Object.create(null);
        const attribsNamespace = /* @__PURE__ */ Object.create(null);
        const attribsPrefix = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < attrs.length; i++) {
          const attrName = attrs[i].name;
          attribs[attrName] = attrs[i].value;
          attribsNamespace[attrName] = attrs[i].namespace;
          attribsPrefix[attrName] = attrs[i].prefix;
        }
        const node = new domhandler_1.Element(tagName, attribs, []);
        node.namespace = namespaceURI;
        node["x-attribsNamespace"] = attribsNamespace;
        node["x-attribsPrefix"] = attribsPrefix;
        return node;
      },
      createCommentNode(data3) {
        return new domhandler_1.Comment(data3);
      },
      //Tree mutation
      appendChild(parentNode, newNode) {
        const prev2 = parentNode.children[parentNode.children.length - 1];
        if (prev2) {
          prev2.next = newNode;
          newNode.prev = prev2;
        }
        parentNode.children.push(newNode);
        newNode.parent = parentNode;
      },
      insertBefore(parentNode, newNode, referenceNode) {
        const insertionIdx = parentNode.children.indexOf(referenceNode);
        const { prev: prev2 } = referenceNode;
        if (prev2) {
          prev2.next = newNode;
          newNode.prev = prev2;
        }
        referenceNode.prev = newNode;
        newNode.next = referenceNode;
        parentNode.children.splice(insertionIdx, 0, newNode);
        newNode.parent = parentNode;
      },
      setTemplateContent(templateElement, contentElement) {
        exports.adapter.appendChild(templateElement, contentElement);
      },
      getTemplateContent(templateElement) {
        return templateElement.children[0];
      },
      setDocumentType(document2, name, publicId, systemId) {
        const data3 = serializeDoctypeContent2(name, publicId, systemId);
        let doctypeNode = document2.children.find((node) => (0, domhandler_1.isDirective)(node) && node.name === "!doctype");
        if (doctypeNode) {
          doctypeNode.data = data3 !== null && data3 !== void 0 ? data3 : null;
        } else {
          doctypeNode = new domhandler_1.ProcessingInstruction("!doctype", data3);
          exports.adapter.appendChild(document2, doctypeNode);
        }
        doctypeNode["x-name"] = name !== null && name !== void 0 ? name : void 0;
        doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
        doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
      },
      setDocumentMode(document2, mode) {
        document2["x-mode"] = mode;
      },
      getDocumentMode(document2) {
        return document2["x-mode"];
      },
      detachNode(node) {
        if (node.parent) {
          const idx = node.parent.children.indexOf(node);
          const { prev: prev2, next: next2 } = node;
          node.prev = null;
          node.next = null;
          if (prev2) {
            prev2.next = next2;
          }
          if (next2) {
            next2.prev = prev2;
          }
          node.parent.children.splice(idx, 1);
          node.parent = null;
        }
      },
      insertText(parentNode, text3) {
        const lastChild = parentNode.children[parentNode.children.length - 1];
        if (lastChild && (0, domhandler_1.isText)(lastChild)) {
          lastChild.data += text3;
        } else {
          exports.adapter.appendChild(parentNode, createTextNode3(text3));
        }
      },
      insertTextBefore(parentNode, text3, referenceNode) {
        const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
        if (prevNode && (0, domhandler_1.isText)(prevNode)) {
          prevNode.data += text3;
        } else {
          exports.adapter.insertBefore(parentNode, createTextNode3(text3), referenceNode);
        }
      },
      adoptAttributes(recipient, attrs) {
        for (let i = 0; i < attrs.length; i++) {
          const attrName = attrs[i].name;
          if (typeof recipient.attribs[attrName] === "undefined") {
            recipient.attribs[attrName] = attrs[i].value;
            recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
            recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
          }
        }
      },
      //Tree traversing
      getFirstChild(node) {
        return node.children[0];
      },
      getChildNodes(node) {
        return node.children;
      },
      getParentNode(node) {
        return node.parent;
      },
      getAttrList(element) {
        return element.attributes;
      },
      //Node data
      getTagName(element) {
        return element.name;
      },
      getNamespaceURI(element) {
        return element.namespace;
      },
      getTextNodeContent(textNode) {
        return textNode.data;
      },
      getCommentNodeContent(commentNode) {
        return commentNode.data;
      },
      getDocumentTypeNodeName(doctypeNode) {
        var _a2;
        return (_a2 = doctypeNode["x-name"]) !== null && _a2 !== void 0 ? _a2 : "";
      },
      getDocumentTypeNodePublicId(doctypeNode) {
        var _a2;
        return (_a2 = doctypeNode["x-publicId"]) !== null && _a2 !== void 0 ? _a2 : "";
      },
      getDocumentTypeNodeSystemId(doctypeNode) {
        var _a2;
        return (_a2 = doctypeNode["x-systemId"]) !== null && _a2 !== void 0 ? _a2 : "";
      },
      //Node types
      isDocumentTypeNode(node) {
        return (0, domhandler_1.isDirective)(node) && node.name === "!doctype";
      },
      // Source code location
      setNodeSourceCodeLocation(node, location) {
        if (location) {
          node.startIndex = location.startOffset;
          node.endIndex = location.endOffset;
        }
        node.sourceCodeLocation = location;
      },
      getNodeSourceCodeLocation(node) {
        return node.sourceCodeLocation;
      },
      updateNodeSourceCodeLocation(node, endLocation) {
        if (endLocation.endOffset != null)
          node.endIndex = endLocation.endOffset;
        node.sourceCodeLocation = Object.assign(Object.assign({}, node.sourceCodeLocation), endLocation);
      }
    };
  }
});

// node_modules/cheerio/lib/parsers/parse5-adapter.js
var require_parse5_adapter = __commonJS({
  "node_modules/cheerio/lib/parsers/parse5-adapter.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderWithParse5 = exports.parseWithParse5 = void 0;
    var domhandler_1 = require_lib7();
    var parse5_1 = require_cjs();
    var parse5_htmlparser2_tree_adapter_1 = require_cjs2();
    function parseWithParse52(content, options, isDocument2, context) {
      var opts = {
        scriptingEnabled: typeof options.scriptingEnabled === "boolean" ? options.scriptingEnabled : true,
        treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter,
        sourceCodeLocationInfo: options.sourceCodeLocationInfo
      };
      return isDocument2 ? (0, parse5_1.parse)(content, opts) : (0, parse5_1.parseFragment)(context, content, opts);
    }
    exports.parseWithParse5 = parseWithParse52;
    var renderOpts2 = { treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter };
    function renderWithParse52(dom) {
      var _a2;
      var nodes = "length" in dom ? dom : [dom];
      for (var index2 = 0; index2 < nodes.length; index2 += 1) {
        var node = nodes[index2];
        if ((0, domhandler_1.isDocument)(node)) {
          (_a2 = Array.prototype.splice).call.apply(_a2, __spreadArray([nodes, index2, 1], node.children, false));
        }
      }
      var result = "";
      for (var index2 = 0; index2 < nodes.length; index2 += 1) {
        var node = nodes[index2];
        result += (0, parse5_1.serializeOuter)(node, renderOpts2);
      }
      return result;
    }
    exports.renderWithParse5 = renderWithParse52;
  }
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuoteType = void 0;
    var decode_js_1 = require_decode();
    var CharCodes3;
    (function(CharCodes4) {
      CharCodes4[CharCodes4["Tab"] = 9] = "Tab";
      CharCodes4[CharCodes4["NewLine"] = 10] = "NewLine";
      CharCodes4[CharCodes4["FormFeed"] = 12] = "FormFeed";
      CharCodes4[CharCodes4["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes4[CharCodes4["Space"] = 32] = "Space";
      CharCodes4[CharCodes4["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes4[CharCodes4["Number"] = 35] = "Number";
      CharCodes4[CharCodes4["Amp"] = 38] = "Amp";
      CharCodes4[CharCodes4["SingleQuote"] = 39] = "SingleQuote";
      CharCodes4[CharCodes4["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes4[CharCodes4["Dash"] = 45] = "Dash";
      CharCodes4[CharCodes4["Slash"] = 47] = "Slash";
      CharCodes4[CharCodes4["Zero"] = 48] = "Zero";
      CharCodes4[CharCodes4["Nine"] = 57] = "Nine";
      CharCodes4[CharCodes4["Semi"] = 59] = "Semi";
      CharCodes4[CharCodes4["Lt"] = 60] = "Lt";
      CharCodes4[CharCodes4["Eq"] = 61] = "Eq";
      CharCodes4[CharCodes4["Gt"] = 62] = "Gt";
      CharCodes4[CharCodes4["Questionmark"] = 63] = "Questionmark";
      CharCodes4[CharCodes4["UpperA"] = 65] = "UpperA";
      CharCodes4[CharCodes4["LowerA"] = 97] = "LowerA";
      CharCodes4[CharCodes4["UpperF"] = 70] = "UpperF";
      CharCodes4[CharCodes4["LowerF"] = 102] = "LowerF";
      CharCodes4[CharCodes4["UpperZ"] = 90] = "UpperZ";
      CharCodes4[CharCodes4["LowerZ"] = 122] = "LowerZ";
      CharCodes4[CharCodes4["LowerX"] = 120] = "LowerX";
      CharCodes4[CharCodes4["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes3 || (CharCodes3 = {}));
    var State3;
    (function(State4) {
      State4[State4["Text"] = 1] = "Text";
      State4[State4["BeforeTagName"] = 2] = "BeforeTagName";
      State4[State4["InTagName"] = 3] = "InTagName";
      State4[State4["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State4[State4["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State4[State4["InClosingTagName"] = 6] = "InClosingTagName";
      State4[State4["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      State4[State4["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State4[State4["InAttributeName"] = 9] = "InAttributeName";
      State4[State4["AfterAttributeName"] = 10] = "AfterAttributeName";
      State4[State4["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State4[State4["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State4[State4["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State4[State4["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      State4[State4["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State4[State4["InDeclaration"] = 16] = "InDeclaration";
      State4[State4["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      State4[State4["BeforeComment"] = 18] = "BeforeComment";
      State4[State4["CDATASequence"] = 19] = "CDATASequence";
      State4[State4["InSpecialComment"] = 20] = "InSpecialComment";
      State4[State4["InCommentLike"] = 21] = "InCommentLike";
      State4[State4["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State4[State4["SpecialStartSequence"] = 23] = "SpecialStartSequence";
      State4[State4["InSpecialTag"] = 24] = "InSpecialTag";
      State4[State4["BeforeEntity"] = 25] = "BeforeEntity";
      State4[State4["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
      State4[State4["InNamedEntity"] = 27] = "InNamedEntity";
      State4[State4["InNumericEntity"] = 28] = "InNumericEntity";
      State4[State4["InHexEntity"] = 29] = "InHexEntity";
    })(State3 || (State3 = {}));
    function isWhitespace3(c) {
      return c === CharCodes3.Space || c === CharCodes3.NewLine || c === CharCodes3.Tab || c === CharCodes3.FormFeed || c === CharCodes3.CarriageReturn;
    }
    function isEndOfTagSection2(c) {
      return c === CharCodes3.Slash || c === CharCodes3.Gt || isWhitespace3(c);
    }
    function isNumber3(c) {
      return c >= CharCodes3.Zero && c <= CharCodes3.Nine;
    }
    function isASCIIAlpha2(c) {
      return c >= CharCodes3.LowerA && c <= CharCodes3.LowerZ || c >= CharCodes3.UpperA && c <= CharCodes3.UpperZ;
    }
    function isHexDigit2(c) {
      return c >= CharCodes3.UpperA && c <= CharCodes3.UpperF || c >= CharCodes3.LowerA && c <= CharCodes3.LowerF;
    }
    var QuoteType2;
    (function(QuoteType3) {
      QuoteType3[QuoteType3["NoValue"] = 0] = "NoValue";
      QuoteType3[QuoteType3["Unquoted"] = 1] = "Unquoted";
      QuoteType3[QuoteType3["Single"] = 2] = "Single";
      QuoteType3[QuoteType3["Double"] = 3] = "Double";
    })(QuoteType2 = exports.QuoteType || (exports.QuoteType = {}));
    var Sequences2 = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    };
    var Tokenizer3 = (
      /** @class */
      function() {
        function Tokenizer4(_a2, cbs) {
          var _b = _a2.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a2.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this.state = State3.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State3.Text;
          this.isSpecial = false;
          this.running = true;
          this.offset = 0;
          this.currentSequence = void 0;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.entityResult = 0;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
        }
        Tokenizer4.prototype.reset = function() {
          this.state = State3.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State3.Text;
          this.currentSequence = void 0;
          this.running = true;
          this.offset = 0;
        };
        Tokenizer4.prototype.write = function(chunk) {
          this.offset += this.buffer.length;
          this.buffer = chunk;
          this.parse();
        };
        Tokenizer4.prototype.end = function() {
          if (this.running)
            this.finish();
        };
        Tokenizer4.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer4.prototype.resume = function() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
            this.parse();
          }
        };
        Tokenizer4.prototype.getIndex = function() {
          return this.index;
        };
        Tokenizer4.prototype.getSectionStart = function() {
          return this.sectionStart;
        };
        Tokenizer4.prototype.stateText = function(c) {
          if (c === CharCodes3.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes3.Lt)) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State3.BeforeTagName;
            this.sectionStart = this.index;
          } else if (this.decodeEntities && c === CharCodes3.Amp) {
            this.state = State3.BeforeEntity;
          }
        };
        Tokenizer4.prototype.stateSpecialStartSequence = function(c) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch = isEnd ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            isEndOfTagSection2(c)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (c | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!isMatch) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this.state = State3.InTagName;
          this.stateInTagName(c);
        };
        Tokenizer4.prototype.stateInSpecialTag = function(c) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes3.Gt || isWhitespace3(c)) {
              var endOfText = this.index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this.index;
                this.index = endOfText;
                this.cbs.ontext(this.sectionStart, endOfText);
                this.index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences2.TitleEnd) {
              if (this.decodeEntities && c === CharCodes3.Amp) {
                this.state = State3.BeforeEntity;
              }
            } else if (this.fastForwardTo(CharCodes3.Lt)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(c === CharCodes3.Lt);
          }
        };
        Tokenizer4.prototype.stateCDATASequence = function(c) {
          if (c === Sequences2.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences2.Cdata.length) {
              this.state = State3.InCommentLike;
              this.currentSequence = Sequences2.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = State3.InDeclaration;
            this.stateInDeclaration(c);
          }
        };
        Tokenizer4.prototype.fastForwardTo = function(c) {
          while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
              return true;
            }
          }
          this.index = this.buffer.length + this.offset - 1;
          return false;
        };
        Tokenizer4.prototype.stateInCommentLike = function(c) {
          if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Sequences2.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index, 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index, 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = State3.Text;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer4.prototype.isTagStartChar = function(c) {
          return this.xmlMode ? !isEndOfTagSection2(c) : isASCIIAlpha2(c);
        };
        Tokenizer4.prototype.startSpecial = function(sequence, offset) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset;
          this.state = State3.SpecialStartSequence;
        };
        Tokenizer4.prototype.stateBeforeTagName = function(c) {
          if (c === CharCodes3.ExclamationMark) {
            this.state = State3.BeforeDeclaration;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes3.Questionmark) {
            this.state = State3.InProcessingInstruction;
            this.sectionStart = this.index + 1;
          } else if (this.isTagStartChar(c)) {
            var lower = c | 32;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences2.TitleEnd[2]) {
              this.startSpecial(Sequences2.TitleEnd, 3);
            } else {
              this.state = !this.xmlMode && lower === Sequences2.ScriptEnd[2] ? State3.BeforeSpecialS : State3.InTagName;
            }
          } else if (c === CharCodes3.Slash) {
            this.state = State3.BeforeClosingTagName;
          } else {
            this.state = State3.Text;
            this.stateText(c);
          }
        };
        Tokenizer4.prototype.stateInTagName = function(c) {
          if (isEndOfTagSection2(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State3.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer4.prototype.stateBeforeClosingTagName = function(c) {
          if (isWhitespace3(c)) {
          } else if (c === CharCodes3.Gt) {
            this.state = State3.Text;
          } else {
            this.state = this.isTagStartChar(c) ? State3.InClosingTagName : State3.InSpecialComment;
            this.sectionStart = this.index;
          }
        };
        Tokenizer4.prototype.stateInClosingTagName = function(c) {
          if (c === CharCodes3.Gt || isWhitespace3(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State3.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
          }
        };
        Tokenizer4.prototype.stateAfterClosingTagName = function(c) {
          if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
            this.state = State3.Text;
            this.baseState = State3.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer4.prototype.stateBeforeAttributeName = function(c) {
          if (c === CharCodes3.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
              this.state = State3.InSpecialTag;
              this.sequenceIndex = 0;
            } else {
              this.state = State3.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes3.Slash) {
            this.state = State3.InSelfClosingTag;
          } else if (!isWhitespace3(c)) {
            this.state = State3.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer4.prototype.stateInSelfClosingTag = function(c) {
          if (c === CharCodes3.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State3.Text;
            this.baseState = State3.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace3(c)) {
            this.state = State3.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer4.prototype.stateInAttributeName = function(c) {
          if (c === CharCodes3.Eq || isEndOfTagSection2(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State3.AfterAttributeName;
            this.stateAfterAttributeName(c);
          }
        };
        Tokenizer4.prototype.stateAfterAttributeName = function(c) {
          if (c === CharCodes3.Eq) {
            this.state = State3.BeforeAttributeValue;
          } else if (c === CharCodes3.Slash || c === CharCodes3.Gt) {
            this.cbs.onattribend(QuoteType2.NoValue, this.index);
            this.state = State3.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          } else if (!isWhitespace3(c)) {
            this.cbs.onattribend(QuoteType2.NoValue, this.index);
            this.state = State3.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer4.prototype.stateBeforeAttributeValue = function(c) {
          if (c === CharCodes3.DoubleQuote) {
            this.state = State3.InAttributeValueDq;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes3.SingleQuote) {
            this.state = State3.InAttributeValueSq;
            this.sectionStart = this.index + 1;
          } else if (!isWhitespace3(c)) {
            this.sectionStart = this.index;
            this.state = State3.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c);
          }
        };
        Tokenizer4.prototype.handleInAttributeValue = function(c, quote) {
          if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes3.DoubleQuote ? QuoteType2.Double : QuoteType2.Single, this.index);
            this.state = State3.BeforeAttributeName;
          } else if (this.decodeEntities && c === CharCodes3.Amp) {
            this.baseState = this.state;
            this.state = State3.BeforeEntity;
          }
        };
        Tokenizer4.prototype.stateInAttributeValueDoubleQuotes = function(c) {
          this.handleInAttributeValue(c, CharCodes3.DoubleQuote);
        };
        Tokenizer4.prototype.stateInAttributeValueSingleQuotes = function(c) {
          this.handleInAttributeValue(c, CharCodes3.SingleQuote);
        };
        Tokenizer4.prototype.stateInAttributeValueNoQuotes = function(c) {
          if (isWhitespace3(c) || c === CharCodes3.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType2.Unquoted, this.index);
            this.state = State3.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          } else if (this.decodeEntities && c === CharCodes3.Amp) {
            this.baseState = this.state;
            this.state = State3.BeforeEntity;
          }
        };
        Tokenizer4.prototype.stateBeforeDeclaration = function(c) {
          if (c === CharCodes3.OpeningSquareBracket) {
            this.state = State3.CDATASequence;
            this.sequenceIndex = 0;
          } else {
            this.state = c === CharCodes3.Dash ? State3.BeforeComment : State3.InDeclaration;
          }
        };
        Tokenizer4.prototype.stateInDeclaration = function(c) {
          if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State3.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer4.prototype.stateInProcessingInstruction = function(c) {
          if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State3.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer4.prototype.stateBeforeComment = function(c) {
          if (c === CharCodes3.Dash) {
            this.state = State3.InCommentLike;
            this.currentSequence = Sequences2.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = State3.InDeclaration;
          }
        };
        Tokenizer4.prototype.stateInSpecialComment = function(c) {
          if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State3.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer4.prototype.stateBeforeSpecialS = function(c) {
          var lower = c | 32;
          if (lower === Sequences2.ScriptEnd[3]) {
            this.startSpecial(Sequences2.ScriptEnd, 4);
          } else if (lower === Sequences2.StyleEnd[3]) {
            this.startSpecial(Sequences2.StyleEnd, 4);
          } else {
            this.state = State3.InTagName;
            this.stateInTagName(c);
          }
        };
        Tokenizer4.prototype.stateBeforeEntity = function(c) {
          this.entityExcess = 1;
          this.entityResult = 0;
          if (c === CharCodes3.Number) {
            this.state = State3.BeforeNumericEntity;
          } else if (c === CharCodes3.Amp) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State3.InNamedEntity;
            this.stateInNamedEntity(c);
          }
        };
        Tokenizer4.prototype.stateInNamedEntity = function(c) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            var valueLength = (masked >> 14) - 1;
            if (!this.allowLegacyEntity() && c !== CharCodes3.Semi) {
              this.trieIndex += valueLength;
            } else {
              var entityStart = this.index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.entityResult = this.trieIndex;
              this.trieIndex += valueLength;
              this.entityExcess = 0;
              this.sectionStart = this.index + 1;
              if (valueLength === 0) {
                this.emitNamedEntity();
              }
            }
          }
        };
        Tokenizer4.prototype.emitNamedEntity = function() {
          this.state = this.baseState;
          if (this.entityResult === 0) {
            return;
          }
          var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (valueLength) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        };
        Tokenizer4.prototype.stateBeforeNumericEntity = function(c) {
          if ((c | 32) === CharCodes3.LowerX) {
            this.entityExcess++;
            this.state = State3.InHexEntity;
          } else {
            this.state = State3.InNumericEntity;
            this.stateInNumericEntity(c);
          }
        };
        Tokenizer4.prototype.emitNumericEntity = function(strict) {
          var entityStart = this.index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + Number(this.state === State3.InHexEntity);
          if (numberStart !== this.index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
          }
          this.state = this.baseState;
        };
        Tokenizer4.prototype.stateInNumericEntity = function(c) {
          if (c === CharCodes3.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber3(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes3.Zero);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer4.prototype.stateInHexEntity = function(c) {
          if (c === CharCodes3.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber3(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes3.Zero);
            this.entityExcess++;
          } else if (isHexDigit2(c)) {
            this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes3.LowerA + 10);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer4.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === State3.Text || this.baseState === State3.InSpecialTag);
        };
        Tokenizer4.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this.index) {
            if (this.state === State3.Text || this.state === State3.InSpecialTag && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (this.state === State3.InAttributeValueDq || this.state === State3.InAttributeValueSq || this.state === State3.InAttributeValueNq) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        };
        Tokenizer4.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        };
        Tokenizer4.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case State3.Text: {
                this.stateText(c);
                break;
              }
              case State3.SpecialStartSequence: {
                this.stateSpecialStartSequence(c);
                break;
              }
              case State3.InSpecialTag: {
                this.stateInSpecialTag(c);
                break;
              }
              case State3.CDATASequence: {
                this.stateCDATASequence(c);
                break;
              }
              case State3.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(c);
                break;
              }
              case State3.InAttributeName: {
                this.stateInAttributeName(c);
                break;
              }
              case State3.InCommentLike: {
                this.stateInCommentLike(c);
                break;
              }
              case State3.InSpecialComment: {
                this.stateInSpecialComment(c);
                break;
              }
              case State3.BeforeAttributeName: {
                this.stateBeforeAttributeName(c);
                break;
              }
              case State3.InTagName: {
                this.stateInTagName(c);
                break;
              }
              case State3.InClosingTagName: {
                this.stateInClosingTagName(c);
                break;
              }
              case State3.BeforeTagName: {
                this.stateBeforeTagName(c);
                break;
              }
              case State3.AfterAttributeName: {
                this.stateAfterAttributeName(c);
                break;
              }
              case State3.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(c);
                break;
              }
              case State3.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(c);
                break;
              }
              case State3.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(c);
                break;
              }
              case State3.AfterClosingTagName: {
                this.stateAfterClosingTagName(c);
                break;
              }
              case State3.BeforeSpecialS: {
                this.stateBeforeSpecialS(c);
                break;
              }
              case State3.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(c);
                break;
              }
              case State3.InSelfClosingTag: {
                this.stateInSelfClosingTag(c);
                break;
              }
              case State3.InDeclaration: {
                this.stateInDeclaration(c);
                break;
              }
              case State3.BeforeDeclaration: {
                this.stateBeforeDeclaration(c);
                break;
              }
              case State3.BeforeComment: {
                this.stateBeforeComment(c);
                break;
              }
              case State3.InProcessingInstruction: {
                this.stateInProcessingInstruction(c);
                break;
              }
              case State3.InNamedEntity: {
                this.stateInNamedEntity(c);
                break;
              }
              case State3.BeforeEntity: {
                this.stateBeforeEntity(c);
                break;
              }
              case State3.InHexEntity: {
                this.stateInHexEntity(c);
                break;
              }
              case State3.InNumericEntity: {
                this.stateInNumericEntity(c);
                break;
              }
              default: {
                this.stateBeforeNumericEntity(c);
              }
            }
            this.index++;
          }
          this.cleanup();
        };
        Tokenizer4.prototype.finish = function() {
          if (this.state === State3.InNamedEntity) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this.index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer4.prototype.handleTrailingData = function() {
          var endIndex = this.buffer.length + this.offset;
          if (this.state === State3.InCommentLike) {
            if (this.currentSequence === Sequences2.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
              this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
          } else if (this.state === State3.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State3.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State3.InTagName || this.state === State3.BeforeAttributeName || this.state === State3.BeforeAttributeValue || this.state === State3.AfterAttributeName || this.state === State3.InAttributeName || this.state === State3.InAttributeValueSq || this.state === State3.InAttributeValueDq || this.state === State3.InAttributeValueNq || this.state === State3.InClosingTagName) {
          } else {
            this.cbs.ontext(this.sectionStart, endIndex);
          }
        };
        Tokenizer4.prototype.emitPartial = function(start, endIndex) {
          if (this.baseState !== State3.Text && this.baseState !== State3.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
          } else {
            this.cbs.ontext(start, endIndex);
          }
        };
        Tokenizer4.prototype.emitCodePoint = function(cp) {
          if (this.baseState !== State3.Text && this.baseState !== State3.InSpecialTag) {
            this.cbs.onattribentity(cp);
          } else {
            this.cbs.ontextentity(cp);
          }
        };
        return Tokenizer4;
      }()
    );
    exports.default = Tokenizer3;
  }
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_js_1 = __importStar(require_Tokenizer());
    var decode_js_1 = require_decode();
    var formTags2 = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag2 = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags2 = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags2 = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags2 = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose2 = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag2],
      ["h1", pTag2],
      ["h2", pTag2],
      ["h3", pTag2],
      ["h4", pTag2],
      ["h5", pTag2],
      ["h6", pTag2],
      ["select", formTags2],
      ["input", formTags2],
      ["output", formTags2],
      ["button", formTags2],
      ["datalist", formTags2],
      ["textarea", formTags2],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags2],
      ["dt", ddtTags2],
      ["address", pTag2],
      ["article", pTag2],
      ["aside", pTag2],
      ["blockquote", pTag2],
      ["details", pTag2],
      ["div", pTag2],
      ["dl", pTag2],
      ["fieldset", pTag2],
      ["figcaption", pTag2],
      ["figure", pTag2],
      ["footer", pTag2],
      ["form", pTag2],
      ["header", pTag2],
      ["hr", pTag2],
      ["main", pTag2],
      ["nav", pTag2],
      ["ol", pTag2],
      ["pre", pTag2],
      ["section", pTag2],
      ["table", pTag2],
      ["ul", pTag2],
      ["rt", rtpTags2],
      ["rp", rtpTags2],
      ["tbody", tableSectionTags2],
      ["tfoot", tableSectionTags2]
    ]);
    var voidElements2 = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements2 = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements2 = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd2 = /\s|\//;
    var Parser3 = (
      /** @class */
      function() {
        function Parser4(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a2, _b, _c, _d, _e;
          this.options = options;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.buffers = [];
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser4.prototype.ontext = function(start, endIndex) {
          var _a2, _b;
          var data3 = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data3);
          this.startIndex = endIndex;
        };
        Parser4.prototype.ontextentity = function(cp) {
          var _a2, _b;
          var index2 = this.tokenizer.getSectionStart();
          this.endIndex = index2 - 1;
          (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, (0, decode_js_1.fromCodePoint)(cp));
          this.startIndex = index2;
        };
        Parser4.prototype.isVoidElement = function(name) {
          return !this.options.xmlMode && voidElements2.has(name);
        };
        Parser4.prototype.onopentagname = function(start, endIndex) {
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.emitOpenTag(name);
        };
        Parser4.prototype.emitOpenTag = function(name) {
          var _a2, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          var impliesClose = !this.options.xmlMode && openImpliesClose2.get(name);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var element = this.stack.pop();
              (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
            }
          }
          if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements2.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements2.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser4.prototype.endOpenTag = function(isImplied) {
          var _a2, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
            (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser4.prototype.onopentagend = function(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.onclosetag = function(start, endIndex) {
          var _a2, _b, _c, _d, _e, _f;
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements2.has(name) || htmlIntegrationElements2.has(name)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count = this.stack.length - pos;
                while (count--) {
                  this.cbs.onclosetag(this.stack.pop(), count !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
              this.emitOpenTag("p");
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name === "br") {
            (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
          }
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.onselfclosingtag = function(endIndex) {
          this.endIndex = endIndex;
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = endIndex + 1;
          } else {
            this.onopentagend(endIndex);
          }
        };
        Parser4.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a2, _b;
          var name = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser4.prototype.onattribname = function(start, endIndex) {
          this.startIndex = start;
          var name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
        };
        Parser4.prototype.onattribdata = function(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
        };
        Parser4.prototype.onattribentity = function(cp) {
          this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
        };
        Parser4.prototype.onattribend = function(quote, endIndex) {
          var _a2, _b;
          this.endIndex = endIndex;
          (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
        };
        Parser4.prototype.getInstructionName = function(value2) {
          var index2 = value2.search(reNameEnd2);
          var name = index2 < 0 ? value2 : value2.substr(0, index2);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser4.prototype.ondeclaration = function(start, endIndex) {
          this.endIndex = endIndex;
          var value2 = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value2);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value2));
          }
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.onprocessinginstruction = function(start, endIndex) {
          this.endIndex = endIndex;
          var value2 = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value2);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value2));
          }
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.oncomment = function(start, endIndex, offset) {
          var _a2, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.oncdata = function(start, endIndex, offset) {
          var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          var value2 = this.getSlice(start, endIndex - offset);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value2);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value2, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = endIndex + 1;
        };
        Parser4.prototype.onend = function() {
          var _a2, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
              ;
          }
          (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
        };
        Parser4.prototype.reset = function() {
          var _a2, _b, _c, _d;
          (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
        };
        Parser4.prototype.parseComplete = function(data3) {
          this.reset();
          this.end(data3);
        };
        Parser4.prototype.getSlice = function(start, end2) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
          }
          var slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
          while (end2 - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
          }
          return slice2;
        };
        Parser4.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
        };
        Parser4.prototype.write = function(chunk) {
          var _a2, _b;
          if (this.ended) {
            (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(chunk);
          if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
          }
        };
        Parser4.prototype.end = function(chunk) {
          var _a2, _b;
          if (this.ended) {
            (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
            return;
          }
          if (chunk)
            this.write(chunk);
          this.ended = true;
          this.tokenizer.end();
        };
        Parser4.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser4.prototype.resume = function() {
          this.tokenizer.resume();
          while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
            this.tokenizer.end();
        };
        Parser4.prototype.parseChunk = function(chunk) {
          this.write(chunk);
        };
        Parser4.prototype.done = function(chunk) {
          this.end(chunk);
        };
        return Parser4;
      }()
    );
    exports.Parser = Parser3;
  }
});

// node_modules/htmlparser2/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/htmlparser2/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
    var Parser_js_1 = require_Parser();
    var Parser_js_2 = require_Parser();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_js_2.Parser;
    } });
    var domhandler_1 = require_lib7();
    var domhandler_2 = require_lib7();
    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    function parseDocument2(data3, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_js_1.Parser(handler, options).end(data3);
      return handler.root;
    }
    exports.parseDocument = parseDocument2;
    function parseDOM(data3, options) {
      return parseDocument2(data3, options).children;
    }
    exports.parseDOM = parseDOM;
    function createDomStream(callback, options, elementCallback) {
      var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
      return new Parser_js_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;
    var Tokenizer_js_1 = require_Tokenizer();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_js_1).default;
    } });
    exports.ElementType = __importStar(require_lib6());
    var domutils_1 = require_lib10();
    var domutils_2 = require_lib10();
    Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
      return domutils_2.getFeed;
    } });
    var parseFeedDefaultOptions = { xmlMode: true };
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = parseFeedDefaultOptions;
      }
      return (0, domutils_1.getFeed)(parseDOM(feed, options));
    }
    exports.parseFeed = parseFeed;
    exports.DomUtils = __importStar(require_lib10());
  }
});

// node_modules/cheerio/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/cheerio/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.root = exports.parseHTML = exports.merge = exports.contains = exports.text = exports.xml = exports.html = exports.load = void 0;
    __exportStar(require_types5(), exports);
    var load_js_1 = require_load();
    var parse_js_1 = require_parse4();
    var parse5_adapter_js_1 = require_parse5_adapter();
    var dom_serializer_1 = __importDefault(require_lib9());
    var htmlparser2_1 = require_lib14();
    var parse9 = (0, parse_js_1.getParse)(function(content, options, isDocument2, context) {
      return options.xmlMode || options._useHtmlParser2 ? (0, htmlparser2_1.parseDocument)(content, options) : (0, parse5_adapter_js_1.parseWithParse5)(content, options, isDocument2, context);
    });
    exports.load = (0, load_js_1.getLoad)(parse9, function(dom, options) {
      return options.xmlMode || options._useHtmlParser2 ? (0, dom_serializer_1.default)(dom, options) : (0, parse5_adapter_js_1.renderWithParse5)(dom);
    });
    exports.default = (0, exports.load)([]);
    var static_js_1 = require_static();
    Object.defineProperty(exports, "html", { enumerable: true, get: function() {
      return static_js_1.html;
    } });
    Object.defineProperty(exports, "xml", { enumerable: true, get: function() {
      return static_js_1.xml;
    } });
    Object.defineProperty(exports, "text", { enumerable: true, get: function() {
      return static_js_1.text;
    } });
    var staticMethods = __importStar(require_static());
    exports.contains = staticMethods.contains;
    exports.merge = staticMethods.merge;
    exports.parseHTML = staticMethods.parseHTML;
    exports.root = staticMethods.root;
  }
});

// node_modules/app-store-scraper/lib/ratings.js
var require_ratings = __commonJS({
  "node_modules/app-store-scraper/lib/ratings.js"(exports, module) {
    "use strict";
    var cheerio = require_lib15();
    var common = require_common2();
    function ratings(opts) {
      return new Promise(function(resolve) {
        if (!opts.id) {
          throw Error("id is required");
        }
        const country = opts.country || "us";
        const storeFront = common.storeId(opts.country);
        const idValue = opts.id;
        const url6 = `https://itunes.apple.com/${country}/customer-reviews/id${idValue}?displayable-kind=11`;
        resolve(common.request(url6, {
          "X-Apple-Store-Front": `${storeFront},12`
        }, opts.requestOptions));
      }).then((html3) => {
        if (html3.length === 0) {
          throw Error("App not found (404)");
        }
        return parseRatings(html3);
      });
    }
    module.exports = ratings;
    function parseRatings(html3) {
      const $2 = cheerio.load(html3);
      const ratingsMatch = $2(".rating-count").text().match(/\d+/);
      const ratings2 = Array.isArray(ratingsMatch) ? parseInt(ratingsMatch[0]) : 0;
      const ratingsByStar = $2(".vote .total").map((i, el) => parseInt($2(el).text())).get();
      const histogram = ratingsByStar.reduce((acc, ratingsForStar, index2) => {
        return Object.assign(acc, { [5 - index2]: ratingsForStar });
      }, {});
      return { ratings: ratings2, histogram };
    }
  }
});

// node_modules/app-store-scraper/lib/app.js
var require_app = __commonJS({
  "node_modules/app-store-scraper/lib/app.js"(exports, module) {
    "use strict";
    var common = require_common2();
    var ratings = require_ratings();
    function app2(opts) {
      return new Promise(function(resolve) {
        if (!opts.id && !opts.appId) {
          throw Error("Either id or appId is required");
        }
        const idField = opts.id ? "id" : "bundleId";
        const idValue = opts.id || opts.appId;
        resolve(common.lookup([idValue], idField, opts.country, opts.lang, opts.requestOptions));
      }).then((results) => {
        if (results.length === 0) {
          throw Error("App not found (404)");
        }
        const result = results[0];
        if (opts.ratings) {
          if (!opts.id) {
            opts.id = result.id;
          }
          return ratings(opts).then((ratingsResult) => Object.assign({}, result, ratingsResult));
        }
        return result;
      });
    }
    module.exports = app2;
  }
});

// node_modules/app-store-scraper/lib/list.js
var require_list = __commonJS({
  "node_modules/app-store-scraper/lib/list.js"(exports, module) {
    "use strict";
    var R = require_ramda();
    var common = require_common2();
    var c = require_constants();
    function parseLink(app2) {
      if (app2.link) {
        const linkArray = Array.isArray(app2.link) ? app2.link : [app2.link];
        const link = linkArray.find((link2) => link2.attributes.rel === "alternate");
        return link && link.attributes.href;
      }
      return void 0;
    }
    function cleanApp(app2) {
      let developerUrl, developerId;
      if (app2["im:artist"].attributes) {
        developerUrl = app2["im:artist"].attributes.href;
        if (app2["im:artist"].attributes.href.includes("/id")) {
          developerId = app2["im:artist"].attributes.href.split("/id")[1].split("?mt")[0];
        }
      }
      const price = parseFloat(app2["im:price"].attributes.amount);
      return {
        id: app2.id.attributes["im:id"],
        appId: app2.id.attributes["im:bundleId"],
        title: app2["im:name"].label,
        icon: app2["im:image"][app2["im:image"].length - 1].label,
        url: parseLink(app2),
        price,
        currency: app2["im:price"].attributes.currency,
        free: price === 0,
        description: app2.summary ? app2.summary.label : void 0,
        developer: app2["im:artist"].label,
        developerUrl,
        developerId,
        genre: app2.category.attributes.label,
        genreId: app2.category.attributes["im:id"],
        released: app2["im:releaseDate"].label
      };
    }
    function processResults(opts) {
      return function(results) {
        const apps = results.feed.entry;
        if (opts.fullDetail) {
          const ids = apps.map((app2) => app2.id.attributes["im:id"]);
          return common.lookup(ids, "id", opts.country, opts.lang, opts.requestOptions);
        }
        return apps.map(cleanApp);
      };
    }
    function validate3(opts) {
      if (opts.category && !R.contains(opts.category, R.values(c.category))) {
        throw Error("Invalid category " + opts.category);
      }
      opts.collection = opts.collection || c.collection.TOP_FREE_IOS;
      if (!R.contains(opts.collection, R.values(c.collection))) {
        throw Error(`Invalid collection ${opts.collection}`);
      }
      opts.num = opts.num || 50;
      if (opts.num > 200) {
        throw Error("Cannot retrieve more than 200 apps");
      }
      opts.country = opts.country || "us";
    }
    function list2(opts) {
      return new Promise(function(resolve, reject) {
        opts = R.clone(opts || {});
        validate3(opts);
        const category = opts.category ? `/genre=${opts.category}` : "";
        const storeId = common.storeId(opts.country);
        const url6 = `http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws/RSS/${opts.collection}/${category}/limit=${opts.num}/json?s=${storeId}`;
        common.request(url6, {}, opts.requestOptions).then(JSON.parse).then(processResults(opts)).then(resolve).catch(reject);
      });
    }
    module.exports = list2;
  }
});

// node_modules/app-store-scraper/lib/search.js
var require_search = __commonJS({
  "node_modules/app-store-scraper/lib/search.js"(exports, module) {
    "use strict";
    var R = require_ramda();
    var common = require_common2();
    var BASE_URL2 = "https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?clientApplication=Software&media=software&term=";
    function paginate(num, page) {
      num = num || 50;
      page = page - 1 || 0;
      const pageStart = num * page;
      const pageEnd = pageStart + num;
      return R.slice(pageStart, pageEnd);
    }
    function search2(opts) {
      return new Promise(function(resolve, reject) {
        if (!opts.term) {
          throw Error("term is required");
        }
        const url6 = BASE_URL2 + encodeURIComponent(opts.term);
        const storeId = common.storeId(opts.country);
        const lang = opts.lang || "en-us";
        common.request(
          url6,
          {
            "X-Apple-Store-Front": `${storeId},24 t:native`,
            "Accept-Language": lang
          },
          opts.requestOptions
        ).then(JSON.parse).then((response2) => response2.bubbles[0] && response2.bubbles[0].results || []).then(paginate(opts.num, opts.page)).then(R.pluck("id")).then((ids) => {
          if (!opts.idsOnly) {
            return common.lookup(ids, "id", opts.country, opts.lang, opts.requestOptions);
          }
          return ids;
        }).then(resolve).catch(reject);
      });
    }
    module.exports = search2;
  }
});

// node_modules/app-store-scraper/lib/developer.js
var require_developer = __commonJS({
  "node_modules/app-store-scraper/lib/developer.js"(exports, module) {
    "use strict";
    var common = require_common2();
    function developer2(opts) {
      return new Promise(function(resolve) {
        if (!opts.devId) {
          throw Error("devId is required");
        }
        resolve(common.lookup([opts.devId], "id", opts.country, opts.lang, opts.requestOptions));
      }).then((results) => {
        if (results.length === 0) {
          throw Error("Developer not found (404)");
        }
        return results;
      });
    }
    module.exports = developer2;
  }
});

// node_modules/app-store-scraper/lib/privacy.js
var require_privacy = __commonJS({
  "node_modules/app-store-scraper/lib/privacy.js"(exports, module) {
    "use strict";
    var common = require_common2();
    function privacy(opts) {
      return new Promise((resolve) => {
        if (opts.id) {
          resolve();
        } else {
          throw Error("Either id or appId is required");
        }
      }).then(() => {
        const tokenUrl = `https://apps.apple.com/us/app/id${opts.id}`;
        return common.request(tokenUrl, {}, opts.requestOptions);
      }).then((html3) => {
        const regExp = /token%22%3A%22([^%]+)%22%7D/g;
        const match = regExp.exec(html3);
        const token = match[1];
        const url6 = `https://amp-api.apps.apple.com/v1/catalog/US/apps/${opts.id}?platform=web&fields=privacyDetails&l=en-us`;
        return common.request(url6, {
          "Origin": "https://apps.apple.com",
          "Authorization": `Bearer ${token}`
        }, opts.requestOptions);
      }).then((json) => {
        if (json.length === 0) {
          throw Error("App not found (404)");
        }
        return JSON.parse(json).data[0].attributes.privacyDetails;
      });
    }
    module.exports = privacy;
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports) {
    (function() {
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports, module) {
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice2 = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice2.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val2) {
        return !!val2 && Object.prototype.toString.call(val2) === "[object Function]";
      };
      isObject = function(val2) {
        var ref;
        return !!val2 && ((ref = typeof val2) === "function" || ref === "object");
      };
      isArray = function(val2) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val2);
        } else {
          return Object.prototype.toString.call(val2) === "[object Array]";
        }
      };
      isEmpty = function(val2) {
        var key;
        if (isArray(val2)) {
          return !val2.length;
        } else {
          for (key in val2) {
            if (!hasProp.call(val2, key))
              continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val2) {
        var ctor, proto;
        return isObject(val2) && (proto = Object.getPrototypeOf(val2)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module.exports.assign = assign;
      module.exports.isFunction = isFunction;
      module.exports.isObject = isObject;
      module.exports.isArray = isArray;
      module.exports.isEmpty = isEmpty;
      module.exports.isPlainObject = isPlainObject;
      module.exports.getValue = getValue;
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module) {
    (function() {
      var XMLDOMImplementation;
      module.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module) {
    (function() {
      var XMLDOMErrorHandler;
      module.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        XMLDOMErrorHandler2.prototype.handleError = function(error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module) {
    (function() {
      var XMLDOMStringList;
      module.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        XMLDOMStringList2.prototype.item = function(index2) {
          return this.arr[index2] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module) {
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name) {
          if (this.params.hasOwnProperty(name)) {
            return this.params[name];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name, value2) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name, value2) {
          if (value2 != null) {
            return this.params[name] = value2;
          } else {
            return delete this.params[name];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports, module) {
    (function() {
      module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module) {
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLAttribute = function() {
        function XMLAttribute2(parent2, name, value2) {
          this.parent = parent2;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.value = this.stringify.attValue(value2);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module) {
    (function() {
      var XMLNamedNodeMap;
      module.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
          return this.nodes[name];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
          var oldNode;
          oldNode = this.nodes[name];
          delete this.nodes[name];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index2) {
          return this.nodes[Object.keys(this.nodes)[index2]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module) {
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent2, name, attributes2) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent2);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes2 != null) {
            this.attribute(attributes2);
          }
          if (parent2.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent2;
            parent2.rootObject = this;
            if (parent2.children) {
              ref1 = parent2.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value2) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            if (this.options.keepNullAttributes && value2 == null) {
              this.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value2 != null) {
              this.attribs[name] = new XMLAttribute(this, name, value2);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, j, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              attName = name[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function(name, value2) {
          return this.attribute(name, value2);
        };
        XMLElement2.prototype.a = function(name, value2) {
          return this.attribute(name, value2);
        };
        XMLElement2.prototype.getAttribute = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name, value2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name) {
          return this.attribs.hasOwnProperty(name);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name, isId) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module) {
    (function() {
      var XMLCharacterData, XMLNode, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent2) {
          XMLCharacterData2.__super__.constructor.call(this, parent2);
          this.value = "";
        }
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module) {
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent2, text3) {
          XMLCData2.__super__.constructor.call(this, parent2);
          if (text3 == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text3);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent2, text3) {
          XMLComment2.__super__.constructor.call(this, parent2);
          if (text3 == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text3);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module) {
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent2, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent2);
          if (isObject(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent2, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent2);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent2, pe, name, value2) {
          XMLDTDEntity2.__super__.constructor.call(this, parent2);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value2 == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value2)) {
            this.value = this.stringify.dtdEntityValue(value2);
            this.internal = true;
          } else {
            if (!value2.pubID && !value2.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value2.pubID && !value2.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            this.internal = false;
            if (value2.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value2.pubID);
            }
            if (value2.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value2.sysID);
            }
            if (value2.nData != null) {
              this.nData = this.stringify.dtdNData(value2.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent2, name, value2) {
          XMLDTDElement2.__super__.constructor.call(this, parent2);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value2) {
            value2 = "(#PCDATA)";
          }
          if (Array.isArray(value2)) {
            value2 = "(" + value2.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value2);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent2, name, value2) {
          XMLDTDNotation2.__super__.constructor.call(this, parent2);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value2.pubID && !value2.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.NotationDeclaration;
          if (value2.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value2.pubID);
          }
          if (value2.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value2.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent2, pubID, sysID) {
          var child, i, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent2);
          this.type = NodeType.DocType;
          if (parent2.children) {
            ref = parent2.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent2;
          if (isObject(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLDocType2.prototype.element = function(name, value2) {
          var child;
          child = new XMLDTDElement(this, name, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value2) {
          var child;
          child = new XMLDTDEntity(this, false, name, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value2) {
          var child;
          child = new XMLDTDEntity(this, true, name, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value2) {
          var child;
          child = new XMLDTDNotation(this, name, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function(name, value2) {
          return this.element(name, value2);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value2) {
          return this.entity(name, value2);
        };
        XMLDocType2.prototype.pent = function(name, value2) {
          return this.pEntity(name, value2);
        };
        XMLDocType2.prototype.not = function(name, value2) {
          return this.notation(name, value2);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module) {
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent2, text3) {
          XMLRaw2.__super__.constructor.call(this, parent2);
          if (text3 == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text3);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent2, text3) {
          XMLText2.__super__.constructor.call(this, parent2);
          if (text3 == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text3);
        }
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next2, prev2, str;
            str = "";
            prev2 = this.previousSibling;
            while (prev2) {
              str = prev2.data + str;
              prev2 = prev2.previousSibling;
            }
            str += this.data;
            next2 = this.nextSibling;
            while (next2) {
              str = str + next2.data;
              next2 = next2.nextSibling;
            }
            return str;
          }
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent2, target, value2) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent2);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value2) {
            this.value = this.stringify.insValue(value2);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module) {
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent2) {
          XMLDummy2.__super__.constructor.call(this, parent2);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module) {
    (function() {
      var XMLNodeList;
      module.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index2) {
          return this.nodes[index2] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module) {
    (function() {
      module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module) {
    (function() {
      var DocumentPosition2, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition2 = null;
      module.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition2 = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value2) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLNode2.prototype.setParent = function(parent2) {
          var child, j, len, ref2, results;
          this.parent = parent2;
          if (parent2) {
            this.options = parent2.options;
            this.stringify = parent2.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name, attributes2, text3) {
          var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val2;
          lastChild = null;
          if (attributes2 === null && text3 == null) {
            ref2 = [{}, null], attributes2 = ref2[0], text3 = ref2[1];
          }
          if (attributes2 == null) {
            attributes2 = {};
          }
          attributes2 = getValue(attributes2);
          if (!isObject(attributes2)) {
            ref3 = [attributes2, text3], text3 = ref3[0], attributes2 = ref3[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val2 = name[key];
              if (isFunction(val2)) {
                val2 = val2.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val2);
              } else if (!this.options.separateArrayItems && Array.isArray(val2) && isEmpty(val2)) {
                lastChild = this.dummy();
              } else if (isObject(val2) && isEmpty(val2)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val2 == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val2)) {
                for (k = 0, len1 = val2.length; k < len1; k++) {
                  item = val2[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val2)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val2);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val2);
                }
              } else {
                lastChild = this.element(key, val2);
              }
            }
          } else if (!this.options.keepNullNodes && text3 === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text3);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text3);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text3);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text3);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text3);
            } else {
              lastChild = this.node(name, attributes2, text3);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes2, text3) {
          var child, i, newChild, refChild, removed;
          if (name != null ? name.type : void 0) {
            newChild = name;
            refChild = attributes2;
            newChild.setParent(this);
            if (refChild) {
              i = children.indexOf(refChild);
              removed = children.splice(i);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.element(name, attributes2, text3);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name, attributes2, text3) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes2, text3);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes2, text3) {
          var child, ref2;
          if (name != null) {
            name = getValue(name);
          }
          attributes2 || (attributes2 = {});
          attributes2 = getValue(attributes2);
          if (!isObject(attributes2)) {
            ref2 = [attributes2, text3], text3 = ref2[0], attributes2 = ref2[1];
          }
          child = new XMLElement(this, name, attributes2);
          if (text3 != null) {
            child.text(text3);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value2) {
          var child;
          if (isObject(value2)) {
            this.element(value2);
          }
          child = new XMLText(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value2) {
          var child;
          child = new XMLCData(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value2) {
          var child;
          child = new XMLComment(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value2) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value2) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value2) {
          var child;
          child = new XMLRaw(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value2) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value2 != null) {
            value2 = getValue(value2);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value2);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value2) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value2) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            child = ref2[i];
            if (child.type === NodeType.DocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
            child = ref3[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref2, ref3;
          name = name || this.name;
          if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes2, text3) {
          return this.element(name, attributes2, text3);
        };
        XMLNode2.prototype.nod = function(name, attributes2, text3) {
          return this.node(name, attributes2, text3);
        };
        XMLNode2.prototype.txt = function(value2) {
          return this.text(value2);
        };
        XMLNode2.prototype.dat = function(value2) {
          return this.cdata(value2);
        };
        XMLNode2.prototype.com = function(value2) {
          return this.comment(value2);
        };
        XMLNode2.prototype.ins = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name, attributes2, text3) {
          return this.element(name, attributes2, text3);
        };
        XMLNode2.prototype.n = function(name, attributes2, text3) {
          return this.node(name, attributes2, text3);
        };
        XMLNode2.prototype.t = function(value2) {
          return this.text(value2);
        };
        XMLNode2.prototype.d = function(value2) {
          return this.cdata(value2);
        };
        XMLNode2.prototype.c = function(value2) {
          return this.comment(value2);
        };
        XMLNode2.prototype.r = function(value2) {
          return this.raw(value2);
        };
        XMLNode2.prototype.i = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition2.Disconnected | DocumentPosition2.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition2.Preceding;
            } else {
              res |= DocumentPosition2.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition2.Contains | DocumentPosition2.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition2.Contains | DocumentPosition2.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition2.Preceding;
          } else {
            return DocumentPosition2.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
            if (!this.children[i].isEqualNode(node.children[i])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data3, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module) {
    (function() {
      var XMLStringifier, bind3 = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalName = bind3(this.assertLegalName, this);
          this.assertLegalChar = bind3(this.assertLegalChar, this);
          var key, ref, value2;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this[key] = value2;
          }
        }
        XMLStringifier2.prototype.name = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalName("" + val2 || "");
        };
        XMLStringifier2.prototype.text = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar(this.textEscape("" + val2 || ""));
        };
        XMLStringifier2.prototype.cdata = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          val2 = "" + val2 || "";
          val2 = val2.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val2);
        };
        XMLStringifier2.prototype.comment = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          val2 = "" + val2 || "";
          if (val2.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val2);
          }
          return this.assertLegalChar(val2);
        };
        XMLStringifier2.prototype.raw = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return "" + val2 || "";
        };
        XMLStringifier2.prototype.attValue = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar(this.attEscape(val2 = "" + val2 || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.insValue = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          val2 = "" + val2 || "";
          if (val2.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val2);
          }
          return this.assertLegalChar(val2);
        };
        XMLStringifier2.prototype.xmlVersion = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          val2 = "" + val2 || "";
          if (!val2.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val2);
          }
          return val2;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          val2 = "" + val2 || "";
          if (!val2.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val2);
          }
          return this.assertLegalChar(val2);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          if (val2) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val2) {
          if (this.options.noValidation) {
            return val2;
          }
          return this.assertLegalChar("" + val2 || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports, module) {
    (function() {
      module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, value2;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this["_" + key] = this[key];
            this[key] = value2;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          r = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function(node, options, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = "";
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r += this.indent(node, options, level) + "<" + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module) {
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc, options) {
          var child, i, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module) {
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root3, whatToShow, filter4) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root3, whatToShow, filter4) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes2, child, i, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes2 = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                attributes2[attName] = att.value;
              }
              this.node(node.name, attributes2);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name, attributes2, text3) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes2 == null) {
            attributes2 = {};
          }
          attributes2 = getValue(attributes2);
          if (!isObject(attributes2)) {
            ref1 = [attributes2, text3], text3 = ref1[0], attributes2 = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes2);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text3 != null) {
            this.text(text3);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes2, text3) {
          var child, i, len, oldValidationFlag, ref1, root3;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root3 = new XMLDocument(this.options).element("TEMP_ROOT");
              root3.element(name);
              this.options.noValidation = oldValidationFlag;
              ref1 = root3.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes2, text3);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name, value2) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            if (this.options.keepNullAttributes && value2 == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value2 != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value2);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value2);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value2);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value2);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value2);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value2) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value2 != null) {
            value2 = getValue(value2);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            node = new XMLProcessingInstruction(this, target, value2);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root3, pubID, sysID) {
          this.openCurrent();
          if (root3 == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root3;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value2);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value2);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value2);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value2);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk, name, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name in ref1) {
                if (!hasProp.call(ref1, name))
                  continue;
                att = ref1[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes2, text3) {
          return this.node(name, attributes2, text3);
        };
        XMLDocumentCB2.prototype.txt = function(value2) {
          return this.text(value2);
        };
        XMLDocumentCB2.prototype.dat = function(value2) {
          return this.cdata(value2);
        };
        XMLDocumentCB2.prototype.com = function(value2) {
          return this.comment(value2);
        };
        XMLDocumentCB2.prototype.ins = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root3, pubID, sysID) {
          return this.doctype(root3, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes2, text3) {
          return this.element(name, attributes2, text3);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes2, text3) {
          return this.node(name, attributes2, text3);
        };
        XMLDocumentCB2.prototype.t = function(value2) {
          return this.text(value2);
        };
        XMLDocumentCB2.prototype.d = function(value2) {
          return this.cdata(value2);
        };
        XMLDocumentCB2.prototype.c = function(value2) {
          return this.comment(value2);
        };
        XMLDocumentCB2.prototype.r = function(value2) {
          return this.raw(value2);
        };
        XMLDocumentCB2.prototype.i = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value2) {
          return this.entity(name, value2);
        };
        XMLDocumentCB2.prototype.pent = function(name, value2) {
          return this.pEntity(name, value2);
        };
        XMLDocumentCB2.prototype.not = function(name, value2) {
          return this.notation(name, value2);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        XMLStreamWriter2.prototype.endline = function(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options) {
          var child, i, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + "<" + node.name);
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module.exports.create = function(name, xmldec, doctype, options) {
        var doc, root3;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root3 = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root3;
      };
      module.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module.exports.implementation = new XMLDOMImplementation();
      module.exports.nodeType = NodeType;
      module.exports.writerState = WriterState;
    }).call(exports);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib16();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports.Builder = function() {
        function Builder(opts) {
          var key, ref, value2;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this.options[key] = value2;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value2 = opts[key];
            this.options[key] = value2;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render3, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render3 = function(_this) {
            return function(element, obj) {
              var attr2, child, entry, index2, key, value2;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index2 in obj) {
                  if (!hasProp.call(obj, index2))
                    continue;
                  child = obj[index2];
                  for (key in child) {
                    entry = child[key];
                    element = render3(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr2 in child) {
                        value2 = child[attr2];
                        element = element.att(attr2, value2);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index2 in child) {
                      if (!hasProp.call(child, index2))
                        continue;
                      entry = child[index2];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render3(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render3(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render3(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end2(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = __require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data3) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data3)) {
          if (!this._decoder) {
            var SD = __require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data3 = this._decoder.write(data3);
        }
        this._parser.write(data3.toString());
        this.emit("data", data3);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA3 = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace3(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace3(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data3) {
        parser[event] && parser[event](data3);
      }
      function emitNode(parser, nodeType, data3) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data3);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text3) {
        if (opt.trim)
          text3 = text3.trim();
        if (opt.normalize)
          text3 = text3.replace(/\s+/g, " ");
        return text3;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end2(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent2 = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent2.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent2 = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent2.ns) {
                tag.ns = Object.create(parent2.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent2 = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent2.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value2 = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value: value2,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent2 = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent2.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace3(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end2(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace3(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace3(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad3 = parser.position - parser.startTagPosition;
                  c = new Array(pad3).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA3) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace3(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace3(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace3(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace3(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace3(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace3(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace3(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace3(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace3(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace3(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace3(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint2 = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index2 < length) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint2,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint2;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports) {
    (function() {
      "use strict";
      exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind3 = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = __require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate2 = __require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors2, item, key) {
        var i, len, process2;
        for (i = 0, len = processors2.length; i < len; i++) {
          process2 = processors2[i];
          item = process2(item, key);
        }
        return item;
      };
      exports.Parser = function(superClass) {
        extend(Parser3, superClass);
        function Parser3(opts) {
          this.parseStringPromise = bind3(this.parseStringPromise, this);
          this.parseString = bind3(this.parseString, this);
          this.reset = bind3(this.reset, this);
          this.assignOrPush = bind3(this.assignOrPush, this);
          this.processAsync = bind3(this.processAsync, this);
          var key, ref, value2;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this.options[key] = value2;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value2 = opts[key];
            this.options[key] = value2;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser3.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser3.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser3.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text3) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text3;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text3.replace(/\\n/g, "").trim() !== "")) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text3;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text3) {
              var s;
              s = ontext(text3);
              if (s) {
                return s.cdata = true;
              }
            };
          }(this);
        };
        Parser3.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser3.prototype.parseStringPromise = function(str) {
          return new Promise(function(_this) {
            return function(resolve, reject) {
              return _this.parseString(str, function(err, value2) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve(value2);
                }
              });
            };
          }(this));
        };
        return Parser3;
      }(events);
      exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
      exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === "object") {
          options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = function(child, parent2) {
        for (var key in parent2) {
          if (hasProp.call(parent2, key))
            child[key] = parent2[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent2.prototype;
        child.prototype = new ctor();
        child.__super__ = parent2.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser3();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
      exports.parseStringPromise = parser.parseStringPromise;
    }).call(exports);
  }
});

// node_modules/app-store-scraper/lib/suggest.js
var require_suggest = __commonJS({
  "node_modules/app-store-scraper/lib/suggest.js"(exports, module) {
    "use strict";
    var common = require_common2();
    var parseString = require_xml2js().parseString;
    var BASE_URL2 = "https://search.itunes.apple.com/WebObjects/MZSearchHints.woa/wa/hints?media=software&q=";
    function parseXML(string) {
      return new Promise(function(resolve, reject) {
        return parseString(string, (err, res) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(res);
        });
      });
    }
    function extractSuggestions(xml2) {
      const toJSON = (item) => ({
        term: item.string[0],
        priority: item.integer[0]
      });
      const list2 = xml2.plist.dict[0].array[0].dict || [];
      return list2.map(toJSON);
    }
    function suggest2(opts) {
      return new Promise(function(resolve) {
        if (!opts && !opts.term) {
          throw Error("term missing");
        }
        return resolve(BASE_URL2 + encodeURIComponent(opts.term));
      }).then((url6) => common.request(url6, {}, opts.requestOptions)).then(parseXML).then(extractSuggestions);
    }
    module.exports = suggest2;
  }
});

// node_modules/app-store-scraper/lib/similar.js
var require_similar = __commonJS({
  "node_modules/app-store-scraper/lib/similar.js"(exports, module) {
    "use strict";
    var app2 = require_app();
    var BASE_URL2 = "https://itunes.apple.com/us/app/app/id";
    var common = require_common2();
    function similar2(opts) {
      return new Promise(function(resolve, reject) {
        if (opts.id) {
          resolve(opts.id);
        } else if (opts.appId) {
          app2(opts).then((app3) => resolve(app3.id)).catch(reject);
        } else {
          throw Error("Either id or appId is required");
        }
      }).then((id) => common.request(
        `${BASE_URL2}${id}`,
        {
          "X-Apple-Store-Front": `${common.storeId(opts.country)},32`
        },
        opts.requestOptions
      )).then(function(text3) {
        const index2 = text3.indexOf("customersAlsoBoughtApps");
        if (index2 === -1) {
          return [];
        }
        const regExp = /customersAlsoBoughtApps":(.*?\])/g;
        const match = regExp.exec(text3);
        const ids = JSON.parse(match[1]);
        return common.lookup(ids, "id", opts.country, opts.lang, opts.requestOptions);
      });
    }
    module.exports = similar2;
  }
});

// node_modules/app-store-scraper/lib/reviews.js
var require_reviews = __commonJS({
  "node_modules/app-store-scraper/lib/reviews.js"(exports, module) {
    "use strict";
    var R = require_ramda();
    var common = require_common2();
    var app2 = require_app();
    var c = require_constants();
    function ensureArray(value2) {
      if (!value2) {
        return [];
      }
      if (Array.isArray(value2)) {
        return value2;
      }
      return [value2];
    }
    function cleanList(results) {
      const reviews3 = ensureArray(results.feed.entry);
      return reviews3.map((review) => ({
        id: review.id.label,
        userName: review.author.name.label,
        userUrl: review.author.uri.label,
        version: review["im:version"].label,
        score: parseInt(review["im:rating"].label),
        title: review.title.label,
        text: review.content.label,
        url: review.link.attributes.href
      }));
    }
    var reviews2 = (opts) => new Promise((resolve) => {
      validate3(opts);
      if (opts.id) {
        resolve(opts.id);
      } else if (opts.appId) {
        resolve(app2(opts).then((app3) => app3.id));
      }
    }).then((id) => {
      opts = opts || {};
      opts.sort = opts.sort || c.sort.RECENT;
      opts.page = opts.page || 1;
      opts.country = opts.country || "us";
      const url6 = `https://itunes.apple.com/${opts.country}/rss/customerreviews/page=${opts.page}/id=${id}/sortby=${opts.sort}/json`;
      return common.request(url6, {}, opts.requestOptions);
    }).then(JSON.parse).then(cleanList);
    function validate3(opts) {
      if (!opts.id && !opts.appId) {
        throw Error("Either id or appId is required");
      }
      if (opts.sort && !R.contains(opts.sort, R.values(c.sort))) {
        throw new Error("Invalid sort " + opts.sort);
      }
      if (opts.page && opts.page < 1) {
        throw new Error("Page cannot be lower than 1");
      }
      if (opts.page && opts.page > 10) {
        throw new Error("Page cannot be greater than 10");
      }
    }
    module.exports = reviews2;
  }
});

// node_modules/app-store-scraper/index.js
var require_app_store_scraper = __commonJS({
  "node_modules/app-store-scraper/index.js"(exports, module) {
    "use strict";
    var R = require_ramda();
    var memoizee2 = require_memoizee2();
    var constants2 = require_constants();
    var methods2 = {
      app: require_app(),
      list: require_list(),
      search: require_search(),
      developer: require_developer(),
      privacy: require_privacy(),
      suggest: require_suggest(),
      similar: require_similar(),
      reviews: require_reviews(),
      ratings: require_ratings()
    };
    function memoized2(opts) {
      const cacheOpts = Object.assign({
        primitive: true,
        normalizer: JSON.stringify,
        maxAge: 1e3 * 60 * 5,
        // cache for 5 minutes
        max: 1e3
        // save up to 1k results to avoid memory issues
      }, opts);
      const doMemoize = (fn) => memoizee2(fn, cacheOpts);
      return Object.assign({}, constants2, R.map(doMemoize, methods2));
    }
    module.exports = Object.assign({ memoized: memoized2 }, constants2, methods2);
  }
});

// extension.ts
import { OAIBaseComponent, OmniComponentMacroTypes } from "omni-sockets";

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_curry1.js
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_curry2.js
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a2) {
          return fn(_a2, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_concat.js
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];
  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_arity.js
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_curryN.js
function _curryN(length, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/curryN.js
var curryN = /* @__PURE__ */ _curry2(function curryN2(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});
var curryN_default = curryN;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_curry3.js
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a2, _c) {
          return fn(_a2, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function(_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a2, _b) {
          return fn(_a2, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a2, _c) {
          return fn(_a2, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function(_a2) {
          return fn(_a2, b, c);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function(_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isArray.js
var isArray_default = Array.isArray || function _isArray(val2) {
  return val2 != null && val2.length >= 0 && Object.prototype.toString.call(val2) === "[object Array]";
};

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isTransformer.js
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_dispatchable.js
function _dispatchable(methodNames, transducerCreator, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var obj = arguments[arguments.length - 1];
    if (!isArray_default(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_xfBase.js
var xfBase_default = {
  init: function() {
    return this.xf["@@transducer/init"]();
  },
  result: function(result) {
    return this.xf["@@transducer/result"](result);
  }
};

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_arrayFromIterator.js
function _arrayFromIterator(iter) {
  var list2 = [];
  var next2;
  while (!(next2 = iter.next()).done) {
    list2.push(next2.value);
  }
  return list2;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_includesWith.js
function _includesWith(pred, x, list2) {
  var idx = 0;
  var len = list2.length;
  while (idx < len) {
    if (pred(x, list2[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_functionName.js
function _functionName(f) {
  var match = String(f).match(/^function (\w*)/);
  return match == null ? "" : match[1];
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_has.js
function _has(prop2, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop2);
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_objectIs.js
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  } else {
    return a !== a && b !== b;
  }
}
var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isArguments.js
var toString = Object.prototype.toString;
var _isArguments = /* @__PURE__ */ function() {
  return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
    return toString.call(x) === "[object Arguments]";
  } : function _isArguments2(x) {
    return _has("callee", x);
  };
}();
var isArguments_default = _isArguments;

// node_modules/google-play-scraper/node_modules/ramda/es/keys.js
var hasEnumBug = !/* @__PURE__ */ {
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = /* @__PURE__ */ function() {
  "use strict";
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list2, item) {
  var idx = 0;
  while (idx < list2.length) {
    if (list2[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : /* @__PURE__ */ _curry1(function keys3(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop2, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
  for (prop2 in obj) {
    if (_has(prop2, obj) && (!checkArgsLength || prop2 !== "length")) {
      ks[ks.length] = prop2;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop2 = nonEnumerableProps[nIdx];
      if (_has(prop2, obj) && !contains(ks, prop2)) {
        ks[ks.length] = prop2;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
var keys_default = keys;

// node_modules/google-play-scraper/node_modules/ramda/es/type.js
var type = /* @__PURE__ */ _curry1(function type2(val2) {
  return val2 === null ? "Null" : val2 === void 0 ? "Undefined" : Object.prototype.toString.call(val2).slice(8, -1);
});
var type_default = type;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_equals.js
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq2(_a2, _b) {
    return _equals(_a2, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq2, aItem, b2);
  }, b, a);
}
function _equals(a, b, stackA, stackB) {
  if (objectIs_default(a, b)) {
    return true;
  }
  var typeA = type_default(a);
  if (typeA !== type_default(b)) {
    return false;
  }
  if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
  }
  if (typeof a.equals === "function" || typeof b.equals === "function") {
    return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
        return a === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!objectIs_default(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a.name === b.name && a.message === b.message;
    case "RegExp":
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case "Set":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys_default(a);
  if (keysA.length !== keys_default(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}

// node_modules/google-play-scraper/node_modules/ramda/es/equals.js
var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
  return _equals(a, b, [], []);
});
var equals_default = equals;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_indexOf.js
function _indexOf(list2, a, idx) {
  var inf, item;
  if (typeof list2.indexOf === "function") {
    switch (typeof a) {
      case "number":
        if (a === 0) {
          inf = 1 / a;
          while (idx < list2.length) {
            item = list2[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          while (idx < list2.length) {
            item = list2[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list2.indexOf(a, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list2.indexOf(a, idx);
      case "object":
        if (a === null) {
          return list2.indexOf(a, idx);
        }
    }
  }
  while (idx < list2.length) {
    if (equals_default(list2[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_includes.js
function _includes(a, list2) {
  return _indexOf(list2, a, 0) >= 0;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_map.js
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_toISOString.js
var pad = function pad2(n) {
  return (n < 10 ? "0" : "") + n;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
  return d.toISOString();
} : function _toISOString3(d) {
  return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_arrayReduce.js
function _arrayReduce(reducer, acc, list2) {
  var index2 = 0;
  var length = list2.length;
  while (index2 < length) {
    acc = reducer(acc, list2[index2]);
    index2 += 1;
  }
  return acc;
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_xmap.js
var XMap = /* @__PURE__ */ function() {
  function XMap2(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap2.prototype["@@transducer/init"] = xfBase_default.init;
  XMap2.prototype["@@transducer/result"] = xfBase_default.result;
  XMap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, this.f(input));
  };
  return XMap2;
}();
var _xmap = function _xmap2(f) {
  return function(xf) {
    return new XMap(f, xf);
  };
};
var xmap_default = _xmap;

// node_modules/google-play-scraper/node_modules/ramda/es/map.js
var map = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["fantasy-land/map", "map"], xmap_default, function map2(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case "[object Function]":
        return curryN_default(functor.length, function() {
          return fn.call(this, functor.apply(this, arguments));
        });
      case "[object Object]":
        return _arrayReduce(function(acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys_default(functor));
      default:
        return _map(fn, functor);
    }
  })
);
var map_default = map;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isInteger.js
var isInteger_default = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isString.js
function _isString(x) {
  return Object.prototype.toString.call(x) === "[object String]";
}

// node_modules/google-play-scraper/node_modules/ramda/es/nth.js
var nth = /* @__PURE__ */ _curry2(function nth2(offset, list2) {
  var idx = offset < 0 ? list2.length + offset : offset;
  return _isString(list2) ? list2.charAt(idx) : list2[idx];
});
var nth_default = nth;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_isArrayLike.js
var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x) {
  if (isArray_default(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== "object") {
    return false;
  }
  if (_isString(x)) {
    return false;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
var isArrayLike_default = _isArrayLike;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_createReduce.js
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _createReduce(arrayReduce, methodReduce, iterableReduce) {
  return function _reduce(xf, acc, list2) {
    if (isArrayLike_default(list2)) {
      return arrayReduce(xf, acc, list2);
    }
    if (list2 == null) {
      return acc;
    }
    if (typeof list2["fantasy-land/reduce"] === "function") {
      return methodReduce(xf, acc, list2, "fantasy-land/reduce");
    }
    if (list2[symIterator] != null) {
      return iterableReduce(xf, acc, list2[symIterator]());
    }
    if (typeof list2.next === "function") {
      return iterableReduce(xf, acc, list2);
    }
    if (typeof list2.reduce === "function") {
      return methodReduce(xf, acc, list2, "reduce");
    }
    throw new TypeError("reduce: list must be array or iterable");
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_xArrayReduce.js
function _xArrayReduce(xf, acc, list2) {
  var idx = 0;
  var len = list2.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list2[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}

// node_modules/google-play-scraper/node_modules/ramda/es/bind.js
var bind = /* @__PURE__ */ _curry2(function bind2(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});
var bind_default = bind;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_xReduce.js
function _xIterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _xMethodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind_default(xf["@@transducer/step"], xf), acc));
}
var _xReduce = /* @__PURE__ */ _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);
var xReduce_default = _xReduce;

// node_modules/google-play-scraper/node_modules/ramda/es/values.js
var values = /* @__PURE__ */ _curry1(function values2(obj) {
  var props = keys_default(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});
var values_default = values;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_assoc.js
function _assoc(prop2, val2, obj) {
  if (isInteger_default(prop2) && isArray_default(obj)) {
    var arr = [].concat(obj);
    arr[prop2] = val2;
    return arr;
  }
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop2] = val2;
  return result;
}

// node_modules/google-play-scraper/node_modules/ramda/es/isNil.js
var isNil = /* @__PURE__ */ _curry1(function isNil2(x) {
  return x == null;
});
var isNil_default = isNil;

// node_modules/google-play-scraper/node_modules/ramda/es/assocPath.js
var assocPath = /* @__PURE__ */ _curry3(function assocPath2(path3, val2, obj) {
  if (path3.length === 0) {
    return val2;
  }
  var idx = path3[0];
  if (path3.length > 1) {
    var nextObj = !isNil_default(obj) && _has(idx, obj) && typeof obj[idx] === "object" ? obj[idx] : isInteger_default(path3[1]) ? [] : {};
    val2 = assocPath2(Array.prototype.slice.call(path3, 1), val2, nextObj);
  }
  return _assoc(idx, val2, obj);
});
var assocPath_default = assocPath;

// node_modules/google-play-scraper/node_modules/ramda/es/assoc.js
var assoc = /* @__PURE__ */ _curry3(function assoc2(prop2, val2, obj) {
  return assocPath_default([prop2], val2, obj);
});
var assoc_default = assoc;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_makeFlat.js
function _makeFlat(recursive) {
  return function flatt(list2) {
    var value2, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list2.length;
    while (idx < ilen) {
      if (isArrayLike_default(list2[idx])) {
        value2 = recursive ? flatt(list2[idx]) : list2[idx];
        j = 0;
        jlen = value2.length;
        while (j < jlen) {
          result[result.length] = value2[j];
          j += 1;
        }
      } else {
        result[result.length] = list2[idx];
      }
      idx += 1;
    }
    return result;
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_forceReduced.js
function _forceReduced(x) {
  return {
    "@@transducer/value": x,
    "@@transducer/reduced": true
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_flatCat.js
var tInit = "@@transducer/init";
var tStep = "@@transducer/step";
var tResult = "@@transducer/result";
var XPreservingReduced = /* @__PURE__ */ function() {
  function XPreservingReduced2(xf) {
    this.xf = xf;
  }
  XPreservingReduced2.prototype[tInit] = xfBase_default.init;
  XPreservingReduced2.prototype[tResult] = xfBase_default.result;
  XPreservingReduced2.prototype[tStep] = function(result, input) {
    var ret = this.xf[tStep](result, input);
    return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
  };
  return XPreservingReduced2;
}();
var XFlatCat = /* @__PURE__ */ function() {
  function XFlatCat2(xf) {
    this.xf = new XPreservingReduced(xf);
  }
  XFlatCat2.prototype[tInit] = xfBase_default.init;
  XFlatCat2.prototype[tResult] = xfBase_default.result;
  XFlatCat2.prototype[tStep] = function(result, input) {
    return !isArrayLike_default(input) ? _xArrayReduce(this.xf, result, [input]) : xReduce_default(this.xf, result, input);
  };
  return XFlatCat2;
}();
var _flatCat = function _xcat(xf) {
  return new XFlatCat(xf);
};
var flatCat_default = _flatCat;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_xchain.js
function _xchain(f) {
  return function(xf) {
    return xmap_default(f)(flatCat_default(xf));
  };
}

// node_modules/google-play-scraper/node_modules/ramda/es/chain.js
var chain = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["fantasy-land/chain", "chain"], _xchain, function chain2(fn, monad) {
    if (typeof monad === "function") {
      return function(x) {
        return fn(monad(x))(x);
      };
    }
    return _makeFlat(false)(map_default(fn, monad));
  })
);
var chain_default = chain;

// node_modules/google-play-scraper/node_modules/ramda/es/includes.js
var includes = /* @__PURE__ */ _curry2(_includes);
var includes_default = includes;

// node_modules/google-play-scraper/node_modules/ramda/es/is.js
var is = /* @__PURE__ */ _curry2(function is2(Ctor, val2) {
  return val2 instanceof Ctor || val2 != null && (val2.constructor === Ctor || Ctor.name === "Object" && typeof val2 === "object");
});
var is_default = is;

// node_modules/google-play-scraper/node_modules/ramda/es/paths.js
var paths = /* @__PURE__ */ _curry2(function paths2(pathsArray, obj) {
  return pathsArray.map(function(paths3) {
    var val2 = obj;
    var idx = 0;
    var p;
    while (idx < paths3.length) {
      if (val2 == null) {
        return;
      }
      p = paths3[idx];
      val2 = isInteger_default(p) ? nth_default(p, val2) : val2[p];
      idx += 1;
    }
    return val2;
  });
});
var paths_default = paths;

// node_modules/google-play-scraper/node_modules/ramda/es/path.js
var path = /* @__PURE__ */ _curry2(function path2(pathAr, obj) {
  return paths_default([pathAr], obj)[0];
});
var path_default = path;

// node_modules/google-play-scraper/node_modules/ramda/es/internal/_createPartialApplicator.js
function _createPartialApplicator(concat) {
  return _curry2(function(fn, args) {
    return _arity(Math.max(0, fn.length - args.length), function() {
      return fn.apply(this, concat(args, arguments));
    });
  });
}

// node_modules/google-play-scraper/node_modules/ramda/es/partial.js
var partial = /* @__PURE__ */ _createPartialApplicator(_concat);
var partial_default = partial;

// node_modules/google-play-scraper/node_modules/ramda/es/trim.js
var hasProtoTrim = typeof String.prototype.trim === "function";

// node_modules/google-play-scraper/lib/constants.js
var BASE_URL = "https://play.google.com";
var constants = {
  clusters: {
    new: "new",
    top: "top"
  },
  category: {
    APPLICATION: "APPLICATION",
    ANDROID_WEAR: "ANDROID_WEAR",
    ART_AND_DESIGN: "ART_AND_DESIGN",
    AUTO_AND_VEHICLES: "AUTO_AND_VEHICLES",
    BEAUTY: "BEAUTY",
    BOOKS_AND_REFERENCE: "BOOKS_AND_REFERENCE",
    BUSINESS: "BUSINESS",
    COMICS: "COMICS",
    COMMUNICATION: "COMMUNICATION",
    DATING: "DATING",
    EDUCATION: "EDUCATION",
    ENTERTAINMENT: "ENTERTAINMENT",
    EVENTS: "EVENTS",
    FINANCE: "FINANCE",
    FOOD_AND_DRINK: "FOOD_AND_DRINK",
    HEALTH_AND_FITNESS: "HEALTH_AND_FITNESS",
    HOUSE_AND_HOME: "HOUSE_AND_HOME",
    LIBRARIES_AND_DEMO: "LIBRARIES_AND_DEMO",
    LIFESTYLE: "LIFESTYLE",
    MAPS_AND_NAVIGATION: "MAPS_AND_NAVIGATION",
    MEDICAL: "MEDICAL",
    MUSIC_AND_AUDIO: "MUSIC_AND_AUDIO",
    NEWS_AND_MAGAZINES: "NEWS_AND_MAGAZINES",
    PARENTING: "PARENTING",
    PERSONALIZATION: "PERSONALIZATION",
    PHOTOGRAPHY: "PHOTOGRAPHY",
    PRODUCTIVITY: "PRODUCTIVITY",
    SHOPPING: "SHOPPING",
    SOCIAL: "SOCIAL",
    SPORTS: "SPORTS",
    TOOLS: "TOOLS",
    TRAVEL_AND_LOCAL: "TRAVEL_AND_LOCAL",
    VIDEO_PLAYERS: "VIDEO_PLAYERS",
    WATCH_FACE: "WATCH_FACE",
    WEATHER: "WEATHER",
    GAME: "GAME",
    GAME_ACTION: "GAME_ACTION",
    GAME_ADVENTURE: "GAME_ADVENTURE",
    GAME_ARCADE: "GAME_ARCADE",
    GAME_BOARD: "GAME_BOARD",
    GAME_CARD: "GAME_CARD",
    GAME_CASINO: "GAME_CASINO",
    GAME_CASUAL: "GAME_CASUAL",
    GAME_EDUCATIONAL: "GAME_EDUCATIONAL",
    GAME_MUSIC: "GAME_MUSIC",
    GAME_PUZZLE: "GAME_PUZZLE",
    GAME_RACING: "GAME_RACING",
    GAME_ROLE_PLAYING: "GAME_ROLE_PLAYING",
    GAME_SIMULATION: "GAME_SIMULATION",
    GAME_SPORTS: "GAME_SPORTS",
    GAME_STRATEGY: "GAME_STRATEGY",
    GAME_TRIVIA: "GAME_TRIVIA",
    GAME_WORD: "GAME_WORD",
    FAMILY: "FAMILY"
  },
  collection: {
    TOP_FREE: "TOP_FREE",
    TOP_PAID: "TOP_PAID",
    GROSSING: "GROSSING"
  },
  sort: {
    NEWEST: 2,
    RATING: 3,
    HELPFULNESS: 1
  },
  age: {
    FIVE_UNDER: "AGE_RANGE1",
    SIX_EIGHT: "AGE_RANGE2",
    NINE_UP: "AGE_RANGE3"
  },
  permission: {
    COMMON: 0,
    OTHER: 1
  }
};

// node_modules/google-play-scraper/index.js
var import_memoizee = __toESM(require_memoizee(), 1);

// node_modules/google-play-scraper/lib/app.js
import queryString from "querystring";

// node_modules/google-play-scraper/lib/utils/request.js
var import_got = __toESM(require_source5(), 1);

// node_modules/google-play-scraper/lib/utils/throttle.js
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function Throttle() {
  let startedAt = null;
  let timesCalled = 0;
  let inThrottle = false;
  return function settingOptions(fn, opts) {
    const ms = opts.interval;
    const number = opts.limit;
    return async function returnedFunction(...args) {
      if (!startedAt)
        startedAt = Date.now();
      if (timesCalled < number && Date.now() - startedAt < ms) {
        timesCalled++;
        const result2 = await fn(...args);
        return result2;
      }
      if (!inThrottle) {
        inThrottle = true;
        await sleep(ms);
        timesCalled = 0;
        startedAt = Date.now();
        const result2 = await returnedFunction(...args);
        inThrottle = false;
        return result2;
      }
      const checkingPromise = new Promise((resolve) => {
        const interval = setInterval(async () => {
          if (!inThrottle) {
            clearInterval(interval);
            const result2 = await returnedFunction(...args);
            return resolve(result2);
          }
        }, 1);
      });
      const result = await checkingPromise;
      return result;
    };
  };
}
var throttledRequest = Throttle();
var throttle_default = throttledRequest;

// node_modules/google-play-scraper/lib/utils/request.js
var import_debug = __toESM(require_src5(), 1);
var debug = (0, import_debug.default)("google-play-scraper");
function doRequest(opts, limit) {
  let req;
  if (limit) {
    req = throttle_default(
      import_got.default,
      {
        interval: 1e3,
        limit
      }
    );
  } else {
    req = import_got.default;
  }
  return new Promise((resolve, reject) => {
    req(opts).then((response2) => resolve(response2.body)).catch((error) => reject(error));
  });
}
async function request(opts, limit) {
  debug("Making request: %j", opts);
  try {
    const response2 = await doRequest(opts, limit);
    debug("Request finished");
    return response2;
  } catch (reason) {
    debug("Request error:", reason.message, reason.response && reason.response.statusCode);
    let message = "Error requesting Google Play:" + reason.message;
    if (reason.response && reason.response.statusCode === 404) {
      message = "App not found (404)";
    }
    const err = Error(message);
    err.status = reason.response && reason.response.statusCode;
    throw err;
  }
}
var request_default = request;

// node_modules/google-play-scraper/lib/utils/scriptData.js
var import_debug2 = __toESM(require_src5(), 1);
var debug2 = (0, import_debug2.default)("google-play-scraper:scriptData");
function extractDataWithServiceRequestId(parsedData, spec) {
  const serviceRequestMapping = Object.keys(parsedData.serviceRequestData);
  const filteredDsRootPath = serviceRequestMapping.filter((serviceRequest) => {
    const dsValues = parsedData.serviceRequestData[serviceRequest];
    return dsValues.id === spec.useServiceRequestId;
  });
  const formattedPath = filteredDsRootPath.length ? [filteredDsRootPath[0], ...spec.path] : spec.path;
  return path_default(formattedPath, parsedData);
}
function extractor(mappings) {
  return function extractFields(parsedData) {
    debug2("parsedData: %o", parsedData);
    return map_default((spec) => {
      if (is_default(Array, spec)) {
        return path_default(spec, parsedData);
      }
      const input = spec.useServiceRequestId ? extractDataWithServiceRequestId(parsedData, spec) : path_default(spec.path, parsedData);
      return spec.fun(input, parsedData);
    }, mappings);
  };
}
function parse(response2) {
  const scriptRegex2 = />AF_initDataCallback[\s\S]*?<\/script/g;
  const keyRegex = /(ds:.*?)'/;
  const valueRegex2 = /data:([\s\S]*?), sideChannel: {}}\);<\//;
  const matches2 = response2.match(scriptRegex2);
  if (!matches2) {
    return {};
  }
  const parsedData = matches2.reduce((accum, data3) => {
    const keyMatch = data3.match(keyRegex);
    const valueMatch2 = data3.match(valueRegex2);
    if (keyMatch && valueMatch2) {
      const key = keyMatch[1];
      const value2 = JSON.parse(valueMatch2[1]);
      return assoc_default(key, value2, accum);
    }
    return accum;
  }, {});
  return Object.assign(
    {},
    parsedData,
    { serviceRequestData: parseServiceRequests(response2) }
  );
}
function parseServiceRequests(response) {
  const scriptRegex = /; var AF_dataServiceRequests[\s\S]*?; var AF_initDataChunkQueue/g;
  const valueRegex = /{'ds:[\s\S]*}}/g;
  const matches = response.match(scriptRegex);
  if (!matches) {
    return {};
  }
  const [data] = matches;
  const valueMatch = data.match(valueRegex);
  if (!valueMatch) {
    return {};
  }
  const value = eval(`(${valueMatch[0]})`);
  return value;
}
var scriptData_default = Object.assign({ parse, parseServiceRequests, extractor, extractDataWithServiceRequestId });

// node_modules/cheerio/lib/esm/options.js
var defaultOpts = {
  xml: false,
  decodeEntities: true
};
var options_default = defaultOpts;
var xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten(options) {
  return (options === null || options === void 0 ? void 0 : options.xml) ? typeof options.xml === "boolean" ? xmlModeDefault : { ...xmlModeDefault, ...options.xml } : options !== null && options !== void 0 ? options : void 0;
}

// node_modules/cheerio/lib/esm/static.js
var static_exports = {};
__export(static_exports, {
  contains: () => contains3,
  html: () => html,
  merge: () => merge,
  parseHTML: () => parseHTML,
  root: () => root,
  text: () => text,
  xml: () => xml
});

// node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// node_modules/domelementtype/lib/esm/index.js
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data3) {
    super();
    this.data = data3;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data3) {
    this.data = data3;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data3) {
    super(data3);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children3) {
    super();
    this.children = children3;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children3) {
    this.children = children3;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children3 = [], type3 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children3);
    this.name = name;
    this.attribs = attribs;
    this.type = type3;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children3 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children3);
    children3.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node)) {
    const children3 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA2(children3);
    children3.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node)) {
    const children3 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children3);
    children3.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children3 = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children3.length; i++) {
    children3[i].prev = children3[i - 1];
    children3[i - 1].next = children3[i];
  }
  return children3;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts2 = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts2;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts2;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type3 = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type3);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data3) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data3;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data3);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data3) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data3;
      return;
    }
    const node = new Comment2(data3);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text3 = new Text2("");
    const node = new CDATA2([text3]);
    this.addNode(node);
    text3.parent = node;
    this.lastNode = text3;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data3) {
    const node = new ProcessingInstruction(name, data3);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent2 = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent2.children[parent2.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent2.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent2;
    this.lastNode = null;
  }
};

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end2, base) {
    if (start !== end2) {
      const digitCount = end2 - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value2 = char - jumpOffset;
    return value2 < 0 || value2 >= branchCount ? -1 : decodeTree[nodeIdx + value2] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next2 = xmlCodeMap.get(char);
    if (next2 !== void 0) {
      ret += str.substring(lastIdx, i) + next2;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map4) {
  return function escape2(data3) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data3)) {
      if (lastIdx !== match.index) {
        result += data3.substring(lastIdx, match.index);
      }
      result += map4.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data3.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));

// node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value2) {
  return value2.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a3, _b;
    const value2 = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value2 === "") {
      return key;
    }
    return `${key}="${encode(value2)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data3 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data3 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data3) : escapeText(data3);
  }
  return data3;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent2 = getParent(elem);
  if (parent2 != null)
    return getChildren(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next2 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next2 != null) {
    siblings2.push(next2);
    ({ next: next2 } = next2);
  }
  return siblings2;
}
function getAttributeValue(elem, name) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next2 } = elem;
  while (next2 !== null && !isTag2(next2))
    ({ next: next2 } = next2);
  return next2;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag2(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}

// node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  const next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  const parent2 = replacement.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent2, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent2;
  if (parent2.children.push(child) > 1) {
    const sibling = parent2.children[parent2.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next2) {
  removeElement(next2);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
}
function prependChild(parent2, child) {
  removeElement(child);
  child.parent = parent2;
  child.prev = null;
  if (parent2.children.unshift(child) !== 1) {
    const sibling = parent2.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}

// node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!isTag2(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne(test, node.children, true);
    }
  }
  return elem;
}
function existsOne(test, nodes) {
  return nodes.some((checked) => isTag2(checked) && (test(checked) || existsOne(test, checked.children)));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag2(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type3) {
    if (typeof type3 === "function") {
      return (elem) => type3(elem.type);
    }
    return (elem) => elem.type === type3;
  },
  tag_contains(data3) {
    if (typeof data3 === "function") {
      return (elem) => isText(elem) && data3(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data3;
  }
};
function getAttribCheck(attrib, value2) {
  if (typeof value2 === "function") {
    return (elem) => isTag2(elem) && value2(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value2;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value2 = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value2) : getAttribCheck(key, value2);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type3, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type3), nodes, recurse, limit);
}

// node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children: children3 } = item;
      const entry = { media: getMediaElements(children3) };
      addConditionally(entry, "id", "id", children3);
      addConditionally(entry, "title", "title", children3);
      const href2 = (_a3 = getOneElement("link", children3)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch("summary", children3) || fetch("content", children3);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children3);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children: children3 } = item;
      const entry = { media: getMediaElements(children3) };
      addConditionally(entry, "id", "guid", children3);
      addConditionally(entry, "title", "title", children3);
      addConditionally(entry, "link", "link", children3);
      addConditionally(entry, "description", "description", children3);
      const pubDate = fetch("pubDate", children3) || fetch("dc:date", children3);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value2) {
  return value2 === "rss" || value2 === "feed" || value2 === "rdf:RDF";
}

// node_modules/cheerio/lib/esm/static.js
function render2(that, dom, options) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options).toString();
}
function isOptions(dom, options) {
  return !options && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html(dom, options) {
  const toRender = isOptions(dom) ? (options = dom, void 0) : dom;
  const opts = {
    ...options_default,
    ...this === null || this === void 0 ? void 0 : this._options,
    ...flatten(options !== null && options !== void 0 ? options : {})
  };
  return render2(this, toRender, opts);
}
function xml(dom) {
  const options = { ...this._options, xmlMode: true };
  return render2(this, dom, options);
}
function text(elements) {
  const elems = elements ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent(elems[i]);
  }
  return ret;
}
function parseHTML(data3, context, keepScripts = typeof context === "boolean" ? context : false) {
  if (!data3 || typeof data3 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data3, options_default, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
function root() {
  return this(this._root);
}
function contains3(container, contained) {
  if (contained === container) {
    return false;
  }
  let next2 = contained;
  while (next2 && next2 !== next2.parent) {
    next2 = next2.parent;
    if (next2 === container) {
      return true;
    }
  }
  return false;
}
function merge(arr1, arr2) {
  if (!isArrayLike2(arr1) || !isArrayLike2(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
function isArrayLike2(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (let i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}

// node_modules/cheerio/lib/esm/api/attributes.js
var attributes_exports = {};
__export(attributes_exports, {
  addClass: () => addClass,
  attr: () => attr,
  data: () => data2,
  hasClass: () => hasClass,
  prop: () => prop,
  removeAttr: () => removeAttr,
  removeClass: () => removeClass,
  toggleClass: () => toggleClass,
  val: () => val
});

// node_modules/cheerio/lib/esm/utils.js
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str) {
  return str.replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
}
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach(array, fn) {
  const len = array.length;
  for (let i = 0; i < len; i++)
    fn(array[i], i);
  return array;
}
function cloneDom(dom) {
  const clone2 = "length" in dom ? Array.prototype.map.call(dom, (el) => cloneNode(el, true)) : [cloneNode(dom, true)];
  const root3 = new Document(clone2);
  clone2.forEach((node) => {
    node.parent = root3;
  });
  return clone2;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3)
    return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
}

// node_modules/cheerio/lib/esm/api/attributes.js
var hasOwn = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = "data-";
var primitives = {
  null: null,
  true: true,
  false: false
};
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name, xmlMode) {
  var _a2;
  if (!elem || !isTag2(elem))
    return void 0;
  (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
  if (!name) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name)) {
    return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
  }
  if (elem.name === "option" && name === "value") {
    return text(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name, value2) {
  if (value2 === null) {
    removeAttribute(el, name);
  } else {
    el.attribs[name] = `${value2}`;
  }
}
function attr(name, value2) {
  if (typeof name === "object" || value2 !== void 0) {
    if (typeof value2 === "function") {
      if (typeof name !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag2(el))
          setAttr(el, name, value2.call(el, i, el.attribs[name]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name === "object") {
        Object.keys(name).forEach((objName) => {
          const objValue = name[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name, value2);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name, this.options.xmlMode);
}
function getProp(el, name, xmlMode) {
  return name in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name]
  ) : !xmlMode && rboolean.test(name) ? getAttr(el, name, false) !== void 0 : getAttr(el, name, xmlMode);
}
function setProp(el, name, value2, xmlMode) {
  if (name in el) {
    el[name] = value2;
  } else {
    setAttr(el, name, !xmlMode && rboolean.test(name) ? value2 ? "" : null : `${value2}`);
  }
}
function prop(name, value2) {
  var _a2;
  if (typeof name === "string" && value2 === void 0) {
    const el = this[0];
    if (!el || !isTag2(el))
      return void 0;
    switch (name) {
      case "style": {
        const property = this.css();
        const keys4 = Object.keys(property);
        keys4.forEach((p, i) => {
          property[i] = p;
        });
        property.length = keys4.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a2 = el.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
        if (typeof URL !== "undefined" && (name === "href" && (el.tagName === "a" || el.name === "link") || name === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el);
      }
      case "textContent": {
        return textContent(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name, this.options.xmlMode);
    }
  }
  if (typeof name === "object" || value2 !== void 0) {
    if (typeof value2 === "function") {
      if (typeof name === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag2(el)) {
          setProp(el, name, value2.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name === "object") {
        Object.keys(name).forEach((key) => {
          const val2 = name[key];
          setProp(el, key, val2, this.options.xmlMode);
        });
      } else {
        setProp(el, name, value2, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData(el, name, value2) {
  var _a2;
  const elem = el;
  (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
  if (typeof name === "object")
    Object.assign(elem.data, name);
  else if (typeof name === "string" && value2 !== void 0) {
    elem.data[name] = value2;
  }
}
function readData(el, name) {
  let domNames;
  let jsNames;
  let value2;
  if (name == null) {
    domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));
    jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));
  } else {
    domNames = [dataAttrPrefix + cssCase(name)];
    jsNames = [name];
  }
  for (let idx = 0; idx < domNames.length; ++idx) {
    const domName = domNames[idx];
    const jsName = jsNames[idx];
    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {
      value2 = el.attribs[domName];
      if (hasOwn.call(primitives, value2)) {
        value2 = primitives[value2];
      } else if (value2 === String(Number(value2))) {
        value2 = Number(value2);
      } else if (rbrace.test(value2)) {
        try {
          value2 = JSON.parse(value2);
        } catch (e) {
        }
      }
      el.data[jsName] = value2;
    }
  }
  return name == null ? el.data : value2;
}
function data2(name, value2) {
  var _a2;
  const elem = this[0];
  if (!elem || !isTag2(elem))
    return;
  const dataEl = elem;
  (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
  if (!name) {
    return readData(dataEl);
  }
  if (typeof name === "object" || value2 !== void 0) {
    domEach(this, (el) => {
      if (isTag2(el)) {
        if (typeof name === "object")
          setData(el, name);
        else
          setData(el, name, value2);
      }
    });
    return this;
  }
  if (hasOwn.call(dataEl.data, name)) {
    return dataEl.data[name];
  }
  return readData(dataEl, name);
}
function val(value2) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag2(element))
    return querying ? void 0 : this;
  switch (element.name) {
    case "textarea":
      return this.text(value2);
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value2 === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values3 = typeof value2 !== "object" ? [value2] : value2;
        for (let i = 0; i < values3.length; i++) {
          this.find(`option[value="${values3[i]}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el) => text(el.children)) : option.attr("value");
    }
    case "input":
    case "option":
      return querying ? this.attr("value") : this.attr("value", value2);
  }
  return void 0;
}
function removeAttribute(elem, name) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name))
    return;
  delete elem.attribs[name];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name) {
  const attrNames = splitNames(name);
  for (let i = 0; i < attrNames.length; i++) {
    domEach(this, (elem) => {
      if (isTag2(elem))
        removeAttribute(elem, attrNames[i]);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag2(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value2) {
  if (typeof value2 === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value2.call(el, i, className));
      }
    });
  }
  if (!value2 || typeof value2 !== "string")
    return this;
  const classNames = value2.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const className = getAttr(el, "class", false);
    if (!className) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      let setClass = ` ${className} `;
      for (let j = 0; j < classNames.length; j++) {
        const appendClass = `${classNames[j]} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
function removeClass(name) {
  if (typeof name === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        removeClass.call([el], name.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag2(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j = 0; j < numClasses; j++) {
        const index2 = elClasses.indexOf(classes[j]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value2, stateVal) {
  if (typeof value2 === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        toggleClass.call([el], value2.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value2 || typeof value2 !== "string")
    return this;
  const classNames = value2.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const elementClasses = splitNames(el.attribs["class"]);
    for (let j = 0; j < numClasses; j++) {
      const index2 = elementClasses.indexOf(classNames[j]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}

// node_modules/cheerio/lib/esm/api/traversing.js
var traversing_exports = {};
__export(traversing_exports, {
  add: () => add,
  addBack: () => addBack,
  children: () => children2,
  closest: () => closest,
  contents: () => contents,
  each: () => each,
  end: () => end,
  eq: () => eq,
  filter: () => filter3,
  filterArray: () => filterArray,
  find: () => find3,
  first: () => first,
  get: () => get,
  has: () => has,
  index: () => index,
  is: () => is5,
  last: () => last,
  map: () => map3,
  next: () => next,
  nextAll: () => nextAll,
  nextUntil: () => nextUntil,
  not: () => not,
  parent: () => parent,
  parents: () => parents,
  parentsUntil: () => parentsUntil,
  prev: () => prev,
  prevAll: () => prevAll,
  prevUntil: () => prevUntil,
  siblings: () => siblings,
  slice: () => slice,
  toArray: () => toArray
});

// node_modules/cheerio-select/lib/esm/index.js
var import_css_what5 = __toESM(require_commonjs(), 1);

// node_modules/css-select/lib/esm/index.js
var import_boolbase6 = __toESM(require_boolbase(), 1);

// node_modules/css-select/lib/esm/compile.js
var import_css_what4 = __toESM(require_commonjs(), 1);
var import_boolbase5 = __toESM(require_boolbase(), 1);

// node_modules/css-select/lib/esm/sort.js
var import_css_what = __toESM(require_commonjs(), 1);
var procedure = /* @__PURE__ */ new Map([
  [import_css_what.SelectorType.Universal, 50],
  [import_css_what.SelectorType.Tag, 30],
  [import_css_what.SelectorType.Attribute, 1],
  [import_css_what.SelectorType.Pseudo, 0]
]);
function isTraversal(token) {
  return !procedure.has(token.type);
}
var attributes = /* @__PURE__ */ new Map([
  [import_css_what.AttributeAction.Exists, 10],
  [import_css_what.AttributeAction.Equals, 8],
  [import_css_what.AttributeAction.Not, 7],
  [import_css_what.AttributeAction.Start, 6],
  [import_css_what.AttributeAction.End, 6],
  [import_css_what.AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a2, _b;
  let proc = (_a2 = procedure.get(token.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token.type === import_css_what.SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === import_css_what.AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === import_css_what.SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

// node_modules/css-select/lib/esm/attributes.js
var import_boolbase = __toESM(require_boolbase(), 1);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value2) {
  return value2.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name } = data3;
    let { value: value2 } = data3;
    if (shouldIgnoreCase(data3, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name);
        return attr2 != null && attr2.length === value2.length && attr2.toLowerCase() === value2 && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) === value2 && next2(elem);
  },
  hyphen(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name } = data3;
    let { value: value2 } = data3;
    const len = value2.length;
    if (shouldIgnoreCase(data3, options)) {
      value2 = value2.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value2 && next2(elem);
      };
    }
    return function hyphen(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value2 && next2(elem);
    };
  },
  element(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name, value: value2 } = data3;
    if (/\s/.test(value2)) {
      return import_boolbase.default.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value2)}(?:$|\\s)`, shouldIgnoreCase(data3, options) ? "i" : "");
    return function element(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name);
      return attr2 != null && attr2.length >= value2.length && regex.test(attr2) && next2(elem);
    };
  },
  exists(next2, { name }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name) && next2(elem);
  },
  start(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name } = data3;
    let { value: value2 } = data3;
    const len = value2.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data3, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value2 && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value2)) && next2(elem);
    };
  },
  end(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name } = data3;
    let { value: value2 } = data3;
    const len = -value2.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data3, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value2 && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value2)) && next2(elem);
    };
  },
  any(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name, value: value2 } = data3;
    if (value2 === "") {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data3, options)) {
      const regex = new RegExp(escapeRegex(value2), "i");
      return function anyIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name);
        return attr2 != null && attr2.length >= value2.length && regex.test(attr2) && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.includes(value2)) && next2(elem);
    };
  },
  not(next2, data3, options) {
    const { adapter: adapter2 } = options;
    const { name } = data3;
    let { value: value2 } = data3;
    if (value2 === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name) && next2(elem);
    } else if (shouldIgnoreCase(data3, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name);
        return (attr2 == null || attr2.length !== value2.length || attr2.toLowerCase() !== value2) && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) !== value2 && next2(elem);
  }
};

// node_modules/css-select/lib/esm/pseudo-selectors/index.js
var import_css_what2 = __toESM(require_commonjs(), 1);

// node_modules/nth-check/lib/esm/parse.js
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse2(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value2 = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value2 = value2 * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value2;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// node_modules/nth-check/lib/esm/compile.js
var import_boolbase2 = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase2.default.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? import_boolbase2.default.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}

// node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse2(formula));
}

// node_modules/css-select/lib/esm/pseudo-selectors/filters.js
var import_boolbase3 = __toESM(require_boolbase(), 1);
function getChildFunc(next2, adapter2) {
  return (elem) => {
    const parent2 = adapter2.getParent(elem);
    return parent2 != null && adapter2.isTag(parent2) && next2(elem);
  };
}
var filters = {
  contains(next2, text3, { adapter: adapter2 }) {
    return function contains5(elem) {
      return next2(elem) && adapter2.getText(elem).includes(text3);
    };
  },
  icontains(next2, text3, { adapter: adapter2 }) {
    const itext = text3.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next2, rule, { adapter: adapter2, equals: equals3 }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        if (equals3(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child"(next2, rule, { adapter: adapter2, equals: equals3 }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals3(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type"(next2, rule, { adapter: adapter2, equals: equals3 }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals3(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type"(next2, rule, { adapter: adapter2, equals: equals3 }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals3(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  // TODO determine the actual root element
  root(next2, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent2 = adapter2.getParent(elem);
      return (parent2 == null || !adapter2.isTag(parent2)) && next2(elem);
    };
  },
  scope(next2, rule, options, context) {
    const { equals: equals3 } = options;
    if (!context || context.length === 0) {
      return filters["root"](next2, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals3(context[0], elem) && next2(elem);
    }
    return (elem) => context.includes(elem) && next2(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next2, _rule, { adapter: adapter2 }) {
    const func = adapter2[name];
    if (typeof func !== "function") {
      return import_boolbase3.default.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next2(elem);
    };
  };
}

// node_modules/css-select/lib/esm/pseudo-selectors/pseudos.js
var pseudos = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter2.isTag(elem2) || adapter2.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter: adapter2, equals: equals3 }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals3(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals: equals3 }) {
    const siblings2 = adapter2.getSiblings(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      if (equals3(elem, siblings2[i]))
        return true;
      if (adapter2.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals: equals3 }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = 0; i < siblings2.length; i++) {
      const currentSibling = siblings2[i];
      if (equals3(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals: equals3 }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      const currentSibling = siblings2[i];
      if (equals3(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals: equals3 }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling) => equals3(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals: equals3 }) {
    return adapter2.getSiblings(elem).every((sibling) => equals3(elem, sibling) || !adapter2.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}

// node_modules/css-select/lib/esm/pseudo-selectors/aliases.js
var aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

// node_modules/css-select/lib/esm/pseudo-selectors/subselects.js
var import_boolbase4 = __toESM(require_boolbase(), 1);
var PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next2, adapter2) {
  if (next2 === import_boolbase4.default.falseFunc)
    return import_boolbase4.default.falseFunc;
  return (elem) => adapter2.isTag(elem) && next2(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings2 = adapter2.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is3 = (next2, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === import_boolbase4.default.trueFunc ? next2 : func === import_boolbase4.default.falseFunc ? import_boolbase4.default.falseFunc : (elem) => func(elem) && next2(elem);
};
var subselects = {
  is: is3,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is3,
  where: is3,
  not(next2, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === import_boolbase4.default.falseFunc ? next2 : func === import_boolbase4.default.trueFunc ? import_boolbase4.default.falseFunc : (elem) => !func(elem) && next2(elem);
  },
  has(next2, subselect, options, _context, compileToken2) {
    const { adapter: adapter2 } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === import_boolbase4.default.falseFunc)
      return import_boolbase4.default.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== import_boolbase4.default.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next2(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next2(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};

// node_modules/css-select/lib/esm/pseudo-selectors/index.js
function compilePseudoSelector(next2, selector, options, context, compileToken2) {
  var _a2;
  const { name, data: data3 } = selector;
  if (Array.isArray(data3)) {
    if (!(name in subselects)) {
      throw new Error(`Unknown pseudo-class :${name}(${data3})`);
    }
    return subselects[name](next2, data3, options, context, compileToken2);
  }
  const userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
  if (typeof stringPseudo === "string") {
    if (data3 != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    const alias = (0, import_css_what2.parse)(stringPseudo);
    return subselects["is"](next2, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name, data3, 1);
    return (elem) => userPseudo(elem, data3) && next2(elem);
  }
  if (name in filters) {
    return filters[name](next2, data3, options, context);
  }
  if (name in pseudos) {
    const pseudo = pseudos[name];
    verifyPseudoArgs(pseudo, name, data3, 2);
    return (elem) => pseudo(elem, options, data3) && next2(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}

// node_modules/css-select/lib/esm/general.js
var import_css_what3 = __toESM(require_commonjs(), 1);
function getElementParent(node, adapter2) {
  const parent2 = adapter2.getParent(node);
  if (parent2 && adapter2.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next2, selector, options, context, compileToken2) {
  const { adapter: adapter2, equals: equals3 } = options;
  switch (selector.type) {
    case import_css_what3.SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case import_css_what3.SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case import_css_what3.SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next2, selector, options);
    }
    case import_css_what3.SelectorType.Pseudo: {
      return compilePseudoSelector(next2, selector, options, context, compileToken2);
    }
    case import_css_what3.SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag(elem) {
        return adapter2.getName(elem) === name && next2(elem);
      };
    }
    case import_css_what3.SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter2)) {
            if (next2(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter2)) {
          if (!isFalseCache.has(current)) {
            if (adapter2.isTag(current) && next2(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next2(current))
            return true;
        } while (current = getElementParent(current, adapter2));
        return false;
      };
    }
    case import_css_what3.SelectorType.Parent: {
      return function parent2(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next2(elem2));
      };
    }
    case import_css_what3.SelectorType.Child: {
      return function child(elem) {
        const parent2 = adapter2.getParent(elem);
        return parent2 != null && adapter2.isTag(parent2) && next2(parent2);
      };
    }
    case import_css_what3.SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals3(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next2(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case import_css_what3.SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next2(previous);
        };
      }
      return function adjacent(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals3(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next2(lastElement);
      };
    }
    case import_css_what3.SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next2;
    }
  }
}

// node_modules/css-select/lib/esm/compile.js
function compile2(selector, options, context) {
  const next2 = compileUnsafe(selector, options, context);
  return ensureIsTag(next2, options.adapter);
}
function compileUnsafe(selector, options, context) {
  const token = typeof selector === "string" ? (0, import_css_what4.parse)(selector) : selector;
  return compileToken(token, options, context);
}
function includesScopePseudo(t) {
  return t.type === import_css_what4.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data3) => data3.some(includesScopePseudo)));
}
var DESCENDANT_TOKEN = { type: import_css_what4.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: import_css_what4.SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter2.isTag(e) && adapter2.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent2 && adapter2.isTag(parent2);
  }));
  for (const t of token) {
    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== import_css_what4.SelectorType.Descendant) {
    } else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a2;
  token.forEach(sortByProcedure);
  context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token.map((rules) => {
    if (rules.length >= 2) {
      const [first2, second] = rules;
      if (first2.type !== import_css_what4.SelectorType.Pseudo || first2.name !== "scope") {
      } else if (isArrayContext && second.type === import_css_what4.SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === import_css_what4.SelectorType.Adjacent || second.type === import_css_what4.SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, import_boolbase5.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules, options, context) {
  var _a2;
  return rules.reduce((previous, rule) => previous === import_boolbase5.default.falseFunc ? import_boolbase5.default.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : import_boolbase5.default.trueFunc);
}
function reduceRules(a, b) {
  if (b === import_boolbase5.default.falseFunc || a === import_boolbase5.default.trueFunc) {
    return a;
  }
  if (a === import_boolbase5.default.falseFunc || b === import_boolbase5.default.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

// node_modules/css-select/lib/esm/index.js
var defaultEquals = (a, b) => a === b;
var defaultOptions = {
  adapter: esm_exports2,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a2, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = esm_exports2;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
var compile3 = wrapCompile(compile2);
var _compileUnsafe = wrapCompile(compileUnsafe);
var _compileToken = wrapCompile(compileToken);
function getSelectorFunc(searchFunc) {
  return function select2(query, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = compileUnsafe(query, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems));
var selectOne = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems));

// node_modules/cheerio-select/lib/esm/index.js
var boolbase7 = __toESM(require_boolbase(), 1);

// node_modules/cheerio-select/lib/esm/positionals.js
var filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter4, data3, partLimit) {
  const num = data3 != null ? parseInt(data3, 10) : NaN;
  switch (filter4) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
    case "lt":
      return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}

// node_modules/cheerio-select/lib/esm/helpers.js
function getDocumentRoot(node) {
  while (node.parent)
    node = node.parent;
  return node;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}

// node_modules/cheerio-select/lib/esm/index.js
var UNIVERSAL_SELECTOR = {
  type: import_css_what5.SelectorType.Universal,
  namespace: null
};
var SCOPE_PSEUDO = {
  type: import_css_what5.SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is4(element, selector, options = {}) {
  return some([element], selector, options);
}
function some(elements, selector, options = {}) {
  if (typeof selector === "function")
    return elements.some(selector);
  const [plain, filtered] = groupSelectors((0, import_css_what5.parse)(selector));
  return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
}
function filterByPosition(filter4, elems, data3, options) {
  const num = typeof data3 === "string" ? parseInt(data3, 10) : NaN;
  switch (filter4) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data3, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter2(selector, elements, options = {}) {
  return filterParsed((0, import_css_what5.parse)(selector), elements, options);
}
function filterParsed(selector, elements, options) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
    const filteredSelector = filteredSelectors[i];
    const missing = found ? elements.filter((e) => isTag2(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : (
    // Filter elements to preserve order
    elements.filter((el) => found.has(el))
  ) : [];
}
function filterBySelector(selector, elements, options) {
  var _a2;
  if (selector.some(import_css_what5.isTraversal)) {
    const root3 = (_a2 = options.root) !== null && _a2 !== void 0 ? _a2 : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root3, selector, opts, true, elements.length);
  }
  return findFilterElements(elements, selector, options, false, elements.length);
}
function select(selector, root3, options = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find2(root3, selector);
  }
  const [plain, filtered] = groupSelectors((0, import_css_what5.parse)(selector));
  const results = filtered.map((sel) => findFilterElements(root3, sel, options, true, limit));
  if (plain.length) {
    results.push(findElements(root3, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
function findFilterElements(root3, selector, options, queryForSelector, totalLimit) {
  const filterIndex = selector.findIndex(isFilter);
  const sub = selector.slice(0, filterIndex);
  const filter4 = selector[filterIndex];
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter4.name, filter4.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub.length === 0 && !Array.isArray(root3) ? getChildren(root3).filter(isTag2) : sub.length === 0 ? (Array.isArray(root3) ? root3 : [root3]).filter(isTag2) : queryForSelector || sub.some(import_css_what5.isTraversal) ? findElements(root3, [sub], options, limit) : filterElements(root3, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter4.name, elems, filter4.data, options);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(import_css_what5.isTraversal);
  if (remainingHasTraversal) {
    if ((0, import_css_what5.isTraversal)(remainingSelector[0])) {
      const { type: type3 } = remainingSelector[0];
      if (type3 === import_css_what5.SelectorType.Sibling || type3 === import_css_what5.SelectorType.Adjacent) {
        result = prepareContext(result, esm_exports2, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el) => result.includes(el)
    };
  } else if (options.rootFunc && options.rootFunc !== boolbase7.trueFunc) {
    options = { ...options, rootFunc: boolbase7.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
    // Query existing elements to resolve traversal.
    findElements(result, [remainingSelector], options, totalLimit)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    filterElements(result, [remainingSelector], options)
  );
}
function findElements(root3, sel, options, limit) {
  const query = _compileToken(sel, options, root3);
  return find2(root3, query, limit);
}
function find2(root3, query, limit = Infinity) {
  const elems = prepareContext(root3, esm_exports2, query.shouldTestNextSiblings);
  return find((node) => isTag2(node) && query(node), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag2);
  if (els.length === 0)
    return els;
  const query = _compileToken(sel, options);
  return query === boolbase7.trueFunc ? els : els.filter(query);
}

// node_modules/cheerio/lib/esm/api/traversing.js
var reSiblingSelector = /^\s*[~+]/;
function find3(selectorOrHaystack) {
  var _a2;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  const context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter((elem) => context.some((node) => contains3(node, elem))));
  }
  const elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  const options = {
    context,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selectorOrHaystack, elems, options));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector) {
      var _a2;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(matched, selector, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
var _matcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value2 = fn(elems[i]);
    ret.push(value2);
  }
  return new Array().concat(...ret);
});
var _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value2 = fn(elems[i]);
    if (value2 !== null) {
      ret.push(value2);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches2 = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next2; next2 = nextElem2(elem); elem = next2) {
        if (matches2 === null || matches2 === void 0 ? void 0 : matches2(next2, matched.length))
          break;
        matched.push(next2);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector, filterSelector) {
    matches2 = typeof selector === "string" ? (elem) => is4(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches2 = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
var parent = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
var parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
var parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector) {
  var _a2;
  const set = [];
  if (!selector) {
    return this._make(set);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
  };
  const selectFn = typeof selector === "string" ? (elem) => is4(elem, selector, selectOpts) : getFilterFn(selector);
  domEach(this, (elem) => {
    while (elem && isTag2(elem)) {
      if (selectFn(elem, 0)) {
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
var next = _singleMatcher((elem) => nextElementSibling(elem));
var nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
var prev = _singleMatcher((elem) => prevElementSibling(elem));
var prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
var siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag2(el) && el !== elem), uniqueSort);
var children2 = _matcher((elem) => getChildren(elem).filter(isTag2), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
function map3(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match) {
  if (typeof match === "function") {
    return (el, i) => match.call(el, i, el);
  }
  if (isCheerio(match)) {
    return (el) => Array.prototype.includes.call(match, el);
  }
  return function(el) {
    return match === el;
  };
}
function filter3(match) {
  var _a2;
  return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
}
function filterArray(nodes, match, xmlMode, root3) {
  return typeof match === "string" ? filter2(match, nodes, { xmlMode, root: root3 }) : nodes.filter(getFilterFn(match));
}
function is5(selector) {
  const nodes = this.toArray();
  return typeof selector === "string" ? some(nodes.filter(isTag2), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
}
function not(match) {
  let nodes = this.toArray();
  if (typeof match === "string") {
    const matches2 = new Set(filter2(match, nodes, this.options));
    nodes = nodes.filter((el) => !matches2.has(el));
  } else {
    const filterFn = getFilterFn(match);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
function has(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${selectorOrHaystack})`
  ) : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
}
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq(i) {
  var _a2;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a2 = this[i]) !== null && _a2 !== void 0 ? _a2 : []);
}
function get(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
function toArray() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
function end() {
  var _a2;
  return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
}
function add(other, context) {
  const selection = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents2);
}
function addBack(selector) {
  return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
}

// node_modules/cheerio/lib/esm/api/manipulation.js
var manipulation_exports = {};
__export(manipulation_exports, {
  _makeDomArray: () => _makeDomArray,
  after: () => after,
  append: () => append2,
  appendTo: () => appendTo,
  before: () => before,
  clone: () => clone,
  empty: () => empty,
  html: () => html2,
  insertAfter: () => insertAfter,
  insertBefore: () => insertBefore,
  prepend: () => prepend2,
  prependTo: () => prependTo,
  remove: () => remove,
  replaceWith: () => replaceWith,
  text: () => text2,
  toString: () => toString2,
  unwrap: () => unwrap,
  wrap: () => wrap,
  wrapAll: () => wrapAll,
  wrapInner: () => wrapInner
});

// node_modules/cheerio/lib/esm/parse.js
function getParse(parser) {
  return function parse9(content, options, isDocument2, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser(content, options, isDocument2, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument(doc)) {
      return doc;
    }
    const root3 = new Document([]);
    update(doc, root3);
    return root3;
  };
}
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i = 0; i < arr.length; i++) {
    const node = arr[i];
    if (node.parent && node.parent.children !== arr) {
      removeElement(node);
    }
    if (parent2) {
      node.prev = arr[i - 1] || null;
      node.next = arr[i + 1] || null;
    } else {
      node.prev = node.next = null;
    }
    node.parent = parent2;
  }
  return parent2;
}

// node_modules/cheerio/lib/esm/api/manipulation.js
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (isCheerio(elem)) {
    return clone2 ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce((newElems, el) => newElems.concat(this._makeDomArray(el, clone2)), []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? cloneDom([elem]) : [elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent2) {
  var _a2, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node = newElems[idx];
    const oldParent = node.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node.parent = parent2;
    if (node.prev) {
      node.prev.next = (_a2 = node.next) !== null && _a2 !== void 0 ? _a2 : null;
    }
    if (node.next) {
      node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
    }
    node.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next2) {
    next2.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
var append2 = _insert((dom, children3, parent2) => {
  uniqueSplice(children3, children3.length, 0, dom, parent2);
});
var prepend2 = _insert((dom, children3, parent2) => {
  uniqueSplice(children3, 0, 0, dom, parent2);
});
function _wrap(insert) {
  return function(wrapper) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap2 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !isHtml(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j = 0;
      while (j < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j];
        if (isTag2(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
var wrap = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el);
  update([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
var wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el))
    return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
function unwrap(selector) {
  this.parent(selector).not("body").each((_, el) => {
    this._make(el).replaceWith(el.children);
  });
  return this;
}
function wrapAll(wrapper) {
  const el = this[0];
  if (el) {
    const wrap2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
    let elInsertLocation;
    for (let i = 0; i < wrap2.length; i++) {
      if (wrap2[i].type === "tag")
        elInsertLocation = wrap2[i];
    }
    let j = 0;
    while (elInsertLocation && j < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent2);
  });
}
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  this._makeDomArray(target).forEach((el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent2);
  });
}
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector) {
  const elems = selector ? this.filter(selector) : this;
  domEach(elems, (el) => {
    removeElement(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el, i, el) : content;
    const dom = this._makeDomArray(cont);
    update(dom, null);
    const index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent2);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
function empty() {
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
function html2(str) {
  if (str === void 0) {
    const el = this[0];
    if (!el || !hasChildren(el))
      return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el).children;
    update(content, el);
  });
}
function toString2() {
  return this._render(this);
}
function text2(str) {
  if (str === void 0) {
    return text(this);
  }
  if (typeof str === "function") {
    return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text([el]))));
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const textNode = new Text2(`${str}`);
    update(textNode, el);
  });
}
function clone() {
  return this._make(cloneDom(this.get()));
}

// node_modules/cheerio/lib/esm/api/css.js
var css_exports = {};
__export(css_exports, {
  css: () => css
});
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
function setCss(el, prop2, value2, idx) {
  if (typeof prop2 === "string") {
    const styles = getCss(el);
    const val2 = typeof value2 === "function" ? value2.call(el, idx, styles[prop2]) : value2;
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el.attribs["style"] = stringify(styles);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach((k, i) => {
      setCss(el, k, prop2[k], i);
    });
  }
}
function getCss(el, prop2) {
  if (!el || !isTag2(el))
    return;
  const styles = parse6(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    prop2.forEach((item) => {
      if (styles[item] != null) {
        newStyles[item] = styles[item];
      }
    });
    return newStyles;
  }
  return styles;
}
function stringify(obj) {
  return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse6(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  const obj = {};
  let key;
  for (const str of styles.split(";")) {
    const n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}

// node_modules/cheerio/lib/esm/api/forms.js
var forms_exports = {};
__export(forms_exports, {
  serialize: () => serialize,
  serializeArray: () => serializeArray
});
var submittableSelector = "input,select,textarea,keygen";
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data3) => `${encodeURIComponent(data3.name)}=${encodeURIComponent(data3.value)}`);
  return retArr.join("&").replace(r20, "+");
}
function serializeArray() {
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag2(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map((_, elem) => {
    var _a2;
    const $elem = this._make(elem);
    const name = $elem.attr("name");
    const value2 = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
    if (Array.isArray(value2)) {
      return value2.map((val2) => (
        /*
         * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
         * These can occur inside of `<textarea>'s`
         */
        { name, value: val2.replace(rCRLF, "\r\n") }
      ));
    }
    return { name, value: value2.replace(rCRLF, "\r\n") };
  }).toArray();
}

// node_modules/cheerio/lib/esm/cheerio.js
var Cheerio = class {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root3, options) {
    this.length = 0;
    this.options = options;
    this._root = root3;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
};
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, attributes_exports, traversing_exports, manipulation_exports, css_exports, forms_exports);

// node_modules/cheerio/lib/esm/load.js
function getLoad(parse9, render3) {
  return function load2(content, options, isDocument2 = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = { ...options_default, ...flatten(options) };
    const initialRoot = parse9(content, internalOpts, isDocument2, null);
    class LoadedCheerio extends Cheerio {
      _make(selector, context) {
        const cheerio = initialize(selector, context);
        cheerio.prevObject = this;
        return cheerio;
      }
      _parse(content2, options2, isDocument3, context) {
        return parse9(content2, options2, isDocument3, context);
      }
      _render(dom) {
        return render3(dom, this.options);
      }
    }
    function initialize(selector, context, root3 = initialRoot, opts) {
      if (selector && isCheerio(selector))
        return selector;
      const options2 = {
        ...internalOpts,
        ...flatten(opts)
      };
      const r = typeof root3 === "string" ? [parse9(root3, options2, false, null)] : "length" in root3 ? root3 : [root3];
      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options2);
      rootInstance._root = rootInstance;
      if (!selector) {
        return new LoadedCheerio(void 0, rootInstance, options2);
      }
      const elements = typeof selector === "string" && isHtml(selector) ? (
        // $(<html>)
        parse9(selector, options2, false, null).children
      ) : isNode(selector) ? (
        // $(dom)
        [selector]
      ) : Array.isArray(selector) ? (
        // $([dom])
        selector
      ) : void 0;
      const instance = new LoadedCheerio(elements, rootInstance, options2);
      if (elements) {
        return instance;
      }
      if (typeof selector !== "string") {
        throw new Error("Unexpected type of selector");
      }
      let search2 = selector;
      const searchContext = !context ? (
        // If we don't have a context, maybe we have a root, from loading
        rootInstance
      ) : typeof context === "string" ? isHtml(context) ? (
        // $('li', '<ul>...</ul>')
        new LoadedCheerio([parse9(context, options2, false, null)], rootInstance, options2)
      ) : (
        // $('li', 'ul')
        (search2 = `${context} ${search2}`, rootInstance)
      ) : isCheerio(context) ? (
        // $('li', $)
        context
      ) : (
        // $('li', node), $('li', [nodes])
        new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2)
      );
      if (!searchContext)
        return instance;
      return searchContext.find(search2);
    }
    Object.assign(initialize, static_exports, {
      load: load2,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}

// node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "\uFFFD";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
  CODE_POINTS2[CODE_POINTS2["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
})(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR = ERR || (ERR = {}));

// node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code) {
    const { line, col, offset } = this;
    return {
      code,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 32;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code = this.html.charCodeAt(pos);
    return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// node_modules/parse5/dist/common/token.js
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType = TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

// node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
  ATTRS: () => ATTRS,
  DOCUMENT_MODE: () => DOCUMENT_MODE,
  NS: () => NS,
  SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
  TAG_ID: () => TAG_ID,
  TAG_NAMES: () => TAG_NAMES,
  getTagID: () => getTagID,
  hasUnescapedText: () => hasUnescapedText,
  isNumberedHeader: () => isNumberedHeader
});
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS = NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS = ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
  TAG_ID2[TAG_ID2["U"] = 117] = "U";
  TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
})(TAG_ID = TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $ = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
function isNumberedHeader(tn) {
  return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
}
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

// node_modules/parse5/dist/tokenizer/index.js
var C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State;
(function(State3) {
  State3[State3["DATA"] = 0] = "DATA";
  State3[State3["RCDATA"] = 1] = "RCDATA";
  State3[State3["RAWTEXT"] = 2] = "RAWTEXT";
  State3[State3["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State3[State3["PLAINTEXT"] = 4] = "PLAINTEXT";
  State3[State3["TAG_OPEN"] = 5] = "TAG_OPEN";
  State3[State3["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State3[State3["TAG_NAME"] = 7] = "TAG_NAME";
  State3[State3["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State3[State3["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State3[State3["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State3[State3["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State3[State3["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State3[State3["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State3[State3["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State3[State3["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State3[State3["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State3[State3["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State3[State3["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State3[State3["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State3[State3["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State3[State3["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State3[State3["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State3[State3["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State3[State3["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State3[State3["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State3[State3["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State3[State3["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State3[State3["COMMENT_START"] = 42] = "COMMENT_START";
  State3[State3["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State3[State3["COMMENT"] = 44] = "COMMENT";
  State3[State3["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State3[State3["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State3[State3["COMMENT_END"] = 50] = "COMMENT_END";
  State3[State3["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State3[State3["DOCTYPE"] = 52] = "DOCTYPE";
  State3[State3["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State3[State3["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State3[State3["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State3[State3["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State3[State3["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State3[State3["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State3[State3["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State3[State3["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State3[State3["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State3[State3["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State3[State3["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State3[State3["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State3[State3["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State3[State3["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State3[State3["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State3[State3["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State3[State3["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State3[State3["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State3[State3["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State3[State3["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State3[State3["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State3[State3["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd2(nextCp) {
  return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric2(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count) {
    this.consumedAfterSnapshot -= count;
    this.preprocessor.retreat(count);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type3, chars) {
    this.currentCharacterToken = {
      type: type3,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({ type: TokenType.EOF, location });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type3, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type3) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type3, ch);
  }
  _emitCodePoint(cp) {
    const type3 = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type3, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i = 0, current = decode_data_html_default[0]; i >= 0; cp = this._consume()) {
      i = determineBranch(decode_data_html_default, current, i + 1, cp);
      if (i < 0)
        break;
      excess += 1;
      current = decode_data_html_default[i];
      const masked = current & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd2(this.preprocessor.peek(1))) {
          result = [CODE_POINTS.AMPERSAND];
          i += valueLength;
        } else {
          result = valueLength === 0 ? [decode_data_html_default[i] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_data_html_default[++i]] : [decode_data_html_default[++i], decode_data_html_default[++i]];
          excess = 0;
          withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === CODE_POINTS.NUMBER_SIGN) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric2(cp)) {
      this.state = State.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation()) {
    } else if (matchResult) {
      for (let i = 0; i < matchResult.length; i++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = State.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric2(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit(cp)) {
      this.state = State.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === CODE_POINTS.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};

// node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [TAG_ID.APPLET, NS.HTML],
  [TAG_ID.CAPTION, NS.HTML],
  [TAG_ID.HTML, NS.HTML],
  [TAG_ID.MARQUEE, NS.HTML],
  [TAG_ID.OBJECT, NS.HTML],
  [TAG_ID.TABLE, NS.HTML],
  [TAG_ID.TD, NS.HTML],
  [TAG_ID.TEMPLATE, NS.HTML],
  [TAG_ID.TH, NS.HTML],
  [TAG_ID.ANNOTATION_XML, NS.MATHML],
  [TAG_ID.MI, NS.MATHML],
  [TAG_ID.MN, NS.MATHML],
  [TAG_ID.MO, NS.MATHML],
  [TAG_ID.MS, NS.MATHML],
  [TAG_ID.MTEXT, NS.MATHML],
  [TAG_ID.DESC, NS.SVG],
  [TAG_ID.FOREIGN_OBJECT, NS.SVG],
  [TAG_ID.TITLE, NS.SVG]
]);
var NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
var TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document2, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document2;
  }
  //Index of element
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (isNumberedHeader(tn) && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (tn === TAG_ID.BUTTON && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType = EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element } = entry;
      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
  }
};

// node_modules/parse5/dist/tree-adapters/default.js
function createTextNode(value2) {
  return {
    nodeName: "#text",
    value: value2,
    parentNode: null
  };
}
var defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data3) {
    return {
      nodeName: "#comment",
      data: data3,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document2, name, publicId, systemId) {
    const doctypeNode = document2.childNodes.find((node) => node.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: "#documentType",
        name,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document2, node);
    }
  },
  setDocumentMode(document2, mode) {
    document2.mode = mode;
  },
  getDocumentMode(document2) {
    return document2.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text3) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text3;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, createTextNode(text3));
  },
  insertTextBefore(parentNode, text3, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text3;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, createTextNode(text3), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  //Node data
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node) {
    return node.nodeName === "#text";
  },
  isCommentNode(node) {
    return node.nodeName === "#comment";
  },
  isDocumentTypeNode(node) {
    return node.nodeName === "#documentType";
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
  }
};

// node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// node_modules/parse5/dist/common/foreign-content.js
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: NS.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value2 = attrs[i].value.toLowerCase();
        return value2 === MIME_TYPES.TEXT_HTML || value2 === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

// node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser = class {
  constructor(options, document2, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html3, options) {
    const parser = new this(options);
    parser.tokenizer.write(html3, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token, code, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err = {
      code,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node, tid);
  }
  onItemPop(node, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  //Tree mutation
  _setDocumentType(token) {
    const name = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && {
        ...location,
        startTag: location
      };
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent2, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent2) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent2, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent2;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent: parent2, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent2, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent2, token.chars);
      }
    } else {
      parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent2, token.chars);
    }
    if (!token.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent2);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
    );
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent2 = this.treeAdapter.getParentNode(openElement);
          if (parent2) {
            return { parent: parent2, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  //Special elements
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  if (token.location) {
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
function startTagBeforeHtml(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p, token);
    }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p, token);
    }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p, token);
    }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (isNumberedHeader(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        noembedStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p, token);
    }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i)
        p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody(p, token);
    }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
function endTagInText(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
function characterInTable(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p, token);
        break;
      }
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p, token);
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p, token);
    }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
function startTagAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

// node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);
function isVoidElement(node, options) {
  return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === NS.HTML && VOID_ELEMENTS.has(options.treeAdapter.getTagName(node));
}
var defaultOpts3 = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
function serializeOuter(node, options) {
  const opts = { ...defaultOpts3, ...options };
  return serializeNode(node, opts);
}
function serializeChildNodes(parentNode, options) {
  let html3 = "";
  const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html3 += serializeNode(currentNode, options);
    }
  }
  return html3;
}
function serializeNode(node, options) {
  if (options.treeAdapter.isElementNode(node)) {
    return serializeElement(node, options);
  }
  if (options.treeAdapter.isTextNode(node)) {
    return serializeTextNode(node, options);
  }
  if (options.treeAdapter.isCommentNode(node)) {
    return serializeCommentNode(node, options);
  }
  if (options.treeAdapter.isDocumentTypeNode(node)) {
    return serializeDocumentTypeNode(node, options);
  }
  return "";
}
function serializeElement(node, options) {
  const tn = options.treeAdapter.getTagName(node);
  return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? "" : `${serializeChildNodes(node, options)}</${tn}>`}`;
}
function serializeAttributes(node, { treeAdapter }) {
  let html3 = "";
  for (const attr2 of treeAdapter.getAttrList(node)) {
    html3 += " ";
    if (!attr2.namespace) {
      html3 += attr2.name;
    } else
      switch (attr2.namespace) {
        case NS.XML: {
          html3 += `xml:${attr2.name}`;
          break;
        }
        case NS.XMLNS: {
          if (attr2.name !== "xmlns") {
            html3 += "xmlns:";
          }
          html3 += attr2.name;
          break;
        }
        case NS.XLINK: {
          html3 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html3 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    html3 += `="${escapeAttribute(attr2.value)}"`;
  }
  return html3;
}
function serializeTextNode(node, options) {
  const { treeAdapter } = options;
  const content = treeAdapter.getTextNodeContent(node);
  const parent2 = treeAdapter.getParentNode(node);
  const parentTn = parent2 && treeAdapter.isElementNode(parent2) && treeAdapter.getTagName(parent2);
  return parentTn && treeAdapter.getNamespaceURI(parent2) === NS.HTML && hasUnescapedText(parentTn, options.scriptingEnabled) ? content : escapeText(content);
}
function serializeCommentNode(node, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
}
function serializeDocumentTypeNode(node, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
}

// node_modules/parse5/dist/index.js
function parse7(html3, options) {
  return Parser.parse(html3, options);
}
function parseFragment(fragmentContext, html3, options) {
  if (typeof fragmentContext === "string") {
    options = html3;
    html3 = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html3, true);
  return parser.getFragment();
}

// node_modules/parse5-htmlparser2-tree-adapter/dist/index.js
function createTextNode2(value2) {
  return new Text2(value2);
}
function enquoteDoctypeId(id) {
  const quote = id.includes('"') ? "'" : '"';
  return quote + id + quote;
}
function serializeDoctypeContent(name, publicId, systemId) {
  let str = "!DOCTYPE ";
  if (name) {
    str += name;
  }
  if (publicId) {
    str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
  } else if (systemId) {
    str += " SYSTEM";
  }
  if (systemId) {
    str += ` ${enquoteDoctypeId(systemId)}`;
  }
  return str;
}
var adapter = {
  // Re-exports from domhandler
  isCommentNode: isComment,
  isElementNode: isTag2,
  isTextNode: isText,
  //Node construction
  createDocument() {
    const node = new Document([]);
    node["x-mode"] = html_exports.DOCUMENT_MODE.NO_QUIRKS;
    return node;
  },
  createDocumentFragment() {
    return new Document([]);
  },
  createElement(tagName, namespaceURI, attrs) {
    const attribs = /* @__PURE__ */ Object.create(null);
    const attribsNamespace = /* @__PURE__ */ Object.create(null);
    const attribsPrefix = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      attribs[attrName] = attrs[i].value;
      attribsNamespace[attrName] = attrs[i].namespace;
      attribsPrefix[attrName] = attrs[i].prefix;
    }
    const node = new Element(tagName, attribs, []);
    node.namespace = namespaceURI;
    node["x-attribsNamespace"] = attribsNamespace;
    node["x-attribsPrefix"] = attribsPrefix;
    return node;
  },
  createCommentNode(data3) {
    return new Comment2(data3);
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    const prev2 = parentNode.children[parentNode.children.length - 1];
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    parentNode.children.push(newNode);
    newNode.parent = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const { prev: prev2 } = referenceNode;
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    referenceNode.prev = newNode;
    newNode.next = referenceNode;
    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    adapter.appendChild(templateElement, contentElement);
  },
  getTemplateContent(templateElement) {
    return templateElement.children[0];
  },
  setDocumentType(document2, name, publicId, systemId) {
    const data3 = serializeDoctypeContent(name, publicId, systemId);
    let doctypeNode = document2.children.find((node) => isDirective(node) && node.name === "!doctype");
    if (doctypeNode) {
      doctypeNode.data = data3 !== null && data3 !== void 0 ? data3 : null;
    } else {
      doctypeNode = new ProcessingInstruction("!doctype", data3);
      adapter.appendChild(document2, doctypeNode);
    }
    doctypeNode["x-name"] = name !== null && name !== void 0 ? name : void 0;
    doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
    doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
  },
  setDocumentMode(document2, mode) {
    document2["x-mode"] = mode;
  },
  getDocumentMode(document2) {
    return document2["x-mode"];
  },
  detachNode(node) {
    if (node.parent) {
      const idx = node.parent.children.indexOf(node);
      const { prev: prev2, next: next2 } = node;
      node.prev = null;
      node.next = null;
      if (prev2) {
        prev2.next = next2;
      }
      if (next2) {
        next2.prev = prev2;
      }
      node.parent.children.splice(idx, 1);
      node.parent = null;
    }
  },
  insertText(parentNode, text3) {
    const lastChild = parentNode.children[parentNode.children.length - 1];
    if (lastChild && isText(lastChild)) {
      lastChild.data += text3;
    } else {
      adapter.appendChild(parentNode, createTextNode2(text3));
    }
  },
  insertTextBefore(parentNode, text3, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
    if (prevNode && isText(prevNode)) {
      prevNode.data += text3;
    } else {
      adapter.insertBefore(parentNode, createTextNode2(text3), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      if (typeof recipient.attribs[attrName] === "undefined") {
        recipient.attribs[attrName] = attrs[i].value;
        recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
        recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.children[0];
  },
  getChildNodes(node) {
    return node.children;
  },
  getParentNode(node) {
    return node.parent;
  },
  getAttrList(element) {
    return element.attributes;
  },
  //Node data
  getTagName(element) {
    return element.name;
  },
  getNamespaceURI(element) {
    return element.namespace;
  },
  getTextNodeContent(textNode) {
    return textNode.data;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-name"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-publicId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-systemId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  //Node types
  isDocumentTypeNode(node) {
    return isDirective(node) && node.name === "!doctype";
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    if (location) {
      node.startIndex = location.startOffset;
      node.endIndex = location.endOffset;
    }
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    if (endLocation.endOffset != null)
      node.endIndex = endLocation.endOffset;
    node.sourceCodeLocation = {
      ...node.sourceCodeLocation,
      ...endLocation
    };
  }
};

// node_modules/cheerio/lib/esm/parsers/parse5-adapter.js
function parseWithParse5(content, options, isDocument2, context) {
  const opts = {
    scriptingEnabled: typeof options.scriptingEnabled === "boolean" ? options.scriptingEnabled : true,
    treeAdapter: adapter,
    sourceCodeLocationInfo: options.sourceCodeLocationInfo
  };
  return isDocument2 ? parse7(content, opts) : parseFragment(context, content, opts);
}
var renderOpts = { treeAdapter: adapter };
function renderWithParse5(dom) {
  const nodes = "length" in dom ? dom : [dom];
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    if (isDocument(node)) {
      Array.prototype.splice.call(nodes, index2, 1, ...node.children);
    }
  }
  let result = "";
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    result += serializeOuter(node, renderOpts);
  }
  return result;
}

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State2;
(function(State3) {
  State3[State3["Text"] = 1] = "Text";
  State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
  State3[State3["InTagName"] = 3] = "InTagName";
  State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
  State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State3[State3["InAttributeName"] = 9] = "InAttributeName";
  State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
  State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State3[State3["InDeclaration"] = 16] = "InDeclaration";
  State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State3[State3["BeforeComment"] = 18] = "BeforeComment";
  State3[State3["CDATASequence"] = 19] = "CDATASequence";
  State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
  State3[State3["InCommentLike"] = 21] = "InCommentLike";
  State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
  State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
  State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
  State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
  State3[State3["InHexEntity"] = 29] = "InHexEntity";
})(State2 || (State2 = {}));
function isWhitespace2(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace2(c);
}
function isNumber2(c) {
  return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer2 = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State2.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.state = State2.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State2.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace2(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.state = State2.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State2.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State2.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State2.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State2.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State2.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State2.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State2.BeforeClosingTagName;
    } else {
      this.state = State2.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace2(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State2.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State2.InClosingTagName : State2.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace2(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State2.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State2.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State2.InSelfClosingTag;
    } else if (!isWhitespace2(c)) {
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace2(c)) {
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State2.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace2(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State2.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State2.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace2(c)) {
      this.sectionStart = this.index;
      this.state = State2.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State2.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace2(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State2.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State2.BeforeComment : State2.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State2.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State2.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State2.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes2.Number) {
      this.state = State2.BeforeNumericEntity;
    } else if (c === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State2.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State2.InHexEntity;
    } else {
      this.state = State2.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State2.Text: {
          this.stateText(c);
          break;
        }
        case State2.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State2.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State2.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State2.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State2.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State2.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State2.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State2.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State2.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State2.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State2.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State2.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State2.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State2.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State2.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State2.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State2.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State2.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State2.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State2.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State2.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State2.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State2.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State2.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State2.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State2.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State2.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State2.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State2.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser2 = class {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer2)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data3 = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data3);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a2, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name) {
    return !this.options.xmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.push(name);
      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value2) {
    const index2 = value2.search(reNameEnd);
    let name = index2 < 0 ? value2 : value2.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value2 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value2);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value2}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value2 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value2);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value2}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value2 = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value2);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value2}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data3) {
    this.reset();
    this.end(data3);
  }
  getSlice(start, end2) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
    while (end2 - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
    }
    return slice2;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data3, options) {
  const handler = new DomHandler(void 0, options);
  new Parser2(handler, options).end(data3);
  return handler.root;
}

// node_modules/cheerio/lib/esm/index.js
var parse8 = getParse((content, options, isDocument2, context) => options.xmlMode || options._useHtmlParser2 ? parseDocument(content, options) : parseWithParse5(content, options, isDocument2, context));
var load = getLoad(parse8, (dom, options) => options.xmlMode || options._useHtmlParser2 ? esm_default(dom, options) : renderWithParse5(dom));
var esm_default2 = load([]);
var { contains: contains4 } = static_exports;
var { merge: merge2 } = static_exports;
var { parseHTML: parseHTML2 } = static_exports;
var { root: root2 } = static_exports;

// node_modules/google-play-scraper/lib/utils/mappingHelpers.js
function descriptionHtmlLocalized(searchArray) {
  const descriptionTranslation = path_default([12, 0, 0, 1], searchArray);
  const descriptionOriginal = path_default([72, 0, 1], searchArray);
  return descriptionTranslation || descriptionOriginal;
}
function descriptionText(description) {
  const html3 = load("<div>" + description.replace(/<br>/g, "\r\n") + "</div>");
  return html3("div").text();
}
function priceText(priceText2) {
  return priceText2 || "Free";
}
function normalizeAndroidVersion(androidVersionText) {
  if (!androidVersionText)
    return "VARY";
  const number = androidVersionText.split(" ")[0];
  if (parseFloat(number)) {
    return number;
  }
  return "VARY";
}
function buildHistogram(container) {
  if (!container) {
    return { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
  }
  return {
    1: container[1][1],
    2: container[2][1],
    3: container[3][1],
    4: container[4][1],
    5: container[5][1]
  };
}
function extractComments(comments) {
  if (!comments)
    return [];
  return comments.map(path_default([4])).slice(0, 5);
}
function extractFeatures(featuresArray) {
  if (featuresArray === null) {
    return [];
  }
  const features = featuresArray[2] || [];
  return features.map((feature) => ({
    title: feature[0],
    description: path_default([1, 0, 0, 1], feature)
  }));
}
function extractCategories(searchArray, categories2 = []) {
  if (searchArray === null || searchArray.length === 0)
    return categories2;
  if (searchArray.length >= 4 && typeof searchArray[0] === "string") {
    categories2.push({
      name: searchArray[0],
      id: searchArray[2]
    });
  } else {
    searchArray.forEach((sub) => {
      extractCategories(sub, categories2);
    });
  }
  return categories2;
}
var mappingHelpers_default = {
  descriptionHtmlLocalized,
  descriptionText,
  priceText,
  normalizeAndroidVersion,
  buildHistogram,
  extractComments,
  extractFeatures,
  extractCategories
};

// node_modules/google-play-scraper/lib/app.js
var PLAYSTORE_URL = `${BASE_URL}/store/apps/details`;
function app(opts) {
  return new Promise(function(resolve, reject) {
    if (!opts || !opts.appId) {
      throw Error("appId missing");
    }
    opts.lang = opts.lang || "en";
    opts.country = opts.country || "us";
    const qs3 = queryString.stringify({
      id: opts.appId,
      hl: opts.lang,
      gl: opts.country
    });
    const reqUrl = `${PLAYSTORE_URL}?${qs3}`;
    const options = Object.assign({
      url: reqUrl,
      followRedirect: true
    }, opts.requestOptions);
    request_default(options, opts.throttle).then(scriptData_default.parse).then(scriptData_default.extractor(MAPPINGS)).then(assoc_default("appId", opts.appId)).then(assoc_default("url", reqUrl)).then(resolve).catch(reject);
  });
}
var MAPPINGS = {
  title: ["ds:5", 1, 2, 0, 0],
  description: {
    path: ["ds:5", 1, 2],
    fun: (val2) => mappingHelpers_default.descriptionText(mappingHelpers_default.descriptionHtmlLocalized(val2))
  },
  descriptionHTML: {
    path: ["ds:5", 1, 2],
    fun: mappingHelpers_default.descriptionHtmlLocalized
  },
  summary: ["ds:5", 1, 2, 73, 0, 1],
  installs: ["ds:5", 1, 2, 13, 0],
  minInstalls: ["ds:5", 1, 2, 13, 1],
  maxInstalls: ["ds:5", 1, 2, 13, 2],
  score: ["ds:5", 1, 2, 51, 0, 1],
  scoreText: ["ds:5", 1, 2, 51, 0, 0],
  ratings: ["ds:5", 1, 2, 51, 2, 1],
  reviews: ["ds:5", 1, 2, 51, 3, 1],
  histogram: {
    path: ["ds:5", 1, 2, 51, 1],
    fun: mappingHelpers_default.buildHistogram
  },
  price: {
    path: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 1, 0, 0],
    fun: (val2) => val2 / 1e6 || 0
  },
  // If there is a discount, originalPrice if filled.
  originalPrice: {
    path: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 1, 1, 0],
    fun: (price) => price ? price / 1e6 : void 0
  },
  discountEndDate: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 14, 1],
  free: {
    path: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 1, 0, 0],
    // considered free only if price is exactly zero
    fun: (val2) => val2 === 0
  },
  currency: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 1, 0, 1],
  priceText: {
    path: ["ds:5", 1, 2, 57, 0, 0, 0, 0, 1, 0, 2],
    fun: mappingHelpers_default.priceText
  },
  available: {
    path: ["ds:5", 1, 2, 18, 0],
    fun: Boolean
  },
  offersIAP: {
    path: ["ds:5", 1, 2, 19, 0],
    fun: Boolean
  },
  IAPRange: ["ds:5", 1, 2, 19, 0],
  androidVersion: {
    path: ["ds:5", 1, 2, 140, 1, 1, 0, 0, 1],
    fun: mappingHelpers_default.normalizeAndroidVersion
  },
  androidVersionText: {
    path: ["ds:5", 1, 2, 140, 1, 1, 0, 0, 1],
    fun: (version) => version || "Varies with device"
  },
  androidMaxVersion: {
    path: ["ds:5", 1, 2, 140, 1, 1, 0, 1, 1],
    fun: mappingHelpers_default.normalizeAndroidVersion
  },
  developer: ["ds:5", 1, 2, 68, 0],
  developerId: {
    path: ["ds:5", 1, 2, 68, 1, 4, 2],
    fun: (devUrl) => devUrl.split("id=")[1]
  },
  developerEmail: ["ds:5", 1, 2, 69, 1, 0],
  developerWebsite: ["ds:5", 1, 2, 69, 0, 5, 2],
  developerAddress: ["ds:5", 1, 2, 69, 2, 0],
  privacyPolicy: ["ds:5", 1, 2, 99, 0, 5, 2],
  developerInternalID: {
    path: ["ds:5", 1, 2, 68, 1, 4, 2],
    fun: (devUrl) => devUrl.split("id=")[1]
  },
  genre: ["ds:5", 1, 2, 79, 0, 0, 0],
  genreId: ["ds:5", 1, 2, 79, 0, 0, 2],
  categories: {
    path: ["ds:5", 1, 2],
    fun: (searchArray) => {
      const categories2 = mappingHelpers_default.extractCategories(path_default([118], searchArray));
      if (categories2.length === 0) {
        categories2.push({
          name: path_default([79, 0, 0, 0], searchArray),
          id: path_default([79, 0, 0, 2], searchArray)
        });
      }
      return categories2;
    }
  },
  icon: ["ds:5", 1, 2, 95, 0, 3, 2],
  headerImage: ["ds:5", 1, 2, 96, 0, 3, 2],
  screenshots: {
    path: ["ds:5", 1, 2, 78, 0],
    fun: (screenshots) => {
      if (screenshots === null)
        return [];
      return screenshots.map(path_default([3, 2]));
    }
  },
  video: ["ds:5", 1, 2, 100, 0, 0, 3, 2],
  videoImage: ["ds:5", 1, 2, 100, 1, 0, 3, 2],
  previewVideo: ["ds:5", 1, 2, 100, 1, 2, 0, 2],
  contentRating: ["ds:5", 1, 2, 9, 0],
  contentRatingDescription: ["ds:5", 1, 2, 9, 2, 1],
  adSupported: {
    path: ["ds:5", 1, 2, 48],
    fun: Boolean
  },
  released: ["ds:5", 1, 2, 10, 0],
  updated: {
    path: ["ds:5", 1, 2, 145, 0, 1, 0],
    fun: (ts) => ts * 1e3
  },
  version: {
    path: ["ds:5", 1, 2, 140, 0, 0, 0],
    fun: (val2) => val2 || "VARY"
  },
  recentChanges: ["ds:5", 1, 2, 144, 1, 1],
  comments: {
    path: ["ds:8", 0],
    isArray: true,
    fun: mappingHelpers_default.extractComments
  },
  preregister: {
    path: ["ds:5", 1, 2, 18, 0],
    fun: (val2) => val2 === 1
  },
  earlyAccessEnabled: {
    path: ["ds:5", 1, 2, 18, 2],
    fun: (val2) => typeof val2 === "string"
  },
  isAvailableInPlayPass: {
    path: ["ds:5", 1, 2, 62],
    fun: (field) => !!field
  }
};
var app_default = app;

// node_modules/google-play-scraper/lib/list.js
import url2 from "url";
import qs from "querystring";

// node_modules/google-play-scraper/lib/utils/appList.js
import url from "url";
var MAPPINGS2 = {
  title: [2],
  appId: [12, 0],
  url: {
    path: [9, 4, 2],
    fun: (path3) => new url.URL(path3, BASE_URL).toString()
  },
  icon: [1, 1, 0, 3, 2],
  developer: [4, 0, 0, 0],
  developerId: {
    path: [4, 0, 0, 1, 4, 2],
    fun: extaractDeveloperId
  },
  priceText: {
    path: [7, 0, 3, 2, 1, 0, 2],
    fun: (price) => price === void 0 ? "FREE" : price
  },
  currency: [7, 0, 3, 2, 1, 0, 1],
  price: {
    path: [7, 0, 3, 2, 1, 0, 2],
    fun: (price) => price === void 0 ? 0 : parseFloat(price.match(/([0-9.,]+)/)[0])
  },
  free: {
    path: [7, 0, 3, 2, 1, 0, 2],
    fun: (price) => price === void 0
  },
  summary: [4, 1, 1, 1, 1],
  scoreText: [6, 0, 2, 1, 0],
  score: [6, 0, 2, 1, 1]
};
function extaractDeveloperId(link) {
  return link.split("?id=")[1];
}
function extract(root3, data3) {
  const input = path_default(root3, data3);
  if (input === void 0)
    return [];
  return map_default(scriptData_default.extractor(MAPPINGS2), input);
}
var appList_default = { MAPPINGS: MAPPINGS2, extract };

// node_modules/google-play-scraper/lib/utils/processPages.js
var import_debug3 = __toESM(require_src5(), 1);
var debug3 = (0, import_debug3.default)("google-play-scraper:processPages");
async function processPages(html3, opts, savedApps, mappings) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  const processedApps = appList_default.extract(mappings.apps, html3);
  const apps = opts.fullDetail ? await processFullDetailApps(processedApps, opts) : processedApps;
  const token = path_default(mappings.token, html3);
  return checkFinished(opts, [...savedApps, ...apps], token);
}
async function processFullDetailApps(apps, opts) {
  const promises = apps.map((app2) => app_default({
    appId: app2.appId,
    lang: opts.lang,
    country: opts.country,
    cache: opts.cache,
    throttle: opts.throttle,
    requestOptions: opts.requestOptions
  }));
  return Promise.all(promises);
}
var REQUEST_MAPPINGS = {
  apps: [0, 0, 0],
  token: [0, 0, 7, 1]
};
function checkFinished(opts, savedApps, nextToken) {
  if (savedApps.length >= opts.num || !nextToken) {
    return savedApps.slice(0, opts.num);
  }
  const body = getBodyForRequests({
    numberOfApps: opts.numberOfApps,
    withToken: nextToken
  });
  const url6 = `${BASE_URL}/_/PlayStoreUi/data/batchexecute?rpcids=qnKhOb&f.sid=-697906427155521722&bl=boq_playuiserver_20190903.08_p0&hl=${opts.lang}&gl=${opts.country}&authuser&soc-app=121&soc-platform=1&soc-device=1&_reqid=1065213`;
  debug3("batchexecute URL: %s", url6);
  debug3("with body: %s", body);
  const requestOptions = Object.assign({
    url: url6,
    method: "POST",
    body,
    followRedirect: true,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
    }
  }, opts.requestOptions);
  return request_default(requestOptions, opts.throttle).then((html3) => {
    const input = JSON.parse(html3.substring(5));
    const data3 = JSON.parse(input[0][2]);
    return data3 === null ? savedApps : processPages(data3, opts, savedApps, REQUEST_MAPPINGS);
  });
}
function getBodyForRequests({
  numberOfApps = 100,
  withToken = "%token%"
}) {
  const body = `f.req=%5B%5B%5B%22qnKhOb%22%2C%22%5B%5Bnull%2C%5B%5B10%2C%5B10%2C${numberOfApps}%5D%5D%2Ctrue%2Cnull%2C%5B96%2C27%2C4%2C8%2C57%2C30%2C110%2C79%2C11%2C16%2C49%2C1%2C3%2C9%2C12%2C104%2C55%2C56%2C51%2C10%2C34%2C77%5D%5D%2Cnull%2C%5C%22${withToken}%5C%22%5D%5D%22%2Cnull%2C%22generic%22%5D%5D%5D`;
  return body;
}

// node_modules/google-play-scraper/lib/list.js
var import_debug4 = __toESM(require_src5(), 1);
var debug4 = (0, import_debug4.default)("google-play-scraper:list");
function getBodyForRequests2(payloadOpts) {
  const { num, collection, category } = payloadOpts;
  const body = `f.req=%5B%5B%5B%22vyAe2%22%2C%22%5B%5Bnull%2C%5B%5B8%2C%5B20%2C${num}%5D%5D%2Ctrue%2Cnull%2C%5B64%2C1%2C195%2C71%2C8%2C72%2C9%2C10%2C11%2C139%2C12%2C16%2C145%2C148%2C150%2C151%2C152%2C27%2C30%2C31%2C96%2C32%2C34%2C163%2C100%2C165%2C104%2C169%2C108%2C110%2C113%2C55%2C56%2C57%2C122%5D%2C%5Bnull%2Cnull%2C%5B%5B%5Btrue%5D%2Cnull%2C%5B%5Bnull%2C%5B%5D%5D%5D%2Cnull%2Cnull%2Cnull%2Cnull%2C%5Bnull%2C2%5D%2Cnull%2Cnull%2Cnull%2Cnull%2Cnull%2Cnull%2C%5B1%5D%2Cnull%2Cnull%2Cnull%2Cnull%2Cnull%2Cnull%2Cnull%2C%5B1%5D%5D%2C%5Bnull%2C%5B%5Bnull%2C%5B%5D%5D%5D%5D%2C%5Bnull%2C%5B%5Bnull%2C%5B%5D%5D%5D%2Cnull%2C%5Btrue%5D%5D%2C%5Bnull%2C%5B%5Bnull%2C%5B%5D%5D%5D%5D%2Cnull%2Cnull%2Cnull%2Cnull%2C%5B%5B%5Bnull%2C%5B%5D%5D%5D%5D%2C%5B%5B%5Bnull%2C%5B%5D%5D%5D%5D%5D%2C%5B%5B%5B%5B7%2C1%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C31%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C104%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C9%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C8%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C27%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C12%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C65%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C110%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C88%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C11%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C56%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C55%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C96%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C10%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C122%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C72%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C71%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C64%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C113%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C139%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C150%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C169%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C165%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C151%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C163%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C32%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C16%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C108%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B7%2C100%5D%2C%5B%5B1%2C73%2C96%2C103%2C97%2C58%2C50%2C92%2C52%2C112%2C69%2C19%2C31%2C101%2C123%2C74%2C49%2C80%2C38%2C20%2C10%2C14%2C79%2C43%2C42%2C139%5D%5D%5D%2C%5B%5B9%2C1%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C31%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C104%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C9%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C8%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C27%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C12%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C65%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C110%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C88%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C11%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C56%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C55%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C96%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C10%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C122%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C72%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C71%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C64%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C113%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C139%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C150%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C169%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C165%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C151%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C163%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C32%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C16%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C108%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B9%2C100%5D%2C%5B%5B1%2C7%2C9%2C24%2C12%2C31%2C5%2C15%2C27%2C8%2C13%2C10%5D%5D%5D%2C%5B%5B17%2C1%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C31%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C104%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C9%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C8%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C27%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C12%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C65%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C110%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C88%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C11%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C56%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C55%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C96%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C10%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C122%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C72%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C71%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C64%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C113%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C139%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C150%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C169%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C165%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C151%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C163%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C32%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C16%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C108%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B17%2C100%5D%2C%5B%5B1%2C7%2C9%2C25%2C13%2C31%2C5%2C41%2C27%2C8%2C14%2C10%5D%5D%5D%2C%5B%5B10%2C1%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C31%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C104%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C9%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C8%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C27%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C12%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C65%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C110%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C88%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C11%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C56%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C55%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C96%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C10%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C122%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C72%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C71%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C64%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C113%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C139%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C150%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C169%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C165%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C151%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C163%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C32%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C16%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C108%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B10%2C100%5D%2C%5B%5B1%2C7%2C6%2C9%5D%5D%5D%2C%5B%5B1%2C1%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C31%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C104%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C9%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C8%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C27%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C12%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C65%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C110%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C88%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C11%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C56%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C55%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C96%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C10%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C122%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C72%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C71%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C64%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C113%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C139%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C150%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C169%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C165%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C151%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C163%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C32%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C16%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C108%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B1%2C100%5D%2C%5B%5B1%2C5%2C14%2C38%2C19%2C29%2C34%2C4%2C12%2C11%2C6%2C30%2C43%2C40%2C42%2C16%2C10%2C7%5D%5D%5D%2C%5B%5B4%2C1%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C31%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C104%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C9%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C8%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C27%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C12%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C65%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C110%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C88%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C11%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C56%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C55%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C96%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C10%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C122%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C72%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C71%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C64%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C113%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C139%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C150%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C169%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C165%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C151%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C163%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C32%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C16%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C108%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B4%2C100%5D%2C%5B%5B1%2C3%2C5%2C4%2C7%2C6%2C11%2C19%2C21%2C17%2C15%2C12%2C16%2C20%5D%5D%5D%2C%5B%5B3%2C1%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C31%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C104%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C9%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C8%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C27%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C12%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C65%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C110%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C88%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C11%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C56%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C55%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C96%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C10%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C122%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C72%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C71%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C64%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C113%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C139%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C150%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C169%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C165%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C151%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C163%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C32%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C16%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C108%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B3%2C100%5D%2C%5B%5B1%2C5%2C14%2C4%2C10%2C17%5D%5D%5D%2C%5B%5B2%2C1%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C31%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C104%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C9%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C8%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C27%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C12%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C65%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C110%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C88%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C11%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C56%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C55%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C96%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C10%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C122%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C72%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C71%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C64%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C113%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C139%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C150%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C169%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C165%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C151%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C163%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C32%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C16%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C108%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%2C%5B%5B2%2C100%5D%2C%5B%5B1%2C5%2C7%2C4%2C13%2C16%2C12%2C18%5D%5D%5D%5D%5D%5D%2Cnull%2Cnull%2C%5B%5B%5B1%2C2%5D%2C%5B10%2C8%2C9%5D%2C%5B%5D%2C%5B%5D%5D%5D%5D%2C%5B2%2C%5C%22${collection}%5C%22%2C%5C%22${category}%5C%22%5D%5D%5D%22%2Cnull%2C%22generic%22%5D%5D%5D&at=AFSRYlx8XZfN8-O-IKASbNBDkB6T%3A1655531200971&`;
  return body;
}
function list(opts) {
  return new Promise(function(resolve, reject) {
    validate(opts);
    const fullListOpts = Object.assign({
      lang: "en",
      country: "us",
      num: 500
    }, opts);
    const body = getBodyForRequests2({
      num: fullListOpts.num,
      collection: CLUSTER_NAMES[fullListOpts.collection],
      category: fullListOpts.category
    });
    const requestOptions = Object.assign({
      url: buildInitialUrl(fullListOpts),
      method: "POST",
      body,
      followRedirect: true,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
      }
    }, opts.requestOptions);
    request_default(requestOptions, opts.throttle).then((html3) => {
      const input = JSON.parse(html3.split("\n")[3]);
      return JSON.parse(input[0][2]);
    }).then((collectionObject) => parseCollectionApps(collectionObject, opts)).then(resolve).catch(reject);
  });
}
function validate(opts) {
  opts.category = opts.category || constants.category.APPLICATION;
  if (opts.category && !includes_default(opts.category, values_default(constants.category))) {
    throw Error("Invalid category " + opts.category);
  }
  opts.collection = opts.collection || constants.collection.TOP_FREE;
  if (!includes_default(opts.collection, values_default(constants.collection))) {
    throw Error(`Invalid collection ${opts.collection}`);
  }
  if (opts.age && !includes_default(opts.age, values_default(constants.age))) {
    throw Error(`Invalid age range ${opts.age}`);
  }
}
function buildInitialUrl(opts) {
  const queryString3 = {
    hl: opts.lang,
    gl: opts.country
  };
  if (opts.age) {
    queryString3.age = opts.age;
  }
  const url6 = `${BASE_URL}/_/PlayStoreUi/data/batchexecute?rpcids=vyAe2&source-path=%2Fstore%2Fapps&f.sid=-4178618388443751758&bl=boq_playuiserver_20220612.08_p0&authuser=0&soc-app=121&soc-platform=1&soc-device=1&_reqid=82003&rt=c`;
  const fullURL = `${url6}&${qs.stringify(queryString3)}`;
  debug4("Initial Request URL: %s", fullURL);
  return fullURL;
}
var CLUSTER_NAMES = {
  TOP_FREE: "topselling_free",
  TOP_PAID: "topselling_paid",
  GROSSING: "topgrossing"
};
async function parseCollectionApps(categoryObject, opts) {
  const appsMappings = {
    title: [0, 3],
    appId: [0, 0, 0],
    url: {
      path: [0, 10, 4, 2],
      fun: (path3) => new url2.URL(path3, BASE_URL).toString()
    },
    icon: [0, 1, 3, 2],
    developer: [0, 14],
    currency: [0, 8, 1, 0, 1],
    price: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [0, 13, 1],
    scoreText: [0, 4, 0],
    score: [0, 4, 1]
  };
  const appsPath = [0, 1, 0, 28, 0];
  const processedApps = map_default(scriptData_default.extractor(appsMappings), path_default(appsPath, categoryObject));
  const apps = opts.fullDetail ? await processFullDetailApps(processedApps, opts) : processedApps;
  return apps;
}
var list_default = list;

// node_modules/google-play-scraper/lib/search.js
import url3 from "url";
function initialRequest(opts) {
  function skipClusterPage(html3) {
    const match = html3.match(/href="\/store\/apps\/collection\/search_collection_more_results_cluster?(.*?)"/);
    if (match) {
      const innerUrl = BASE_URL + match[0].split(/"/)[1];
      return request_default(Object.assign({
        url: innerUrl
      }, opts.requestOptions), opts.throttle);
    }
    return html3;
  }
  const url6 = `${BASE_URL}/store/search?c=apps&q=${opts.term}&hl=${opts.lang}&gl=${opts.country}&price=${opts.price}`;
  return request_default(Object.assign({ url: url6 }, opts.requestOptions), opts.throttle).then(skipClusterPage).then((html3) => processFirstPage(html3, opts, [], INITIAL_MAPPINGS));
}
function extaractDeveloperId2(link) {
  return link.split("?id=")[1];
}
async function processFirstPage(html3, opts, savedApps, mappings) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  const mainAppMapping = {
    title: [16, 2, 0, 0],
    appId: [16, 11, 0, 0],
    url: {
      path: [17, 0, 0, 4, 2],
      fun: (path3) => new url3.URL(path3, BASE_URL).toString()
    },
    icon: [16, 2, 95, 0, 3, 2],
    developer: [16, 2, 68, 0],
    developerId: {
      path: [16, 2, 68, 1, 4, 2],
      fun: extaractDeveloperId2
    },
    currency: [17, 0, 2, 0, 1, 0, 1],
    price: {
      path: [17, 0, 2, 0, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [17, 0, 2, 0, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [16, 2, 73, 0, 1],
    scoreText: [16, 2, 51, 0, 0],
    score: [16, 2, 51, 0, 1]
  };
  const moreResultsMapping = {
    title: [0, 3],
    appId: [0, 0, 0],
    url: {
      path: [0, 10, 4, 2],
      fun: (path3) => new url3.URL(path3, BASE_URL).toString()
    },
    icon: [0, 1, 3, 2],
    developer: [0, 14],
    currency: [0, 8, 1, 0, 1],
    price: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [0, 13, 1],
    scoreText: [0, 4, 0],
    score: [0, 4, 1]
  };
  removeUnneededSections(html3, mappings);
  const sections = path_default(mappings.sections, html3);
  if (noResultsFound(sections, opts))
    return [];
  const moreResultsSection = sections.filter((section) => isMoreSection(section))[0];
  const mainAppSection = path_default(mappings.app, html3);
  const processedApps = map_default(scriptData_default.extractor(moreResultsMapping), path_default(SECTIONS_MAPPING.apps, moreResultsSection));
  if (mainAppSection) {
    processedApps.unshift(scriptData_default.extractor(mainAppMapping)(mainAppSection));
  }
  const apps = opts.fullDetail ? await processFullDetailApps(processedApps, opts) : processedApps;
  const token = path_default(SECTIONS_MAPPING.token, moreResultsSection);
  return checkFinished(opts, [...savedApps, ...apps], token);
}
function isMoreSection(section) {
  const sectionTitle = path_default(SECTIONS_MAPPING.title, section);
  return is_default(String, sectionTitle);
}
function removeUnneededSections(html3, mappings) {
  removeSectionsIfPathValueOfType(html3, SECTIONS_MAPPING.aboutResultsTitle, String);
  removeSectionsIfPathValueOfType(html3, [...mappings.sections, 0, ...SECTIONS_MAPPING.suggestedResultDescritpion], String);
  removeSectionsIfPathValueOfType(html3, SECTIONS_MAPPING.aboutResultsTitle, String);
}
function removeSectionsIfPathValueOfType(html3, path3, type3) {
  if (is_default(type3, path_default(path3, html3))) {
    path_default(INITIAL_MAPPINGS.sections, html3).shift();
  }
}
function noResultsFound(sections, opts) {
  return sections.some((section) => {
    const noResults = path_default(SECTIONS_MAPPING.noResults, section);
    return is_default(String, noResults) && noResults.endsWith(`<b>${opts.term}</b>`);
  });
}
var INITIAL_MAPPINGS = {
  app: ["ds:4", 0, 1, 0, 23],
  sections: ["ds:4", 0, 1]
};
var SECTIONS_MAPPING = {
  title: [22, 1, 0],
  token: [22, 1, 3, 1],
  apps: [22, 0],
  noResults: [25, 0, 0, 0, 1],
  suggestedResultDescritpion: [25, 0, 0, 1, 1],
  aboutResultsTitle: ["ds:4", 0, 1, 0, 31, 0]
};
function getPriceGoogleValue(value2) {
  switch (value2.toLowerCase()) {
    case "free":
      return 1;
    case "paid":
      return 2;
    case "all":
    default:
      return 0;
  }
}
function search(appData, opts) {
  return new Promise(function(resolve, reject) {
    if (!opts || !opts.term) {
      throw Error("Search term missing");
    }
    if (opts.num && opts.num > 250) {
      throw Error("The number of results can't exceed 250");
    }
    opts = {
      term: encodeURIComponent(opts.term),
      lang: opts.lang || "en",
      country: opts.country || "us",
      num: opts.num || 20,
      fullDetail: opts.fullDetail,
      price: opts.price ? getPriceGoogleValue(opts.price) : 0,
      throttle: opts.throttle,
      cache: opts.cache,
      requestOptions: opts.requestOptions
    };
    initialRequest(opts).then(resolve).catch(reject);
  }).then((results) => {
    if (opts.fullDetail) {
      return Promise.all(results.map((app2) => appData({ ...opts, appId: app2.appId })));
    }
    return results;
  });
}
var search_default = search;

// node_modules/google-play-scraper/lib/suggest.js
function suggest(opts) {
  return new Promise(function(resolve, reject) {
    if (!opts && !opts.term) {
      throw Error("term missing");
    }
    const lang = opts.lang || "en";
    const country = opts.country || "us";
    const url6 = `${BASE_URL}/_/PlayStoreUi/data/batchexecute?rpcids=IJ4APc&f.sid=-697906427155521722&bl=boq_playuiserver_20190903.08_p0&hl=${lang}&gl=${country}&authuser&soc-app=121&soc-platform=1&soc-device=1&_reqid=1065213`;
    const term = encodeURIComponent(opts.term);
    const body = `f.req=%5B%5B%5B%22IJ4APc%22%2C%22%5B%5Bnull%2C%5B%5C%22${term}%5C%22%5D%2C%5B10%5D%2C%5B2%5D%2C4%5D%5D%22%5D%5D%5D`;
    const options = Object.assign({
      url: url6,
      body,
      method: "POST",
      followAllRedirects: true,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
      }
    }, opts.requestOptions);
    request_default(options, opts.throttle).then((html3) => {
      const input = JSON.parse(html3.substring(5));
      const data3 = JSON.parse(input[0][2]);
      if (data3 === null) {
        return [];
      }
      return data3[0][0].map((s) => s[0]);
    }).then(resolve).catch(reject);
  });
}
var suggest_default = suggest;

// node_modules/google-play-scraper/lib/developer.js
import qs2 from "querystring";
import url4 from "url";
var import_debug5 = __toESM(require_src5(), 1);
var debug5 = (0, import_debug5.default)("google-play-scraper:developer");
function buildUrl(opts) {
  const { lang, devId, country } = opts;
  const url6 = `${BASE_URL}/store/apps`;
  const path3 = isNaN(opts.devId) ? "/developer" : "/dev";
  const queryString3 = {
    id: devId,
    hl: lang,
    gl: country
  };
  const fullURL = `${url6}${path3}?${qs2.stringify(queryString3)}`;
  debug5("Initial request: %s", fullURL);
  return fullURL;
}
function developer(opts) {
  return new Promise(function(resolve, reject) {
    if (!opts.devId) {
      throw Error("devId missing");
    }
    opts = Object.assign({
      num: 60,
      lang: "en",
      country: "us"
    }, opts);
    const options = Object.assign({
      url: buildUrl(opts),
      method: "GET",
      followRedirect: true
    }, opts.requestOptions);
    request_default(options, opts.throttle).then(scriptData_default.parse).then((parsedObject) => parseDeveloperApps(parsedObject, opts)).then(resolve).catch(reject);
  });
}
async function parseDeveloperApps(html3, opts) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  const initialMappings = isNaN(opts.devId) ? {
    apps: ["ds:3", 0, 1, 0, 22, 0],
    token: ["ds:3", 0, 1, 0, 22, 1, 3, 1]
  } : {
    apps: ["ds:3", 0, 1, 0, 21, 0],
    token: ["ds:3", 0, 1, 0, 21, 1, 3, 1]
  };
  const appsMappings = isNaN(opts.devId) ? {
    title: [0, 3],
    appId: [0, 0, 0],
    url: {
      path: [0, 10, 4, 2],
      fun: (path3) => new url4.URL(path3, BASE_URL).toString()
    },
    icon: [0, 1, 3, 2],
    developer: [0, 14],
    currency: [0, 8, 1, 0, 1],
    price: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [0, 8, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [0, 13, 1],
    scoreText: [0, 4, 0],
    score: [0, 4, 1]
  } : {
    title: [3],
    appId: [0, 0],
    url: {
      path: [10, 4, 2],
      fun: (path3) => new url4.URL(path3, BASE_URL).toString()
    },
    icon: [1, 3, 2],
    developer: [14],
    currency: [8, 1, 0, 1],
    price: {
      path: [8, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [8, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [13, 1],
    scoreText: [4, 0],
    score: [4, 1]
  };
  const processedApps = map_default(scriptData_default.extractor(appsMappings), path_default(initialMappings.apps, html3));
  const apps = opts.fullDetail ? await processFullDetailApps(processedApps, opts) : processedApps;
  const token = path_default(initialMappings.token, html3);
  return checkFinished(opts, apps, token);
}
var developer_default = developer;

// node_modules/google-play-scraper/lib/reviews.js
var import_debug6 = __toESM(require_src5(), 1);
var debug6 = (0, import_debug6.default)("google-play-scraper:reviews");
function reviews(opts) {
  return new Promise(function(resolve, reject) {
    validate2(opts);
    const fullOptions = Object.assign({
      sort: constants.sort.NEWEST,
      lang: "en",
      country: "us",
      num: 150,
      paginate: false,
      nextPaginationToken: null
    }, opts);
    processReviews(fullOptions).then(resolve).catch(reject);
  });
}
function validate2(opts) {
  if (!opts || !opts.appId) {
    throw Error("appId missing");
  }
  if (opts.sort && !includes_default(opts.sort, values_default(constants.sort))) {
    throw new Error("Invalid sort " + opts.sort);
  }
}
function formatReviewsResponse({
  reviews: reviews2,
  num,
  token = null
}) {
  const reviewsToResponse = reviews2.length >= num ? reviews2.slice(0, num) : reviews2;
  return {
    data: reviewsToResponse,
    nextPaginationToken: token
  };
}
var REQUEST_TYPE = {
  initial: "initial",
  paginated: "paginated"
};
function getBodyForRequests3({
  appId,
  sort,
  numberOfReviewsPerRequest = 150,
  withToken = "%token%",
  requestType = REQUEST_TYPE.initial
}) {
  const formBody = {
    [REQUEST_TYPE.initial]: `f.req=%5B%5B%5B%22UsvDTd%22%2C%22%5Bnull%2Cnull%2C%5B2%2C${sort}%2C%5B${numberOfReviewsPerRequest}%2Cnull%2Cnull%5D%2Cnull%2C%5B%5D%5D%2C%5B%5C%22${appId}%5C%22%2C7%5D%5D%22%2Cnull%2C%22generic%22%5D%5D%5D`,
    [REQUEST_TYPE.paginated]: `f.req=%5B%5B%5B%22UsvDTd%22%2C%22%5Bnull%2Cnull%2C%5B2%2C${sort}%2C%5B${numberOfReviewsPerRequest}%2Cnull%2C%5C%22${withToken}%5C%22%5D%2Cnull%2C%5B%5D%5D%2C%5B%5C%22${appId}%5C%22%2C7%5D%5D%22%2Cnull%2C%22generic%22%5D%5D%5D`
  };
  return formBody[requestType];
}
var REQUEST_MAPPINGS2 = {
  reviews: [0],
  token: [1, 1]
};
async function processReviewsAndGetNextPage(html3, opts, savedReviews) {
  const processAndRecurOptions = Object.assign({}, opts, { requestType: REQUEST_TYPE.paginated });
  const { appId, paginate, num } = processAndRecurOptions;
  const parsedHtml = is_default(String, html3) ? scriptData_default.parse(html3) : html3;
  if (parsedHtml.length === 0) {
    return formatReviewsResponse({ reviews: savedReviews, token: null, num });
  }
  const reviews2 = extract2(REQUEST_MAPPINGS2.reviews, parsedHtml, appId);
  const token = path_default(REQUEST_MAPPINGS2.token, parsedHtml);
  const reviewsAccumulator = [...savedReviews, ...reviews2];
  return !paginate && token && reviewsAccumulator.length < num ? makeReviewsRequest(processAndRecurOptions, reviewsAccumulator, token) : formatReviewsResponse({ reviews: reviewsAccumulator, token, num });
}
function makeReviewsRequest(opts, savedReviews, nextToken) {
  debug6("nextToken: %s", nextToken);
  debug6("savedReviews length: %s", savedReviews.length);
  debug6("requestType: %s", opts.requestType);
  const {
    appId,
    sort,
    requestType,
    lang,
    country,
    requestOptions,
    throttle,
    num
  } = opts;
  const body = getBodyForRequests3({
    appId,
    sort,
    withToken: nextToken,
    requestType
  });
  const url6 = `${BASE_URL}/_/PlayStoreUi/data/batchexecute?rpcids=qnKhOb&f.sid=-697906427155521722&bl=boq_playuiserver_20190903.08_p0&hl=${lang}&gl=${country}&authuser&soc-app=121&soc-platform=1&soc-device=1&_reqid=1065213`;
  debug6("batchexecute URL: %s", url6);
  debug6("with body: %s", body);
  const reviewRequestOptions = Object.assign({
    url: url6,
    method: "POST",
    body,
    followRedirect: true,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
    }
  }, requestOptions);
  return request_default(reviewRequestOptions, throttle).then((html3) => {
    const input = JSON.parse(html3.substring(5));
    const data3 = JSON.parse(input[0][2]);
    return data3 === null ? formatReviewsResponse({ reviews: savedReviews, token: null, num }) : processReviewsAndGetNextPage(data3, opts, savedReviews);
  });
}
function processReviews(opts) {
  const requestType = !opts.nextPaginationToken ? REQUEST_TYPE.initial : REQUEST_TYPE.paginated;
  const token = opts.nextPaginationToken || "%token%";
  const reviewsOptions = Object.assign({}, { requestType }, opts);
  return makeReviewsRequest(reviewsOptions, [], token);
}
function getReviewsMappings(appId) {
  const MAPPINGS5 = {
    id: [0],
    userName: [1, 0],
    userImage: [1, 1, 3, 2],
    date: {
      path: [5],
      fun: generateDate
    },
    score: [2],
    scoreText: {
      path: [2],
      fun: (score) => String(score)
    },
    url: {
      path: [0],
      fun: (reviewId) => `${BASE_URL}/store/apps/details?id=${appId}&reviewId=${reviewId}`
    },
    title: {
      path: [0],
      fun: () => null
    },
    text: [4],
    replyDate: {
      path: [7, 2],
      fun: generateDate
    },
    replyText: {
      path: [7, 1],
      fun: (text3) => text3 || null
    },
    version: {
      path: [10],
      fun: (version) => version || null
    },
    thumbsUp: [6],
    criterias: {
      path: [12, 0],
      fun: (criterias = []) => criterias.map(buildCriteria)
    }
  };
  return MAPPINGS5;
}
var buildCriteria = (criteria) => ({
  criteria: criteria[0],
  rating: criteria[1] ? criteria[1][0] : null
});
function generateDate(dateArray) {
  if (!dateArray) {
    return null;
  }
  const millisecondsLastDigits = String(dateArray[1] || "000");
  const millisecondsTotal = `${dateArray[0]}${millisecondsLastDigits.substring(0, 3)}`;
  const date = new Date(Number(millisecondsTotal));
  return date.toJSON();
}
function extract2(root3, data3, appId) {
  const input = path_default(root3, data3);
  const MAPPINGS5 = getReviewsMappings(appId);
  return map_default(scriptData_default.extractor(MAPPINGS5), input);
}
var reviews_default = reviews;

// node_modules/google-play-scraper/lib/similar.js
import url5 from "url";
import queryString2 from "querystring";
var import_debug7 = __toESM(require_src5(), 1);
var debug7 = (0, import_debug7.default)("google-play-scraper:similar");
function similar(opts) {
  return new Promise(function(resolve, reject) {
    validateSimilarParameters(opts);
    const mergedOpts = Object.assign(
      {},
      {
        appId: encodeURIComponent(opts.appId),
        lang: opts.lang || "en",
        country: opts.country || "us",
        fullDetail: opts.fullDetail
      }
    );
    const qs3 = queryString2.stringify({
      id: mergedOpts.appId,
      hl: "en",
      gl: mergedOpts.country
    });
    const similarUrl = `${BASE_URL}/store/apps/details?${qs3}`;
    const options = Object.assign({
      url: similarUrl,
      followRedirect: true
    }, opts.requestOptions);
    debug7("Similar Request URL: %s", similarUrl);
    request_default(options, opts.throttle).then(scriptData_default.parse).then((parsedObject) => parseSimilarApps(parsedObject, mergedOpts)).then(resolve).catch(reject);
  });
}
function validateSimilarParameters(opts) {
  if (!opts || !opts.appId) {
    throw Error("appId missing");
  }
}
var INITIAL_MAPPINGS2 = {
  clusters: {
    path: [1, 1],
    useServiceRequestId: "ag2B9c"
  },
  apps: ["ds:3", 0, 1, 0, 21, 0],
  token: ["ds:3", 0, 1, 0, 21, 1, 3, 1]
};
var CLUSTER_MAPPING = {
  title: [21, 1, 0],
  url: [21, 1, 2, 4, 2]
};
var SIMILAR_APPS = "Similar apps";
var SIMILAR_GAMES = "Similar games";
function parseSimilarApps(similarObject, opts) {
  const clusters = scriptData_default.extractDataWithServiceRequestId(similarObject, INITIAL_MAPPINGS2.clusters);
  if (clusters.length === 0) {
    throw Error("Similar apps not found");
  }
  let similarAppsCluster = clusters.filter((cluster) => {
    return path_default(CLUSTER_MAPPING.title, cluster) === SIMILAR_APPS || path_default(CLUSTER_MAPPING.title, cluster) === SIMILAR_GAMES || clusters;
  });
  if (similarAppsCluster.length === 0) {
    similarAppsCluster = clusters;
  }
  const clusterUrl = getParsedCluster(similarAppsCluster[0]);
  const fullClusterUrl = `${BASE_URL}${clusterUrl}&gl=${opts.country}&hl=${opts.lang}`;
  debug7("Cluster Request URL: %s", fullClusterUrl);
  const options = Object.assign({
    url: fullClusterUrl,
    followRedirect: true
  }, opts.requestOptions);
  return request_default(options, opts.throttle).then(scriptData_default.parse).then((htmlParsed) => processFirstPage2(htmlParsed, opts, [], INITIAL_MAPPINGS2));
}
async function processFirstPage2(html3, opts, savedApps, mappings) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  const mapping = {
    title: [3],
    appId: [0, 0],
    url: {
      path: [10, 4, 2],
      fun: (path3) => new url5.URL(path3, BASE_URL).toString()
    },
    icon: [1, 3, 2],
    developer: [14],
    currency: [8, 1, 0, 1],
    price: {
      path: [8, 1, 0, 0],
      fun: (price) => price / 1e6
    },
    free: {
      path: [8, 1, 0, 0],
      fun: (price) => price === 0
    },
    summary: [13, 1],
    scoreText: [4, 0],
    score: [4, 1]
  };
  const processedApps = map_default(scriptData_default.extractor(mapping), path_default(mappings.apps, html3));
  const apps = opts.fullDetail ? await processFullDetailApps(processedApps, opts) : processedApps;
  const token = path_default(mappings.token, html3);
  return checkFinished(opts, [...savedApps, ...apps], token);
}
function getParsedCluster(similarObject) {
  const clusterUrl = path_default(CLUSTER_MAPPING.url, similarObject);
  return clusterUrl;
}
var similar_default = similar;

// node_modules/google-play-scraper/lib/permissions.js
var import_debug8 = __toESM(require_src5(), 1);
var debug8 = (0, import_debug8.default)("google-play-scraper:permissions");
function permissions(opts) {
  return new Promise(function(resolve, reject) {
    if (!opts && !opts.appId) {
      throw Error("appId missing");
    }
    opts.lang = opts.lang || "en";
    processPermissions(opts).then(resolve).catch(reject);
  });
}
function processPermissions(opts) {
  const body = `f.req=%5B%5B%5B%22xdSrCf%22%2C%22%5B%5Bnull%2C%5B%5C%22${opts.appId}%5C%22%2C7%5D%2C%5B%5D%5D%5D%22%2Cnull%2C%221%22%5D%5D%5D`;
  const url6 = `${BASE_URL}/_/PlayStoreUi/data/batchexecute?rpcids=qnKhOb&f.sid=-697906427155521722&bl=boq_playuiserver_20190903.08_p0&hl=${opts.lang}&authuser&soc-app=121&soc-platform=1&soc-device=1&_reqid=1065213`;
  debug8("batchexecute URL: %s", url6);
  debug8("with body: %s", body);
  const requestOptions = Object.assign({
    url: url6,
    method: "POST",
    body,
    followRedirect: true,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
    }
  }, opts.requestOptions);
  return request_default(requestOptions, opts.throttle).then((html3) => {
    const input = JSON.parse(html3.substring(5));
    const data3 = JSON.parse(input[0][2]);
    if (data3 === null) {
      return [];
    }
    return opts.short ? processShortPermissionsData(data3) : processPermissionData(data3);
  });
}
var MAPPINGS3 = {
  permissions: [2],
  type: 0
};
function processShortPermissionsData(html3) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  const commonPermissions = html3[constants.permission.COMMON];
  if (!commonPermissions) {
    return [];
  }
  const validPermissions = commonPermissions.filter((permission) => permission.length);
  const permissionNames = chain_default((permission) => permission[MAPPINGS3.type], validPermissions);
  return permissionNames;
}
function processPermissionData(html3) {
  if (is_default(String, html3)) {
    html3 = scriptData_default.parse(html3);
  }
  debug8("html %o", html3);
  const permissions2 = Object.values(constants.permission).reduce((permissionAccummulator, permission) => {
    if (!html3[permission]) {
      return permissionAccummulator;
    }
    permissionAccummulator.push(
      ...chain_default(flatMapPermissions, html3[permission])
    );
    return permissionAccummulator;
  }, []);
  debug8("Permissions %o", permissions2);
  return permissions2;
}
function flatMapPermissions(permission) {
  const input = path_default(MAPPINGS3.permissions, permission);
  if (typeof input === "undefined") {
    return [];
  }
  const mappings = getPermissionMappings(permission[MAPPINGS3.type]);
  return map_default(scriptData_default.extractor(mappings), input);
}
function getPermissionMappings(type3) {
  return {
    permission: [1],
    type: {
      path: 0,
      fun: () => type3
    }
  };
}
var permissions_default = permissions;

// node_modules/google-play-scraper/lib/datasafety.js
function dataSafety(opts) {
  return new Promise(function(resolve, reject) {
    if (!opts && !opts.appId) {
      throw Error("appId missing");
    }
    opts.lang = opts.lang || "en";
    processDataSafety(opts).then(resolve).catch(reject);
  });
}
function processDataSafety(opts) {
  const PLAYSTORE_URL3 = `${BASE_URL}/store/apps/datasafety`;
  const searchParams = new URLSearchParams({
    id: opts.appId,
    hl: opts.lang
  });
  const reqUrl = `${PLAYSTORE_URL3}?${searchParams}`;
  const options = Object.assign({
    url: reqUrl,
    followRedirect: true
  }, opts.requestOptions);
  return request_default(options, opts.throttle).then(scriptData_default.parse).then(scriptData_default.extractor(MAPPINGS4));
}
var MAPPINGS4 = {
  sharedData: {
    path: ["ds:3", 1, 2, 137, 4, 0, 0],
    fun: mapDataEntries
  },
  collectedData: {
    path: ["ds:3", 1, 2, 137, 4, 1, 0],
    fun: mapDataEntries
  },
  securityPractices: {
    path: ["ds:3", 1, 2, 137, 9, 2],
    fun: mapSecurityPractices
  },
  privacyPolicyUrl: ["ds:3", 1, 2, 99, 0, 5, 2]
};
function mapSecurityPractices(practices) {
  if (!practices) {
    return [];
  }
  return practices.map((practice) => ({
    practice: path_default([1], practice),
    description: path_default([2, 1], practice)
  }));
}
function mapDataEntries(dataEntries) {
  if (!dataEntries) {
    return [];
  }
  return dataEntries.flatMap((data3) => {
    const type3 = path_default([0, 1], data3);
    const details = path_default([4], data3);
    return details.map((detail) => ({
      data: path_default([0], detail),
      optional: path_default([1], detail),
      purpose: path_default([2], detail),
      type: type3
    }));
  });
}
var datasafety_default = dataSafety;

// node_modules/google-play-scraper/lib/categories.js
var PLAYSTORE_URL2 = `${BASE_URL}/store/apps`;
var CATEGORY_URL_PREFIX = "/store/apps/category/";
function categories(opts) {
  opts = Object.assign({}, opts);
  return new Promise(function(resolve, reject) {
    const options = Object.assign(
      {
        url: PLAYSTORE_URL2
      },
      opts.requestOptions
    );
    request_default(options, opts.throttle).then(load).then(extractCategories2).then(resolve).catch(reject);
  });
}
function extractCategories2($2) {
  const categoryIds = $2("ul li a").toArray().map((el) => $2(el).attr("href")).filter((url6) => url6.startsWith(CATEGORY_URL_PREFIX) && !url6.includes("?age=")).map((url6) => url6.substr(CATEGORY_URL_PREFIX.length));
  categoryIds.push("APPLICATION");
  return categoryIds;
}
var categories_default = categories;

// node_modules/google-play-scraper/index.js
var methods = {
  app: app_default,
  list: list_default,
  search: partial_default(search_default, [app_default]),
  suggest: suggest_default,
  developer: developer_default,
  reviews: reviews_default,
  similar: similar_default,
  permissions: permissions_default,
  datasafety: datasafety_default,
  categories: categories_default
};
function memoized(opts) {
  const cacheOpts = Object.assign({
    primitive: true,
    normalizer: JSON.stringify,
    maxAge: 1e3 * 60 * 5,
    // cache for 5 minutes
    max: 1e3
    // save up to 1k results to avoid memory issues
  }, opts);
  const doMemoize = (fn) => (0, import_memoizee.default)(fn, cacheOpts);
  const mAppMethod = (0, import_memoizee.default)(app_default, cacheOpts);
  const otherMethods = {
    list: list_default,
    search: partial_default(search_default, [mAppMethod]),
    suggest: suggest_default,
    developer: developer_default,
    reviews: reviews_default,
    similar: similar_default,
    permissions: permissions_default,
    datasafety: datasafety_default,
    categories: categories_default
  };
  return Object.assign(
    { app: mAppMethod },
    constants,
    map_default(doMemoize, otherMethods)
  );
}
var google_play_scraper_default = Object.assign({ memoized }, constants, methods);

// extension.ts
var import_app_store_scraper = __toESM(require_app_store_scraper());
var NS_OMNI = "appstore-parser";
var component = OAIBaseComponent.create(NS_OMNI, "google-play-reviews").fromScratch().set("description", "Extracts reviews from Google Play Store for a specific application.").set("title", "Google Play Reviews").set("category", "Data Extraction").setMethod("X-CUSTOM").setMeta({
  source: {
    summary: "Extracts reviews from Google Play Store for a specific application.",
    authors: ["Mercenaries.ai Team"],
    links: {
      "Google Play Scraper Github": "https://github.com/facundoolano/google-play-scraper",
      "Google Play Store": "https://play.google.com/store"
    }
  }
});
component.addInput(
  component.createInput("appId", "string").set("description", "Unique application id for Google Play.").setRequired(true).toOmniIO()
).addInput(
  component.createInput("lang", "string").set("description", "The two letter language code in which to fetch the reviews.").setChoices([
    { "title": "Afrikaans", "value": "af" },
    { "title": "Amharic", "value": "am" },
    { "title": "Bulgarian", "value": "bg" },
    { "title": "Catalan", "value": "ca" },
    { "title": "Chinese (Hong Kong)", "value": "zh-HK" },
    { "title": "Chinese (PRC)", "value": "zh-CN" },
    { "title": "Chinese (Taiwan)", "value": "zh-TW" },
    { "title": "Croatian", "value": "hr" },
    { "title": "Czech", "value": "cs" },
    { "title": "Danish", "value": "da" },
    { "title": "Dutch", "value": "nl" },
    { "title": "English (UK)", "value": "en-GB" },
    { "title": "English (US)", "value": "en-US" },
    { "title": "Estonian", "value": "et" },
    { "title": "Filipino", "value": "fil" },
    { "title": "Finnish", "value": "fi" },
    { "title": "French (Canada)", "value": "fr-CA" },
    { "title": "French (France)", "value": "fr-FR" },
    { "title": "German", "value": "de" },
    { "title": "Greek", "value": "el" },
    { "title": "Hebrew", "value": "he" },
    { "title": "Hindi", "value": "hi" },
    { "title": "Hungarian", "value": "hu" },
    { "title": "Icelandic", "value": "is" },
    { "title": "Indonesian", "value": "id" },
    { "title": "Italian", "value": "it" },
    { "title": "Japanese", "value": "ja" },
    { "title": "Korean", "value": "ko" },
    { "title": "Latvian", "value": "lv" },
    { "title": "Lithuanian", "value": "lt" },
    { "title": "Malay", "value": "ms" },
    { "title": "Norwegian", "value": "no" },
    { "title": "Polish", "value": "pl" },
    { "title": "Portuguese (Brazil)", "value": "pt-BR" },
    { "title": "Portuguese (Portugal)", "value": "pt-PT" },
    { "title": "Romanian", "value": "ro" },
    { "title": "Russian", "value": "ru" },
    { "title": "Serbian", "value": "sr" },
    { "title": "Slovak", "value": "sk" },
    { "title": "Slovenian", "value": "sl" },
    { "title": "Spanish (Latin America)", "value": "es-419" },
    { "title": "Spanish (Spain)", "value": "es-ES" },
    { "title": "Swahili", "value": "sw" },
    { "title": "Swedish", "value": "sv" },
    { "title": "Thai", "value": "th" },
    { "title": "Turkish", "value": "tr" },
    { "title": "Ukrainian", "value": "uk" },
    { "title": "Vietnamese", "value": "vi" },
    { "title": "Zulu", "value": "zu" }
  ], "en-US").toOmniIO()
).addInput(
  component.createInput("country", "string").set("description", "The two letter country code in which to fetch the reviews.").setChoices(
    [
      { "title": "Albania", "value": "al" },
      { "title": "Algeria", "value": "dz" },
      { "title": "Angola", "value": "ao" },
      { "title": "Antigua and Barbuda", "value": "ag" },
      { "title": "Argentina", "value": "ar" },
      { "title": "Armenia", "value": "am" },
      { "title": "Aruba", "value": "aw" },
      { "title": "Australia", "value": "au" },
      { "title": "Austria", "value": "at" },
      { "title": "Azerbaijan", "value": "az" },
      { "title": "Bahamas", "value": "bs" },
      { "title": "Bahrain", "value": "bh" },
      { "title": "Bangladesh", "value": "bd" },
      { "title": "Belarus", "value": "by" },
      { "title": "Belgium", "value": "be" },
      { "title": "Belize", "value": "bz" },
      { "title": "Benin", "value": "bj" },
      { "title": "Bolivia", "value": "bo" },
      { "title": "Bosnia and Herzegovina", "value": "ba" },
      { "title": "Botswana", "value": "bw" },
      { "title": "Brazil", "value": "br" },
      { "title": "Bulgaria", "value": "bg" },
      { "title": "Burkina", "value": "bf" },
      { "title": "Cambodia", "value": "kh" },
      { "title": "Cameroon", "value": "cm" },
      { "title": "Canada", "value": "ca" },
      { "title": "Cape Verde", "value": "cv" },
      { "title": "Chile", "value": "cl" },
      { "title": "Colombia", "value": "co" },
      { "title": "Costa Rica", "value": "cr" },
      { "title": "Cote d' Ivore", "value": "ci" },
      { "title": "Croatia", "value": "hr" },
      { "title": "Cyprus", "value": "cy" },
      { "title": "Czech Republic", "value": "cz" },
      { "title": "Denmark", "value": "dk" },
      { "title": "Dominican Republic", "value": "do" },
      { "title": "Ecuador", "value": "ec" },
      { "title": "Egypt", "value": "eg" },
      { "title": "El Salvador", "value": "sv" },
      { "title": "Estonia", "value": "ee" },
      { "title": "Fiji", "value": "fj" },
      { "title": "Finland", "value": "fi" },
      { "title": "France", "value": "fr" },
      { "title": "Gabon", "value": "ga" },
      { "title": "Georgia", "value": "ge" },
      { "title": "Germany", "value": "de" },
      { "title": "Ghana", "value": "gh" },
      { "title": "Gibraltar", "value": "gi" },
      { "title": "Greece", "value": "gr" },
      { "title": "Guatemala", "value": "gt" },
      { "title": "Guinea-Bissau", "value": "gw" },
      { "title": "Haiti", "value": "ht" },
      { "title": "Honduras", "value": "hn" },
      { "title": "Hong Kong", "value": "hk" },
      { "title": "Hungary", "value": "hu" },
      { "title": "Iceland", "value": "is" },
      { "title": "India", "value": "in" },
      { "title": "Indonesia", "value": "id" },
      { "title": "Iraq", "value": "iq" },
      { "title": "Ireland", "value": "ie" },
      { "title": "Israel", "value": "il" },
      { "title": "Italy", "value": "it" },
      { "title": "Jamaica", "value": "jm" },
      { "title": "Japan", "value": "jp" },
      { "title": "Jordan", "value": "jo" },
      { "title": "Kazakhstan", "value": "kz" },
      { "title": "Kenya", "value": "ke" },
      { "title": "Kuwait", "value": "kw" },
      { "title": "Kyrgyzstan", "value": "kg" },
      { "title": "Laos", "value": "la" },
      { "title": "Latvia", "value": "lv" },
      { "title": "Lebanon", "value": "lb" },
      { "title": "Liechtenstein", "value": "li" },
      { "title": "Lithuania", "value": "lt" },
      { "title": "Luxembourg", "value": "lu" },
      { "title": "Macau", "value": "mo" },
      { "title": "Macedonia", "value": "mk" },
      { "title": "Malaysia", "value": "my" },
      { "title": "Mali", "value": "ml" },
      { "title": "Malta", "value": "mt" },
      { "title": "Mauritius", "value": "mu" },
      { "title": "Mexico", "value": "mx" },
      { "title": "Moldova", "value": "md" },
      { "title": "Monaco", "value": "mc" },
      { "title": "Morocco", "value": "ma" },
      { "title": "Mozambique", "value": "mz" },
      { "title": "Myanmar", "value": "mm" },
      { "title": "Namibia", "value": "na" },
      { "title": "Nepal", "value": "np" },
      { "title": "Netherlands", "value": "nl" },
      { "title": "Netherlands Antilles", "value": "an" },
      { "title": "New Zealand", "value": "nz" },
      { "title": "Nicaragua", "value": "ni" },
      { "title": "Niger", "value": "ne" },
      { "title": "Nigeria", "value": "ng" },
      { "title": "Norway", "value": "no" },
      { "title": "Oman", "value": "om" },
      { "title": "Pakistan", "value": "pk" },
      { "title": "Panama", "value": "pa" },
      { "title": "Papua New Guinea", "value": "pg" },
      { "title": "Paraguay", "value": "py" },
      { "title": "Peru", "value": "pe" },
      { "title": "Philippines", "value": "ph" },
      { "title": "Poland", "value": "pl" },
      { "title": "Portugal", "value": "pt" },
      { "title": "Qatar", "value": "qa" },
      { "title": "Romania", "value": "ro" },
      { "title": "Russia", "value": "ru" },
      { "title": "Rwanda", "value": "rw" },
      { "title": "San Marino", "value": "sm" },
      { "title": "Saudi Arabia", "value": "sa" },
      { "title": "Senegal", "value": "sn" },
      { "title": "Serbia", "value": "rs" },
      { "title": "Singapore", "value": "sg" },
      { "title": "Slovakia", "value": "sk" },
      { "title": "Slovenia", "value": "si" },
      { "title": "South Africa", "value": "za" },
      { "title": "South Korea", "value": "kr" },
      { "title": "Spain", "value": "es" },
      { "title": "Sri Lanka", "value": "lk" },
      { "title": "Sweden", "value": "se" },
      { "title": "Switzerland", "value": "ch" },
      { "title": "Taiwan", "value": "tw" },
      { "title": "Tajikistan", "value": "tj" },
      { "title": "Tanzania", "value": "tz" },
      { "title": "Thailand", "value": "th" },
      { "title": "Togo", "value": "tg" },
      { "title": "Trinidad and Tobago", "value": "tt" },
      { "title": "Tunisia", "value": "tn" },
      { "title": "Turkey", "value": "tr" },
      { "title": "Turkmenistan", "value": "tm" },
      { "title": "Uganda", "value": "ug" },
      { "title": "Ukraine", "value": "ua" },
      { "title": "United Arab Emirates", "value": "ae" },
      { "title": "United Kingdom", "value": "gb" },
      { "title": "United States", "value": "us" },
      { "title": "Uruguay", "value": "uy" },
      { "title": "Uzbekistan", "value": "uz" },
      { "title": "Venezuela", "value": "ve" },
      { "title": "Vietnam", "value": "vn" },
      { "title": "Yemen", "value": "ye" },
      { "title": "Zambia", "value": "zm" },
      { "title": "Zimbabwe", "value": "zw" }
    ],
    "us"
  ).toOmniIO()
).addInput(
  component.createInput("sort", "string").set("description", "The way the reviews are going to be sorted.").setChoices([
    { title: "Newest", value: google_play_scraper_default.sort.NEWEST },
    { title: "Rating", value: google_play_scraper_default.sort.RATING },
    { title: "Helpfulness", value: google_play_scraper_default.sort.HELPFULNESS }
  ], google_play_scraper_default.sort.NEWEST).toOmniIO()
).addInput(
  component.createInput("num", "integer").set("description", "Quantity of reviews to be captured.").setDefault(50).toOmniIO()
).addInput(
  component.createInput("paginate", "boolean").set("description", "Defines if the result will be paginated").setDefault(false).toOmniIO()
).addInput(
  component.createInput("nextPaginationToken", "string").set("description", "The next token to paginate").setDefault(null).toOmniIO()
).addOutput(
  component.createOutput("nextPaginationToken", "string").set("description", "The next token to paginate").toOmniIO()
).addOutput(
  component.createOutput("reviews", "array", "objectArray").set("description", "The reviews data").toOmniIO()
).setMacro(OmniComponentMacroTypes.EXEC, async (payload, ctx) => {
  const reviews2 = await google_play_scraper_default.reviews(payload);
  return reviews2;
});
var GooglePlayReviewsComponent = component.toJSON();
component = OAIBaseComponent.create(NS_OMNI, "apple-store-reviews").fromScratch().set("description", "Extracts reviews from Apple Store for a specific application.").set("title", "Apple Store Reviews").set("category", "Data Extraction").setMethod("X-CUSTOM").setMeta({
  "source": {
    "summary": "Extracts reviews from Apple Store for a specific application.",
    links: {
      "App Store Scraper Github": "https://github.com/facundoolano/app-store-scraper",
      "Apple Store": "https://www.apple.com/app-store/"
    }
  }
});
component.addInput(
  component.createInput("appId", "string").set("description", "Unique application id for Apple Store. Either iTune trackId or appId.").setRequired(true).toOmniIO()
).addInput(
  component.createInput("country", "string").set("description", "The two-letter country code to get the reviews from.").setChoices([
    { "title": "Albania", "value": "al" },
    { "title": "Algeria", "value": "dz" },
    { "title": "Angola", "value": "ao" },
    { "title": "Antigua and Barbuda", "value": "ag" },
    { "title": "Argentina", "value": "ar" },
    { "title": "Armenia", "value": "am" },
    { "title": "Aruba", "value": "aw" },
    { "title": "Australia", "value": "au" },
    { "title": "Austria", "value": "at" },
    { "title": "Azerbaijan", "value": "az" },
    { "title": "Bahamas", "value": "bs" },
    { "title": "Bahrain", "value": "bh" },
    { "title": "Bangladesh", "value": "bd" },
    { "title": "Belarus", "value": "by" },
    { "title": "Belgium", "value": "be" },
    { "title": "Belize", "value": "bz" },
    { "title": "Benin", "value": "bj" },
    { "title": "Bolivia", "value": "bo" },
    { "title": "Bosnia and Herzegovina", "value": "ba" },
    { "title": "Botswana", "value": "bw" },
    { "title": "Brazil", "value": "br" },
    { "title": "Bulgaria", "value": "bg" },
    { "title": "Burkina", "value": "bf" },
    { "title": "Cambodia", "value": "kh" },
    { "title": "Cameroon", "value": "cm" },
    { "title": "Canada", "value": "ca" },
    { "title": "Cape Verde", "value": "cv" },
    { "title": "Chile", "value": "cl" },
    { "title": "Colombia", "value": "co" },
    { "title": "Costa Rica", "value": "cr" },
    { "title": "Cote d' Ivore", "value": "ci" },
    { "title": "Croatia", "value": "hr" },
    { "title": "Cyprus", "value": "cy" },
    { "title": "Czech Republic", "value": "cz" },
    { "title": "Denmark", "value": "dk" },
    { "title": "Dominican Republic", "value": "do" },
    { "title": "Ecuador", "value": "ec" },
    { "title": "Egypt", "value": "eg" },
    { "title": "El Salvador", "value": "sv" },
    { "title": "Estonia", "value": "ee" },
    { "title": "Fiji", "value": "fj" },
    { "title": "Finland", "value": "fi" },
    { "title": "France", "value": "fr" },
    { "title": "Gabon", "value": "ga" },
    { "title": "Georgia", "value": "ge" },
    { "title": "Germany", "value": "de" },
    { "title": "Ghana", "value": "gh" },
    { "title": "Gibraltar", "value": "gi" },
    { "title": "Greece", "value": "gr" },
    { "title": "Guatemala", "value": "gt" },
    { "title": "Guinea-Bissau", "value": "gw" },
    { "title": "Haiti", "value": "ht" },
    { "title": "Honduras", "value": "hn" },
    { "title": "Hong Kong", "value": "hk" },
    { "title": "Hungary", "value": "hu" },
    { "title": "Iceland", "value": "is" },
    { "title": "India", "value": "in" },
    { "title": "Indonesia", "value": "id" },
    { "title": "Iraq", "value": "iq" },
    { "title": "Ireland", "value": "ie" },
    { "title": "Israel", "value": "il" },
    { "title": "Italy", "value": "it" },
    { "title": "Jamaica", "value": "jm" },
    { "title": "Japan", "value": "jp" },
    { "title": "Jordan", "value": "jo" },
    { "title": "Kazakhstan", "value": "kz" },
    { "title": "Kenya", "value": "ke" },
    { "title": "Kuwait", "value": "kw" },
    { "title": "Kyrgyzstan", "value": "kg" },
    { "title": "Laos", "value": "la" },
    { "title": "Latvia", "value": "lv" },
    { "title": "Lebanon", "value": "lb" },
    { "title": "Liechtenstein", "value": "li" },
    { "title": "Lithuania", "value": "lt" },
    { "title": "Luxembourg", "value": "lu" },
    { "title": "Macau", "value": "mo" },
    { "title": "Macedonia", "value": "mk" },
    { "title": "Malaysia", "value": "my" },
    { "title": "Mali", "value": "ml" },
    { "title": "Malta", "value": "mt" },
    { "title": "Mauritius", "value": "mu" },
    { "title": "Mexico", "value": "mx" },
    { "title": "Moldova", "value": "md" },
    { "title": "Monaco", "value": "mc" },
    { "title": "Morocco", "value": "ma" },
    { "title": "Mozambique", "value": "mz" },
    { "title": "Myanmar", "value": "mm" },
    { "title": "Namibia", "value": "na" },
    { "title": "Nepal", "value": "np" },
    { "title": "Netherlands", "value": "nl" },
    { "title": "Netherlands Antilles", "value": "an" },
    { "title": "New Zealand", "value": "nz" },
    { "title": "Nicaragua", "value": "ni" },
    { "title": "Niger", "value": "ne" },
    { "title": "Nigeria", "value": "ng" },
    { "title": "Norway", "value": "no" },
    { "title": "Oman", "value": "om" },
    { "title": "Pakistan", "value": "pk" },
    { "title": "Panama", "value": "pa" },
    { "title": "Papua New Guinea", "value": "pg" },
    { "title": "Paraguay", "value": "py" },
    { "title": "Peru", "value": "pe" },
    { "title": "Philippines", "value": "ph" },
    { "title": "Poland", "value": "pl" },
    { "title": "Portugal", "value": "pt" },
    { "title": "Qatar", "value": "qa" },
    { "title": "Romania", "value": "ro" },
    { "title": "Russia", "value": "ru" },
    { "title": "Rwanda", "value": "rw" },
    { "title": "San Marino", "value": "sm" },
    { "title": "Saudi Arabia", "value": "sa" },
    { "title": "Senegal", "value": "sn" },
    { "title": "Serbia", "value": "rs" },
    { "title": "Singapore", "value": "sg" },
    { "title": "Slovakia", "value": "sk" },
    { "title": "Slovenia", "value": "si" },
    { "title": "South Africa", "value": "za" },
    { "title": "South Korea", "value": "kr" },
    { "title": "Spain", "value": "es" },
    { "title": "Sri Lanka", "value": "lk" },
    { "title": "Sweden", "value": "se" },
    { "title": "Switzerland", "value": "ch" },
    { "title": "Taiwan", "value": "tw" },
    { "title": "Tajikistan", "value": "tj" },
    { "title": "Tanzania", "value": "tz" },
    { "title": "Thailand", "value": "th" },
    { "title": "Togo", "value": "tg" },
    { "title": "Trinidad and Tobago", "value": "tt" },
    { "title": "Tunisia", "value": "tn" },
    { "title": "Turkey", "value": "tr" },
    { "title": "Turkmenistan", "value": "tm" },
    { "title": "Uganda", "value": "ug" },
    { "title": "Ukraine", "value": "ua" },
    { "title": "United Arab Emirates", "value": "ae" },
    { "title": "United Kingdom", "value": "gb" },
    { "title": "United States", "value": "us" },
    { "title": "Uruguay", "value": "uy" },
    { "title": "Uzbekistan", "value": "uz" },
    { "title": "Venezuela", "value": "ve" },
    { "title": "Vietnam", "value": "vn" },
    { "title": "Yemen", "value": "ye" },
    { "title": "Zambia", "value": "zm" },
    { "title": "Zimbabwe", "value": "zw" }
  ], "us").toOmniIO()
).addInput(
  component.createInput("page", "integer").set("description", "The review page number to retrieve. Defaults to 1, maximum allowed is 10.").setDefault(1).setConstraints(1, 10).toOmniIO()
).addInput(
  component.createInput("sort", "string").set("description", "The review sort order.").setChoices([import_app_store_scraper.default.sort.RECENT, import_app_store_scraper.default.sort.HELPFUL], import_app_store_scraper.default.sort.RECENT).toOmniIO()
).addOutput(
  component.createOutput("data", "array", "objectArray").set("description", "The reviews data").toOmniIO()
).setMacro(OmniComponentMacroTypes.EXEC, async (payload, ctx) => {
  if (!isNaN(payload.appId)) {
    payload.id = parseInt(payload.appId, 10);
    delete payload.appId;
  } else {
  }
  const reviews2 = await import_app_store_scraper.default.reviews(payload);
  return reviews2;
});
var AppleStoreReviewsComponent = component.toJSON();
var extension_default = {
  createComponents: () => ({
    blocks: [GooglePlayReviewsComponent, AppleStoreReviewsComponent],
    patches: []
  })
};
export {
  extension_default as default
};
/*! Bundled license information:

tough-cookie/lib/pubsuffix-psl.js:
  (*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/store.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/permuteDomain.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/pathMatch.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/memstore.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/cookie.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

aws-sign2/index.js:
  (*!
   *  Copyright 2010 LearnBoost <dev@learnboost.com>
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
